--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Cache.php ---
<?php
// app/Core/Cache.php
// MODIFIZIERT: Logik zum Löschen des Caches hinzugefügt.

namespace App\Core; // KORRIGIERT: Namespace muss App\Core sein, nicht App

class Cache
{
    /**
     * Definiert das Cache-Verzeichnis.
     * Liegt im Root-Verzeichnis des Projekts.
     */
    private static function getCacheDir(): string
    {
        // __DIR__ ist app/Core
        // Wir wollen <projekt_root>/cache/
        return dirname(__DIR__, 2) . '/cache/';
    }

    /**
     * Löscht alle .cache-Dateien aus dem Cache-Verzeichnis.
     *
     * @return array [success (bool), message (string)]
     */
    public static function clearAll(): array
    {
        $cacheDir = self::getCacheDir();

        if (!is_dir($cacheDir)) {
            // Wenn das Verzeichnis nicht existiert, ist das kein Fehler,
            // es gibt einfach nichts zu tun.
            return ['success' => true, 'message' => 'Cache-Verzeichnis existiert nicht, nichts zu tun.'];
        }

        // Finde alle .cache Dateien
        $files = glob($cacheDir . '*.cache');
        $successCount = 0;
        $failCount = 0;

        if ($files === false) {
            // Fehler beim Lesen des Verzeichnisses
            error_log("Fehler beim Lesen des Cache-Verzeichnisses: " . $cacheDir);
            return ['success' => false, 'message' => 'Fehler beim Lesen des Cache-Verzeichnisses.'];
        }

        foreach ($files as $file) {
            if (is_file($file)) {
                if (@unlink($file)) { // @ unterdrückt Warnungen, falls Datei inzwischen weg ist
                    $successCount++;
                } else {
                    $failCount++;
                    error_log("Konnte Cache-Datei nicht löschen: " . $file);
                }
            }
        }

        if ($failCount > 0) {
            return [
                'success' => false,
                'message' => "Konnte $failCount von " . ($successCount + $failCount) . " Cache-Dateien nicht löschen. Details im Server-Log."
            ];
        }

        if ($successCount === 0) {
            return ['success' => true, 'message' => 'App-Cache war bereits leer.'];
        }

        return ['success' => true, 'message' => "Erfolgreich $successCount App-Cache-Datei(en) gelöscht."];
    }
    
    // Zukünftige Cache-Methoden (get, set, etc.) würden hier hinkommen
    // public static function get($key) { ... }
    // public static function set($key, $data, $ttl) { ... }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Cache.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Database.php ---
<?php
// app/Core/Database.php

namespace App\Core;

use PDO;
use PDOException;
use RuntimeException;

/**
 * Singleton-Klasse für die Datenbankverbindung.
 * Stellt sicher, dass nur eine PDO-Instanz pro Anfrage erstellt wird.
 */
class Database
{
    private static ?PDO $instance = null;
    private static array $config = [];

    // Private constructor and clone method to prevent multiple instances.
    private function __construct() {}
    private function __clone() {}

    /**
     * Loads the database configuration from the config file.
     * @return array The configuration array.
     */
    public static function getConfig(): array
    {
        if (empty(self::$config)) {
            self::$config = require __DIR__ . '/../../config/database_access.php';
        }
        return self::$config;
    }

    /**
     * Establishes and returns the single PDO database connection instance.
     * @return PDO The PDO instance.
     * @throws RuntimeException If the database connection fails.
     */
    public static function getInstance(): PDO
    {
        if (self::$instance === null) {
            $config = self::getConfig();
            
            $dsn = "mysql:host={$config['db_host']};port={$config['db_port']};dbname={$config['db_name']};charset={$config['db_charset']}";

            // PDO connection options.
            $options = [
                PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                // WICHTIGE ÄNDERUNG:
                // Das Setzen von EMULATE_PREPARES auf 'true' umgeht einen bekannten Bug in einigen
                // PDO-MySQL-Treibern, der den Fehler 'SQLSTATE[HY093]: Invalid parameter number'
                // verursacht, obwohl der PHP-Code und die SQL-Syntax korrekt sind.
                PDO::ATTR_EMULATE_PREPARES   => true,
            ];

            try {
                self::$instance = new PDO($dsn, $config['db_user'], $config['db_pass'], $options);
            } catch (PDOException $e) {
                // Prevents leaking sensitive connection details in a production environment.
                error_log("Database connection error: " . $e->getMessage());
                throw new RuntimeException("Database connection could not be established.");
            }
        }

        return self::$instance;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Database.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Router.php ---
<?php
// app/Core/Router.php

namespace App\Core;

class Router
{
    private array $routes = [];

    public function add(string $pattern, $handler): void
    {
        $this->routes[$pattern] = $handler;
    }

    public function resolve(string $uri): ?array
    {
        foreach ($this->routes as $pattern => $handler) {
            if (preg_match($pattern, $uri, $matches)) {
                array_shift($matches); // Entfernt den kompletten Match
                return [
                    'handler' => $handler,
                    'matches' => $matches
                ];
            }
        }
        return null;
    }
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Router.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Security.php ---
<?php
// app/Core/Security.php
namespace App\Core;

use Exception; // Added

class Security
{
    /**
     * Stellt sicher, dass ein Benutzer angemeldet ist.
     * Leitet andernfalls zur Login-Seite weiter.
     */
    public static function requireLogin(): void
    {
        if (!isset($_SESSION['user_id'])) {
            header("Location: " . Utils::url('login'));
            exit();
        }
    }

    /**
     * Stellt sicher, dass ein Benutzer eine bestimmte Rolle hat.
     *
     * @param string|array $requiredRoles Die erforderliche Rolle oder ein Array von Rollen.
     */
    public static function requireRole($requiredRoles): void
    {
        self::requireLogin();

        if (!is_array($requiredRoles)) {
            $requiredRoles = [$requiredRoles];
        }

        $userRole = $_SESSION['user_role'] ?? '';

        if (!in_array($userRole, $requiredRoles)) {
            // Optional: Weiterleitung zu einer "Zugriff verweigert"-Seite
            http_response_code(403);
            // Include a more user-friendly error page/message in production
            die("Zugriff verweigert. Sie haben nicht die erforderliche Rolle (" . htmlspecialchars($userRole) . "). Benötigt: " . implode(', ', $requiredRoles));
        }
    }

    /**
     * Generiert ein CSRF-Token, speichert es in der Session und gibt es zurück.
     * Wenn bereits ein Token in der Session existiert, wird dieses zurückgegeben.
     * @return string Das CSRF-Token.
     */
    public static function getCsrfToken(): string
    {
        // Renamed from generateCsrfToken for consistency, kept the logic
        if (empty($_SESSION['csrf_token'])) {
            $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
        }
        return $_SESSION['csrf_token'];
    }

    /**
     * Verifiziert das übermittelte CSRF-Token gegen das in der Session gespeicherte.
     * Wird für POST-Requests und AJAX-Anfragen mit Header verwendet.
     * @throws Exception Wenn das Token ungültig oder nicht vorhanden ist.
     */
    public static function verifyCsrfToken(): void
    {
        // Renamed from validateCsrfToken
        // Check both POST data and potential AJAX header
        $submittedToken = $_POST['_csrf_token'] ?? $_SERVER['HTTP_X_CSRF_TOKEN'] ?? null;
        $sessionToken = $_SESSION['csrf_token'] ?? null;

        if (!$submittedToken || !$sessionToken || !hash_equals($sessionToken, $submittedToken)) {
             http_response_code(403); // Forbidden
             // Log this attempt for security monitoring
             error_log("CSRF token validation failed. Submitted: " . ($submittedToken ?? 'NULL') . ", Session: " . ($sessionToken ?? 'NULL') . ", IP: " . ($_SERVER['REMOTE_ADDR'] ?? 'UNKNOWN'));

            // Provide appropriate response based on request type
             if (!empty($_SERVER['HTTP_X_REQUESTED_WITH']) && strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) == 'xmlhttprequest') {
                 // AJAX request
                 header('Content-Type: application/json');
                 // Throwing exception might be better handled by a global error handler
                 // echo json_encode(['success' => false, 'message' => 'Ungültiges CSRF-Token. Bitte laden Sie die Seite neu.']);
                 // exit();
                 throw new Exception("Sicherheitsüberprüfung fehlgeschlagen (CSRF-Token ungültig oder fehlt).");

             } else {
                 // Standard form submission
                 // In production, show a user-friendly error page instead of die()
                 // die('Fehler: Ungültiges Sicherheitstoken. Bitte versuchen Sie es erneut.');
                 throw new Exception("Sicherheitsüberprüfung fehlgeschlagen (CSRF). Bitte gehen Sie zurück und versuchen Sie es erneut.");
             }
        }
         // Optional: Consider regenerating the token after successful validation for one-time use tokens,
         // but this can cause issues with multiple tabs or back button usage.
         // unset($_SESSION['csrf_token']); // Remove if implementing one-time tokens
    }


    /**
     * Gibt das HTML für das versteckte CSRF-Input-Feld aus.
     * Ruft intern getCsrfToken auf, um sicherzustellen, dass ein Token existiert.
     */
    public static function csrfInput(): void
    {
        echo '<input type="hidden" name="_csrf_token" value="' . htmlspecialchars(self::getCsrfToken()) . '">';
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Security.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Utils.php ---
<?php

namespace App\Core;

use App\Repositories\SettingsRepository; // NEU: Importiere SettingsRepository
use Exception; // NEU: Importiere Exception

class Utils
{
    private static ?array $settingsCache = null; // NEU: Cache für Einstellungen

    /**
     * Generiert eine saubere, SEO-freundliche URL, die vom .htaccess-Router verarbeitet wird.
     * @param string $path Der interne Pfad (z.B. 'profil' oder 'admin/users').
     * @return string Die vollständige, funktionierende URL.
     */
    public static function url(string $path): string
    {
        // Holt die Basis-URL aus der Konfiguration.
        // Diese sollte auf den öffentlichen Ordner zeigen, z.B. '/files/PAUSE/public'.
        $base_url = rtrim(Database::getConfig()['base_url'], '/');

        // Wenn der Pfad leer ist oder nur aus einem / besteht, verlinke zur Startseite.
        if (empty($path) || $path === '/') {
            return $base_url . '/';
        }

        // Hängt den internen Pfad an die Basis-URL an.
        // z.B. wird aus 'login/process' -> '/files/PAUSE/public/login/process'
        return $base_url . '/' . ltrim($path, '/');
    }

    /**
     * Holt die Einstellungen.
     * Versucht zuerst, aus der DB zu laden, und verwendet Standardwerte als Fallback.
     * Ergebnisse werden für die Dauer des Requests zwischengespeichert.
     * @return array
     */
    public static function getSettings(): array
    {
        // Prüfe, ob Einstellungen bereits im Cache liegen
        if (self::$settingsCache !== null) {
            return self::$settingsCache;
        }

        // 1. Definiere Standardwerte
        $defaultSettings = [
            'site_title' => 'PAUSE Portal',
            'maintenance_mode' => '0', // Standardwert für Wartungsmodus
            'maintenance_message' => 'Die Anwendung wird gerade gewartet. Bitte versuchen Sie es später erneut.',
            'maintenance_whitelist_ips' => "127.0.0.1, ::1", // IP Whitelist als String
            'default_start_hour' => 1,
            'default_end_hour' => 10,
            'max_login_attempts' => 5,
            'lockout_minutes' => 15,
            'site_logo_path' => null,
            'site_favicon_path' => null,
            'default_theme' => 'light',
            'ical_enabled' => '1',
            'ical_weeks_future' => 8,
            'pdf_footer_text' => 'PAUSE Portal - PMI - Ein Produkt des PMI.',
            'community_board_enabled' => '1', // NEU: Standardmäßig aktiviert
        ];

        // 2. Lade Einstellungen aus der Datenbank
        try {
            $settingsRepo = new SettingsRepository();
            $dbSettings = $settingsRepo->loadSettings();
        } catch (Exception $e) {
            // Fährt fort, wenn DB-Tabelle (z.B. bei Erstinstallation) noch nicht existiert
            error_log("Hinweis: Konnte Einstellungen nicht aus der DB laden, verwende Standardwerte. Fehler: " . $e->getMessage());
            $dbSettings = [];
        }

        // 3. Überschreibe Standardwerte mit den Werten aus der Datenbank
        // (DB hat Vorrang)
        $finalSettings = array_merge($defaultSettings, $dbSettings);

        // 4. Typkonvertierung (DB speichert alles als String)
        $finalSettings['maintenance_mode'] = (($finalSettings['maintenance_mode'] ?? '0') === '1' || ($finalSettings['maintenance_mode'] ?? false) === true);
        $finalSettings['default_start_hour'] = (int)($finalSettings['default_start_hour'] ?? 1);
        $finalSettings['default_end_hour'] = (int)($finalSettings['default_end_hour'] ?? 10);
        $finalSettings['max_login_attempts'] = (int)($finalSettings['max_login_attempts'] ?? 5);
        $finalSettings['lockout_minutes'] = (int)($finalSettings['lockout_minutes'] ?? 15);
        $finalSettings['ical_enabled'] = (($finalSettings['ical_enabled'] ?? '1') === '1' || ($finalSettings['ical_enabled'] ?? false) === true);
        $finalSettings['ical_weeks_future'] = (int)($finalSettings['ical_weeks_future'] ?? 8);
        // NEU: Konvertierung für Community Board
        $finalSettings['community_board_enabled'] = (($finalSettings['community_board_enabled'] ?? '1') === '1' || ($finalSettings['community_board_enabled'] ?? false) === true);
        // maintenance_whitelist_ips bleibt ein String

        // 5. Im Cache speichern und zurückgeben
        self::$settingsCache = $finalSettings;
        return $finalSettings;
    }

    /**
     * NEU: Löscht den Einstellungs-Cache.
     * Wird nach dem Speichern von Einstellungen aufgerufen.
     */
    public static function clearSettingsCache(): void
    {
        self::$settingsCache = null;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Utils.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\AnnouncementController.php ---
<?php
// app/Http/Controllers/Admin/AnnouncementController.php

namespace App\Http\Controllers\Admin;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\AnnouncementRepository;
use App\Repositories\StammdatenRepository;
use App\Repositories\UserRepository;
use Exception;
use PDO;
use \Parsedown; // KORREKTUR: Parsedown aus dem globalen Namespace importieren

class AnnouncementController
{
    private PDO $pdo;
    private AnnouncementRepository $announcementRepo;
    private StammdatenRepository $stammdatenRepo;
    private UserRepository $userRepo;
    private Parsedown $parsedown; // KORREKTUR: Typehint kann jetzt ohne Backslash sein

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->announcementRepo = new AnnouncementRepository($this->pdo);
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
        $this->parsedown = new Parsedown(); // KORREKTUR: Kann jetzt direkt verwendet werden
        $this->parsedown->setSafeMode(true); 
    }

    /**
     * Zeigt die Hauptseite für die Ankündigungsverwaltung an.
     * Stellt Daten für das Formular bereit (Klassenliste).
     */
    public function index()
    {
        Security::requireRole(['admin', 'planer', 'lehrer']);
        global $config;
        $config = Database::getConfig();

        $page_title = 'Ankündigungsverwaltung';
        $body_class = 'admin-dashboard-body';

        try {
             $userRole = $_SESSION['user_role'] ?? 'Unbekannt';
             $userId = $_SESSION['user_id'] ?? null;
             $user = $userId ? $this->userRepo->findById($userId) : null;
             $allAnnouncements = $this->announcementRepo->getAllAnnouncementsWithDetails();
             $availableClasses = [];
             if (in_array($userRole, ['admin', 'planer'])) {
                 $availableClasses = $this->stammdatenRepo->getClasses();
             } elseif ($userRole === 'lehrer' && $user && isset($user['teacher_id'])) {
                 $availableClasses = $this->stammdatenRepo->getClasses(); // TODO: Ggf. auf Lehrer-Klassen einschränken
             }

             // Convert content to HTML and add file URL
             foreach ($allAnnouncements as &$announcement) {
                 // Convert Markdown content to safe HTML
                 $announcement['content_html'] = $this->parsedown->text($announcement['content'] ?? '');

                 // Add file URL
                if (!empty($announcement['file_path'])) {
                    $announcement['file_url'] = rtrim($config['base_url'], '/') . '/' . ltrim($announcement['file_path'], '/');
                } else {
                    $announcement['file_url'] = null;
                }
             }
             unset($announcement); // Break reference


            Security::getCsrfToken();
            include_once dirname(__DIR__, 4) .'/pages/admin/announcements.php';

        } catch (Exception $e) {
             error_log("Error loading announcement admin page: " . $e->getMessage());
             http_response_code(500);
             die("Ein Fehler ist beim Laden der Seite aufgetreten: " . $e->getMessage());
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\AnnouncementController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\AuditLogController.php ---
<?php
// app/Http/Controllers/AnnouncementController.php

// MODIFIZIERT:
// 1. ApiHandlerTrait importiert und verwendet.
// 2. getAnnouncements (GET) nutzt handleApiRequest('inputType' => 'get').
// 3. createAnnouncement (FormData) nutzt handleApiRequest('inputType' => 'form').
// 4. deleteAnnouncement (FormData) nutzt handleApiRequest('inputType' => 'form').
// 5. Alle manuellen try/catch, header(), json_encode() und Security-Checks
//    wurden aus den API-Methoden entfernt und in den Trait-Callback verschoben.
// 6. Parsedown-Import korrigiert (Backslash entfernt).

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\AnnouncementRepository;
use App\Repositories\UserRepository;
use App\Http\Traits\ApiHandlerTrait; // NEU: Trait importieren
use Exception;
use PDO;
use Parsedown; // KORRIGIERT: Backslash entfernt
use App\Services\AuditLogger; // Import bleibt (wird vom Trait genutzt)

class AnnouncementController
{
    // NEU: Trait für API-Behandlung einbinden
    use ApiHandlerTrait;

    private PDO $pdo;
    private AnnouncementRepository $announcementRepo;
    private UserRepository $userRepo;
    private Parsedown $parsedown;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->announcementRepo = new AnnouncementRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
        $this->parsedown = new Parsedown();
        $this->parsedown->setSafeMode(true);
    }

    /**
     * API: Holt Ankündigungen basierend auf der Rolle des Benutzers. (GET)
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function getAnnouncements()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $user = $this->userRepo->findById($userId);

            if (!$user) {
                throw new Exception("Benutzer nicht gefunden.", 404);
            }

            $classId = ($userRole === 'schueler' && isset($user['class_id'])) ? $user['class_id'] : null;
            $announcements = $this->announcementRepo->getVisibleAnnouncements($userRole, $classId);

            // Add author info, file URL, and convert content to HTML
            foreach ($announcements as &$announcement) {
                $author = $this->userRepo->findById($announcement['user_id']);
                $announcement['author_name'] = $author ? ($author['first_name'] . ' ' . $author['last_name']) : 'Unbekannt';

                $announcement['content_html'] = $this->parsedown->text($announcement['content'] ?? '');

                if (!empty($announcement['file_path'])) {
                    $announcement['file_url'] = rtrim(Database::getConfig()['base_url'], '/') . '/' . ltrim($announcement['file_path'], '/');
                } else {
                    $announcement['file_url'] = null;
                }
                $announcement['visibility'] = $announcement['is_global'] ? 'global' : 'class';
            }
            unset($announcement);

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'data' => $announcements]
            ];

        }, [
            'inputType' => 'get',
            // HINWEIS: checkRole ist nötig, da /api/announcements direkt aufgerufen wird (nicht über index()).
            // Security::requireRole prüft intern auf requireLogin().
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin']
        ]);
    }

    /**
     * API: Erstellt eine neue Ankündigung. (POST/FormData)
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_POST.
     */
    public function createAnnouncement()
    {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $title = trim($data['title'] ?? '');
            $content = trim($data['content'] ?? ''); // Raw Markdown content

            if (empty($title) || empty($content)) {
                throw new Exception("Titel und Inhalt dürfen nicht leer sein.", 400);
            }

            // --- Determine Target Role and Class ID ---
            $targetRole = 'all'; // Default
            $targetClassId = null;
            if ($userRole === 'lehrer') {
                $targetClassId = filter_var($data['target_class_id'] ?? null, FILTER_VALIDATE_INT);
                if (!$targetClassId) { throw new Exception("Lehrer müssen eine Klasse auswählen.", 400); }
                $targetRole = 'schueler';
            }
            elseif (in_array($userRole, ['admin', 'planer'])) {
                $isGlobal = isset($data['target_global']) && $data['target_global'] === '1';
                $isTeacher = isset($data['target_teacher']) && $data['target_teacher'] === '1';
                $isPlaner = isset($data['target_planer']) && $data['target_planer'] === '1';
                $selectedClassId = filter_var($data['target_class_id'] ?? null, FILTER_VALIDATE_INT);
                $selectedClassId = ($selectedClassId === false || $selectedClassId === 0) ? null : $selectedClassId;
                $checkedCount = ($isGlobal ? 1 : 0) + ($isTeacher ? 1 : 0) + ($isPlaner ? 1 : 0);

                if ($checkedCount > 1) { throw new Exception("Bitte nur eine Zielgruppen-Checkbox auswählen.", 400); }
                elseif ($checkedCount === 1) {
                    if ($isGlobal) $targetRole = 'all'; elseif ($isTeacher) $targetRole = 'lehrer'; elseif ($isPlaner) $targetRole = 'planer';
                    $targetClassId = null;
                } elseif ($selectedClassId !== null) {
                    $targetRole = 'schueler'; $targetClassId = $selectedClassId;
                } else { $targetRole = 'all'; $targetClassId = null; }
            } else { throw new Exception("Unbekannte Benutzerrolle.", 403); }

            // Handle File Upload if present
            $attachmentPath = null;
            if (isset($_FILES['attachment']) && $_FILES['attachment']['error'] === UPLOAD_ERR_OK) {
                if (!in_array($userRole, ['admin', 'planer'])) { throw new Exception("Nur Admins und Planer dürfen Dateien anhängen.", 403); }
                $uploadDir = dirname(__DIR__, 3) . '/public/uploads/announcements/';
                if (!is_dir($uploadDir)) { if (!mkdir($uploadDir, 0775, true)) { throw new Exception("Upload-Verzeichnis konnte nicht erstellt werden.", 500); } }
                $fileName = uniqid('', true) . '_' . basename($_FILES['attachment']['name']); $targetFile = $uploadDir . $fileName;
                $allowedTypes = ['image/jpeg', 'image/png', 'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
                $fileType = mime_content_type($_FILES['attachment']['tmp_name']);
                if (!in_array($fileType, $allowedTypes)) { throw new Exception("Ungültiger Dateityp.", 400); }
                if ($_FILES['attachment']['size'] > 5 * 1024 * 1024) { throw new Exception("Datei ist zu groß (max. 5MB).", 400); }
                if (move_uploaded_file($_FILES['attachment']['tmp_name'], $targetFile)) { $attachmentPath = 'uploads/announcements/' . $fileName; }
                else { throw new Exception("Fehler beim Hochladen der Datei.", 500); }
            }

            // Speichern
            $newId = $this->announcementRepo->createAnnouncement(
                $userId,
                $title,
                $content,
                $targetRole,
                $targetClassId,
                $attachmentPath
            );

            // Daten für Rückgabe holen
            $newAnnouncement = $this->announcementRepo->getAnnouncementById($newId);
            if ($newAnnouncement) {
                $newAnnouncement['content_html'] = $this->parsedown->text($newAnnouncement['content'] ?? '');
                $author = $this->userRepo->findById($newAnnouncement['user_id']);
                $newAnnouncement['author_name'] = $author ? ($author['first_name'] . ' ' . $author['last_name']) : 'Unbekannt';
                if (!empty($newAnnouncement['file_path'])) {
                     $newAnnouncement['file_url'] = rtrim(Database::getConfig()['base_url'], '/') . '/' . ltrim($newAnnouncement['file_path'], '/');
                } else {
                   $newAnnouncement['file_url'] = null;
                }
                $newAnnouncement['visibility'] = $newAnnouncement['is_global'] ? 'global' : 'class';
            }
            
            // Log-Details
            $logDetails = [
                'title' => $title, 
                'target_role' => $targetRole, 
                'target_class_id' => $targetClassId,
                'has_attachment' => !empty($attachmentPath)
            ];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Ankündigung erfolgreich erstellt.', 'data' => $newAnnouncement],
                'log_action' => 'create_announcement',
                'log_target_type' => 'announcement',
                'log_target_id' => $newId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'form', // Wichtig: Nutzt $_POST und $_FILES
            'checkRole' => ['admin', 'planer', 'lehrer']
        ]);
    }

    /**
     * API: Löscht eine Ankündigung. (POST/FormData)
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_POST.
     */
    public function deleteAnnouncement()
    {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $announcementId = filter_var($data['announcement_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$announcementId) { throw new Exception("Ungültige Ankündigungs-ID.", 400); }
            $announcement = $this->announcementRepo->getAnnouncementById($announcementId);
            if (!$announcement) { throw new Exception("Ankündigung nicht gefunden.", 404); }
            
            // Berechtigungsprüfung
            if ($userRole === 'lehrer' && $announcement['user_id'] !== $userId) { 
                 throw new Exception("Sie sind nicht berechtigt, diese Ankündigung zu löschen.", 403); 
            }

            $success = $this->announcementRepo->deleteAnnouncement($announcementId);
            if (!$success) { 
                 throw new Exception("Fehler beim Löschen der Ankündigung.", 500); 
            }
            
            // Log-Details
            $logDetails = ['title' => $announcement['title'] ?? 'N/A'];
            
            // Rückgabe für Trait
            return [
                 'json_response' => ['success' => true, 'message' => 'Ankündigung erfolgreich gelöscht.'],
                 'log_action' => 'delete_announcement',
                 'log_target_type' => 'announcement',
                 'log_target_id' => $announcementId,
                 'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'form', // JS sendet FormData
            'checkRole' => ['admin', 'planer', 'lehrer']
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\AuditLogController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\CommunityController.php ---
<?php
// app/Http/Controllers/Admin/CommunityController.php

namespace App\Http\Controllers\Admin;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\CommunityPostRepository;
use Exception;
use PDO;
use \Parsedown; // KORREKTUR: Parsedown aus dem globalen Namespace importieren

class CommunityController
{
    private PDO $pdo;
    private CommunityPostRepository $postRepo;
    private Parsedown $parsedown; // KORREKTUR: Typehint kann jetzt ohne Backslash sein

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->postRepo = new CommunityPostRepository($this->pdo);
        $this->parsedown = new Parsedown(); // KORREKTUR: Kann jetzt direkt verwendet werden
        $this->parsedown->setSafeMode(true);
    }

    /**
     * Zeigt die Hauptseite für die Moderation des Schwarzen Bretts an.
     * NEU: Lädt jetzt ausstehende UND freigegebene Beiträge.
     */
    public function index()
    {
        Security::requireRole(['admin', 'planer']); // Nur Admins/Planer dürfen moderieren
        global $config;
        $config = Database::getConfig();

        $page_title = 'Moderation Schwarzes Brett';
        $body_class = 'admin-dashboard-body';

        try {
            // Lade alle ausstehenden Beiträge
            $pendingPosts = $this->postRepo->getPostsByStatus('pending');
            
            // Konvertiere Markdown zu HTML für die Vorschau
            foreach ($pendingPosts as &$post) {
                $post['content_html'] = $this->parsedown->text($post['content'] ?? '');
            }
            unset($post); // Referenz aufheben

            // NEU: Lade alle freigegebenen Beiträge
            $approvedPosts = $this->postRepo->getPostsByStatus('approved');
            
            // Konvertiere Markdown zu HTML für die Vorschau
            foreach ($approvedPosts as &$post) {
                $post['content_html'] = $this->parsedown->text($post['content'] ?? '');
            }
            unset($post); // Referenz aufheben


            Security::getCsrfToken();
            include_once dirname(__DIR__, 4) .'/pages/admin/community_moderation.php';

        } catch (Exception $e) {
            error_log("Fehler beim Laden der Moderationsseite: " . $e->getMessage());
            http_response_code(500);
            die("Ein Fehler ist beim Laden der Seite aufgetreten: " . $e->getMessage());
        }
    }
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\CommunityController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\CsvTemplateController.php ---
<?php
// app/Http/Controllers/Admin/CsvTemplateController.php

namespace App\Http\Controllers\Admin;

use App\Core\Security;
use App\Core\Database;
use Exception;

class CsvTemplateController
{
    /**
     * Zeigt die Seite mit der CSV-Importvorlage an.
     */
    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();

        $page_title = 'CSV Importvorlage';
        $body_class = 'admin-dashboard-body';
        
        $templateData = $this->loadCsvTemplate();

        // Übergibt $templateData (Header und Zeilen) an die View
        include_once dirname(__DIR__, 4) . '/pages/admin/csv_template.php';
    }

    /**
     * Lädt die CSV-Vorlagendatei und parst sie.
     * @return array Ein Array mit 'headers' (array) und 'rows' (array of arrays).
     */
    private function loadCsvTemplate(): array
    {
        $templatePath = dirname(__DIR__, 4) . '/public/assets/templates/user_import_template.csv';
        $csvData = [
            'headers' => [],
            'rows' => []
        ];

        if (!file_exists($templatePath)) {
            // Zeigt einen Fehler an, wenn die Vorlagendatei fehlt
            $csvData['error'] = "Vorlagendatei nicht gefunden unter: " . htmlspecialchars($templatePath);
            return $csvData;
        }

        if (($handle = fopen($templatePath, "r")) !== FALSE) {
            // Lese Header
            if (($headers = fgetcsv($handle, 1000, ",")) !== FALSE) {
                $csvData['headers'] = $headers;
            }
            // Lese Beispielzeilen
            while (($data = fgetcsv($handle, 1000, ",")) !== FALSE) {
                $csvData['rows'][] = $data;
            }
            fclose($handle);
        } else {
             $csvData['error'] = "Vorlagendatei konnte nicht gelesen werden.";
        }

        return $csvData;
    }
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\CsvTemplateController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\DashboardController.php ---
<?php
// app/Http/Controllers/Admin/DashboardController.php

// MODIFIZIERT:
// 1. SystemHealthService importiert und im Konstruktor instanziiert.
// 2. Die private Methode performSystemChecks() wurde entfernt.
// 3. index() ruft jetzt $this->healthService->getSystemInfo() und
//    $this->healthService->performSystemChecks() auf, um die Daten zu laden.

namespace App\Http\Controllers\Admin;

use App\Core\Security;
use App\Core\Database;
use App\Core\Utils;
use App\Repositories\UserRepository;
use App\Repositories\StammdatenRepository;
use App\Repositories\AuditLogRepository;
use App\Repositories\PlanRepository;
use App\Services\SystemHealthService; // NEU: Service importieren
use PDO;
use Exception;
use DateTime;

class DashboardController
{
    private PDO $pdo;
    private UserRepository $userRepo;
    private StammdatenRepository $stammdatenRepo;
    private AuditLogRepository $auditRepo;
    private PlanRepository $planRepo;
    private SystemHealthService $healthService; // NEU

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->userRepo = new UserRepository($this->pdo);
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
        $this->auditRepo = new AuditLogRepository($this->pdo);
        $this->planRepo = new PlanRepository($this->pdo);
        $this->healthService = new SystemHealthService(); // NEU
    }

    /**
     * VERALTET: Die Methode private function performSystemChecks() wurde entfernt.
     * Die Logik befindet sich jetzt im SystemHealthService.
     */
    // private function performSystemChecks(): array { ... } // (ENTFERNT)


    /**
     * Zeigt das Admin-Dashboard an.
     * MODIFIZIERT: Ruft System-Infos und Checks vom SystemHealthService ab.
     */
    public function index()
    {
        Security::requireRole('admin');

        global $config;
        $config = Database::getConfig();

        $page_title = 'Admin Dashboard';
        $body_class = 'admin-dashboard-body';

        $dashboardData = [];
        try {
            // Statistiken
            $dashboardData['userCounts'] = $this->userRepo->countUsersByRole();
            $dashboardData['totalUsers'] = array_sum($dashboardData['userCounts']);
            $dashboardData['classCount'] = $this->stammdatenRepo->countClasses();
            $dashboardData['teacherCount'] = $this->stammdatenRepo->countTeachers();
            $dashboardData['subjectCount'] = $this->stammdatenRepo->countSubjects();
            $dashboardData['roomCount'] = $this->stammdatenRepo->countRooms();

            // Letzte Audit-Logs
            $dashboardData['latestLogs'] = $this->auditRepo->getLogs(1, 5);

            // Aktuelle Einstellungen
            $dashboardData['settings'] = Utils::getSettings();

            // NEU: System-Infos und Checks vom Service holen
            $dashboardData['systemInfo'] = $this->healthService->getSystemInfo();
            $dashboardData['systemChecks'] = $this->healthService->performSystemChecks();

            // Veröffentlichungsstatus
            $currentYear = (int)date('o');
            $currentWeek = (int)date('W');
            $nextWeekDate = new DateTime('+1 week');
            $nextYear = (int)$nextWeekDate->format('o');
            $nextWeek = (int)$nextWeekDate->format('W');
            
            $dashboardData['publishStatus']['currentWeekNum'] = $currentWeek;
            $dashboardData['publishStatus']['nextWeekNum'] = $nextWeek;
            $dashboardData['publishStatus']['current'] = $this->planRepo->getPublishStatus($currentYear, $currentWeek);
            $dashboardData['publishStatus']['next'] = $this->planRepo->getPublishStatus($nextYear, $nextWeek);

        } catch (Exception $e) {
            error_log("Fehler beim Laden der Admin-Dashboard-Daten: " . $e->getMessage());
            // Setze leere Werte, um Fehler in der View zu vermeiden
            $dashboardData['userCounts'] = [];
            $dashboardData['totalUsers'] = 0;
            $dashboardData['classCount'] = 0;
            $dashboardData['teacherCount'] = 0;
            $dashboardData['subjectCount'] = 0;
            $dashboardData['roomCount'] = 0;
            $dashboardData['latestLogs'] = [];
            $dashboardData['settings'] = Utils::getSettings();
            $dashboardData['systemInfo'] = ['php' => 'N/A', 'db' => 'N/A', 'webserver' => 'N/A'];
            $dashboardData['systemChecks'] = [];
            $dashboardData['publishStatus'] = ['current' => [], 'next' => [], 'currentWeekNum' => (int)date('W'), 'nextWeekNum' => (int)(new DateTime('+1 week'))->format('W')];
            $dashboardData['error'] = "Einige Dashboard-Daten konnten nicht geladen werden.";
        }

        Security::getCsrfToken();

        require_once dirname(__DIR__, 4) . '/pages/admin/dashboard.php';
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\DashboardController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\SettingsController.php ---
<?php
// app/Http/Controllers/Admin/SettingsController.php

// MODIFIZIZERT:
// 1. FileUploadService importiert und im Konstruktor injiziert.
// 2. Die private Methode handleFileUpload() wurde entfernt.
// 3. Die save()-Methode verwendet jetzt $this->fileUploadService->handleUpload()
//    und $this->fileUploadService->deleteFile().
// 4. Die Logik zum Entfernen von Dateien wurde in den Callback des Traits verschoben.

namespace App\Http\Controllers\Admin;

use App\Core\Security;
use App\Core\Database;
use App\Core\Utils;
use App\Core\Cache;
use App\Repositories\SettingsRepository;
use App\Services\AuditLogger;
use App\Http\Traits\ApiHandlerTrait;
use App\Services\FileUploadService; // NEU: FileUploadService importieren
use Exception;
use PDO;

class SettingsController
{
    use ApiHandlerTrait;

    private SettingsRepository $settingsRepo;
    private FileUploadService $fileUploadService; // NEU

    // VERALTET: $uploadDir wird nicht mehr benötigt, da der Service den Pfad kennt.
    // private string $uploadDir; 

    public function __construct()
    {
        $this->settingsRepo = new SettingsRepository();
        $this->fileUploadService = new FileUploadService(); // NEU: Service instanziieren
        // $this->uploadDir = ... (ENTFERNT)
    }

    /**
     * Zeigt die Hauptseite für die Anwendungseinstellungen an.
     * MODIFIZIERT: Erstellt das Verzeichnis nicht mehr hier, der Service macht das bei Bedarf.
     */
    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();

        $page_title = 'Anwendungs-Einstellungen';
        $body_class = 'admin-dashboard-body';

        $currentSettings = Utils::getSettings();

        // Verzeichnis-Erstellung entfernt - der FileUploadService kümmert sich darum.

        Security::getCsrfToken();
        include_once dirname(__DIR__, 4) . '/pages/admin/settings.php';
    }

    /**
     * VERALTET: Die Methode private function handleFileUpload() wurde entfernt.
     * Die Logik befindet sich jetzt im FileUploadService.
     */
    // private function handleFileUpload(...) { ... } // (ENTFERNT)


    /**
     * API: Speichert die Anwendungseinstellungen.
     * MODIFIZIERT: Nutzt jetzt FileUploadService.
     */
    public function save()
    {
        $this->handleApiRequest(function($data) { // $data ist $_POST

            $oldSettings = Utils::getSettings();
            $logoPath = $oldSettings['site_logo_path'] ?? null;
            $faviconPath = $oldSettings['site_favicon_path'] ?? null;

            // --- Datei-Uploads / Löschungen ---
            
            // 1. Logo verarbeiten
            if (isset($_FILES['site_logo']) && $_FILES['site_logo']['error'] === UPLOAD_ERR_OK) {
                // Wenn ein neues Logo hochgeladen wird, altes zuerst löschen
                $this->fileUploadService->deleteFile($logoPath);
                // Neues Logo hochladen und Pfad speichern
                $logoPath = $this->fileUploadService->handleUpload(
                    'site_logo',
                    'branding',
                    ['image/png' => 'png', 'image/jpeg' => 'jpg', 'image/svg+xml' => 'svg', 'image/gif' => 'gif']
                );
            } elseif (isset($data['remove_site_logo']) && $data['remove_site_logo'] === '1') {
                // Logo entfernen (ohne neues hochzuladen)
                $this->fileUploadService->deleteFile($logoPath);
                $logoPath = null;
            }
            // (Wenn nichts passiert, bleibt $logoPath der alte Pfad)

            // 2. Favicon verarbeiten
            if (isset($_FILES['site_favicon']) && $_FILES['site_favicon']['error'] === UPLOAD_ERR_OK) {
                $this->fileUploadService->deleteFile($faviconPath);
                $faviconPath = $this->fileUploadService->handleUpload(
                    'site_favicon',
                    'branding',
                    ['image/x-icon' => 'ico', 'image/png' => 'png', 'image/svg+xml' => 'svg']
                );
            } elseif (isset($data['remove_site_favicon']) && $data['remove_site_favicon'] === '1') {
                $this->fileUploadService->deleteFile($faviconPath);
                $faviconPath = null;
            }

            // --- Validierungen (unverändert) ---
            $startHour = filter_var($data['default_start_hour'] ?? 1, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 12]]);
            $endHour = filter_var($data['default_end_hour'] ?? 10, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 12]]);
            if ($startHour === false || $endHour === false || $startHour >= $endHour) {
                throw new Exception("Ungültiger Stundenbereich (1-12, Start < Ende).", 400);
            }
            $maxAttempts = filter_var($data['max_login_attempts'] ?? 5, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 100]]);
            $lockoutMinutes = filter_var($data['lockout_minutes'] ?? 15, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 1440]]);
            if ($maxAttempts === false || $lockoutMinutes === false) {
                throw new Exception("Ungültige Werte für Login-Sperre.", 400);
            }
            $defaultTheme = $data['default_theme'] ?? 'light';
            if (!in_array($defaultTheme, ['light', 'dark'])) {
                $defaultTheme = 'light';
            }
            $icalWeeksFuture = filter_var($data['ical_weeks_future'] ?? 8, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 52]]);
            if ($icalWeeksFuture === false) {
                throw new Exception("Ungültige Anzahl an iCal-Wochen (1-52).", 400);
            }
            $whitelistIPs = $data['maintenance_whitelist_ips'] ?? '';
            $whitelistIPs = preg_replace('/[^0-9a-fA-F:.,\s]/', '', $whitelistIPs);
            $whitelistIPs = preg_replace('/[\s,]+/', ',', $whitelistIPs);
            $whitelistIPs = trim($whitelistIPs, ',');


            // Aufbereitete Einstellungen für das Repository
            $settingsToSave = [
                'site_title' => trim($data['site_title'] ?? 'PAUSE Portal'),
                'maintenance_mode' => (isset($data['maintenance_mode']) && ($data['maintenance_mode'] === 'on' || $data['maintenance_mode'] === '1')) ? '1' : '0',
                'maintenance_message' => trim($data['maintenance_message'] ?? ''),
                'maintenance_whitelist_ips' => $whitelistIPs,
                'default_start_hour' => $startHour,
                'default_end_hour' => $endHour,
                'max_login_attempts' => $maxAttempts,
                'lockout_minutes' => $lockoutMinutes,
                'site_logo_path' => $logoPath, // NEU: Der aktualisierte Pfad
                'site_favicon_path' => $faviconPath, // NEU: Der aktualisierte Pfad
                'default_theme' => $defaultTheme,
                'ical_enabled' => (isset($data['ical_enabled']) && ($data['ical_enabled'] === 'on' || $data['ical_enabled'] === '1')) ? '1' : '0',
                'ical_weeks_future' => $icalWeeksFuture,
                'pdf_footer_text' => trim($data['pdf_footer_text'] ?? ''),
                'community_board_enabled' => (isset($data['community_board_enabled']) && ($data['community_board_enabled'] === 'on' || $data['community_board_enabled'] === '1')) ? '1' : '0',
            ];

            // Speichern
            $this->settingsRepo->saveSettings($settingsToSave);

            // Cache in Utils löschen (wichtig!)
            Utils::clearSettingsCache();

            // Protokollierung - logge nur geänderte Werte
            $changedDetails = [];
            foreach ($settingsToSave as $key => $newValue) {
                $oldValue = $oldSettings[$key];
                
                if (is_bool($oldValue)) {
                     $newValueForCompare = $newValue === '1';
                } else if (is_numeric($newValue)) {
                     $newValueForCompare = (int)$newValue;
                } else {
                     $newValueForCompare = $newValue;
                }

                if ($newValueForCompare != $oldValue) {
                    if ($key === 'site_logo_path' || $key === 'site_favicon_path') {
                        if ($newValue === null && $oldValue !== null) $changedDetails[$key] = 'entfernt';
                        elseif ($newValue !== null && $oldValue === null) $changedDetails[$key] = 'hinzugefügt';
                        elseif ($newValue !== $oldValue) $changedDetails[$key] = 'geändert';
                    } else {
                        $changedDetails[$key] = ['old' => $oldValue, 'new' => $newValueForCompare];
                    }
                }
            }
            $changedDetails = array_filter($changedDetails);


            // Rückgabe-Array für den ApiHandlerTrait
            return [
                'json_response' => [
                    'success' => true,
                    'message' => 'Einstellungen erfolgreich gespeichert.',
                    'data' => [ 
                        'site_logo_path' => $logoPath,
                        'site_favicon_path' => $faviconPath,
                        'default_theme' => $defaultTheme
                    ]
                ],
                'log_action' => 'update_settings',
                'log_target_type' => 'system',
                'log_details' => $changedDetails ?: null
            ];

        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }


    /**
     * API-Endpunkt zum Leeren des Caches.
     * (Unverändert)
     */
    public function clearCacheApi()
    {
        $this->handleApiRequest(function($data) {

            Utils::clearSettingsCache();
            $settingsMessage = 'Einstellungen-Cache geleert.';

            $appCacheResult = Cache::clearAll();
            $appMessage = $appCacheResult['message'];

            if (!$appCacheResult['success']) {
                throw new Exception("Fehler beim Leeren des App-Caches: " . $appMessage, 500);
            }

            return [
                'json_response' => [
                    'success' => true,
                    'message' => "Erfolgreich! $settingsMessage. $appMessage"
                ],
                'log_action' => 'clear_cache',
                'log_target_type' => 'system',
                'log_details' => ['cache_type' => 'all_application_caches']
            ];

        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\SettingsController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\StammdatenController.php ---
<?php
// app/Http/Controllers/Admin/StammdatenController.php

// MODIFIZIERT:
// 1. ApiHandlerTrait importiert und verwendet.
// 2. Die lokale Implementierung von handleApiRequest() wurde entfernt.
// 3. Alle API-Methoden (get/create/update/delete für alle Typen) wurden
//    vollständig refaktorisiert, um die Trait-Methode zu nutzen.
// 4. 'inputType' => 'get' für Lesezugriffe, 'inputType' => 'form' für Schreibzugriffe.
// 5. Alle Callbacks geben jetzt das vom Trait erwartete Array-Format zurück
//    (inkl. 'json_response', 'log_action', 'log_target_id' etc.).

namespace App\Http\Controllers\Admin;

use App\Core\Security;
use App\Core\Database;
use App\Repositories\StammdatenRepository;
use Exception;
use PDO;
use App\Services\AuditLogger;
use App\Http\Traits\ApiHandlerTrait; // NEU: Trait importieren

class StammdatenController
{
    // NEU: Trait für API-Behandlung einbinden
    use ApiHandlerTrait;

    private PDO $pdo;
    private StammdatenRepository $repository;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->repository = new StammdatenRepository($this->pdo);
    }

    /**
     * Zeigt die Hauptseite für die Stammdatenverwaltung an.
     * (Unverändert)
     */
    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();

        $page_title = 'Stammdatenverwaltung';
        $body_class = 'admin-dashboard-body';
         
        Security::getCsrfToken();

        include_once dirname(__DIR__, 4) . '/pages/admin/stammdaten.php';
    }

    // --- API METHODS FOR SUBJECTS ---

    /**
     * API: Holt alle Fächer und gibt sie als JSON zurück.
     * MODIFIZIERT: Nutzt ApiHandlerTrait.
     */
    public function getSubjects()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            $subjects = $this->repository->getSubjects();
            
            return [
                'json_response' => ['success' => true, 'data' => $subjects]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => 'admin'
        ]);
    }

    /**
     * API: Erstellt ein neues Fach.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_POST.
     */
    public function createSubject()
    {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            
            $name = trim($data['subject_name'] ?? '');
            $shortcut = trim($data['subject_shortcut'] ?? '');
            if (empty($name) || empty($shortcut)) {
                throw new Exception("Fachname und Kürzel dürfen nicht leer sein.", 400);
            }
            $newId = $this->repository->createSubject($name, $shortcut);
            $newSubject = ['subject_id' => $newId, 'subject_name' => $name, 'subject_shortcut' => $shortcut];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Fach erfolgreich erstellt.', 'data' => $newSubject],
                'log_action' => 'create_subject',
                'log_target_type' => 'subject',
                'log_target_id' => $newId,
                'log_details' => ['name' => $name, 'shortcut' => $shortcut]
            ];

        }, [
            'inputType' => 'form', // JS sendet FormData
            'checkRole' => 'admin'
        ]);
    }

    /**
     * API: Aktualisiert ein bestehendes Fach.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_POST.
     */
    public function updateSubject()
    {
         $this->handleApiRequest(function($data) { // $data ist $_POST
            
            $id = filter_var($data['subject_id'] ?? null, FILTER_VALIDATE_INT);
            $name = trim($data['subject_name'] ?? '');
            $shortcut = trim($data['subject_shortcut'] ?? '');

            if (!$id || empty($name) || empty($shortcut)) {
                throw new Exception("Ungültige Daten für das Update.", 400);
            }
            $this->repository->updateSubject($id, $name, $shortcut);
            $updatedSubject = ['subject_id' => $id, 'subject_name' => $name, 'subject_shortcut' => $shortcut];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Fach erfolgreich aktualisiert.', 'data' => $updatedSubject],
                'log_action' => 'update_subject',
                'log_target_type' => 'subject',
                'log_target_id' => $id,
                'log_details' => ['name' => $name, 'shortcut' => $shortcut]
            ];

        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    /**
     * API: Löscht ein Fach.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_POST.
     */
    public function deleteSubject()
    {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            
            $id = filter_var($data['subject_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$id) {
                throw new Exception("Ungültige ID.", 400);
            }

            // Hole Daten für Log VOR dem Löschen (optional, aber gut für Details)
            // $subject = $this->repository->getSubjectById($id); // Annahme: getSubjectById existiert
            // $details = ['name' => $subject['subject_name'] ?? 'N/A'];
            
            $this->repository->deleteSubject($id);

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Fach erfolgreich gelöscht.'],
                'log_action' => 'delete_subject',
                'log_target_type' => 'subject',
                'log_target_id' => $id,
                'log_details' => ['id' => $id] // $details
            ];

        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    // --- API METHODS FOR ROOMS ---

    public function getRooms() {
        $this->handleApiRequest(function($data) {
            $rooms = $this->repository->getRooms();
            return [
                'json_response' => ['success' => true, 'data' => $rooms]
            ];
        }, [
            'inputType' => 'get',
            'checkRole' => 'admin'
        ]);
    }

    public function createRoom() {
        $this->handleApiRequest(function($data) {
            $name = trim($data['room_name'] ?? '');
            if (empty($name)) throw new Exception("Raumname darf nicht leer sein.", 400);
            
            $newId = $this->repository->createRoom($name);
            $newRoom = ['room_id' => $newId, 'room_name' => $name];

            return [
                'json_response' => ['success' => true, 'message' => 'Raum erfolgreich erstellt.', 'data' => $newRoom],
                'log_action' => 'create_room',
                'log_target_type' => 'room',
                'log_target_id' => $newId,
                'log_details' => ['name' => $name]
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function updateRoom() {
        $this->handleApiRequest(function($data) {
            $id = filter_var($data['room_id'] ?? null, FILTER_VALIDATE_INT);
            $name = trim($data['room_name'] ?? '');
            if (!$id || empty($name)) throw new Exception("Ungültige Daten.", 400);
            
            $this->repository->updateRoom($id, $name);
            $updatedRoom = ['room_id' => $id, 'room_name' => $name];

            return [
                'json_response' => ['success' => true, 'message' => 'Raum erfolgreich aktualisiert.', 'data' => $updatedRoom],
                'log_action' => 'update_room',
                'log_target_type' => 'room',
                'log_target_id' => $id,
                'log_details' => ['name' => $name]
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function deleteRoom() {
        $this->handleApiRequest(function($data) {
            $id = filter_var($data['room_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$id) throw new Exception("Ungültige ID.", 400);
            
            $this->repository->deleteRoom($id);

            return [
                'json_response' => ['success' => true, 'message' => 'Raum erfolgreich gelöscht.'],
                'log_action' => 'delete_room',
                'log_target_type' => 'room',
                'log_target_id' => $id
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    // --- API METHODS FOR TEACHERS ---

    public function getTeachers() {
        $this->handleApiRequest(function($data) {
            $teachers = $this->repository->getTeachers();
            return [
                'json_response' => ['success' => true, 'data' => $teachers]
            ];
        }, [
            'inputType' => 'get',
            'checkRole' => 'admin'
        ]);
    }

    public function createTeacher() {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            $teacherData = [
                'shortcut' => trim($data['teacher_shortcut'] ?? ''),
                'first_name' => trim($data['first_name'] ?? ''),
                'last_name' => trim($data['last_name'] ?? ''),
                'email' => empty(trim($data['email'] ?? '')) ? null : trim($data['email'])
            ];

            if (empty($teacherData['shortcut']) || empty($teacherData['first_name']) || empty($teacherData['last_name'])) {
                throw new Exception("Kürzel, Vorname und Nachname sind Pflichtfelder.", 400);
            }
            
            $newId = $this->repository->createTeacher($teacherData);
            $newTeacher = array_merge(['teacher_id' => $newId], $teacherData);

            return [
                'json_response' => ['success' => true, 'message' => 'Lehrer erfolgreich erstellt.', 'data' => $newTeacher],
                'log_action' => 'create_teacher',
                'log_target_type' => 'teacher',
                'log_target_id' => $newId,
                'log_details' => $teacherData
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function updateTeacher() {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            $id = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $teacherData = [
                'shortcut' => trim($data['teacher_shortcut'] ?? ''),
                'first_name' => trim($data['first_name'] ?? ''),
                'last_name' => trim($data['last_name'] ?? ''),
                'email' => empty(trim($data['email'] ?? '')) ? null : trim($data['email'])
            ];

            if (!$id || empty($teacherData['shortcut']) || empty($teacherData['first_name']) || empty($teacherData['last_name'])) {
                throw new Exception("Ungültige Daten.", 400);
            }
            
            $this->repository->updateTeacher($id, $teacherData);
            $updatedTeacher = array_merge(['teacher_id' => $id], $teacherData);

            return [
                'json_response' => ['success' => true, 'message' => 'Lehrer erfolgreich aktualisiert.', 'data' => $updatedTeacher],
                'log_action' => 'update_teacher',
                'log_target_type' => 'teacher',
                'log_target_id' => $id,
                'log_details' => $teacherData
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function deleteTeacher() {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            $id = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$id) throw new Exception("Ungültige ID.", 400);
            
            $this->repository->deleteTeacher($id);

            return [
                'json_response' => ['success' => true, 'message' => 'Lehrer erfolgreich gelöscht.'],
                'log_action' => 'delete_teacher',
                'log_target_type' => 'teacher',
                'log_target_id' => $id
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    // --- API METHODS FOR CLASSES ---

    public function getClasses() {
        $this->handleApiRequest(function($data) {
            $classes = $this->repository->getClasses();
            return [
                'json_response' => ['success' => true, 'data' => $classes]
            ];
        }, [
            'inputType' => 'get',
            'checkRole' => 'admin'
        ]);
    }

    public function createClass() {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            
            // KORREKTUR: JS sendet 'class_id_input'
            $id = filter_var($data['class_id_input'] ?? null, FILTER_VALIDATE_INT);
            $name = trim($data['class_name'] ?? '');
            $teacherId = filter_var($data['class_teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $teacherId = ($teacherId === 0 || $teacherId === false) ? null : $teacherId;

            if (empty($name) || !$id || $id <= 0) {
                 throw new Exception("Klassen-ID (positiv) und Klassenname dürfen nicht leer sein.", 400);
            }

            // Repository wirft Exception bei Duplikat
            $this->repository->createClass($id, $name, $teacherId);
            $newClass = ['class_id' => $id, 'class_name' => $name, 'class_teacher_id' => $teacherId];
            
            // Log-Details
            $logDetails = ['name' => $name, 'teacher_id' => $teacherId];

            return [
                'json_response' => ['success' => true, 'message' => 'Klasse erfolgreich erstellt.', 'data' => $newClass],
                'log_action' => 'create_class',
                'log_target_type' => 'class',
                'log_target_id' => $id,
                'log_details' => $logDetails
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function updateClass() {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            
            // KORREKTUR: JS sendet 'class_id_hidden'
            $id = filter_var($data['class_id_hidden'] ?? null, FILTER_VALIDATE_INT);
            $name = trim($data['class_name'] ?? '');
            $teacherId = filter_var($data['class_teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $teacherId = ($teacherId === 0 || $teacherId === false) ? null : $teacherId;

            if (!$id || empty($name)) {
                 throw new Exception("Ungültige Daten für Update (ID und Name benötigt).", 400);
            }
            
            $this->repository->updateClass($id, $name, $teacherId);
            $updatedClass = ['class_id' => $id, 'class_name' => $name, 'class_teacher_id' => $teacherId];

            // Log-Details
            $logDetails = ['name' => $name, 'teacher_id' => $teacherId];

            return [
                'json_response' => ['success' => true, 'message' => 'Klasse erfolgreich aktualisiert.', 'data' => $updatedClass],
                'log_action' => 'update_class',
                'log_target_type' => 'class',
                'log_target_id' => $id,
                'log_details' => $logDetails
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function deleteClass() {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            
            $id = filter_var($data['class_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$id) throw new Exception("Ungültige ID.", 400);
            
            $this->repository->deleteClass($id);

            return [
                'json_response' => ['success' => true, 'message' => 'Klasse erfolgreich gelöscht.'],
                'log_action' => 'delete_class',
                'log_target_type' => 'class',
                'log_target_id' => $id
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\StammdatenController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\SystemHealthController.php ---
<?php
// app/Http/Controllers/Admin/SystemHealthController.php

// MODIFIZIERT:
// 1. SystemHealthService importiert und im Konstruktor instanziiert.
// 2. Alle privaten Logik-Methoden (checkDbStatus, checkExtensions, checkDirectories) wurden entfernt.
// 3. index() ruft jetzt $this->healthService->performSystemChecks() und
//    $this->healthService->getSystemInfo() auf, um die Daten zu laden.
// 4. Die Datenstruktur, die an die View übergeben wird, wurde angepasst,
//    um dem neuen Service-Format zu entsprechen.

namespace App\Http\Controllers\Admin;

use App\Core\Security;
use App\Core\Utils;
use App\Core\Database;
use App\Services\SystemHealthService; // NEU: Service importieren

class SystemHealthController
{
    private SystemHealthService $healthService; // NEU

    public function __construct()
    {
        Security::requireRole('admin');
        $this->healthService = new SystemHealthService(); // NEU
    }

    /**
     * Zeigt die System-Status-Seite an.
     * MODIFIZIERT: Ruft Daten vom SystemHealthService ab.
     */
    public function index()
    {
        global $config;
        $config = Database::getConfig();
        $page_title = 'System-Status';
        $body_class = 'admin-dashboard-body';

        // NEU: Daten vom Service abrufen
        $systemInfo = $this->healthService->getSystemInfo();
        $systemChecks = $this->healthService->performSystemChecks();

        // Daten für die View aufbereiten
        $data = [
            'phpVersion' => $systemInfo['php'],
            'serverSoftware' => $systemInfo['webserver'],
            'dbStatus' => $systemChecks['database'], // 'database' enthält jetzt [status, message, tooltip]
            'extensions' => [], // Wird unten gefüllt
            'directoryStatus' => [], // Wird unten gefüllt
            'settings' => Utils::getSettings() // Für den Wartungsmodus-Status
        ];

        // Daten aus den Checks extrahieren, damit die View (system_health.php)
        // weiterhin funktioniert, ohne die View ändern zu müssen.
        foreach ($systemChecks as $key => $check) {
            if (str_starts_with($key, 'ext_')) {
                $extName = str_replace('ext_', '', $key);
                $data['extensions'][$extName] = $check['status']; // true oder false
            }
            if (str_starts_with($key, 'uploads/') || $key === 'cache') {
                 $data['directoryStatus'][$key] = [
                    'status' => $check['status'] ? 'ok' : 'error',
                    'message' => $check['message']
                 ];
            }
        }

        // KORREKTUR: View direkt laden
        include_once dirname(__DIR__, 4) . '/pages/admin/system_health.php';
    }

    /**
     * VERALTET: Alle privaten Check-Methoden wurden entfernt.
     * Die Logik befindet sich jetzt im SystemHealthService.
     */
    // private function checkDbStatus(): array { ... } // (ENTFERNT)
    // private function checkExtensions(): array { ... } // (ENTFERNT)
    // private function checkDirectories(): array { ... } // (ENTFERNT)
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\SystemHealthController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\UserController.php ---
<?php
// app/Http/Controllers/Admin/UserController.php

// MODIFIZIERT:
// 1. ImpersonationService importiert und im Konstruktor injiziert.
// 2. impersonateUserApi() wurde refaktorisiert:
//    - Die gesamte Session-Logik wurde entfernt.
//    - Ruft jetzt $this->impersonationService->start() auf.
//    - Nutzt die Rückgabe des Service für das Audit-Log.
// KORREKTUR: Duplizierter Code (Zeile 63-102) entfernt und index() wiederhergestellt.

namespace App\Http\Controllers\Admin;

use App\Core\Security;
use App\Core\Database;
use App\Core\Utils;
use App\Repositories\UserRepository;
use App\Repositories\StammdatenRepository;
use App\Repositories\LoginAttemptRepository;
use App\Services\AuthenticationService;
use App\Services\ImpersonationService; // NEU: Service importieren
use App\Http\Traits\ApiHandlerTrait;
use Exception;
use PDO;
use App\Services\AuditLogger;

class UserController
{
    use ApiHandlerTrait;

    private PDO $pdo;
    private UserRepository $userRepository;
    private StammdatenRepository $stammdatenRepository;
    private AuthenticationService $authService;
    private ImpersonationService $impersonationService; // NEU

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->userRepository = new UserRepository($this->pdo);
        $this->stammdatenRepository = new StammdatenRepository($this->pdo);
        
        $loginAttemptRepository = new LoginAttemptRepository($this->pdo);
        $this->authService = new AuthenticationService($this->userRepository, $loginAttemptRepository);
        
        // NEU: ImpersonationService instanziieren (benötigt UserRepository)
        $this->impersonationService = new ImpersonationService($this->userRepository);
    }

    /**
     * Zeigt die Hauptseite für die Benutzerverwaltung an.
     * KORRIGIERT: Korrekte Implementierung wiederhergestellt.
     */
    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();

        $page_title = 'Benutzerverwaltung';
        $body_class = 'admin-dashboard-body';
        
        Security::getCsrfToken();

        include_once dirname(__DIR__, 4) . '/pages/admin/users.php';
    }

    /**
     * API: Holt alle Benutzer und gibt sie als JSON zurück. (GET request)
     * (Unverändert)
     */
    public function getUsers()
    {
        $this->handleApiRequest(function($data) {
            
            $users = $this->userRepository->getAll();
            $roles = $this->userRepository->getAvailableRoles();
            $classes = $this->stammdatenRepository->getClasses();
            $teachers = $this->stammdatenRepository->getTeachers();

            return [
                'json_response' => [
                    'success' => true, 
                    'data' => [
                        'users' => $users,
                        'roles' => $roles,
                        'classes' => $classes,
                        'teachers' => $teachers
                    ]
                ]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => 'admin'
        ]);
    }

    /**
     * API: Erstellt einen neuen Benutzer. (FormData request)
     * (Unverändert)
     */
    public function createUser()
    {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            
            $newUserId = $this->userRepository->create($data);
            $newUser = $this->userRepository->findById($newUserId);

            $details = $data;
            unset($details['password']);
            
            return [
                'json_response' => ['success' => true, 'message' => 'Benutzer erfolgreich erstellt.', 'data' => $newUser],
                'log_action' => 'create_user',
                'log_target_type' => 'user',
                'log_target_id' => $newUserId,
                'log_details' => $details
            ];

        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    /**
     * API: Aktualisiert einen bestehenden Benutzer. (FormData request)
     * (Unverändert)
     */
    public function updateUser()
    {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            
            $id = $data['user_id'] ?? null;
            if (!$id) {
                throw new Exception("Ungültige Benutzer-ID.", 400);
            }
            
            $this->userRepository->update($id, $data);
            $updatedUser = $this->userRepository->findById($id);

            $details = $data;
            unset($details['password']);

            return [
                'json_response' => ['success' => true, 'message' => 'Benutzer erfolgreich aktualisiert.', 'data' => $updatedUser],
                'log_action' => 'update_user',
                'log_target_type' => 'user',
                'log_target_id' => $id,
                'log_details' => $details
            ];

        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    /**
     * API: Löscht einen Benutzer. (FormData request)
     * (Unverändert)
     */
    public function deleteUser()
    {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            
            $id = $data['user_id'] ?? null;
            if (!$id) {
                throw new Exception("Ungültige ID.", 400);
            }
            
            $user = $this->userRepository->findById($id);
            $details = ['username' => $user['username'] ?? 'N/A'];
            
            $this->userRepository->delete($id);

            return [
                'json_response' => ['success' => true, 'message' => 'Benutzer erfolgreich gelöscht.'],
                'log_action' => 'delete_user',
                'log_target_type' => 'user',
                'log_target_id' => $id,
                'log_details' => $details
            ];

        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    /**
     * API: Importiert Benutzer aus einer CSV-Datei. (FormData request)
     * (Unverändert)
     */
    public function importUsers()
    {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            
            if (!isset($_FILES['csv_file']) || $_FILES['csv_file']['error'] !== UPLOAD_ERR_OK) {
                throw new Exception('Keine CSV-Datei hochgeladen oder Fehler beim Upload.', 400);
            }

            $tmpFilePath = $_FILES['csv_file']['tmp_name'];
            $fileType = mime_content_type($tmpFilePath);
            $fileExtension = strtolower(pathinfo($_FILES['csv_file']['name'], PATHINFO_EXTENSION));

            if (!in_array($fileType, ['text/plain', 'text/csv', 'application/csv']) && $fileExtension !== 'csv') {
                 throw new Exception('Ungültiger Dateityp. Bitte laden Sie eine CSV-Datei hoch.', 400);
            }

            $validClasses = $this->stammdatenRepository->getClasses();
            $validTeachers = $this->stammdatenRepository->getTeachers();
            $validRoles = $this->userRepository->getAvailableRoles();
            
            $validationData = [
                'class_ids' => array_column($validClasses, 'class_id'),
                'teacher_ids' => array_column($validTeachers, 'teacher_id'),
                'roles' => $validRoles
            ];

            $result = $this->userRepository->importFromCSV($tmpFilePath, $validationData);

            $logDetails = [
                'filename' => $_FILES['csv_file']['name'],
                'success_count' => $result['success_count'],
                'failure_count' => $result['failure_count'],
                'errors' => array_slice($result['errors'], 0, 10)
            ];

            return [
                'json_response' => ['success' => true, 'message' => 'Import abgeschlossen.', 'data' => $result],
                'log_action' => 'import_users_csv',
                'log_target_type' => 'system',
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }
    
    /**
     * API-Endpunkt zum Starten der User-Impersonation. (JSON request)
     * (Unverändert)
     */
    public function impersonateUserApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $targetUserId = $data['user_id'] ?? null;
            if (!$targetUserId) {
                throw new Exception("Keine Benutzer-ID zum Imitieren angegeben.", 400);
            }
            $currentAdminId = $_SESSION['user_id'];

            $targetUser = $this->impersonationService->start((int)$targetUserId, (int)$currentAdminId);

            $logDetails = [
                'target_user_id' => $targetUserId, 
                'target_username' => $targetUser['username'] ?? 'N/A'
            ];

            return [
                'json_response' => ['success' => true, 'redirectUrl' => Utils::url('dashboard')],
                'log_action' => 'impersonate_start',
                'log_target_type' => 'user',
                'log_target_id' => $currentAdminId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => 'admin'
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\UserController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Auth\AuthController.php ---
<?php
// app/Http/Controllers/Auth/AuthController.php

// MODIFIZIERT:
// 1. ImpersonationService importiert und im Konstruktor injiziert.
// 2. revertImpersonation() wurde refaktorisiert:
//    - Die gesamte Session-Logik wurde entfernt.
//    - Ruft jetzt $this->impersonationService->revert() auf.
//    - Nutzt die Rückgabe des Service für das Audit-Log.
//    - Leitet bei Erfolg zum Admin-Dashboard (Benutzerliste) weiter.
// 3. KORREKTUR: Syntaxfehler (eingefügtes "Dienstag") in handleLogin() entfernt.

namespace App\Http\Controllers\Auth;

use App\Core\Database;
use App\Core\Utils;
use App\Core\Security;
use App\Repositories\UserRepository;
use App\Services\AuthenticationService;
use App\Services\AuditLogger;
use App\Services\ImpersonationService; // NEU: Service importieren
use Exception;
use PDO;

class AuthController
{
    private PDO $pdo;
    private UserRepository $userRepository;
    private ImpersonationService $impersonationService; // NEU

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->userRepository = new UserRepository($this->pdo);
        // NEU: Service instanziieren (benötigt UserRepository)
        $this->impersonationService = new ImpersonationService($this->userRepository);
    }

    /**
     * Verarbeitet die POST-Anfrage vom Login-Formular.
     * KORRIGIERT: Syntaxfehler entfernt.
     */
    public function handleLogin()
    {
        try {
            Security::verifyCsrfToken();
        } catch (Exception $e) {
            $message = $e->getMessage();
            $page_title = 'Login';
            Security::getCsrfToken();
            include_once dirname(__DIR__, 4) . '/pages/auth/login.php';
            return;
        }

        $identifier = $_POST['identifier'] ?? '';
        $password = $_POST['password'] ?? '';

        try {
            // Erstelle die notwendigen Objekte.
            $loginAttemptRepository = new \App\Repositories\LoginAttemptRepository($this->pdo);
            $authService = new AuthenticationService($this->userRepository, $loginAttemptRepository);

            // Führe den Login-Versuch durch.
            $userData = $authService->login($identifier, $password);

            // Wenn der Login erfolgreich war (kein Fehler geworfen wurde):
            session_regenerate_id(true); // Wichtig für die Sicherheit
            $_SESSION['user_id'] = $userData['user_id'];
            $_SESSION['username'] = $userData['username'];
            $_SESSION['user_role'] = $userData['role'];
            // NEU: Sperrstatus in Session geladen (passiert in AuthenticationService)
            
            Security::getCsrfToken();

            // Leite zum Dashboard weiter.
            // KORREKTUR: "Dienstag" entfernt
            header("Location: " . Utils::url('dashboard'));
            exit();

        } catch (Exception $e) {
            $message = $e->getMessage();
            $page_title = 'Login';
            Security::getCsrfToken();
            include_once dirname(__DIR__, 4) . '/pages/auth/login.php';
        }
    }

    /**
     * Zeigt die Login-Seite an.
     * (Unverändert)
     */
    public function showLogin()
    {
        global $config;
        $config = Database::getConfig(); // KORREKTUR: getConfig() statt getInstance()
        $page_title = 'Login';
        $message = $_SESSION['flash_message'] ?? '';
        unset($_SESSION['flash_message']);
        Security::getCsrfToken();
        include_once dirname(__DIR__, 4) . '/pages/auth/login.php';
    }

    /**
     * Loggt den Benutzer aus.
     * (Unverändert)
     */
    public function logout()
    {
        $_SESSION = [];
        session_destroy();
        session_start();
        $_SESSION['flash_message'] = "Sie wurden erfolgreich abgemeldet.";
        header("Location: " . Utils::url('login'));
        exit();
    }
    
    /**
     * Beendet die Impersonation und stellt die Admin-Sitzung wieder her.
     * MODIFIZIERT: Nutzt jetzt ImpersonationService.
     */
    public function revertImpersonation()
    {
        try {
            // 1. Logik an den Service delegieren
            // Der Service kümmert sich um Session-Zerstörung, Neuerstellung und DB-Abfragen
            $result = $this->impersonationService->revert();
            
            $adminUser = $result['adminUser'];
            $impersonatedUserId = $result['impersonatedUserId'];

            // 2. Aktion protokollieren (Session wurde bereits vom Service wiederhergestellt)
            AuditLogger::log(
                'impersonate_revert',
                'user',
                $adminUser['user_id'], // Der Admin, der die Aktion ausführt
                ['reverted_from_user_id' => $impersonatedUserId]
            );

            // 3. Zurück zur Benutzerliste im Admin-Panel
            header("Location: " . Utils::url('admin/users'));
            exit();

        } catch (Exception $e) {
            // Im schlimmsten Fall (Service wirft Fehler), sicher ausloggen
            error_log("Fehler bei revertImpersonation: " . $e->getMessage());
            // Rufe die lokale logout()-Methode auf, um eine saubere Weiterleitung zu gewährleisten
            $this->logout();
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Auth\AuthController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Planer\AbsenceController.php ---
<?php
// app/Http/Controllers/Planer/AbsenceController.php

// MODIFIZIERT:
// 1. ApiHandlerTrait importiert und verwendet.
// 2. getAbsencesApi (GET) nutzt handleApiRequest('inputType' => 'get').
// 3. saveAbsenceApi (JSON) nutzt handleApiRequest('inputType' => 'json').
// 4. deleteAbsenceApi (JSON) nutzt handleApiRequest('inputType' => 'json').
// 5. Alle manuellen try/catch, header(), json_decode(), json_encode() und Security-Checks
//    wurden aus den API-Methoden entfernt und in den Trait-Callback verschoben.

namespace App\Http\Controllers\Planer;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\TeacherAbsenceRepository;
use App\Repositories\StammdatenRepository;
use App\Services\AuditLogger; // Import bleibt (wird vom Trait genutzt)
use App\Http\Traits\ApiHandlerTrait; // NEU: Trait importieren
use Exception;
use PDO;
use DateTime;
use DateTimeZone;

/**
 * Controller für die Verwaltung von Lehrer-Abwesenheiten (nur für Planer/Admins).
 */
class AbsenceController
{
    // NEU: Trait für API-Behandlung einbinden
    use ApiHandlerTrait;

    private PDO $pdo;
    private TeacherAbsenceRepository $absenceRepo;
    private StammdatenRepository $stammdatenRepo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->absenceRepo = new TeacherAbsenceRepository($this->pdo);
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
    }

    /**
     * Zeigt die Hauptseite für die Abwesenheitsverwaltung an.
     * (Unverändert)
     */
    public function index()
    {
        Security::requireRole(['admin', 'planer']);
        global $config;
        $config = Database::getConfig();

        $page_title = 'Lehrer-Abwesenheiten';
        $body_class = 'planer-dashboard-body';

        try {
            $availableTeachers = $this->stammdatenRepo->getTeachers();
            $absenceTypes = $this->absenceRepo->getAbsenceTypes();

            Security::getCsrfToken();
            include_once dirname(__DIR__, 4) .'/pages/planer/absences.php';

        } catch (Exception $e) {
            error_log("Fehler beim Laden der Abwesenheits-Seite: " . $e->getMessage());
            http_response_code(500);
            die("Ein Fehler ist beim Laden der Seite aufgetreten: " . $e->getMessage());
        }
    }

    /**
     * API: Holt Abwesenheiten für einen bestimmten Zeitraum (z.B. einen Monat).
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function getAbsencesApi()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $startDate = $data['start'] ?? null; // YYYY-MM-DD
            $endDate = $data['end'] ?? null; // YYYY-MM-DD

            if (!$startDate || !$endDate) {
                $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                $startDate = $today->format('Y-m-01');
                $endDate = $today->format('Y-m-t');
            }

            if (DateTime::createFromFormat('Y-m-d', $startDate) === false || DateTime::createFromFormat('Y-m-d', $endDate) === false) {
                throw new Exception("Ungültiges Datumsformat.", 400);
            }

            $absences = $this->absenceRepo->getAbsencesForPeriod($startDate, $endDate);

            // Rückgabe für den Trait (Erfolgsfall)
            return [
                'json_response' => ['success' => true, 'data' => $absences]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => ['admin', 'planer']
        ]);
    }

    /**
     * API: Erstellt oder aktualisiert eine Abwesenheit.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function saveAbsenceApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $absenceId = filter_var($data['absence_id'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $teacherId = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $startDate = $data['start_date'] ?? null;
            $endDate = $data['end_date'] ?? null;
            $reason = trim($data['reason'] ?? '');
            $comment = isset($data['comment']) ? trim($data['comment']) : null;

            if (!$teacherId || !$startDate || !$endDate || empty($reason)) {
                throw new Exception("Fehlende Daten: Lehrer, Start, Ende und Grund sind erforderlich.", 400);
            }
            if (DateTime::createFromFormat('Y-m-d', $startDate) === false || DateTime::createFromFormat('Y-m-d', $endDate) === false) {
                throw new Exception("Ungültiges Datumsformat.", 400);
            }
            if ($endDate < $startDate) {
                throw new Exception("Enddatum muss nach dem Startdatum liegen.", 400);
            }

            $validTypes = $this->absenceRepo->getAbsenceTypes();
            if (!in_array($reason, $validTypes)) {
                throw new Exception("Ungültiger Abwesenheitsgrund.", 400);
            }

            $savedAbsence = $this->absenceRepo->createAbsence($absenceId, $teacherId, $startDate, $endDate, $reason, $comment);
            $newId = $savedAbsence['absence_id'];

            // Log-Details vorbereiten
            $logDetails = [
                'teacher_id' => $teacherId,
                'start_date' => $startDate,
                'end_date' => $endDate,
                'reason' => $reason
            ];

            // Rückgabe für den Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Abwesenheit gespeichert.', 'data' => $savedAbsence],
                'log_action' => $absenceId ? 'update_absence' : 'create_absence',
                'log_target_type' => 'teacher_absence',
                'log_target_id' => $newId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['admin', 'planer']
        ]);
    }

    /**
     * API: Löscht eine Abwesenheit.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function deleteAbsenceApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $absenceId = filter_var($data['absence_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$absenceId) {
                throw new Exception("Fehlende Abwesenheits-ID.", 400);
            }

            // Hole Daten für das Log, bevor gelöscht wird
            $absence = $this->absenceRepo->getAbsenceById($absenceId);
            if (!$absence) {
                throw new Exception("Abwesenheit nicht gefunden.", 404);
            }

            $success = $this->absenceRepo->deleteAbsence($absenceId);
            if (!$success) {
                // Sollte nicht passieren, wenn getAbsenceById funktioniert hat, aber zur Sicherheit
                throw new Exception("Abwesenheit konnte nicht gelöscht werden.", 500);
            }

            // Log-Details vorbereiten
            $logDetails = [
                'teacher_id' => $absence['teacher_id'],
                'reason' => $absence['reason'],
                'start_date' => $absence['start_date']
            ];

            // Rückgabe für den Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Abwesenheit gelöscht.'],
                'log_action' => 'delete_absence',
                'log_target_type' => 'teacher_absence',
                'log_target_id' => $absenceId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['admin', 'planer']
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Planer\AbsenceController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Planer\PlanController.php ---
<?php
// app/Http/Controllers/Planer/PlanController.php

// MODIFIZIERT:
// 1. ApiHandlerTrait importiert und verwendet.
// 2. Die lokale Implementierung von handleApiRequest() wurde entfernt.
// 3. Alle API-Methoden (getTimetableData, saveEntry, deleteEntry, etc.) wurden
//    vollständig refaktorisiert, um die Trait-Methode zu nutzen.
// 4. 'inputType' => 'get' für Lesezugriffe, 'inputType' => 'json' für Schreibzugriffe.
// 5. Alle Callbacks geben jetzt das vom Trait erwartete Array-Format zurück.
// 6. TeacherAbsenceRepository-Import und -Nutzung bleiben erhalten.

namespace App\Http\Controllers\Planer;

use App\Core\Security;
use App\Core\Database;
use App\Repositories\PlanRepository;
use App\Repositories\StammdatenRepository;
use App\Repositories\TeacherAbsenceRepository;
use App\Services\AuditLogger; // Import bleibt (wird vom Trait genutzt)
use App\Http\Traits\ApiHandlerTrait; // NEU: Trait importieren
use Exception;
use PDO;
use DateTime;
use DateTimeZone;

class PlanController
{
    // NEU: Trait für API-Behandlung einbinden
    use ApiHandlerTrait;

    private PDO $pdo;
    private PlanRepository $planRepository;
    private StammdatenRepository $stammdatenRepository;
    private TeacherAbsenceRepository $absenceRepo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->planRepository = new PlanRepository($this->pdo);
        $this->stammdatenRepository = new StammdatenRepository($this->pdo);
        $this->absenceRepo = new TeacherAbsenceRepository($this->pdo);
    }

    /**
     * Zeigt die Hauptseite des Planer-Dashboards an.
     * (Unverändert)
     */
    public function index()
    {
        Security::requireRole(['planer', 'admin']);
        global $config;
        $config = Database::getConfig();
        $page_title = 'Stundenplan-Verwaltung';
        $body_class = 'planer-dashboard-body';
        Security::getCsrfToken();
        include_once dirname(__DIR__, 4) . '/pages/planer/dashboard.php';
    }

    /**
     * VERALTET: Die Methode private function handleApiRequest() wurde entfernt.
     * Die Logik befindet sich jetzt im ApiHandlerTrait.
     */
    // private function handleApiRequest(...) { ... } // (ENTFERNT)


    /**
     * API: Holt Stundenplan-Daten für den Planer (Klassen ODER Lehrer).
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function getTimetableData()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
             $classId = filter_var($data['class_id'] ?? null, FILTER_VALIDATE_INT);
             $teacherId = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
             $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
             $calendarWeek = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);
             $date = $data['date'] ?? null;

             if ($date && (DateTime::createFromFormat('Y-m-d', $date) === false)) {
                 throw new Exception("Ungültiges Datumsformat. Bitte YYYY-MM-DD verwenden.", 400);
             }

             $baseData = [];
             $absencesData = [];
             
             // Initial-Load (Stammdaten)
             if (!$classId && !$teacherId && !$year && !$calendarWeek) { 
                 $baseData = [
                     'classes' => $this->stammdatenRepository->getClasses(),
                     'teachers' => $this->stammdatenRepository->getTeachers(),
                     'subjects' => $this->stammdatenRepository->getSubjects(),
                     'rooms' => $this->stammdatenRepository->getRooms(),
                     'templates' => $this->planRepository->getTemplates(), 
                 ];
                 $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                 $startDate = $today->format('Y-m-01');
                 $endDate = $today->modify('+3 months')->format('Y-m-t');
                 $absencesData = $this->absenceRepo->getAbsencesForDateRange($startDate, $endDate);
                 $baseData['absences'] = $absencesData;
             }

             $timetable = [];
             $substitutions = [];
             $publishStatus = ['student' => false, 'teacher' => false];

             // Daten für eine spezifische Woche/Entität laden
             if (($classId || $teacherId) && $year && $calendarWeek) {
                 $publishStatus = $this->planRepository->getPublishStatus($year, $calendarWeek);

                 if ($classId) {
                     $timetable = $this->planRepository->getTimetableForClassAsPlaner($classId, $year, $calendarWeek);
                     $substitutions = $this->planRepository->getSubstitutionsForClassWeekAsPlaner($classId, $year, $calendarWeek);
                 } elseif ($teacherId) {
                     $timetable = $this->planRepository->getTimetableForTeacherAsPlaner($teacherId, $year, $calendarWeek);
                     $substitutions = $this->planRepository->getSubstitutionsForTeacherWeekAsPlaner($teacherId, $year, $calendarWeek);
                 }
                 
                 // Abwesenheiten für die ausgewählte Woche
                 $dto = new DateTime();
                 $dto->setISODate($year, $calendarWeek, 1);
                 $startDate = $dto->format('Y-m-d');
                 $dto->setISODate($year, $calendarWeek, 7);
                 $endDate = $dto->format('Y-m-d');
                 $absencesData = $this->absenceRepo->getAbsencesForDateRange($startDate, $endDate);

             } elseif (($classId || $teacherId) && (!$year || !$calendarWeek)) {
                 // Fallback auf aktuelle Woche
                 $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                 $year = (int)$today->format('o');
                 $calendarWeek = (int)$today->format('W');
                 $publishStatus = $this->planRepository->getPublishStatus($year, $calendarWeek);

                 if ($classId) {
                     $timetable = $this->planRepository->getTimetableForClassAsPlaner($classId, $year, $calendarWeek);
                     $substitutions = $this->planRepository->getSubstitutionsForClassWeekAsPlaner($classId, $year, $calendarWeek);
                 } elseif ($teacherId) {
                     $timetable = $this->planRepository->getTimetableForTeacherAsPlaner($teacherId, $year, $calendarWeek);
                     $substitutions = $this->planRepository->getSubstitutionsForTeacherWeekAsPlaner($teacherId, $year, $calendarWeek);
                 }
                 
                 $dto = new DateTime();
                 $dto->setISODate($year, $calendarWeek, 1);
                 $startDate = $dto->format('Y-m-d');
                 $dto->setISODate($year, $calendarWeek, 7);
                 $endDate = $dto->format('Y-m-d');
                 $absencesData = $this->absenceRepo->getAbsencesForDateRange($startDate, $endDate);
             }

            // Rückgabe für Trait (Erfolgsfall)
            // Der Trait kümmert sich um json_encode()
            return [
                'json_response' => ['success' => true, 'data' => array_merge($baseData, [
                    'timetable' => $timetable,
                    'substitutions' => $substitutions,
                    'publishStatus' => $publishStatus,
                    'absences' => $absencesData
                ])]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    /**
     * API: Speichert einen regulären Eintrag (oder Block).
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function saveEntry()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            if (!$data) throw new Exception("Ungültige Daten empfangen.", 400);

            // Repository wirft Exception bei Konflikt
            $resultData = $this->planRepository->createOrUpdateEntry($data);
            
            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Eintrag erfolgreich gespeichert.', 'data' => $resultData],
                'log_action' => 'save_entry',
                'log_target_type' => 'timetable_entry',
                'log_target_id' => $data['entry_id'] ?? $resultData['entry_ids'][0] ?? null,
                'log_details' => $data
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    /**
     * API: Löscht einen regulären Eintrag (oder Block).
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function deleteEntry()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $entryId = $data['entry_id'] ?? null;
            $blockId = $data['block_id'] ?? null;
            $logTargetId = null;
            $logDetails = $data;

            if ($blockId) {
                $this->planRepository->deleteEntryBlock($blockId);
                $message = 'Block erfolgreich gelöscht.';
                $logTargetId = $blockId;
            } elseif ($entryId && filter_var($entryId, FILTER_VALIDATE_INT)) {
                $this->planRepository->deleteEntry((int)$entryId);
                $message = 'Eintrag erfolgreich gelöscht.';
                $logTargetId = $entryId;
            } else {
                throw new Exception("Ungültige Eintrags- oder Block-ID.", 400);
            }

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => $message],
                'log_action' => 'delete_entry',
                'log_target_type' => 'timetable_entry',
                'log_target_id' => $logTargetId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    /**
     * API: Speichert eine Vertretung.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function saveSubstitution()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            if (!$data) throw new Exception("Ungültige Daten empfangen.", 400);
            
            // Repository wirft Exception bei Konflikt
            $resultData = $this->planRepository->createOrUpdateSubstitution($data);
            
            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Vertretung erfolgreich gespeichert.', 'data' => $resultData],
                'log_action' => 'save_substitution',
                'log_target_type' => 'substitution',
                'log_target_id' => $resultData['substitution_id'] ?? $data['substitution_id'] ?? null,
                'log_details' => $data
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    /**
     * API: Löscht eine Vertretung.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function deleteSubstitution()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $id = $data['substitution_id'] ?? null;
            if (!filter_var($id, FILTER_VALIDATE_INT)) {
                throw new Exception("Ungültige Vertretungs-ID.", 400);
            }
            
            $this->planRepository->deleteSubstitution((int)$id);
            
            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Vertretung erfolgreich gelöscht.'],
                'log_action' => 'delete_substitution',
                'log_target_type' => 'substitution',
                'log_target_id' => $id,
                'log_details' => $data
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    /**
     * API: Veröffentlicht eine Woche.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function publish()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $week = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);
            $target = $data['target'] ?? null;
            $userId = $_SESSION['user_id'];

            if (!$year || !$week || !in_array($target, ['student', 'teacher'])) {
                throw new Exception("Ungültige Parameter für Veröffentlichung.", 400);
            }

            $success = $this->planRepository->publishWeek($year, $week, $target, $userId);
            if (!$success) {
                throw new Exception("Veröffentlichung fehlgeschlagen.", 500);
            }

            $newStatus = $this->planRepository->getPublishStatus($year, $week);
            
            // Rückgabe für Trait
            return [
                'json_response' => [
                    'success' => true,
                    'message' => "Stundenplan KW $week/$year für " . ($target === 'student' ? 'Schüler' : 'Lehrer') . " veröffentlicht.",
                    'data' => ['publishStatus' => $newStatus]
                ],
                'log_action' => 'publish_week',
                'log_target_type' => 'system',
                'log_details' => ['year' => $year, 'week' => $week, 'target' => $target]
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    /**
     * API: Nimmt Veröffentlichung zurück.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function unpublish()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $week = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);
            $target = $data['target'] ?? null;

            if (!$year || !$week || !in_array($target, ['student', 'teacher'])) {
                throw new Exception("Ungültige Parameter.", 400);
            }

            $success = $this->planRepository->unpublishWeek($year, $week, $target);
            if (!$success) {
                throw new Exception("Zurücknahme fehlgeschlagen.", 500);
            }

            $newStatus = $this->planRepository->getPublishStatus($year, $week);
            
            // Rückgabe für Trait
            return [
                'json_response' => [
                    'success' => true,
                    'message' => "Veröffentlichung KW $week/$year für " . ($target === 'student' ? 'Schüler' : 'Lehrer') . " zurückgenommen.",
                    'data' => ['publishStatus' => $newStatus]
                ],
                'log_action' => 'unpublish_week',
                'log_target_type' => 'system',
                'log_details' => ['year' => $year, 'week' => $week, 'target' => $target]
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    /**
     * API: Holt den aktuellen Veröffentlichungsstatus.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
     public function getStatus() {
         $this->handleApiRequest(function($data) { // $data ist $_GET
             
             $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
             $week = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);

             if (!$year || !$week) {
                 throw new Exception("Jahr und Woche erforderlich.", 400);
             }
             $status = $this->planRepository->getPublishStatus($year, $week);
             
             // Rückgabe für Trait
             return [
                 'json_response' => ['success' => true, 'data' => ['publishStatus' => $status]]
             ];

         }, [
             'inputType' => 'get',
             'checkRole' => ['planer', 'admin']
         ]);
     }

    /**
     * API: Echtzeit-Konfliktprüfung.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function checkConflictsApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            if (!$data) {
                throw new Exception("Keine Daten für Konfliktprüfung empfangen.", 400);
            }

            if (empty($data['year']) || empty($data['calendar_week']) || empty($data['day_of_week']) || empty($data['start_period_number']) || empty($data['end_period_number'])) {
                throw new Exception("Unvollständige Daten für Konfliktprüfung.", 400);
            }
            if (!isset($data['class_id'])) {
                throw new Exception("Fehlende class_id für Konfliktprüfung.", 400);
            }

            $excludeEntryId = !empty($data['entry_id']) ? (int)$data['entry_id'] : null;
            $excludeBlockId = !empty($data['block_id']) ? (string)$data['block_id'] : null;

            // Repository wirft Exception bei Konflikt
            $conflicts = $this->planRepository->checkConflicts($data, $excludeEntryId, $excludeBlockId);

            // Keine Exception = keine Konflikte
            return [
                'json_response' => ['success' => true, 'conflicts' => []]
                // Kein Audit-Log für diese Lese-Aktion
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    /**
     * API: Kopiert eine Woche.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function copyWeek()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $sourceYear = filter_var($data['sourceYear'] ?? null, FILTER_VALIDATE_INT);
            $sourceWeek = filter_var($data['sourceWeek'] ?? null, FILTER_VALIDATE_INT);
            $targetYear = filter_var($data['targetYear'] ?? null, FILTER_VALIDATE_INT);
            $targetWeek = filter_var($data['targetWeek'] ?? null, FILTER_VALIDATE_INT);
            $classId = filter_var($data['classId'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $teacherId = filter_var($data['teacherId'] ?? null, FILTER_VALIDATE_INT) ?: null;

            if (!$sourceYear || !$sourceWeek || !$targetYear || !$targetWeek) {
                throw new Exception("Quell- und Zielwoche sind erforderlich.", 400);
            }
            if ($classId === null && $teacherId === null) {
                throw new Exception("Klasse oder Lehrer erforderlich.", 400);
            }

            $copiedCount = $this->planRepository->copyWeekData(
                $sourceYear, $sourceWeek, $targetYear, $targetWeek, $classId, $teacherId
            );
            
            // Rückgabe für Trait
            return [
                'json_response' => [
                    'success' => true,
                    'message' => "Woche erfolgreich kopiert. {$copiedCount} Einträge wurden in KW {$targetWeek}/{$targetYear} eingefügt.",
                    'copiedCount' => $copiedCount
                ],
                'log_action' => 'copy_week',
                'log_target_type' => 'system',
                'log_details' => $data
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    // --- API METHODEN FÜR VORLAGEN (alle refaktorisiert) ---

    /**
     * API: Holt alle Vorlagen. (GET)
     */
    public function getTemplates()
    {
        $this->handleApiRequest(function($data) {
            $templates = $this->planRepository->getTemplates();
            return [
                'json_response' => ['success' => true, 'data' => $templates]
            ];
        }, [
            'inputType' => 'get',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    /**
     * API: Erstellt Vorlage aus Woche. (JSON)
     */
    public function createTemplate()
    {
        $this->handleApiRequest(function($data) {
            
            $name = trim($data['name'] ?? '');
            $description = trim($data['description'] ?? '') ?: null;
            $sourceYear = filter_var($data['sourceYear'] ?? null, FILTER_VALIDATE_INT);
            $sourceWeek = filter_var($data['sourceWeek'] ?? null, FILTER_VALIDATE_INT);
            $sourceClassId = filter_var($data['sourceClassId'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $sourceTeacherId = filter_var($data['sourceTeacherId'] ?? null, FILTER_VALIDATE_INT) ?: null;

            if (empty($name) || !$sourceYear || !$sourceWeek || ($sourceClassId === null && $sourceTeacherId === null)) {
                throw new Exception("Ungültige Daten zum Erstellen der Vorlage.", 400);
            }

            $sourceEntries = [];
            if ($sourceClassId) {
                $sourceEntries = $this->planRepository->getTimetableForClassAsPlaner($sourceClassId, $sourceYear, $sourceWeek);
            } elseif ($sourceTeacherId) {
                $sourceEntries = $this->planRepository->getTimetableForTeacherAsPlaner($sourceTeacherId, $sourceYear, $sourceWeek);
            }

            if (empty($sourceEntries)) {
                throw new Exception("Keine Stundenplandaten in der Quellwoche gefunden.", 400);
            }

            // Repository wirft 409 bei Namenskonflikt
            $newTemplateId = $this->planRepository->createTemplate($name, $description, $sourceEntries);
            $newTemplate = ['template_id' => $newTemplateId, 'name' => $name, 'description' => $description];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => "Vorlage '{$name}' erfolgreich erstellt.", 'data' => $newTemplate],
                'log_action' => 'create_template_from_week',
                'log_target_type' => 'template',
                'log_target_id' => $newTemplateId,
                'log_details' => $data
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    /**
     * API: Wendet Vorlage an. (JSON)
     */
    public function applyTemplate()
    {
        $this->handleApiRequest(function($data) {
            
            $templateId = filter_var($data['templateId'] ?? null, FILTER_VALIDATE_INT);
            $targetYear = filter_var($data['targetYear'] ?? null, FILTER_VALIDATE_INT);
            $targetWeek = filter_var($data['targetWeek'] ?? null, FILTER_VALIDATE_INT);
            $targetClassId = filter_var($data['targetClassId'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $targetTeacherId = filter_var($data['targetTeacherId'] ?? null, FILTER_VALIDATE_INT) ?: null;

            if (!$templateId || !$targetYear || !$targetWeek || ($targetClassId === null && $targetTeacherId === null)) {
                throw new Exception("Ungültige Daten zum Anwenden der Vorlage.", 400);
            }

            $appliedCount = $this->planRepository->applyTemplateToWeek(
                $templateId, $targetYear, $targetWeek, $targetClassId, $targetTeacherId
            );
            
            // Rückgabe für Trait
            return [
                'json_response' => [
                    'success' => true,
                    'message' => "Vorlage erfolgreich angewendet. {$appliedCount} Einträge wurden in KW {$targetWeek}/{$targetYear} eingefügt.",
                    'appliedCount' => $appliedCount
                ],
                'log_action' => 'apply_template',
                'log_target_type' => 'template',
                'log_target_id' => $templateId,
                'log_details' => $data
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    /**
     * API: Löscht Vorlage. (JSON)
     */
    public function deleteTemplate()
    {
        $this->handleApiRequest(function($data) {
            
            $templateId = filter_var($data['templateId'] ?? null, FILTER_VALIDATE_INT);
            if (!$templateId) {
                throw new Exception("Ungültige Vorlagen-ID.", 400);
            }

            $success = $this->planRepository->deleteTemplate($templateId);
            if (!$success) {
                throw new Exception("Fehler beim Löschen der Vorlage.", 500);
            }

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Vorlage erfolgreich gelöscht.'],
                'log_action' => 'delete_template',
                'log_target_type' => 'template',
                'log_target_id' => $templateId,
                'log_details' => $data
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }
    
    /**
     * API: Lädt Details einer Vorlage. (GET)
     * (Parameter $templateId wird von der Route übergeben)
     */
    public function getTemplateDetails(int $templateId)
    {
        $this->handleApiRequest(function($data) use ($templateId) { // $data ist $_GET
            
            $details = $this->planRepository->loadTemplateDetails($templateId);
            
            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'data' => $details]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => ['planer', 'admin']
        ]);
    }
    
    /**
     * API: Speichert Details einer Vorlage (aus dem Editor). (JSON)
     */
    public function saveTemplateDetails()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            if (empty($data['name'])) {
                throw new Exception("Vorlagenname darf nicht leer sein.", 400);
            }

            // Repository wirft 409 bei Namenskonflikt
            $savedTemplate = $this->planRepository->saveTemplateDetails($data);
            
            $action = empty($data['template_id']) ? 'create_template' : 'update_template';

            // Log-Details
            $logDetails = [
                'name' => $savedTemplate['name'],
                'description' => $savedTemplate['description'],
                'entries_count' => count($data['entries'] ?? [])
            ];

            // Rückgabe für Trait
            return [
                'json_response' => [
                    'success' => true,
                    'message' => 'Vorlage erfolgreich gespeichert.',
                    'data' => $savedTemplate
                ],
                'log_action' => $action,
                'log_target_type' => 'template',
                'log_target_id' => $savedTemplate['template_id'],
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Planer\PlanController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\AcademicEventController.php ---
<?php
// app/Http/Controllers/AcademicEventController.php

// MODIFIZIERT:
// 1. ApiHandlerTrait importiert und verwendet.
// 2. getForStudent (GET) nutzt handleApiRequest('inputType' => 'get').
// 3. getForTeacher (GET) nutzt handleApiRequest('inputType' => 'get').
// 4. createOrUpdate (JSON) nutzt handleApiRequest('inputType' => 'json').
// 5. delete (JSON) nutzt handleApiRequest('inputType' => 'json').
// 6. Alle manuellen try/catch, header(), json_decode(), json_encode() und Security-Checks
//    wurden aus den API-Methoden entfernt und in den Trait-Callback verschoben.

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\AcademicEventRepository;
use App\Repositories\UserRepository;
use App\Repositories\StammdatenRepository;
use App\Services\AuditLogger; // Import bleibt (wird vom Trait genutzt)
use App\Http\Traits\ApiHandlerTrait; // NEU: Trait importieren
use Exception;
use PDO;
use DateTime;
use DateTimeZone;

class AcademicEventController
{
    // NEU: Trait für API-Behandlung einbinden
    use ApiHandlerTrait;

    private PDO $pdo;
    private AcademicEventRepository $eventRepo;
    private UserRepository $userRepo;
    private StammdatenRepository $stammdatenRepo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->eventRepo = new AcademicEventRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
    }

    /**
     * API: Holt Events für den eingeloggten Schüler für eine bestimmte Woche.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function getForStudent()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $userId = $_SESSION['user_id'];
            $user = $this->userRepo->findById($userId);
            if (!$user || !$user['class_id']) {
                throw new Exception("Schülerdaten unvollständig (Klasse fehlt).", 400);
            }
            $classId = $user['class_id'];

            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $week = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);

            if (!$year || !$week) {
                 $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                 $year = (int)$today->format('o'); // ISO year
                 $week = (int)$today->format('W'); // ISO week
            }

            $events = $this->eventRepo->getEventsForClassByWeek($classId, $year, $week);

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'data' => $events]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => 'schueler'
        ]);
    }

    /**
     * API: Holt Events, die vom eingeloggten Lehrer erstellt wurden.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function getForTeacher()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $userId = $_SESSION['user_id'];
            $daysInFuture = 14; // Standardmäßig die nächsten 14 Tage

            $events = $this->eventRepo->getEventsByTeacher($userId, $daysInFuture);

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'data' => $events]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => 'lehrer'
        ]);
    }

    /**
     * API: Erstellt oder aktualisiert ein Event (Aufgabe/Klausur/Info).
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function createOrUpdate()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $userId = $_SESSION['user_id'];
            $user = $this->userRepo->findById($userId);
            if (!$user || !$user['teacher_id']) {
                throw new Exception("Lehrerprofil nicht gefunden.", 403);
            }
            $teacherId = $user['teacher_id']; // teacher_id aus teachers Tabelle

            // Validierung der Eingaben
            $eventId = filter_var($data['event_id'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $classId = filter_var($data['class_id'] ?? null, FILTER_VALIDATE_INT);
            $subjectId = filter_var($data['subject_id'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $eventType = $data['event_type'] ?? null;
            $title = trim($data['title'] ?? '');
            $dueDate = $data['due_date'] ?? null;
            $description = isset($data['description']) ? trim($data['description']) : null;

            if (!$classId || !$eventType || empty($title) || !$dueDate || !in_array($eventType, ['aufgabe', 'klausur', 'info'])) {
                throw new Exception("Fehlende oder ungültige Pflichtfelder (Typ, Klasse, Titel, Datum).", 400);
            }
            if (DateTime::createFromFormat('Y-m-d', $dueDate) === false) {
                 throw new Exception("Ungültiges Datumsformat. Bitte YYYY-MM-DD verwenden.", 400);
            }

            // Berechtigungsprüfung
            if (!$this->eventRepo->checkTeacherAuthorization($teacherId, $classId, $dueDate)) {
                 error_log("Hinweis: Lehrer {$userId} erstellt Event für Klasse {$classId} an Datum {$dueDate} ohne expliziten Unterrichtsnachweis.");
            }

            // Speichern
            $savedEvent = $this->eventRepo->saveEvent(
                $eventId,
                $userId, // Wichtig: Die user_id des Lehrers
                $classId,
                $subjectId,
                $eventType,
                $title,
                $dueDate,
                $description
            );

            // Log-Details
            $logDetails = [
                'type' => $eventType,
                'title' => $title,
                'class_id' => $classId,
                'due_date' => $dueDate
            ];
            
            // Rückgabe für Trait
            return [
                'json_response' => [
                    'success' => true,
                    'message' => 'Eintrag erfolgreich ' . ($eventId ? 'aktualisiert' : 'erstellt') . '.',
                    'data' => $savedEvent
                ],
                'log_action' => $eventId ? 'update_event' : 'create_event',
                'log_target_type' => 'academic_event',
                'log_target_id' => $savedEvent['event_id'],
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => 'lehrer'
        ]);
    }

    /**
     * API: Löscht ein Event.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function delete()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $userId = $_SESSION['user_id'];
            $eventId = filter_var($data['event_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$eventId) {
                throw new Exception("Keine Event-ID angegeben.", 400);
            }

            // Hole Event-Details vor dem Löschen für das Logging
            $eventToDelete = $this->eventRepo->getEventById($eventId);
            if (!$eventToDelete) {
                // Wenn das Event nicht existiert, RowCount = 0, also behandeln wir es wie einen Fehler
                throw new Exception("Eintrag nicht gefunden.", 404);
            }
            
            // Berechtigungsprüfung (wird auch im Repository geprüft, aber hier für Log-Details)
            if ($eventToDelete['user_id'] != $userId) {
                 throw new Exception("Sie sind nicht berechtigt, diesen Eintrag zu löschen.", 403);
            }

            $success = $this->eventRepo->deleteEvent($eventId, $userId);
            if (!$success) {
                // Sollte durch die Prüfungen oben nicht passieren
                throw new Exception("Eintrag konnte nicht gelöscht werden.", 500);
            }

            // Log-Details
            $logDetails = [
                 'title' => $eventToDelete['title'] ?? 'N/A',
                 'type' => $eventToDelete['event_type'] ?? 'N/A',
                 'class_id' => $eventToDelete['class_id'] ?? 'N/A',
                 'due_date' => $eventToDelete['due_date'] ?? 'N/A'
            ];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Eintrag erfolgreich gelöscht.'],
                'log_action' => 'delete_event',
                'log_target_type' => 'academic_event',
                'log_target_id' => $eventId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => 'lehrer'
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\AcademicEventController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\AnnouncementController.php ---
<?php
// app/Http/Controllers/AnnouncementController.php

// MODIFIZIERT:
// 1. FileUploadService importiert und im Konstruktor injiziert.
// 2. Die createAnnouncement()-Methode verwendet jetzt $this->fileUploadService->handleUpload().
// 3. Die manuelle Logik für Datei-Upload (MIME-Typ, Größe, Verschieben) wurde entfernt.

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\AnnouncementRepository;
use App\Repositories\UserRepository;
use App\Http\Traits\ApiHandlerTrait;
use App\Services\FileUploadService; // NEU: Service importieren
use Exception;
use PDO;
use Parsedown;
use App\Services\AuditLogger;

class AnnouncementController
{
    use ApiHandlerTrait;

    private PDO $pdo;
    private AnnouncementRepository $announcementRepo;
    private UserRepository $userRepo;
    private Parsedown $parsedown;
    private FileUploadService $fileUploadService; // NEU

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->announcementRepo = new AnnouncementRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
        $this->parsedown = new Parsedown();
        $this->parsedown->setSafeMode(true);
        $this->fileUploadService = new FileUploadService(); // NEU
    }

    /**
     * API: Holt Ankündigungen basierend auf der Rolle des Benutzers. (GET)
     * (Unverändert)
     */
    public function getAnnouncements()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $user = $this->userRepo->findById($userId);

            if (!$user) {
                throw new Exception("Benutzer nicht gefunden.", 404);
            }

            $classId = ($userRole === 'schueler' && isset($user['class_id'])) ? $user['class_id'] : null;
            $announcements = $this->announcementRepo->getVisibleAnnouncements($userRole, $classId);

            foreach ($announcements as &$announcement) {
                $author = $this->userRepo->findById($announcement['user_id']);
                $announcement['author_name'] = $author ? ($author['first_name'] . ' ' . $author['last_name']) : 'Unbekannt';
                $announcement['content_html'] = $this->parsedown->text($announcement['content'] ?? '');

                if (!empty($announcement['file_path'])) {
                    $announcement['file_url'] = rtrim(Database::getConfig()['base_url'], '/') . '/' . ltrim($announcement['file_path'], '/');
                } else {
                    $announcement['file_url'] = null;
                }
                $announcement['visibility'] = $announcement['is_global'] ? 'global' : 'class';
            }
            unset($announcement);

            return [
                'json_response' => ['success' => true, 'data' => $announcements]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin']
        ]);
    }

    /**
     * API: Erstellt eine neue Ankündigung. (POST/FormData)
     * MODIFIZIERT: Nutzt jetzt FileUploadService.
     */
    public function createAnnouncement()
    {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $title = trim($data['title'] ?? '');
            $content = trim($data['content'] ?? '');

            if (empty($title) || empty($content)) {
                throw new Exception("Titel und Inhalt dürfen nicht leer sein.", 400);
            }

            // --- Zielgruppen-Logik (unverändert) ---
            $targetRole = 'all';
            $targetClassId = null;
            if ($userRole === 'lehrer') {
                $targetClassId = filter_var($data['target_class_id'] ?? null, FILTER_VALIDATE_INT);
                if (!$targetClassId) { throw new Exception("Lehrer müssen eine Klasse auswählen.", 400); }
                $targetRole = 'schueler';
            }
            elseif (in_array($userRole, ['admin', 'planer'])) {
                $isGlobal = isset($data['target_global']) && $data['target_global'] === '1';
                $isTeacher = isset($data['target_teacher']) && $data['target_teacher'] === '1';
                $isPlaner = isset($data['target_planer']) && $data['target_planer'] === '1';
                $selectedClassId = filter_var($data['target_class_id'] ?? null, FILTER_VALIDATE_INT);
                $selectedClassId = ($selectedClassId === false || $selectedClassId === 0) ? null : $selectedClassId;
                $checkedCount = ($isGlobal ? 1 : 0) + ($isTeacher ? 1 : 0) + ($isPlaner ? 1 : 0);

                if ($checkedCount > 1) { throw new Exception("Bitte nur eine Zielgruppen-Checkbox auswählen.", 400); }
                elseif ($checkedCount === 1) {
                    if ($isGlobal) $targetRole = 'all'; elseif ($isTeacher) $targetRole = 'lehrer'; elseif ($isPlaner) $targetRole = 'planer';
                    $targetClassId = null;
                } elseif ($selectedClassId !== null) {
                    $targetRole = 'schueler'; $targetClassId = $selectedClassId;
                } else { $targetRole = 'all'; $targetClassId = null; }
            } else { throw new Exception("Unbekannte Benutzerrolle.", 403); }

            // --- NEU: Datei-Upload über Service ---
            $attachmentPath = null;
            if (isset($_FILES['attachment']) && $_FILES['attachment']['error'] === UPLOAD_ERR_OK) {
                if (!in_array($userRole, ['admin', 'planer'])) { 
                    throw new Exception("Nur Admins und Planer dürfen Dateien anhängen.", 403); 
                }
                
                // Erlaube gängige Dokumenten- und Bildtypen
                $allowedMimes = [
                    'image/jpeg' => 'jpg',
                    'image/png' => 'png',
                    'application/pdf' => 'pdf',
                    'application/msword' => 'doc',
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document' => 'docx'
                ];
                
                // Der Service wirft bei Fehlern (Größe, Typ, Verschieben) eine Exception
                $attachmentPath = $this->fileUploadService->handleUpload(
                    'attachment',
                    'announcements',
                    $allowedMimes,
                    5 * 1024 * 1024 // 5MB Limit
                );
            }
            // --- ENDE NEU ---

            // Speichern
            $newId = $this->announcementRepo->createAnnouncement(
                $userId,
                $title,
                $content,
                $targetRole,
                $targetClassId,
                $attachmentPath
            );

            // Daten für Rückgabe holen
            $newAnnouncement = $this->announcementRepo->getAnnouncementById($newId);
            if ($newAnnouncement) {
                $newAnnouncement['content_html'] = $this->parsedown->text($newAnnouncement['content'] ?? '');
                $author = $this->userRepo->findById($newAnnouncement['user_id']);
                $newAnnouncement['author_name'] = $author ? ($author['first_name'] . ' ' . $author['last_name']) : 'Unbekannt';
                if (!empty($newAnnouncement['file_path'])) {
                     $newAnnouncement['file_url'] = rtrim(Database::getConfig()['base_url'], '/') . '/' . ltrim($newAnnouncement['file_path'], '/');
                } else {
                   $newAnnouncement['file_url'] = null;
                }
                $newAnnouncement['visibility'] = $newAnnouncement['is_global'] ? 'global' : 'class';
            }
            
            // Log-Details
            $logDetails = [
                'title' => $title, 
                'target_role' => $targetRole, 
                'target_class_id' => $targetClassId,
                'has_attachment' => !empty($attachmentPath)
            ];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Ankündigung erfolgreich erstellt.', 'data' => $newAnnouncement],
                'log_action' => 'create_announcement',
                'log_target_type' => 'announcement',
                'log_target_id' => $newId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'form',
            'checkRole' => ['admin', 'planer', 'lehrer']
        ]);
    }

    /**
     * API: Löscht eine Ankündigung. (POST/FormData)
     * MODIFIZIERT: Nutzt jetzt FileUploadService zum Löschen der Datei.
     */
    public function deleteAnnouncement()
    {
        $this->handleApiRequest(function($data) { // $data ist $_POST
            
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $announcementId = filter_var($data['announcement_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$announcementId) { throw new Exception("Ungültige Ankündigungs-ID.", 400); }
            $announcement = $this->announcementRepo->getAnnouncementById($announcementId);
            if (!$announcement) { throw new Exception("Ankündigung nicht gefunden.", 404); }
            
            if ($userRole === 'lehrer' && $announcement['user_id'] !== $userId) { 
                 throw new Exception("Sie sind nicht berechtigt, diese Ankündigung zu löschen.", 403); 
            }

            // NEU: Datei löschen, BEVOR der DB-Eintrag entfernt wird
            $filePathToDelete = $announcement['file_path'] ?? null;
            if ($filePathToDelete) {
                $this->fileUploadService->deleteFile($filePathToDelete);
                // Wir loggen Fehler beim Löschen, aber stoppen den Vorgang nicht
            }

            // DB-Eintrag löschen
            $success = $this->announcementRepo->deleteAnnouncement($announcementId);
            if (!$success) { 
                 throw new Exception("Fehler beim Löschen der Ankündigung aus der Datenbank.", 500); 
            }
            
            $logDetails = ['title' => $announcement['title'] ?? 'N/A'];
            
            return [
                 'json_response' => ['success' => true, 'message' => 'Ankündigung erfolgreich gelöscht.'],
                 'log_action' => 'delete_announcement',
                 'log_target_type' => 'announcement',
                 'log_target_id' => $announcementId,
                 'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'form',
            'checkRole' => ['admin', 'planer', 'lehrer']
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\AnnouncementController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\CommunityController.php ---
<?php
// app/Http/Controllers/CommunityController.php

// MODIFIZIERT:
// 1. ApiHandlerTrait importiert und verwendet.
// 2. Alle API-Methoden (getPostsApi, getMyPostsApi, createPostApi, updatePostApi,
//    approvePostApi, rejectPostApi, deletePostApi) nutzen jetzt handleApiRequest().
// 3. inputType 'get' für Lesezugriffe, 'json' für Schreibzugriffe (da JS JSON sendet).
// 4. Manuelle Security-Checks (requireLogin, verifyCsrfToken) wurden in die Trait-Optionen verlagert.
// 5. Manuelle json_encode/decode, header() und try/catch-Blöcke entfernt.
// 6. AuditLogger-Aufrufe in die 'log_action'-Rückgaben für den Trait umgewandelt.

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Security; // Wird vom Trait intern genutzt
use App\Repositories\CommunityPostRepository;
use App\Services\AuditLogger; // Import bleibt (wird vom Trait genutzt)
use App\Http\Traits\ApiHandlerTrait; // NEU: Trait importieren
use Exception;
use PDO;
use Parsedown; // KORRIGIERT: Backslash entfernt

class CommunityController
{
    // NEU: Trait für API-Behandlung einbinden
    use ApiHandlerTrait;

    private PDO $pdo;
    private CommunityPostRepository $postRepo;
    private Parsedown $parsedown;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->postRepo = new CommunityPostRepository($this->pdo);
        $this->parsedown = new Parsedown();
        $this->parsedown->setSafeMode(true);
    }

    /**
     * API: Holt die letzten 50 freigegebenen Beiträge für das Dashboard.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function getPostsApi()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $posts = $this->postRepo->getApprovedPostsWithAuthorEmail(50);

            foreach ($posts as &$post) {
                $post['content_html'] = $this->parsedown->text($post['content'] ?? '');
            }
            unset($post);

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'data' => $posts]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin'] // Jede eingeloggte Rolle
        ]);
    }

    /**
     * API: Holt alle Beiträge, die vom aktuell eingeloggten Benutzer erstellt wurden.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function getMyPostsApi()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $userId = $_SESSION['user_id'];
            $posts = $this->postRepo->getPostsByUserId($userId);

            foreach ($posts as &$post) {
                $post['content_html'] = $this->parsedown->text($post['content'] ?? '');
            }
            unset($post);

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'data' => $posts]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin'] // Jede eingeloggte Rolle
        ]);
    }

    /**
     * API: Erstellt einen neuen Beitrag.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function createPostApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];

            $title = trim($data['title'] ?? '');
            $content = trim($data['content'] ?? '');

            if (empty($title) || empty($content)) {
                throw new Exception("Titel und Inhalt dürfen nicht leer sein.", 400);
            }

            $allowedToAutoApprove = ['admin', 'planer', 'lehrer'];
            $initialStatus = in_array($userRole, $allowedToAutoApprove) ? 'approved' : 'pending';

            $newPostId = $this->postRepo->createPost($userId, $title, $content, $initialStatus);
            
            $message = ($initialStatus === 'approved')
                ? 'Beitrag erfolgreich veröffentlicht.'
                : 'Beitrag wurde zur Moderation eingereicht.';

            // Log-Details
            $logDetails = [
                'title' => $title,
                'status' => $initialStatus
            ];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => $message, 'status' => $initialStatus],
                'log_action' => 'create_community_post',
                'log_target_type' => 'community_post',
                'log_target_id' => $newPostId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin'] // Jede eingeloggte Rolle
        ]);
    }

    /**
     * API: Aktualisiert einen bestehenden Beitrag.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function updatePostApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];

            $postId = filter_var($data['post_id'] ?? null, FILTER_VALIDATE_INT);
            $title = trim($data['title'] ?? '');
            $content = trim($data['content'] ?? '');

            if (!$postId || empty($title) || empty($content)) {
                throw new Exception("ID, Titel und Inhalt dürfen nicht leer sein.", 400);
            }

            $post = $this->postRepo->getPostById($postId);
            if (!$post) {
                throw new Exception("Beitrag nicht gefunden.", 404);
            }

            $isOwner = ($post['user_id'] == $userId);
            $isModerator = in_array($userRole, ['admin', 'planer']);

            if (!$isOwner && !$isModerator) {
                throw new Exception("Sie sind nicht berechtigt, diesen Beitrag zu bearbeiten.", 403);
            }

            $newStatus = $post['status'];
            if ($isOwner && !$isModerator) {
                $newStatus = 'pending';
            }
            
            $moderatorId = $isModerator ? $userId : null;

            // ANNAHME: Die 'updatePost'-Methode im Repository wurde (in V10) so angepasst,
            // dass sie (int $postId, string $title, string $content, string $newStatus, ?int $moderatorId) akzeptiert.
            $success = $this->postRepo->updatePost($postId, $title, $content, $newStatus, $moderatorId);

            if (!$success) {
                throw new Exception("Beitrag konnte nicht aktualisiert werden (möglicherweise keine Berechtigung oder Daten waren identisch).", 500);
            }
            
            $message = ($newStatus === 'pending')
                ? 'Beitrag aktualisiert und zur erneuten Moderation eingereicht.'
                : 'Beitrag erfolgreich aktualisiert.';

            // Log-Details
            $logDetails = [
                'title' => $title,
                'new_status' => $newStatus
            ];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => $message, 'new_status' => $newStatus],
                'log_action' => 'update_community_post',
                'log_target_type' => 'community_post',
                'log_target_id' => $postId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin'] // Jede eingeloggte Rolle
        ]);
    }

    /**
     * API: Genehmigt einen Beitrag (Admin/Planer).
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function approvePostApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $moderatorId = $_SESSION['user_id'];
            $postId = filter_var($data['post_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$postId) {
                throw new Exception("Ungültige Beitrags-ID.", 400);
            }

            $success = $this->postRepo->updatePostStatus($postId, 'approved', $moderatorId);

            if (!$success) {
                throw new Exception("Beitrag konnte nicht freigegeben werden (vielleicht schon moderiert?).", 404);
            }
            
            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Beitrag freigegeben.'],
                'log_action' => 'approve_community_post',
                'log_target_type' => 'community_post',
                'log_target_id' => $postId
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['admin', 'planer']
        ]);
    }
    
    /**
     * API: Lehnt einen Beitrag ab (Admin/Planer).
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function rejectPostApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $moderatorId = $_SESSION['user_id'];
            $postId = filter_var($data['post_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$postId) {
                throw new Exception("Ungültige Beitrags-ID.", 400);
            }
            
            $post = $this->postRepo->getPostById($postId);
            $success = $this->postRepo->updatePostStatus($postId, 'rejected', $moderatorId);

            if (!$success) {
                throw new Exception("Beitrag konnte nicht abgelehnt werden (vielleicht schon moderiert?).", 404);
            }

            // Log-Details
            $logDetails = ['title' => $post['title'] ?? 'N/A'];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Beitrag abgelehnt.'],
                'log_action' => 'reject_community_post',
                'log_target_type' => 'community_post',
                'log_target_id' => $postId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['admin', 'planer']
        ]);
    }

    /**
     * API: Löscht einen Beitrag (Admin, Planer oder Ersteller).
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function deletePostApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];

            $postId = filter_var($data['post_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$postId) {
                throw new Exception("Ungültige Beitrags-ID.", 400);
            }

            $post = $this->postRepo->getPostById($postId);
            if (!$post) {
                throw new Exception("Beitrag nicht gefunden.", 404);
            }

            $isOwner = ($post['user_id'] == $userId);
            $isModerator = in_array($userRole, ['admin', 'planer']);

            if (!$isOwner && !$isModerator) {
                throw new Exception("Sie sind nicht berechtigt, diesen Beitrag zu löschen.", 403);
            }

            $success = $this->postRepo->deletePost($postId);
            if (!$success) {
                throw new Exception("Beitrag konnte nicht gelöscht werden.", 500);
            }

            // Log-Details
            $logDetails = [
                'title' => $post['title'] ?? 'N/A',
                'deleted_by' => $userRole
            ];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Beitrag erfolgreich gelöscht.'],
                'log_action' => 'delete_community_post',
                'log_target_type' => 'community_post',
                'log_target_id' => $postId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin'] // Jede eingeloggte Rolle
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\CommunityController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\DashboardController.php ---
<?php
// app/Http/Controllers/DashboardController.php

// MODIFIZIERT:
// 1. ApiHandlerTrait importiert und verwendet.
// 2. Alle API-Methoden (getWeeklyData, saveNoteApi, getAvailableSlotsApi, bookAppointmentApi,
//    cancelAppointmentApi) nutzen jetzt handleApiRequest().
// 3. inputType 'get' für Lesezugriffe, 'json' für Schreibzugriffe.
// 4. Manuelle Security-Checks (requireLogin, verifyCsrfToken) wurden in die Trait-Optionen verlagert.
// 5. Manuelle json_encode/decode, header() und try/catch-Blöcke entfernt.
// 6. AuditLogger-Aufrufe in die 'log_action'-Rückgaben für den Trait umgewandelt.

namespace App\Http\Controllers;

use App\Core\Security;
use App\Core\Utils;
use App\Core\Database;
use App\Repositories\PlanRepository;
use App\Repositories\UserRepository;
use App\Repositories\AppointmentRepository;
use App\Repositories\StudentNoteRepository;
use App\Services\AuditLogger; // Import bleibt (wird vom Trait genutzt)
use App\Http\Traits\ApiHandlerTrait; // NEU: Trait importieren
use Exception;
use PDO;
use DateTime;
use DateTimeZone;

class DashboardController
{
    // NEU: Trait für API-Behandlung einbinden
    use ApiHandlerTrait;

    private PDO $pdo;
    private UserRepository $userRepository;
    private PlanRepository $planRepository;
    private AppointmentRepository $appointmentRepo;
    private StudentNoteRepository $noteRepo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->userRepository = new UserRepository($this->pdo);
        $this->planRepository = new PlanRepository($this->pdo);
        $this->appointmentRepo = new AppointmentRepository($this->pdo);
        $this->noteRepo = new StudentNoteRepository($this->pdo);
    }

    /**
     * Zeigt das Haupt-Dashboard an (oder leitet Admin/Planer weiter).
     * (Logik für iCal-URL bleibt unverändert)
     */
    public function index()
    {
        Security::requireLogin();
        $userId = $_SESSION['user_id'];
        $role = $_SESSION['user_role'] ?? 'Unbekannt';
        global $config;
        $config = Database::getConfig();

        if ($role === 'admin') {
            header("Location: " . Utils::url('admin/dashboard'));
            exit();
        }
        if ($role === 'planer') {
            header("Location: " . Utils::url('planer/dashboard'));
            exit();
        }

        $icalSubscriptionUrl = null;
        $user = null;
        if (in_array($role, ['schueler', 'lehrer'])) {
             try {
                 $user = $this->userRepository->findById($userId);
                 if ($user) {
                     $token = $this->userRepository->generateOrGetIcalToken($userId);
                     if ($token) {
                         $baseUrl = rtrim($config['base_url'], '/');
                         $icalPath = 'ical/' . $token;
                         $protocol = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off' || $_SERVER['SERVER_PORT'] == 443) ? "https://" : "http://";
                         $host = $_SERVER['HTTP_HOST'];
                         $icalSubscriptionUrl = $protocol . $host . Utils::url($icalPath);
                     } else {
                          error_log("Could not generate or get iCal token for user ID: " . $userId);
                     }
                 } else {
                      error_log("User not found for ID: " . $userId . " in DashboardController");
                 }
             } catch (Exception $e) {
                   error_log("Error fetching iCal token: " . $e->getMessage());
             }
        }

        $page_title = 'Mein Stundenplan';
        $body_class = 'dashboard-body';

        $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
        $dayOfWeekName = [
            1 => 'Montag', 2 => 'Dienstag', 3 => 'Mittwoch', 4 => 'Donnerstag', 5 => 'Freitag', 6 => 'Samstag', 7 => 'Sonntag'
        ][$today->format('N')] ?? 'Unbekannt';
        $dateFormatted = $today->format('d.m.Y');

        require_once dirname(__DIR__, 3) . '/pages/dashboard.php';
    }


    /**
     * API: Laden des kompletten Wochenplans, Vertretungen, Termine & Notizen.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function getWeeklyData()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];

            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $calendarWeek = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);

            if (!$year || !$calendarWeek) {
                $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                $year = (int)$today->format('o');
                $calendarWeek = (int)$today->format('W');
            }
            
            $monday = new DateTime();
            $monday->setISODate($year, $calendarWeek, 1);
            $startDate = $monday->format('Y-m-d');
            
            $sunday = new DateTime();
            $sunday->setISODate($year, $calendarWeek, 7);
            $endDate = $sunday->format('Y-m-d');
            
            $user = $this->userRepository->findById($userId);
            if (!$user) {
                throw new Exception("Benutzer nicht gefunden.", 404);
            }

            $regularTimetable = [];
            $substitutions = [];
            $appointments = [];
            $notes = [];
            $targetGroup = null;

            if ($userRole === 'schueler' && !empty($user['class_id'])) {
                $targetGroup = 'student';
                if ($this->planRepository->isWeekPublishedFor($targetGroup, $year, $calendarWeek)) {
                    $regularTimetable = $this->planRepository->getPublishedTimetableForClass($user['class_id'], $year, $calendarWeek);
                    $substitutions = $this->planRepository->getPublishedSubstitutionsForClassWeek($user['class_id'], $year, $calendarWeek);
                    $appointments = $this->appointmentRepo->getAppointmentsForStudent($userId, $startDate, $endDate);
                    $notes = $this->noteRepo->getNotesForWeek($userId, $year, $calendarWeek);
                }
            } elseif ($userRole === 'lehrer' && !empty($user['teacher_id'])) {
                 $targetGroup = 'teacher';
                 if ($this->planRepository->isWeekPublishedFor($targetGroup, $year, $calendarWeek)) {
                      $regularTimetable = $this->planRepository->getPublishedTimetableForTeacher($user['teacher_id'], $year, $calendarWeek);
                      $substitutions = $this->planRepository->getPublishedSubstitutionsForTeacherWeek($user['teacher_id'], $year, $calendarWeek);
                      $appointments = $this->appointmentRepo->getAppointmentsForTeacher($userId, $startDate, $endDate);
                 }
            }

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'data' => [
                    'timetable' => $regularTimetable,
                    'substitutions' => $substitutions,
                    'appointments' => $appointments,
                    'notes' => $notes
                ]]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => ['schueler', 'lehrer'] // Nur für diese Rollen
        ]);
    }

    /**
     * API: Speichert eine private Notiz für einen Schüler.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function saveNoteApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $userId = $_SESSION['user_id'];

            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $calendarWeek = filter_var($data['calendar_week'] ?? null, FILTER_VALIDATE_INT);
            $dayOfWeek = filter_var($data['day_of_week'] ?? null, FILTER_VALIDATE_INT);
            $periodNumber = filter_var($data['period_number'] ?? null, FILTER_VALIDATE_INT);
            $content = $data['note_content'] ?? '';

            if (!$year || !$calendarWeek || !$dayOfWeek || !$periodNumber) {
                throw new Exception("Fehlende Kontextdaten (Woche, Tag oder Stunde).", 400);
            }

            $success = $this->noteRepo->saveNote(
                $userId,
                $year,
                $calendarWeek,
                $dayOfWeek,
                $periodNumber,
                $content
            );

            if (!$success) {
                throw new Exception("Notiz konnte nicht gespeichert werden.", 500);
            }

            // Log-Details
            $logDetails = [
                'year' => $year,
                'week' => $calendarWeek,
                'day' => $dayOfWeek,
                'period' => $periodNumber,
                'action' => empty(trim($content)) ? 'deleted' : 'saved'
            ];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Notiz gespeichert.'],
                'log_action' => 'save_student_note',
                'log_target_type' => 'student_note',
                'log_target_id' => $userId, // Ziel ist der Benutzer
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => 'schueler'
        ]);
    }

    /**
     * API: Holt die verfügbaren Slots für einen Lehrer an einem Datum.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function getAvailableSlotsApi()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $teacherId = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $date = filter_var($data['date'] ?? null, FILTER_UNSAFE_RAW);

            if (!$teacherId || !$date || DateTime::createFromFormat('Y-m-d', $date) === false) {
                throw new Exception("Ungültige Lehrer-ID oder Datum.", 400);
            }
            
            $teacherUser = $this->userRepository->findUserByTeacherId($teacherId);
            if (!$teacherUser) {
                throw new Exception("Lehrerprofil (Benutzer) nicht gefunden.", 404);
            }
            $teacherUserId = $teacherUser['user_id'];
            
            $today = (new DateTime('now', new DateTimeZone('Europe/Berlin')))->format('Y-m-d');
            $slots = [];
            if ($date < $today) {
                 $slots = $this->appointmentRepo->getAvailableSlots($teacherUserId, $date);
                 if (empty($slots) && $date < $today) {
                      throw new Exception("Termine können nicht in der Vergangenheit gebucht werden.", 400);
                 }
            } else {
                 $slots = $this->appointmentRepo->getAvailableSlots($teacherUserId, $date);
            }
            
            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'data' => $slots]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => 'schueler'
        ]);
    }

    /**
     * API: Bucht einen Termin.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function bookAppointmentApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $studentUserId = $_SESSION['user_id'];

            $teacherId = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $date = $data['date'] ?? null;
            $time = $data['time'] ?? null;
            $duration = filter_var($data['duration'] ?? null, FILTER_VALIDATE_INT);
            $notes = isset($data['notes']) ? trim($data['notes']) : null;

            if (!$teacherId || !$date || !$time || !$duration) {
                throw new Exception("Fehlende Daten für die Buchung.", 400);
            }
            
            $teacherUser = $this->userRepository->findUserByTeacherId($teacherId);
            if (!$teacherUser) {
                throw new Exception("Lehrerprofil (Benutzer) nicht gefunden.", 404);
            }
            $teacherUserId = $teacherUser['user_id'];
            
            $today = (new DateTime('now', new DateTimeZone('Europe/Berlin')))->format('Y-m-d');
            if ($date < $today) {
                 throw new Exception("Termine können nicht in der Vergangenheit gebucht werden.", 400);
            }

            $newId = $this->appointmentRepo->bookAppointment(
                $studentUserId,
                $teacherUserId,
                $date,
                $time,
                $duration,
                $notes
            );
            
            // Log-Details
            $logDetails = [
                'teacher_user_id' => $teacherUserId,
                'date' => $date,
                'time' => $time
            ];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Sprechstunde erfolgreich gebucht!'],
                'log_action' => 'book_appointment',
                'log_target_type' => 'appointment',
                'log_target_id' => $newId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => 'schueler'
        ]);
    }

    /**
     * API: Storniert einen Termin.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function cancelAppointmentApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $userId = $_SESSION['user_id'];
            $role = $_SESSION['user_role'];

            $appointmentId = filter_var($data['appointment_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$appointmentId) {
                throw new Exception("Keine Termin-ID angegeben.", 400);
            }

            // Repository wirft 403/404 bei Fehlern
            $success = $this->appointmentRepo->cancelAppointment($appointmentId, $userId, $role);
            
            if (!$success) {
                // Sollte nicht passieren, wenn Repo Exceptions wirft, aber zur Sicherheit
                throw new Exception("Termin konnte nicht storniert werden.", 500);
            }

            // Log-Details
            $logDetails = ['cancelled_by_role' => $role];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Termin erfolgreich storniert.'],
                'log_action' => 'cancel_appointment',
                'log_target_type' => 'appointment',
                'log_target_id' => $appointmentId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => ['schueler', 'lehrer'] // Beide Rollen dürfen stornieren
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\DashboardController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\IcalController.php ---
<?php
// app/Http/Controllers/IcalController.php

// MODIFIZIERT:
// 1. Alle Repositories und Utils wurden entfernt.
// 2. IcalService wurde importiert und im Konstruktor instanziiert.
// 3. Alle privaten Hilfsmethoden (getWeekYear, processWeekData, formatAsIcs etc.) wurden entfernt.
// 4. Die generateFeed() Methode wurde komplett refaktorisiert:
//    - Sie ruft nur noch $this->icalService->generateFeed() auf.
//    - Sie kümmert sich um das Setzen der HTTP-Header.
//    - Sie fängt Exceptions vom Service ab und zeigt eine saubere Fehlermeldung an.

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Utils;
use App\Repositories\UserRepository;
use App\Repositories\PlanRepository;
use App\Repositories\AcademicEventRepository;
use App\Services\IcalService; // NEU: Service importieren
use Exception;

class IcalController
{
    // VERALTET: Repositories werden nicht mehr direkt benötigt
    // private UserRepository $userRepository;
    // private PlanRepository $planRepository;
    // private AcademicEventRepository $eventRepository;
    // private \PDO $pdo;
    // private array $settings;

    private IcalService $icalService; // NEU

    // VERALTET: Zeitdefinitionen wurden in den Service verschoben
    // private const PERIOD_TIMES = [ ... ];

    public function __construct()
    {
        // NEU: Service instanziieren und ihm seine Abhängigkeiten übergeben
        $pdo = Database::getInstance();
        $this->icalService = new IcalService(
            new UserRepository($pdo),
            new PlanRepository($pdo),
            new AcademicEventRepository($pdo),
            Utils::getSettings()
        );
        
        // VERALTETE Initialisierungen:
        // $this->pdo = Database::getInstance();
        // $this->userRepository = new UserRepository($this->pdo);
        // $this->planRepository = new PlanRepository($this->pdo);
        // $this->eventRepository = new AcademicEventRepository($this->pdo);
        // $this->settings = Utils::getSettings();
    }

    /**
     * Generiert den iCal-Feed, indem der IcalService aufgerufen wird.
     * Kümmert sich um das Senden der Header und der Antwort.
     *
     * @param string $token Der iCal-Token aus der URL.
     */
    public function generateFeed(string $token)
    {
        try {
            // 1. Die gesamte Logik an den Service delegieren
            $icsContent = $this->icalService->generateFeed($token);

            // 2. Header setzen (bei Erfolg)
            if (!headers_sent()) {
                header('Content-Type: text/calendar; charset=utf-8');
                header('Content-Disposition: inline; filename="pause_stundenplan.ics"');
                header('Cache-Control: no-cache, no-store, must-revalidate');
                header('Pragma: no-cache');
                header('Expires: 0');
            }

            // 3. Inhalt ausgeben
            echo $icsContent;
            exit;

        } catch (Exception $e) {
            // 4. Fehlerbehandlung (vom Service geworfen)
            $statusCode = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            
            if (!headers_sent()) {
                http_response_code($statusCode);
                header('Content-Type: text/plain; charset=utf-8');
            }
            
            // Logge den serverseitigen Fehler
            if ($statusCode >= 500) {
                 error_log("Fehler bei iCal-Generierung: " . $e->getMessage());
            }

            // Zeige eine saubere Fehlermeldung für den Benutzer an
            echo "Fehler beim Generieren des Kalender-Feeds: " . $e->getMessage();
            exit;
        }
    }

    /**
     * VERALTET: Alle privaten Hilfsmethoden wurden in den IcalService verschoben.
     */
    // private function getWeekYear(...) { ... }
    // private function getWeekDateRange(...) { ... }
    // private function getDateForDayOfWeek(...) { ... }
    // private function processWeekData(...) { ... }
    // private function processAcademicEvents(...) { ... }
    // private function formatAsIcs(...) { ... }
    // private function escapeIcsString(...) { ... }

} // End class
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\IcalController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\PdfController.php ---
<?php
// app/Http/Controllers/PdfController.php

// MODIFIZIERT:
// 1. Erbt nicht mehr von tFPDF.
// 2. Importiert den neuen PdfService.
// 3. Instanziiert den PdfService im Konstruktor.
// 4. Die Methode generateTimetablePdf() wurde komplett refaktorisiert:
//    - Sie ruft nur noch $this->pdfService->generateTimetablePdf() auf.
//    - Sie fängt Exceptions vom Service ab (z.B. "nicht veröffentlicht").
//    - Sie kümmert sich um das Senden der HTTP-Header und des PDF-Inhalts.
// 5. Alle privaten PDF-Zeichnungsmethoden (drawPdfHeader, drawTimetableCell etc.)
//    wurden entfernt, da sie sich nun im Service befinden.

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Security;
use App\Core\Utils;
use App\Repositories\PlanRepository;
use App\Repositories\UserRepository;
use App\Services\PdfService; // NEU: Service importieren
use Exception;

// VERALTET: tFPDF wird nur noch im Service benötigt
// if (!defined('FPDF_FONTPATH')) { ... }
// require_once dirname(__DIR__, 3) . '/libs/tfpdf/tfpdf.php';
// class PdfController extends \tFPDF // VERALTET

class PdfController
{
    // VERALTET: Alle privaten Eigenschaften wurden in den Service verschoben
    // private PlanRepository $planRepository;
    // ...

    private PdfService $pdfService; // NEU

    /**
     * Konstruktor: Instanziiert den PdfService und übergibt Abhängigkeiten.
     */
    public function __construct()
    {
        // Hole die Abhängigkeiten
        $pdo = Database::getInstance();
        $planRepository = new PlanRepository($pdo);
        $userRepository = new UserRepository($pdo);
        $settings = Utils::getSettings();

        // NEU: Injiziere die Abhängigkeiten in den Service
        $this->pdfService = new PdfService(
            $planRepository,
            $userRepository,
            $settings
        );
    }

    /**
     * Einstiegspunkt zur Generierung des PDF-Stundenplans.
     * Delegiert die Logik an den PdfService und sendet die Antwort.
     *
     * @param int $year Das Ziel-Jahr aus der URL.
     * @param int $week Die Ziel-Woche aus der URL.
     */
    public function generateTimetablePdf(int $year, int $week)
    {
        try {
            // 1. Sicherheitscheck und Benutzerdaten holen
            Security::requireLogin();
            $userId = $_SESSION['user_id'] ?? null;
            $userRole = $_SESSION['user_role'] ?? null;

            if (!$userId || !$userRole) {
                throw new Exception("PDF Export nur für angemeldete Benutzer verfügbar.", 403);
            }

            // 2. PDF-Generierung an den Service delegieren
            // Der Service prüft Berechtigungen (Schüler/Lehrer) und Veröffentlichungsstatus
            $pdfOutput = $this->pdfService->generateTimetablePdf($userId, $userRole, $year, $week);

            // 3. Dateinamen generieren (im Controller, da er den User kennt)
            $username = $_SESSION['username'] ?? 'User';
            $filename = sprintf(
                'Stundenplan_%s_KW%02d_%d.pdf',
                preg_replace('/[^A-Za-z0-9_-]/', '_', $username), // Bereinigter Benutzername
                $week,
                $year
            );

            // 4. Header senden (falls noch nicht gesendet)
            if (!headers_sent()) {
                header('Content-Type: application/pdf');
                header('Content-Disposition: inline; filename="' . $filename . '"');
                header('Cache-Control: no-cache, no-store, must-revalidate');
                header('Pragma: no-cache');
                header('Expires: 0');
            }

            // 5. PDF-Inhalt ausgeben
            echo $pdfOutput;
            exit;

        } catch (Exception $e) {
            // 6. Fehlerbehandlung (z.B. wenn Plan nicht veröffentlicht ist)
            $statusCode = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            
            if ($statusCode >= 500) {
                 error_log("Kritischer PDF-Generierungsfehler: " . $e->getMessage());
            }

            // Zeige eine saubere HTML-Fehlerseite statt eines kaputten PDFs
            http_response_code($statusCode);
            
            // Lade Header/Footer für eine konsistente Fehlerseite
            global $config;
            $config = Database::getConfig(); // Stelle sicher, dass $config für Header/Footer verfügbar ist
            $page_title = "PDF Fehler";
            
            include_once dirname(__DIR__, 3) . '/pages/partials/header.php';
            echo '<div class="page-wrapper" style="padding-top: 50px;">';
            echo '<div class="container message error" style="max-width: 600px;">';
            echo '<h1>PDF Generierungsfehler</h1>';
            echo '<p>' . htmlspecialchars($e->getMessage()) . '</p>';
            echo '<p><a href="' . Utils::url('dashboard') . '" class="btn btn-primary" style="width: auto;">Zurück zum Dashboard</a></p>';
            echo '</div>';
            echo '</div>';
            include_once dirname(__DIR__, 3) . '/pages/partials/footer.php';
            exit;
        }
    }

    /**
     * VERALTET: Alle privaten PDF-Zeichnungsmethoden wurden in den PdfService verschoben.
     */
    // private function drawPdfHeader(): float { ... }
    // private function drawTimetableGrid() { ... }
    // private function prepareTimetableData(): array { ... }
    // private function drawTimetableCell(...) { ... }
    // private function getDateOfISOWeek(...) { ... }
    // public function Header() { ... }
    // public function Footer() { ... }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\PdfController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\SingleEventController.php ---
<?php
// app/Http/Controllers/SingleEventController.php

// MODIFIZIERT:
// 1. Abhängigkeiten (Repositories) entfernt.
// 2. SingleIcalService importiert und im Konstruktor instanziiert.
// 3. Die Methode generateIcs() wurde komplett refaktorisiert:
//    - Sie ruft nur noch $this->icalService->generateSingleIcs() auf.
//    - Sie kümmert sich um das Setzen der HTTP-Header (basierend auf der Service-Antwort).
//    - Sie fängt Exceptions vom Service ab und zeigt eine saubere Fehlermeldung an.
// 4. Alle privaten Hilfsmethoden (getAcademicEventData, formatAsIcs etc.) wurden entfernt.

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\AcademicEventRepository;
use App\Repositories\PlanRepository;
use App\Services\SingleIcalService; // NEU: Service importieren
use Exception;
use PDO;

/**
 * Erstellt einzelne .ics-Dateien für spezifische Events.
 * MODIFIZIERT: Nutzt jetzt den SingleIcalService für die Logik.
 */
class SingleEventController
{
    // VERALTET: Repositories werden nicht mehr direkt benötigt
    // private PDO $pdo;
    // private AcademicEventRepository $eventRepo;
    // private PlanRepository $planRepo;
    
    private SingleIcalService $icalService; // NEU

    // VERALTET: Zeitdefinitionen und Zeitzone wurden in den Service verschoben
    // private DateTimeZone $timezone;
    // private const PERIOD_TIMES = [ ... ];

    public function __construct()
    {
        // NEU: Service instanziieren und Abhängigkeiten übergeben
        $pdo = Database::getInstance();
        $this->icalService = new SingleIcalService(
            new AcademicEventRepository($pdo),
            new PlanRepository($pdo)
        );
    }

    /**
     * Generiert eine .ics-Datei für ein einzelnes Event (Aufgabe, Klausur oder Sonderevent).
     *
     * @param string $type Typ des Events ('acad' oder 'sub')
     * @param int $id Die ID des Events
     */
    public function generateIcs(string $type, int $id)
    {
        try {
            // 1. Benutzer muss angemeldet sein
            Security::requireLogin();

            // 2. Logik an den Service delegieren
            $result = $this->icalService->generateSingleIcs($type, $id);
            
            $icsContent = $result['content'];
            $filename = $result['filename'];

            // 3. HTTP-Header für .ics-Download senden
            if (!headers_sent()) {
                header('Content-Type: text/calendar; charset=utf-8');
                header('Content-Disposition: attachment; filename="' . $filename . '"');
                header('Cache-Control: no-cache, no-store, must-revalidate');
                header('Pragma: no-cache');
                header('Expires: 0');
            }
            
            // 4. Inhalt ausgeben
            echo $icsContent;
            exit;

        } catch (Exception $e) {
            // 5. Fehlerbehandlung
            $statusCode = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            
            if (!headers_sent()) {
                 http_response_code($statusCode);
                 header('Content-Type: text/plain; charset=utf-8');
            }
           
            if ($statusCode >= 500) {
                 error_log("Fehler bei Einzel-ICS-Generierung: " . $e->getMessage());
            }

            // Zeige eine einfache Fehlermeldung statt die App abzustürzen
            die("Fehler beim Erstellen der Kalenderdatei: " . htmlspecialchars($e->getMessage()));
        }
    }

    /**
     * VERALTET: Alle privaten Hilfsmethoden wurden in den SingleIcalService verschoben.
     */
    // private function getAcademicEventData(int $id): ?array { ... }
    // private function getSubstitutionEventData(int $id): ?array { ... }
    // private function formatAsIcs(array $event): string { ... }
    // private function escapeIcsString(?string $string): string { ... }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\SingleEventController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\TeacherController.php ---
<?php
// app/Http/Controllers/TeacherController.php

// MODIFIZIERT:
// 1. ApiHandlerTrait importiert und verwendet.
// 2. Alle API-Methoden nutzen jetzt handleApiRequest().
// 3. inputType 'get' für Lesezugriffe, 'json' für Schreibzugriffe.
// 4. Manuelle Security-Checks (requireRole, verifyCsrfToken) wurden in die Trait-Optionen verlagert.
// 5. Manuelle json_encode/decode, header() und try/catch-Blöcke entfernt.
// 6. AuditLogger-Aufrufe in die 'log_action'-Rückgaben für den Trait umgewandelt.

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Security;
use App\Core\Utils;
use App\Repositories\StammdatenRepository;
use App\Repositories\PlanRepository;
use App\Repositories\UserRepository;
use App\Repositories\AttendanceRepository;
use App\Repositories\AppointmentRepository;
use App\Services\AuditLogger; // Import bleibt (wird vom Trait genutzt)
use App\Http\Traits\ApiHandlerTrait; // NEU: Trait importieren
use Exception;
use PDO;
use DateTime;
use DateTimeZone;

class TeacherController
{
    // NEU: Trait für API-Behandlung einbinden
    use ApiHandlerTrait;

    private PDO $pdo;
    private StammdatenRepository $stammdatenRepo;
    private PlanRepository $planRepo;
    private UserRepository $userRepo;
    private AttendanceRepository $attendanceRepo;
    private AppointmentRepository $appointmentRepo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
        $this->planRepo = new PlanRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
        $this->attendanceRepo = new AttendanceRepository($this->pdo);
        $this->appointmentRepo = new AppointmentRepository($this->pdo);
    }

    /**
     * API: Sucht nach Lehrern (für Schüler oder Lehrer).
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function searchColleaguesApi()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $query = filter_var($data['query'] ?? '', FILTER_UNSAFE_RAW);
            
            $allTeachers = $this->stammdatenRepo->getTeachers();
            
            $filteredTeachers = [];
            if (!empty($query)) {
                $filteredTeachers = array_filter($allTeachers, function($teacher) use ($query) {
                    $fullName = $teacher['first_name'] . ' ' . $teacher['last_name'];
                    return stripos($fullName, $query) !== false || 
                           stripos($teacher['teacher_shortcut'], $query) !== false;
                });
            } else {
                $filteredTeachers = array_slice($allTeachers, 0, 10);
            }

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'data' => array_values($filteredTeachers)]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => ['lehrer', 'schueler'] // Erweitert
        ]);
    }

    /**
     * API: Findet den aktuellen Aufenthaltsort (Stunde/Raum) eines Lehrers.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function findColleagueApi()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $teacherId = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$teacherId) {
                throw new Exception("Keine Lehrer-ID angegeben.", 400);
            }

            $now = new DateTime('now', new DateTimeZone('Europe/Berlin'));
            $currentDate = $now->format('Y-m-d');
            $currentYear = (int)$now->format('o');
            $currentWeek = (int)$now->format('W');
            $currentDayOfWeek = (int)$now->format('N');
            $currentHourMinute = (int)$now->format('Hi');
            $currentPeriod = $this->getCurrentPeriod($currentHourMinute);

            if ($currentDayOfWeek > 5 || $currentPeriod === null) {
                // Rückgabe für Trait (Erfolgreich, aber außerhalb der Zeit)
                return [
                    'json_response' => ['success' => true, 'data' => [
                        'status' => 'Außerhalb der Zeit',
                        'message' => 'Der Kollege befindet sich wahrscheinlich nicht im Unterricht (Wochenende oder außerhalb der Unterrichtszeit).'
                    ]]
                ];
            }

            $lessonInfo = $this->planRepo->findTeacherLocation(
                $teacherId,
                $currentDate,
                $currentYear,
                $currentWeek,
                $currentDayOfWeek,
                $currentPeriod
            );
            
            $message = $this->formatLessonInfo($lessonInfo);

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'data' => [
                    'status' => $lessonInfo['status'],
                    'message' => $message,
                    'details' => $lessonInfo['data'] ?? null
                ]]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => 'lehrer'
        ]);
    }
    
    /**
     * API: Holt die aktuelle Stunde des Lehrers UND die Schülerliste dafür.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function getCurrentLessonWithStudentsApi()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $user = $this->userRepo->findById($_SESSION['user_id']);
            if (!$user || !$user['teacher_id']) {
                throw new Exception("Kein gültiges Lehrerprofil gefunden.", 403);
            }
            $teacherId = $user['teacher_id'];

            $now = new DateTime('now', new DateTimeZone('Europe/Berlin'));
            $currentDate = $now->format('Y-m-d');
            $currentYear = (int)$now->format('o');
            $currentWeek = (int)$now->format('W');
            $currentDayOfWeek = (int)$now->format('N');
            $currentHourMinute = (int)$now->format('Hi');
            $currentPeriod = $this->getCurrentPeriod($currentHourMinute);
            
            if ($currentDayOfWeek > 5 || $currentPeriod === null) {
                return [
                    'json_response' => ['success' => true, 'data' => ['status' => 'Außerhalb der Zeit', 'lesson' => null, 'students' => []]]
                ];
            }
            
            $lessonInfo = $this->planRepo->findTeacherLocation(
                $teacherId,
                $currentDate,
                $currentYear,
                $currentWeek,
                $currentDayOfWeek,
                $currentPeriod
            );
            
            if ($lessonInfo['status'] === 'Unterricht' || $lessonInfo['status'] === 'Vertretung') {
                $lessonData = $lessonInfo['data'];
                $classId = $lessonData['class_id'];
                
                $students = $this->userRepo->getStudentsByClassId($classId);
                $attendance = $this->attendanceRepo->getAttendance($classId, $currentDate, $currentPeriod);
                
                return [
                    'json_response' => ['success' => true, 'data' => [
                        'status' => $lessonInfo['status'],
                        'lesson' => $lessonData,
                        'students' => $students,
                        'attendance' => $attendance,
                        'context' => ['date' => $currentDate, 'period' => $currentPeriod]
                    ]]
                ];

            } else {
                return [
                    'json_response' => ['success' => true, 'data' => ['status' => $lessonInfo['status'], 'lesson' => null, 'students' => []]]
                ];
            }

        }, [
            'inputType' => 'get',
            'checkRole' => 'lehrer'
        ]);
    }
    
    /**
     * API: Speichert die Anwesenheitsliste.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function saveAttendanceApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $user = $this->userRepo->findById($_SESSION['user_id']);
            if (!$user || !$user['teacher_id']) {
                throw new Exception("Kein gültiges Lehrerprofil gefunden.", 403);
            }
            $teacherUserId = $user['user_id'];
            
            $classId = filter_var($data['class_id'] ?? null, FILTER_VALIDATE_INT);
            $date = $data['date'] ?? null;
            $period = filter_var($data['period_number'] ?? null, FILTER_VALIDATE_INT);
            $students = $data['students'] ?? [];

            if (!$classId || !$date || !$period || empty($students) || !is_array($students)) {
                throw new Exception("Fehlende oder ungültige Daten (Klasse, Datum, Stunde oder Schülerliste).", 400);
            }
            
            $success = $this->attendanceRepo->saveAttendance(
                $teacherUserId,
                $classId,
                $date,
                $period,
                $students
            );

            if (!$success) {
                throw new Exception("Anwesenheit konnte nicht gespeichert werden.", 500);
            }

            // Log-Details
            $logDetails = [
                'date' => $date, 
                'period' => $period, 
                'student_count' => count($students)
            ];

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Anwesenheit gespeichert!'],
                'log_action' => 'save_attendance',
                'log_target_type' => 'class',
                'log_target_id' => $classId,
                'log_details' => $logDetails
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => 'lehrer'
        ]);
    }
    
    /**
     * API: Holt die Voraussetzungen (Fächer und unterrichtete Klassen) für das Event-Formular.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function getPrerequisitesApi()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $user = $this->userRepo->findById($_SESSION['user_id']);
            if (!$user || !$user['teacher_id']) {
                throw new Exception("Kein gültiges Lehrerprofil gefunden.", 403);
            }
            $teacherId = $user['teacher_id'];

            $subjects = $this->stammdatenRepo->getSubjects();
            $classes = $this->planRepo->getClassesForTeacher($teacherId);

            // Rückgabe für Trait
            return [
                'json_response' => [
                    'success' => true,
                    'data' => [
                        'subjects' => $subjects,
                        'classes' => $classes
                    ]
                ]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => 'lehrer'
        ]);
    }

    // --- NEUE METHODEN FÜR SPRECHSTUNDEN (Refaktorisiert) ---

    /**
     * API: Holt die definierten Sprechstundenfenster des eingeloggten Lehrers.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist $_GET.
     */
    public function getOfficeHoursApi()
    {
        $this->handleApiRequest(function($data) { // $data ist $_GET
            
            $teacherUserId = $_SESSION['user_id'];
            $availabilities = $this->appointmentRepo->getAvailabilities($teacherUserId);
            
            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'data' => $availabilities]
            ];

        }, [
            'inputType' => 'get',
            'checkRole' => 'lehrer'
        ]);
    }

    /**
     * API: Speichert ein neues Sprechstundenfenster für den eingeloggten Lehrer.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function saveOfficeHoursApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $teacherUserId = $_SESSION['user_id'];

            $dayOfWeek = filter_var($data['day_of_week'] ?? null, FILTER_VALIDATE_INT);
            $startTime = $data['start_time'] ?? null;
            $endTime = $data['end_time'] ?? null;
            $slotDuration = filter_var($data['slot_duration'] ?? 15, FILTER_VALIDATE_INT);

            if (!$dayOfWeek || !$startTime || !$endTime || !$slotDuration || $dayOfWeek < 1 || $dayOfWeek > 5 || $slotDuration < 5) {
                throw new Exception("Ungültige Eingabedaten.", 400);
            }

            $newId = $this->appointmentRepo->createAvailability($teacherUserId, $dayOfWeek, $startTime, $endTime, $slotDuration);
            
            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Sprechzeit erfolgreich gespeichert.', 'data' => ['availability_id' => $newId]],
                'log_action' => 'create_office_hours',
                'log_target_type' => 'teacher_availability',
                'log_target_id' => $newId,
                'log_details' => $data
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => 'lehrer'
        ]);
    }

    /**
     * API: Löscht ein Sprechstundenfenster des eingeloggten Lehrers.
     * MODIFIZIERT: Nutzt ApiHandlerTrait. $data ist geparstes JSON.
     */
    public function deleteOfficeHoursApi()
    {
        $this->handleApiRequest(function($data) { // $data ist JSON-Body
            
            $teacherUserId = $_SESSION['user_id'];
            $availabilityId = filter_var($data['availability_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$availabilityId) {
                throw new Exception("Keine ID angegeben.", 400);
            }

            // Repository wirft 404 bei Fehler
            $success = $this->appointmentRepo->deleteAvailability($availabilityId, $teacherUserId);
            
            if (!$success) {
                 throw new Exception("Sprechzeit nicht gefunden oder keine Berechtigung.", 404);
            }

            // Rückgabe für Trait
            return [
                'json_response' => ['success' => true, 'message' => 'Sprechzeit erfolgreich gelöscht.'],
                'log_action' => 'delete_office_hours',
                'log_target_type' => 'teacher_availability',
                'log_target_id' => $availabilityId
            ];

        }, [
            'inputType' => 'json',
            'checkRole' => 'lehrer'
        ]);
    }

    
    /**
     * Hilfsfunktion: Wandelt einen 'Hi'-Zeitstempel in eine Periodennummer um.
     * (Unverändert)
     */
    private function getCurrentPeriod(int $hourMinute): ?int
    {
        if ($hourMinute >= 800 && $hourMinute <= 845) return 1;
        if ($hourMinute >= 855 && $hourMinute <= 940) return 2;
        if ($hourMinute >= 940 && $hourMinute <= 1025) return 3;
        if ($hourMinute >= 1035 && $hourMinute <= 1120) return 4;
        if ($hourMinute >= 1120 && $hourMinute <= 1205) return 5;
        // Mittagspause
        if ($hourMinute >= 1305 && $hourMinute <= 1350) return 6;
        if ($hourMinute >= 1350 && $hourMinute <= 1435) return 7;
        if ($hourMinute >= 1445 && $hourMinute <= 1530) return 8;
        if ($hourMinute >= 1530 && $hourMinute <= 1615) return 9;
        if ($hourMinute >= 1625 && $hourMinute <= 1710) return 10;
        
        return null;
    }
    
    /**
     * Hilfsfunktion: Formatiert die Rohdaten aus dem Repository in eine lesbare Nachricht.
     * (Unverändert)
     */
    private function formatLessonInfo(array $info): string
    {
        $data = $info['data'] ?? null;
        
        switch ($info['status']) {
            case 'Unterricht':
                return sprintf(
                    "Hält regulären Unterricht (%s) in Klasse %s in Raum %s.",
                    htmlspecialchars($data['subject_shortcut'] ?? '?'),
                    htmlspecialchars($data['class_name'] ?? '?'),
                    htmlspecialchars($data['room_name'] ?? '?')
                );
            case 'Vertretung':
                return sprintf(
                    "Ist als Vertretung (%s) in Klasse %s in Raum %s.",
                    htmlspecialchars($data['new_subject_shortcut'] ?? '?'),
                    htmlspecialchars($data['class_name'] ?? '?'),
                    htmlspecialchars($data['new_room_name'] ?? '?')
                );
            case 'Entfall':
                return sprintf(
                    "Die Stunde (%s, Klasse %s) entfällt. Der Kollege ist voraussichtlich frei.",
                    htmlspecialchars($data['original_subject_shortcut'] ?? '?'),
                    htmlspecialchars($data['class_name'] ?? '?')
                );
            case 'Raumänderung':
                return sprintf(
                    "Die Stunde (%s, Klasse %s) wurde nach Raum %s verlegt.",
                    htmlspecialchars($data['original_subject_shortcut'] ?? '?'),
                    htmlspecialchars($data['class_name'] ?? '?'),
                    htmlspecialchars($data['new_room_name'] ?? '?')
                );
            case 'Sonderevent':
                 return sprintf(
                    "Nimmt am Sonderevent '%s' (Klasse %s) in Raum %s teil.",
                    htmlspecialchars($data['comment'] ?? 'Event'),
                    htmlspecialchars($data['class_name'] ?? '?'),
                    htmlspecialchars($data['new_room_name'] ?? '?')
                );
            case 'Freistunde':
                return "Hat laut Plan jetzt eine Freistunde (FU).";
            default:
                return "Status unbekannt.";
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\TeacherController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Traits\ApiHandlerTrait.php ---
<?php
// app/Http/Traits/ApiHandlerTrait.php

namespace App\Http\Traits;

use App\Core\Security;
use App\Services\AuditLogger;
use Exception;
use PDOException;

/**
 * Trait ApiHandlerTrait
 *
 * Stellt eine standardisierte Methode zur Behandlung von API-Anfragen (JSON, FormData, GET) bereit.
 * Dieses Trait kümmert sich um:
 * - Setzen des JSON-Headers
 * - CSRF-Token-Überprüfung (für POST/JSON)
 * - Parsen von Eingabedaten (JSON-Body, FormData/POST, GET)
 * - Zentrales try/catch-Fehlerhandling
 * - Standardisierte JSON-Antworten (Erfolg/Fehler)
 * - Automatisches Audit-Logging bei Erfolg
 */
trait ApiHandlerTrait
{
    /**
     * Verarbeitet eine API-Anfrage standardisiert.
     *
     * @param callable $callback Die auszuführende Geschäftslogik. Erhält $data (geparste Eingabe) als Parameter.
     * MUSS ein Array zurückgeben, z.B.:
     * [
     * 'json_response' => ['success' => true, 'data' => ...],
     * 'log_action' => 'create_user',
     * 'log_target_type' => 'user',
     * 'log_target_id' => $newId,
     * 'log_details' => [...]
     * ]
     * oder für GET-Anfragen (die selbst 'echo' verwenden):
     * [ 'is_get_request' => true ]
     *
     * @param array $options Konfigurationsoptionen:
     * - 'inputType' (string): 'json' (default), 'form' (für $_POST/FormData), 'get' (für $_GET).
     * - 'checkRole' (string|array|null): Rolle(n), die via Security::requireRole geprüft werden sollen.
     */
    protected function handleApiRequest(callable $callback, array $options = []): void
    {
        // 1. Optionen und Standardwerte festlegen
        $inputType = $options['inputType'] ?? 'json'; // 'json', 'form', 'get'
        $roleToCheck = $options['checkRole'] ?? null;

        // 2. HTTP-Header setzen
        // (Wir setzen ihn immer, da auch Fehler als JSON zurückgegeben werden)
        if (!headers_sent()) {
            header('Content-Type: application/json');
        }

        $data = [];

        try {
            // 3. Sicherheitsüberprüfungen (Rolle und CSRF)
            if ($roleToCheck) {
                Security::requireRole($roleToCheck);
            }

            // CSRF-Prüfung (überspringen bei GET)
            if ($inputType !== 'get') {
                Security::verifyCsrfToken(); // KORREKTUR: Name der Security-Methode
            }

            // 4. Eingabedaten parsen
            switch ($inputType) {
                case 'json':
                    $input = file_get_contents('php://input');
                    $data = json_decode($input, true);
                    if (json_last_error() !== JSON_ERROR_NONE && !empty($input)) {
                        throw new Exception("Ungültige JSON-Daten empfangen.", 400);
                    }
                    break;
                case 'form':
                    $data = $_POST; // Behandelt FormData und Standard-Formular-POST
                    // Hinweis: $_FILES muss im Callback separat behandelt werden
                    break;
                case 'get':
                    $data = $_GET;
                    break;
            }

            // 5. Geschäftslogik (Callback) ausführen
            $result = $callback($data);

            // 6. Antwort verarbeiten
            if (isset($result['is_get_request']) && $result['is_get_request'] === true) {
                // Der Callback hat die Antwort bereits gesendet (z.B. PlanController::getTimetableData)
                // Nichts weiter tun.
            } elseif (isset($result['json_response'])) {
                // Standard-Erfolgsfall:

                // 7. Audit-Log bei Erfolg (falls Daten vorhanden)
                if (isset($result['log_action'])) {
                    AuditLogger::log(
                        $result['log_action'],
                        $result['log_target_type'] ?? null,
                        $result['log_target_id'] ?? null,
                        $result['log_details'] ?? null
                    );
                }

                // 8. Erfolgs-JSON senden
                echo json_encode($result['json_response'], JSON_THROW_ON_ERROR);

            } else {
                // Fallback, falls der Callback kein 'json_response' zurückgibt
                throw new Exception("Interner Serverfehler: API-Callback lieferte keine gültige Antwort.", 500);
            }

        } catch (Exception $e) {
            // 9. Zentrales Fehlerhandling
            $statusCode = 500; // Standard-Serverfehler

            if ($e instanceof PDOException) {
                // Spezifische DB-Fehler
                if ($e->errorInfo[1] == 1062) { // Duplicate entry
                    $statusCode = 409; // Conflict
                } else {
                    $statusCode = 500; // Anderer DB-Fehler
                }
            } elseif (is_int($e->getCode()) && $e->getCode() >= 400 && $e->getCode() < 600) {
                // Verwende den HTTP-Code aus der Exception (z.B. 400, 403, 404, 409)
                $statusCode = $e->getCode();
            } elseif (str_contains($e->getMessage(), 'CSRF')) {
                $statusCode = 403;
            } elseif (str_contains($e->getMessage(), 'Berechtigung') || str_contains($e->getMessage(), 'Rolle')) {
                $statusCode = 403;
            }

            // Setze den HTTP-Statuscode
            http_response_code($statusCode);

            // Logge den serverseitigen Fehler (außer bei reinen Client-Fehlern wie 400, 404)
            if ($statusCode >= 500) {
                error_log("API Fehler (Trait): " . $e->getMessage() . "\n" . $e->getTraceAsString());
            }

            // Sende die Fehler-JSON-Antwort
            echo json_encode([
                'success' => false,
                'message' => $e->getMessage()
            ], JSON_THROW_ON_ERROR);
        }
        
        // 10. Skriptausführung beenden
        exit();
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Traits\ApiHandlerTrait.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AcademicEventRepository.php ---
<?php
// app/Repositories/AcademicEventRepository.php

namespace App\Repositories;

use PDO;
use Exception;
use DateTime; // Wichtig für Datumsberechnungen

class AcademicEventRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Holt alle Events (Aufgaben, Klausuren) für eine bestimmte Klasse in einem Zeitraum.
     * @param int $classId
     * @param int $year
     * @param int $week
     * @return array
     */
    public function getEventsForClassByWeek(int $classId, int $year, int $week): array
    {
        // Berechne Start- und Enddatum der Woche (Mo-So)
        $monday = new DateTime();
        $monday->setISODate($year, $week, 1); // 1 = Montag
        $startDate = $monday->format('Y-m-d');

        $sunday = new DateTime();
        $sunday->setISODate($year, $week, 7); // 7 = Sonntag
        $endDate = $sunday->format('Y-m-d');

        // Nutze die neue, allgemeinere Funktion
        return $this->getEventsForClassByDateRange($classId, $startDate, $endDate);
    }

    /**
     * Holt Events für eine Klasse in einem Datumsbereich.
     * @param int $classId
     * @param string $startDate (Y-m-d)
     * @param string $endDate (Y-m-d)
     * @return array
     */
    public function getEventsForClassByDateRange(int $classId, string $startDate, string $endDate): array
    {
        // KORREKTUR: ae.period_number aus ORDER BY entfernt
        $sql = "SELECT
                    ae.*,
                    s.subject_shortcut,
                    u.first_name AS teacher_first_name,
                    u.last_name AS teacher_last_name
                FROM academic_events ae
                LEFT JOIN subjects s ON ae.subject_id = s.subject_id
                JOIN users u ON ae.user_id = u.user_id
                WHERE ae.class_id = :class_id
                  AND ae.due_date BETWEEN :start_date AND :end_date
                ORDER BY ae.due_date ASC, ae.event_type ASC";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':class_id' => $classId,
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }


    /**
     * Holt alle Events, die ein Lehrer für die nahe Zukunft erstellt hat.
     * @param int $teacherUserId Die user_id des Lehrers
     * @param int $daysInFuture
     * @return array
     */
    public function getEventsByTeacher(int $teacherUserId, int $daysInFuture = 14): array
    {
        $startDate = (new DateTime('now', new \DateTimeZone('Europe/Berlin')))->format('Y-m-d');
        $endDate = (new DateTime('now', new \DateTimeZone('Europe/Berlin')))->modify("+{$daysInFuture} days")->format('Y-m-d');

        // Nutze die neue, allgemeinere Funktion
        return $this->getEventsByTeacherForDateRange($teacherUserId, $startDate, $endDate);
    }

    /**
     * Holt Events, die ein Lehrer erstellt hat, in einem Datumsbereich.
     * @param int $teacherUserId
     * @param string $startDate (Y-m-d)
     * @param string $endDate (Y-m-d)
     * @return array
     */
    public function getEventsByTeacherForDateRange(int $teacherUserId, string $startDate, string $endDate): array
    {
        // KORREKTUR: ae.period_number aus ORDER BY entfernt
         $sql = "SELECT
                    ae.*,
                    s.subject_shortcut,
                    c.class_name
                FROM academic_events ae
                LEFT JOIN subjects s ON ae.subject_id = s.subject_id
                JOIN classes c ON ae.class_id = c.class_id
                WHERE ae.user_id = :teacher_user_id
                  AND ae.due_date BETWEEN :start_date AND :end_date
                ORDER BY ae.due_date ASC, c.class_name ASC";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':teacher_user_id' => $teacherUserId,
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Prüft, ob ein Lehrer berechtigt ist, für eine Klasse an einem Datum einen Eintrag zu erstellen.
     * (Prüft, ob der Lehrer an dem Tag Unterricht in der Klasse hat)
     * @param int $teacherId Die teacher_id (aus der teachers Tabelle)
     * @param int $classId
     * @param string $date YYYY-MM-DD
     * @return bool
     */
    public function checkTeacherAuthorization(int $teacherId, int $classId, string $date): bool
    {
        try {
            $dateObj = new DateTime($date);
            $year = (int)$dateObj->format('o');
            $week = (int)$dateObj->format('W');
            $dayOfWeek = (int)$dateObj->format('N'); // 1=Mo, 7=So

            // 1. Prüfen auf regulären Unterricht
            $sqlRegular = "SELECT 1 FROM timetable_entries
                           WHERE teacher_id = :teacher_id
                             AND class_id = :class_id
                             AND year = :year
                             AND calendar_week = :week
                             AND day_of_week = :day_of_week
                           LIMIT 1";

            $stmtRegular = $this->pdo->prepare($sqlRegular);
            $stmtRegular->execute([
                ':teacher_id' => $teacherId,
                ':class_id' => $classId,
                ':year' => $year,
                ':week' => $week,
                ':day_of_week' => $dayOfWeek
            ]);

            if ($stmtRegular->fetchColumn()) {
                return true; // Ja, hat regulären Unterricht
            }

            // 2. Prüfen auf Vertretung (als neuer Lehrer)
            $sqlSub = "SELECT 1 FROM substitutions
                       WHERE new_teacher_id = :teacher_id
                         AND class_id = :class_id
                         AND date = :date
                       LIMIT 1";

            $stmtSub = $this->pdo->prepare($sqlSub);
            $stmtSub->execute([
                ':teacher_id' => $teacherId,
                ':class_id' => $classId,
                ':date' => $date
            ]);

            if ($stmtSub->fetchColumn()) {
                return true; // Ja, hält eine Vertretung
            }

            return false; // Kein Unterricht an diesem Tag in dieser Klasse gefunden

        } catch (Exception $e) {
            error_log("Fehler bei checkTeacherAuthorization: " . $e->getMessage());
            return false; // Im Zweifel ablehnen
        }
    }

    /**
     * Speichert (Insert/Update) ein Event.
     * KORREKTUR: Parameter $period entfernt.
     * @param int|null $eventId
     * @param int $teacherUserId (Dies ist die user_id aus der users Tabelle)
     * @param int $classId
     * @param int|null $subjectId
     * @param string $eventType
     * @param string $title
     * @param string $dueDate
     * @param string|null $description
     * @return array Das gespeicherte Event
     * @throws Exception
     */
    public function saveEvent(?int $eventId, int $teacherUserId, int $classId, ?int $subjectId, string $eventType, string $title, string $dueDate, ?string $description): array
    {
        if ($eventId) {
            // Update
            // KORREKTUR: period_number entfernt
            $sql = "UPDATE academic_events SET
                        class_id = :class_id,
                        subject_id = :subject_id,
                        event_type = :event_type,
                        title = :title,
                        due_date = :due_date,
                        description = :description
                    WHERE event_id = :event_id AND user_id = :teacher_user_id";

            $params = [
                ':event_id' => $eventId,
                ':teacher_user_id' => $teacherUserId,
                ':class_id' => $classId,
                ':subject_id' => $subjectId,
                ':event_type' => $eventType,
                ':title' => $title,
                ':due_date' => $dueDate,
                ':description' => $description
            ];
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute($params);

        } else {
            // Insert
            // KORREKTUR: period_number entfernt
            $sql = "INSERT INTO academic_events
                        (user_id, class_id, subject_id, event_type, title, due_date, description)
                    VALUES
                        (:teacher_user_id, :class_id, :subject_id, :event_type, :title, :due_date, :description)";

            $params = [
                ':teacher_user_id' => $teacherUserId,
                ':class_id' => $classId,
                ':subject_id' => $subjectId,
                ':event_type' => $eventType,
                ':title' => $title,
                ':due_date' => $dueDate,
                ':description' => $description
            ];
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute($params);
            $eventId = (int)$this->pdo->lastInsertId();
        }

        // Hole den gespeicherten Datensatz (inkl. Joins) für die Rückgabe an das Frontend
        $savedEvent = $this->getEventById($eventId);
        if (!$savedEvent) {
            throw new Exception("Fehler beim Abrufen des gespeicherten Events.");
        }
        return $savedEvent;
    }

    /**
     * Löscht ein Event, wenn es dem Lehrer gehört.
     * @param int $eventId
     * @param int $teacherUserId (Dies ist die user_id)
     * @return bool
     */
    public function deleteEvent(int $eventId, int $teacherUserId): bool
    {
        $sql = "DELETE FROM academic_events
                WHERE event_id = :event_id AND user_id = :teacher_user_id";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':event_id' => $eventId,
            ':teacher_user_id' => $teacherUserId
        ]);

        return $stmt->rowCount() > 0;
    }

    /**
     * Hilfsfunktion: Holt ein einzelnes Event anhand seiner ID (mit Joins).
     * @param int $eventId
     * @return array|false
     */
    public function getEventById(int $eventId)
    {
         $sql = "SELECT
                    ae.*,
                    s.subject_shortcut,
                    c.class_name,
                    u.first_name AS teacher_first_name,
                    u.last_name AS teacher_last_name
                FROM academic_events ae
                LEFT JOIN subjects s ON ae.subject_id = s.subject_id
                JOIN classes c ON ae.class_id = c.class_id
                JOIN users u ON ae.user_id = u.user_id
                WHERE ae.event_id = :event_id";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':event_id' => $eventId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AcademicEventRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AnnouncementRepository.php ---
<?php
// app/Repositories/AnnouncementRepository.php
namespace App\Repositories;

use PDO;
use Exception; // Added for potential errors

class AnnouncementRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Erstellt eine neue Ankündigung in der Datenbank.
     * Nutzt is_global und class_id basierend auf der Logik im Controller.
     *
     * @param int $userId ID des Autors
     * @param string $title Titel
     * @param string $content Inhalt
     * @param string $targetRole Zielgruppe ('all', 'schueler', 'lehrer', 'planer') - Wird jetzt in is_global/class_id übersetzt
     * @param ?int $targetClassId Klassen-ID (nur wenn targetRole 'schueler')
     * @param ?string $attachmentPath Pfad zur angehängten Datei (relativ zum public-Ordner)
     * @return int Die ID der neu erstellten Ankündigung.
     * @throws Exception
     */
    public function createAnnouncement(int $userId, string $title, string $content, string $targetRole, ?int $targetClassId, ?string $attachmentPath): int
    {
        // *** Convert targetRole/targetClassId to is_global/class_id ***
        // 'schueler' with a class ID means it's class-specific (is_global = 0)
        // 'all', 'lehrer', 'planer', or 'schueler' without a class ID means it's global (is_global = 1)
        $isGlobal = !($targetRole === 'schueler' && $targetClassId !== null);
        $dbClassId = ($targetRole === 'schueler' && $targetClassId !== null) ? $targetClassId : null;

        // *** Use is_global and class_id in SQL ***
        $sql = "INSERT INTO announcements (user_id, title, content, is_global, class_id, file_path, created_at) /* Corrected column name file_path */
                VALUES (:user_id, :title, :content, :is_global, :class_id, :file_path, NOW())";
        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([
            ':user_id' => $userId,
            ':title' => $title,
            ':content' => $content,
            ':is_global' => $isGlobal ? 1 : 0,
            ':class_id' => $dbClassId,
            ':file_path' => $attachmentPath // Corrected parameter name
        ]);

        if (!$success) {
            // Log detailed error
            error_log("Announcement creation failed: " . print_r($stmt->errorInfo(), true));
            throw new Exception("Fehler beim Erstellen der Ankündigung.");
        }
        return (int)$this->pdo->lastInsertId();
    }

    /**
     * Holt Ankündigungen, die für einen bestimmten Benutzer sichtbar sind.
     * Berücksichtigt Rolle und ggf. Klassenzugehörigkeit.
     *
     * @param string $userRole Rolle des aktuellen Benutzers
     * @param ?int $classId Klassen-ID des Schülers (falls zutreffend)
     * @return array Array von Ankündigungen.
     */
    public function getVisibleAnnouncements(string $userRole, ?int $classId): array
    {
        // *** Uses is_global and class_id ***
        $sql = "SELECT a.*, CONCAT(u.first_name, ' ', u.last_name) as author_name, c.class_name as target_class_name
                FROM announcements a
                JOIN users u ON a.user_id = u.user_id
                LEFT JOIN classes c ON a.class_id = c.class_id
                WHERE (
                    a.is_global = 1"; // Global announcements are always visible (covers all, lehrer, planer types)

        $params = [];

        // Add condition for students to see their class-specific announcements
        if ($userRole === 'schueler' && $classId !== null) {
            $sql .= " OR (a.is_global = 0 AND a.class_id = :class_id)";
            $params[':class_id'] = $classId;
        }

        // Close the main WHERE parenthesis
        $sql .= " ) ORDER BY a.created_at DESC LIMIT 20";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($params);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }


    /**
     * Holt alle Ankündigungen mit zusätzlichen Details (Autor, Klasse).
     * Wird für die Admin-Ansicht verwendet.
     * @return array Array aller Ankündigungen.
     */
    public function getAllAnnouncementsWithDetails(): array
    {
        $sql = "SELECT a.*, CONCAT(u.first_name, ' ', u.last_name) as author_name, c.class_name as target_class_name
                FROM announcements a
                JOIN users u ON a.user_id = u.user_id
                LEFT JOIN classes c ON a.class_id = c.class_id
                ORDER BY a.created_at DESC";
        $stmt = $this->pdo->query($sql);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }


    /**
     * Holt eine einzelne Ankündigung anhand ihrer ID.
     * @param int $announcementId
     * @return array|false Die Ankündigungsdaten oder false, wenn nicht gefunden.
     */
    public function getAnnouncementById(int $announcementId): array|false
    {
        $sql = "SELECT a.*, CONCAT(u.first_name, ' ', u.last_name) as author_name, c.class_name as target_class_name
                FROM announcements a
                JOIN users u ON a.user_id = u.user_id
                LEFT JOIN classes c ON a.class_id = c.class_id
                WHERE a.announcement_id = :id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':id' => $announcementId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    /**
     * Löscht eine Ankündigung anhand ihrer ID.
     * @param int $announcementId
     * @return bool True bei Erfolg, False bei Misserfolg.
     */
    public function deleteAnnouncement(int $announcementId): bool
    {
        $announcement = $this->getAnnouncementById($announcementId);

        $sql = "DELETE FROM announcements WHERE announcement_id = :id";
        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([':id' => $announcementId]);

        // If deletion was successful and there was an attachment, try to delete the file
        if ($success && $announcement && !empty($announcement['file_path'])) {
             $filePath = dirname(__DIR__, 2) . '/public/' . $announcement['file_path'];
            if (file_exists($filePath)) {
                @unlink($filePath);
            }
        }

        return $success;
    }

     // Update method (Placeholder - needs implementation)
     /*
     public function updateAnnouncement(int $announcementId, int $userId, string $title, string $content, string $targetRole, ?int $targetClassId, ?string $attachmentPath, bool $removeAttachment): bool {
         // Determine is_global and dbClassId based on targetRole/targetClassId
         $isGlobal = !($targetRole === 'schueler' && $targetClassId !== null);
         $dbClassId = ($targetRole === 'schueler' && $targetClassId !== null) ? $targetClassId : null;

         // Fetch current announcement to handle file deletion if requested or replaced
         $current = $this->getAnnouncementById($announcementId);
         $currentFilePath = $current['file_path'] ?? null;
         $newFilePath = $attachmentPath; // If a new file was uploaded
         $finalFilePath = $newFilePath; // Assume new file replaces old by default

         if ($removeAttachment && !$newFilePath && $currentFilePath) {
             // Delete existing file, set path to NULL
             $filePathToDelete = dirname(__DIR__, 2) . '/public/' . $currentFilePath;
              if (file_exists($filePathToDelete)) {
                  @unlink($filePathToDelete);
              }
             $finalFilePath = null;
         } elseif ($newFilePath && $currentFilePath && $newFilePath !== $currentFilePath) {
             // New file replaces old one, delete the old one
              $filePathToDelete = dirname(__DIR__, 2) . '/public/' . $currentFilePath;
              if (file_exists($filePathToDelete)) {
                  @unlink($filePathToDelete);
              }
             $finalFilePath = $newFilePath;
         } elseif (!$newFilePath && !$removeAttachment) {
              // No new file, don't remove existing -> keep current path
              $finalFilePath = $currentFilePath;
         }
         // If !$newFilePath and $removeAttachment, finalFilePath is already correctly set to null above.


         $sql = "UPDATE announcements SET
                     title = :title,
                     content = :content,
                     is_global = :is_global,
                     class_id = :class_id,
                     file_path = :file_path
                     -- Optionally update user_id or created_at? Probably not.
                 WHERE announcement_id = :id";

         $stmt = $this->pdo->prepare($sql);
         return $stmt->execute([
             ':title' => $title,
             ':content' => $content,
             ':is_global' => $isGlobal ? 1 : 0,
             ':class_id' => $dbClassId,
             ':file_path' => $finalFilePath,
             ':id' => $announcementId
         ]);
     }
     */
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AnnouncementRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AppointmentRepository.php ---
<?php
// app/Repositories/AppointmentRepository.php

namespace App\Repositories;

use PDO;
use Exception;
use DateTime;
use DateTimeZone;
use DateInterval;
use DatePeriod;

class AppointmentRepository
{
    private PDO $pdo;
    private DateTimeZone $timezone;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
        $this->timezone = new DateTimeZone('Europe/Berlin');
    }

    // --- Lehrer: Verfügbarkeit verwalten ---

    /**
     * Fügt ein neues Verfügbarkeitsfenster für einen Lehrer hinzu.
     * @param int $teacherUserId
     * @param int $dayOfWeek (1-5)
     * @param string $startTime (HH:MM)
     * @param string $endTime (HH:MM)
     * @param int $slotDuration (in Minuten)
     * @return int ID der neuen Verfügbarkeit
     * @throws Exception
     */
    public function createAvailability(int $teacherUserId, int $dayOfWeek, string $startTime, string $endTime, int $slotDuration): int
    {
        // TODO: Auf Überlappung mit bestehenden Fenstern prüfen
        $sql = "INSERT INTO teacher_availability (teacher_user_id, day_of_week, start_time, end_time, slot_duration)
                VALUES (:teacher_user_id, :day_of_week, :start_time, :end_time, :slot_duration)";
        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([
            ':teacher_user_id' => $teacherUserId,
            ':day_of_week' => $dayOfWeek,
            ':start_time' => $startTime,
            ':end_time' => $endTime,
            ':slot_duration' => $slotDuration
        ]);

        if (!$success) {
            throw new Exception("Sprechzeit konnte nicht gespeichert werden (eventuell überlappend?).");
        }
        return (int)$this->pdo->lastInsertId();
    }

    /**
     * Löscht ein Verfügbarkeitsfenster.
     * @param int $availabilityId
     * @param int $teacherUserId (Zur Sicherheit)
     * @return bool
     */
    public function deleteAvailability(int $availabilityId, int $teacherUserId): bool
    {
        // Löscht auch alle zukünftigen, noch nicht stattgefundenen Termine, die auf diesem Fenster basieren
        $this->pdo->beginTransaction();
        try {
            // 1. Zukünftige Termine löschen
            $sqlDeleteAppointments = "DELETE FROM appointments 
                                      WHERE teacher_user_id = :teacher_user_id 
                                        AND appointment_date >= CURDATE()
                                        AND status = 'booked'
                                        AND appointment_time >= (SELECT start_time FROM teacher_availability WHERE availability_id = :availability_id)
                                        AND appointment_time < (SELECT end_time FROM teacher_availability WHERE availability_id = :availability_id)";
            // HINWEIS: Diese Logik ist vereinfacht. Sie löscht alle Termine des Lehrers an dem Tag im Fenster.
            // Eine bessere Logik würde die availability_id in appointments speichern.
            // Für dieses MVP löschen wir einfach das Fenster.
            
            // TODO: Wenn appointments.availability_id hinzugefügt wird, stattdessen das verwenden:
            // $sqlDeleteAppointments = "DELETE FROM appointments WHERE availability_id = :availability_id AND appointment_date >= CURDATE()";
            // $this->pdo->prepare($sqlDeleteAppointments)->execute([':availability_id' => $availabilityId]);


            // 2. Verfügbarkeitsfenster löschen
            $sqlDeleteAvailability = "DELETE FROM teacher_availability 
                                      WHERE availability_id = :availability_id AND teacher_user_id = :teacher_user_id";
            $stmt = $this->pdo->prepare($sqlDeleteAvailability);
            $stmt->execute([
                ':availability_id' => $availabilityId,
                ':teacher_user_id' => $teacherUserId
            ]);
            
            $this->pdo->commit();
            return $stmt->rowCount() > 0;

        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("Fehler beim Löschen der Sprechzeit: " . $e->getMessage());
            return false;
        }
    }

    /**
     * Holt alle Verfügbarkeitsfenster für einen Lehrer.
     * @param int $teacherUserId
     * @return array
     */
    public function getAvailabilities(int $teacherUserId): array
    {
        $sql = "SELECT * FROM teacher_availability WHERE teacher_user_id = :teacher_user_id ORDER BY day_of_week, start_time";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':teacher_user_id' => $teacherUserId]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }


    // --- Schüler: Slots abrufen und buchen ---

    /**
     * Holt alle verfügbaren (noch nicht gebuchten) Slots für einen Lehrer an einem bestimmten Datum.
     * @param int $teacherUserId
     * @param string $date (Y-m-d)
     * @return array
     * @throws Exception
     */
    public function getAvailableSlots(int $teacherUserId, string $date): array
    {
        $dateObj = new DateTime($date, $this->timezone);
        $dayOfWeek = (int)$dateObj->format('N'); // 1=Mo, 7=So

        // 1. Hole alle Fenster für diesen Wochentag
        $sqlAvail = "SELECT * FROM teacher_availability 
                     WHERE teacher_user_id = :teacher_user_id AND day_of_week = :day_of_week";
        $stmtAvail = $this->pdo->prepare($sqlAvail);
        $stmtAvail->execute([':teacher_user_id' => $teacherUserId, ':day_of_week' => $dayOfWeek]);
        $availabilities = $stmtAvail->fetchAll(PDO::FETCH_ASSOC);

        if (empty($availabilities)) {
            return []; // Lehrer bietet an diesem Wochentag keine Sprechzeiten an
        }

        // 2. Hole alle bereits gebuchten Termine für diesen Tag
        $sqlBooked = "SELECT appointment_time FROM appointments 
                      WHERE teacher_user_id = :teacher_user_id AND appointment_date = :date AND status = 'booked'";
        $stmtBooked = $this->pdo->prepare($sqlBooked);
        $stmtBooked->execute([':teacher_user_id' => $teacherUserId, ':date' => $date]);
        $bookedTimes = $stmtBooked->fetchAll(PDO::FETCH_COLUMN, 0);
        $bookedSlots = array_flip($bookedTimes); // Macht Zeiten zu Schlüsseln für schnelle Suche

        $availableSlots = [];

        // 3. Generiere Slots aus den Fenstern und filtere gebuchte heraus
        foreach ($availabilities as $window) {
            $start = new DateTime($date . ' ' . $window['start_time'], $this->timezone);
            $end = new DateTime($date . ' ' . $window['end_time'], $this->timezone);
            $duration = $window['slot_duration'];
            $interval = new DateInterval("PT{$duration}M");
            $period = new DatePeriod($start, $interval, $end);

            foreach ($period as $slotStart) {
                $timeString = $slotStart->format('H:i:s'); // z.B. 14:00:00
                $timeStringShort = $slotStart->format('H:i'); // z.B. 14:00

                // Prüfe, ob der Slot bereits gebucht ist
                if (!isset($bookedSlots[$timeString])) {
                    $availableSlots[] = [
                        'time' => $timeString, // Volle Zeit für die Buchung
                        'display' => $timeStringShort, // Angezeigte Zeit
                        'duration' => $duration
                    ];
                }
            }
        }

        return $availableSlots;
    }

    /**
     * Bucht einen Termin für einen Schüler.
     * @param int $studentUserId
     * @param int $teacherUserId
     * @param string $date (Y-m-d)
     * @param string $time (HH:MM:SS)
     * @param int $duration
     * @param string|null $notes
     * @return int ID des neuen Termins
     * @throws Exception
     */
    public function bookAppointment(int $studentUserId, int $teacherUserId, string $date, string $time, int $duration, ?string $notes): int
    {
        // Atomare Operation: INSERT versuchen. Wenn der unique_appointment_slot fehlschlägt,
        // (weil jemand anderes schneller war), wird eine PDOException ausgelöst.
        $sql = "INSERT INTO appointments (student_user_id, teacher_user_id, appointment_date, appointment_time, duration, notes, status)
                VALUES (:student_user_id, :teacher_user_id, :date, :time, :duration, :notes, 'booked')";
        
        try {
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute([
                ':student_user_id' => $studentUserId,
                ':teacher_user_id' => $teacherUserId,
                ':date' => $date,
                ':time' => $time,
                ':duration' => $duration,
                ':notes' => $notes
            ]);
            return (int)$this->pdo->lastInsertId();

        } catch (\PDOException $e) {
            if ($e->errorInfo[1] == 1062) { // 1062 = Duplicate entry
                throw new Exception("Dieser Termin wurde gerade von jemand anderem gebucht. Bitte wählen Sie einen anderen Slot.", 409);
            } else {
                error_log("Fehler bei Terminbuchung: " . $e->getMessage());
                throw new Exception("Ein Fehler ist bei der Buchung aufgetreten.", 500);
            }
        }
    }
    
    // --- Termine abrufen (für "Mein Tag") ---

    /**
     * Holt alle gebuchten Termine eines Schülers in einem Datumsbereich.
     * @param int $studentUserId
     * @param string $startDate (Y-m-d)
     * @param string $endDate (Y-m-d)
     * @return array
     */
    public function getAppointmentsForStudent(int $studentUserId, string $startDate, string $endDate): array
    {
        $sql = "SELECT a.*, CONCAT(t.first_name, ' ', t.last_name) as teacher_name, t.teacher_shortcut
                FROM appointments a
                JOIN users u ON a.teacher_user_id = u.user_id
                JOIN teachers t ON u.teacher_id = t.teacher_id
                WHERE a.student_user_id = :student_user_id
                  AND a.status = 'booked'
                  AND a.appointment_date BETWEEN :start_date AND :end_date
                ORDER BY a.appointment_date, a.appointment_time";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':student_user_id' => $studentUserId,
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Holt alle gebuchten Termine eines Lehrers in einem Datumsbereich.
     * @param int $teacherUserId
     * @param string $startDate (Y-m-d)
     * @param string $endDate (Y-m-d)
     * @return array
     */
    public function getAppointmentsForTeacher(int $teacherUserId, string $startDate, string $endDate): array
    {
        $sql = "SELECT a.*, CONCAT(u.first_name, ' ', u.last_name) as student_name, c.class_name
                FROM appointments a
                JOIN users u ON a.student_user_id = u.user_id
                LEFT JOIN classes c ON u.class_id = c.class_id
                WHERE a.teacher_user_id = :teacher_user_id
                  AND a.status = 'booked'
                  AND a.appointment_date BETWEEN :start_date AND :end_date
                ORDER BY a.appointment_date, a.appointment_time";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':teacher_user_id' => $teacherUserId,
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    /**
     * Storniert einen Termin (durch Schüler oder Lehrer).
     * @param int $appointmentId
     * @param int $userId (Der stornierende Benutzer)
     * @param string $role (Die Rolle des stornierenden Benutzers)
     * @return bool
     * @throws Exception
     */
    public function cancelAppointment(int $appointmentId, int $userId, string $role): bool
    {
        $sql = "UPDATE appointments SET status = :status 
                WHERE appointment_id = :appointment_id AND ";

        if ($role === 'schueler') {
            $sql .= "student_user_id = :user_id";
            $newStatus = 'cancelled_by_student';
        } elseif ($role === 'lehrer') {
            $sql .= "teacher_user_id = :user_id";
            $newStatus = 'cancelled_by_teacher';
        } else {
            throw new Exception("Nur Schüler oder Lehrer können Termine stornieren.", 403);
        }

        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([
            ':status' => $newStatus,
            ':appointment_id' => $appointmentId,
            ':user_id' => $userId
        ]);
        
        if ($stmt->rowCount() === 0) {
            throw new Exception("Termin nicht gefunden oder keine Berechtigung zum Stornieren.", 404);
        }
        
        return $success;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AppointmentRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AttendanceRepository.php ---
<?php
// app/Repositories/AttendanceRepository.php

namespace App\Repositories;

use PDO;
use Exception;
use PDOException;

class AttendanceRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Speichert oder aktualisiert einen Batch von Anwesenheitsdaten.
     *
     * @param int $teacherUserId Der Lehrer, der die Daten speichert
     * @param int $classId
     * @param string $date (Y-m-d)
     * @param int $periodNumber
     * @param array $studentsStatus Array von ['student_id' => X, 'status' => '...']
     * @return bool
     * @throws Exception
     */
    public function saveAttendance(int $teacherUserId, int $classId, string $date, int $periodNumber, array $studentsStatus): bool
    {
        // SQL mit ON DUPLICATE KEY UPDATE, um Atomarität zu gewährleisten
        $sql = "INSERT INTO attendance_logs (date, period_number, class_id, student_user_id, teacher_user_id, status)
                VALUES (:date, :period_number, :class_id, :student_user_id, :teacher_user_id, :status)
                ON DUPLICATE KEY UPDATE 
                    teacher_user_id = VALUES(teacher_user_id), 
                    status = VALUES(status)";
        
        try {
            $this->pdo->beginTransaction();
            $stmt = $this->pdo->prepare($sql);

            foreach ($studentsStatus as $student) {
                if (!isset($student['student_id']) || !isset($student['status'])) {
                    throw new Exception("Ungültige Studentendaten im Batch.");
                }
                
                $stmt->execute([
                    ':date' => $date,
                    ':period_number' => $periodNumber,
                    ':class_id' => $classId,
                    ':student_user_id' => $student['student_id'],
                    ':teacher_user_id' => $teacherUserId,
                    ':status' => $student['status']
                ]);
            }
            
            return $this->pdo->commit();

        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("Fehler beim Speichern der Anwesenheit: " . $e->getMessage());
            throw new Exception("Fehler beim Speichern der Anwesenheit: " . $e->getMessage());
        }
    }

    /**
     * Ruft die bereits erfasste Anwesenheit für eine bestimmte Stunde ab.
     *
     * @param int $classId
     * @param string $date
     * @param int $periodNumber
     * @return array Assoziatives Array [student_user_id => status]
     */
    public function getAttendance(int $classId, string $date, int $periodNumber): array
    {
        $sql = "SELECT student_user_id, status 
                FROM attendance_logs
                WHERE class_id = :class_id 
                  AND date = :date 
                  AND period_number = :period_number";
                  
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':class_id' => $classId,
            ':date' => $date,
            ':period_number' => $periodNumber
        ]);
        
        // Gibt ein Array zurück, z.B. [15 => 'anwesend', 16 => 'abwesend']
        return $stmt->fetchAll(PDO::FETCH_KEY_PAIR) ?: [];
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AttendanceRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AuditLogRepository.php ---
<?php
// app/Repositories/AuditLogRepository.php
namespace App\Repositories;
use PDO;

class AuditLogRepository
{
    private PDO $pdo;
    public function __construct(PDO $pdo) { $this->pdo = $pdo; }

    /**
     * Holt eine paginierte Liste von Logs, optional gefiltert.
     * NEU: Limit kann übergeben werden, Standard 20
     * @param int $page
     * @param int $limit
     * @param array $filters
     * @return array
     */
    public function getLogs(int $page = 1, int $limit = 20, array $filters = []): array
    {
        $offset = ($page - 1) * $limit;

        // Basis-SQL mit JOIN, um Benutzerinformationen abzurufen
        $sql = "SELECT l.*, u.username, u.first_name, u.last_name
                FROM audit_logs l
                LEFT JOIN users u ON l.user_id = u.user_id";

        list($whereClause, $params) = $this->buildWhereClause($filters);
        $sql .= $whereClause;

        // Verwende den korrekten Spaltennamen 'timestamp'
        $sql .= " ORDER BY l.timestamp DESC";
        $sql .= " LIMIT :limit OFFSET :offset";

        $stmt = $this->pdo->prepare($sql);

        // Füge Paginierungs-Parameter hinzu
        $params[':limit'] = $limit;
        $params[':offset'] = $offset;

        // Binde alle Parameter (Filter + Paginierung)
        $this->bindValues($stmt, $params);

        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Zählt die Gesamtanzahl der Logs für die Filter.
     *
     * @param array $filters
     * @return int
     */
    public function getLogsCount(array $filters = []): int
    {
        $sql = "SELECT COUNT(*) FROM audit_logs l"; // Alias 'l' ist wichtig
        list($whereClause, $params) = $this->buildWhereClause($filters);
        $sql .= $whereClause;

        $stmt = $this->pdo->prepare($sql);

        // Binde nur die Filter-Parameter
        $this->bindValues($stmt, $params);

        $stmt->execute();
        return (int)$stmt->fetchColumn();
    }

    /**
     * Baut die WHERE-Klausel und Parameter für die Log-Abfragen.
     *
     * @param array $filters
     * @return array [string $whereClause, array $params]
     */
    private function buildWhereClause(array $filters): array
    {
        $where = [];
        $params = [];

        if (!empty($filters['user_id'])) {
            $where[] = "l.user_id = :user_id"; // 'l.' alias ist wichtig
            $params[':user_id'] = $filters['user_id'];
        }
        if (!empty($filters['action'])) {
            $where[] = "l.action LIKE :action";
            $params[':action'] = '%' . $filters['action'] . '%';
        }
        if (!empty($filters['target_type'])) {
            $where[] = "l.target_type = :target_type";
            $params[':target_type'] = $filters['target_type'];
        }
        if (!empty($filters['start_date'])) {
            // Verwende den korrekten Spaltennamen 'timestamp'
            $where[] = "l.timestamp >= :start_date";
            $params[':start_date'] = $filters['start_date'];
        }
        if (!empty($filters['end_date'])) {
            // Um das gesamte Enddatum einzuschließen (bis 23:59:59)
            // Verwende den korrekten Spaltennamen 'timestamp'
            $where[] = "l.timestamp <= :end_date";
            $params[':end_date'] = $filters['end_date'] . ' 23:59:59';
        }

        $whereClause = !empty($where) ? ' WHERE ' . implode(' AND ', $where) : '';

        return [$whereClause, $params];
    }

    /**
     * Hilfsfunktion zum korrekten Binden von Werten an ein PDO-Statement.
     * Behandelt INT- und STR-Typen.
     *
     * @param \PDOStatement $stmt
     * @param array $params
     */
    private function bindValues(\PDOStatement $stmt, array $params): void
    {
        foreach ($params as $key => $val) {
            // Bestimme den Typ für bindValue
            if ($key === ':limit' || $key === ':offset' || $key === ':user_id') {
                $stmt->bindValue($key, $val, PDO::PARAM_INT);
            } else {
                $stmt->bindValue($key, $val, PDO::PARAM_STR);
            }
        }
    }

    /**
     * Holt alle eindeutigen Aktions-Typen aus dem Log.
     *
     * @return array
     */
    public function getDistinctActions(): array
    {
        $sql = "SELECT DISTINCT action FROM audit_logs WHERE action IS NOT NULL AND action != '' ORDER BY action ASC";
        $stmt = $this->pdo->query($sql);
        return $stmt->fetchAll(PDO::FETCH_COLUMN);
    }

    /**
     * Holt alle eindeutigen Ziel-Typen aus dem Log.
     *
     * @return array
     */
    public function getDistinctTargetTypes(): array
    {
        $sql = "SELECT DISTINCT target_type FROM audit_logs WHERE target_type IS NOT NULL AND target_type != '' ORDER BY target_type ASC";
        $stmt = $this->pdo->query($sql);
        return $stmt->fetchAll(PDO::FETCH_COLUMN);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AuditLogRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\CommunityPostRepository.php ---
<?php
// app/Repositories/CommunityPostRepository.php

namespace App\Repositories;

use PDO;
use Exception;

class CommunityPostRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Erstellt einen neuen Beitrag.
     * @param int $userId
     * @param string $title
     * @param string $content
     * @param string $initialStatus (z.B. 'pending' oder 'approved')
     * @return int
     * @throws Exception
     */
    public function createPost(int $userId, string $title, string $content, string $initialStatus = 'pending'): int
    {
        $sql = "INSERT INTO community_posts (user_id, title, content, status, created_at)
                VALUES (:user_id, :title, :content, :status, NOW())";
        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([
            ':user_id' => $userId,
            ':title' => $title,
            ':content' => $content,
            ':status' => $initialStatus
        ]);

        if (!$success) {
            throw new Exception("Beitrag konnte nicht erstellt werden.");
        }
        return (int)$this->pdo->lastInsertId();
    }

    /**
     * NEU: Aktualisiert einen bestehenden Beitrag.
     * @param int $postId
     * @param int $userId (Zur Verifizierung der Inhaberschaft)
     * @param string $title
     * @param string $content
     * @param string $newStatus (z.B. 'pending' nach Bearbeitung)
     * @return bool
     */
    public function updatePost(int $postId, int $userId, string $title, string $content, string $newStatus): bool
    {
        $sql = "UPDATE community_posts SET
                    title = :title,
                    content = :content,
                    status = :status,
                    moderated_at = NULL,
                    moderator_id = NULL
                WHERE post_id = :post_id AND user_id = :user_id";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':title' => $title,
            ':content' => $content,
            ':status' => $newStatus,
            ':post_id' => $postId,
            ':user_id' => $userId
        ]);
        
        return $stmt->rowCount() > 0;
    }


    /**
     * Holt Beiträge basierend auf dem Status, sortiert von neu nach alt.
     * @param string $status ('approved', 'pending', 'rejected')
     * @param int $limit
     * @return array
     */
    public function getPostsByStatus(string $status, int $limit = 50): array
    {
        // Hole Posts inklusive Ersteller-Infos
        $sql = "SELECT p.*, u.username, u.first_name, u.last_name
                FROM community_posts p
                JOIN users u ON p.user_id = u.user_id
                WHERE p.status = :status
                ORDER BY p.created_at DESC
                LIMIT :limit";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindParam(':status', $status, PDO::PARAM_STR);
        $stmt->bindParam(':limit', $limit, PDO::PARAM_INT);
        $stmt->execute();
        
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    /**
     * NEU: Holt alle Beiträge eines bestimmten Benutzers.
     * @param int $userId
     * @return array
     */
    public function getPostsByUserId(int $userId): array
    {
        // Holt Posts ohne Ersteller-Infos (da es der eigene Benutzer ist)
        // Sortiert, sodass 'pending' oben steht, dann nach Datum
        $sql = "SELECT *
                FROM community_posts
                WHERE user_id = :user_id
                ORDER BY
                    CASE status
                        WHEN 'pending' THEN 1
                        WHEN 'approved' THEN 2
                        WHEN 'rejected' THEN 3
                        ELSE 4
                    END,
                    created_at DESC";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':user_id' => $userId]);
        
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    
    /**
     * NEU: Holt freigegebene Beiträge INKLUSIVE E-Mail des Autors.
     * @param int $limit
     * @return array
     */
    public function getApprovedPostsWithAuthorEmail(int $limit = 50): array
    {
        $sql = "SELECT p.*, u.username, u.first_name, u.last_name, u.email
                FROM community_posts p
                JOIN users u ON p.user_id = u.user_id
                WHERE p.status = 'approved'
                ORDER BY p.created_at DESC
                LIMIT :limit";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindParam(':limit', $limit, PDO::PARAM_INT);
        $stmt->execute();
        
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }


    /**
     * Holt einen einzelnen Post anhand der ID.
     * @param int $postId
     * @return array|false
     */
    public function getPostById(int $postId)
    {
        $sql = "SELECT * FROM community_posts WHERE post_id = :post_id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':post_id' => $postId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    /**
     * Aktualisiert den Status eines Beitrags.
     * @param int $postId
     * @param string $newStatus ('approved', 'rejected')
     * @param int $moderatorUserId
     * @return bool
     */
    public function updatePostStatus(int $postId, string $newStatus, int $moderatorUserId): bool
    {
        if (!in_array($newStatus, ['approved', 'rejected'])) {
            return false; // Ungültiger Status
        }

        $sql = "UPDATE community_posts SET
                    status = :status,
                    moderator_id = :moderator_id,
                    moderated_at = NOW()
                WHERE post_id = :post_id";
        
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':status' => $newStatus,
            ':moderator_id' => $moderatorUserId,
            ':post_id' => $postId
        ]);
    }

    /**
     * Löscht einen Beitrag (alternativ zu 'rejected').
     * @param int $postId
     * @return bool
     */
    public function deletePost(int $postId): bool
    {
        $sql = "DELETE FROM community_posts WHERE post_id = :post_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':post_id' => $postId]);
    }
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\CommunityPostRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\LoginAttemptRepository.php ---
<?php
// app/Repositories/LoginAttemptRepository.php
namespace App\Repositories;

use App\Core\Utils; // NEU: Utils importieren
use PDO;

class LoginAttemptRepository
{
    private PDO $pdo;
    // VERALTET: Konstanten werden durch Einstellungen ersetzt
    // private const MAX_ATTEMPTS = 5;
    // private const LOCKOUT_MINUTES = 15;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Prüft, ob ein Login-Versuch für den gegebenen Identifier erlaubt ist.
     * Gibt `false` zurück, wenn die maximale Anzahl an Versuchen im Lockout-Zeitraum überschritten wurde.
     */
    public function isAllowed(string $identifier): bool
    {
        // NEU: Hole Werte aus den Einstellungen
        $settings = Utils::getSettings();
        $maxAttempts = $settings['max_login_attempts'];
        $lockoutMinutes = $settings['lockout_minutes'];

        $sql = "SELECT COUNT(*) FROM login_attempts
                WHERE identifier = :identifier
                AND attempt_time > (NOW() - INTERVAL :lockout MINUTE)";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':identifier' => $identifier,
            ':lockout' => $lockoutMinutes // Verwende den Wert aus den Einstellungen
        ]);

        $attempts = (int)$stmt->fetchColumn();

        return $attempts < $maxAttempts; // Vergleiche mit dem Wert aus den Einstellungen
    }

    /**
     * Speichert einen fehlgeschlagenen Login-Versuch in der Datenbank.
     */
    public function recordFailure(string $identifier): void
    {
        $sql = "INSERT INTO login_attempts (identifier, ip_address, attempt_time)
                VALUES (:identifier, :ip_address, NOW())";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':identifier' => $identifier,
            ':ip_address' => $_SERVER['REMOTE_ADDR'] ?? 'UNKNOWN'
        ]);
    }

    /**
     * Löscht alle Login-Versuche für einen Identifier nach einem erfolgreichen Login.
     */
    public function clearAttempts(string $identifier): void
    {
        $sql = "DELETE FROM login_attempts WHERE identifier = :identifier";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':identifier' => $identifier]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\LoginAttemptRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\PlanRepository.php ---
<?php
// app/Repositories/PlanRepository.php
namespace App\Repositories;

use PDO;
use Exception;
use DateTime;
use DateTimeZone; // Added explicit use
use PDOException; // Added for specific exception handling
use App\Repositories\TeacherAbsenceRepository; // NEU: Import

class PlanRepository
{
    private PDO $pdo;
    private TeacherAbsenceRepository $absenceRepo; // NEU: Property

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
        $this->absenceRepo = new TeacherAbsenceRepository($pdo); // NEU: Instanziieren
    }

    /**
     * Hilfsfunktion, um Start- und Enddatum einer Kalenderwoche zu ermitteln.
     * @param int $year ISO Year
     * @param int $week ISO Week
     * @return array ['Y-m-d', 'Y-m-d']
     */
    private function getWeekDateRange(int $year, int $week): array
    {
        // Use DateTime for ISO week date calculations
        $dto = new DateTime();
        $dto->setISODate($year, $week, 1); // Set to Monday of the week
        $startDate = $dto->format('Y-m-d');
        $dto->setISODate($year, $week, 5); // Set to Friday of the week
        $endDate = $dto->format('Y-m-d');
        return [$startDate, $endDate];
    }

    // --- Methoden für den öffentlichen Dashboard-Zugriff (Schüler/Lehrer) ---

    /**
     * Holt den regulären Stundenplan für eine Klasse, ABER NUR WENN veröffentlicht.
     * @param int $classId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getPublishedTimetableForClass(int $classId, int $year, int $calendarWeek): array
    {
        // Prüfe zuerst, ob die Woche veröffentlicht ist
        if (!$this->isWeekPublishedFor('student', $year, $calendarWeek)) {
            return []; // Leeres Array, wenn nicht veröffentlicht
        }
        // Use the AsPlaner method as the underlying data is the same
        return $this->getTimetableForClassAsPlaner($classId, $year, $calendarWeek);
    }

    /**
     * Holt den regulären Stundenplan für einen Lehrer, ABER NUR WENN veröffentlicht.
     * @param int $teacherId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getPublishedTimetableForTeacher(int $teacherId, int $year, int $calendarWeek): array
    {
        // Prüfe zuerst, ob die Woche veröffentlicht ist
        if (!$this->isWeekPublishedFor('teacher', $year, $calendarWeek)) {
            return []; // Leeres Array, wenn nicht veröffentlicht
        }
        // Use the AsPlaner method as the underlying data is the same
        return $this->getTimetableForTeacherAsPlaner($teacherId, $year, $calendarWeek);
    }

    /**
     * Holt alle Vertretungen für eine Klasse in einer Woche, ABER NUR WENN veröffentlicht.
     * @param int $classId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getPublishedSubstitutionsForClassWeek(int $classId, int $year, int $calendarWeek): array
    {
        if (!$this->isWeekPublishedFor('student', $year, $calendarWeek)) {
            return [];
        }
        // Use the AsPlaner method as the underlying data is the same
        return $this->getSubstitutionsForClassWeekAsPlaner($classId, $year, $calendarWeek);
    }

    /**
     * Holt alle Vertretungen für einen Lehrer in einer Woche, ABER NUR WENN veröffentlicht.
     * @param int $teacherId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getPublishedSubstitutionsForTeacherWeek(int $teacherId, int $year, int $calendarWeek): array
    {
        if (!$this->isWeekPublishedFor('teacher', $year, $calendarWeek)) {
            return [];
        }
        // Use the AsPlaner method as the underlying data is the same
        return $this->getSubstitutionsForTeacherWeekAsPlaner($teacherId, $year, $calendarWeek);
    }

    // --- Methoden für den Planer-Zugriff ---

    /**
     * Holt den regulären Stundenplan für eine Klasse (für Planer/Admin).
     * @param int $classId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getTimetableForClassAsPlaner(int $classId, int $year, int $calendarWeek): array
    {
        $sql = "SELECT te.*, s.subject_shortcut, s.subject_name, t.teacher_shortcut, r.room_name, c.class_name
                FROM timetable_entries te
                LEFT JOIN subjects s ON te.subject_id = s.subject_id
                LEFT JOIN teachers t ON te.teacher_id = t.teacher_id
                LEFT JOIN rooms r ON te.room_id = r.room_id
                LEFT JOIN classes c ON te.class_id = c.class_id
                WHERE te.class_id = :class_id
                    AND te.year = :year
                    AND te.calendar_week = :calendar_week
                ORDER BY te.day_of_week ASC, te.period_number ASC, te.entry_id ASC"; // KORRIGIERT: Sortiere nach entry_id für parallele
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':class_id' => $classId, ':year' => $year, ':calendar_week' => $calendarWeek]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Holt den regulären Stundenplan für einen Lehrer (für Planer/Admin).
     * @param int $teacherId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getTimetableForTeacherAsPlaner(int $teacherId, int $year, int $calendarWeek): array
    {
        $sql = "SELECT te.*, s.subject_shortcut, s.subject_name, c.class_name, r.room_name, t.teacher_shortcut
                FROM timetable_entries te
                LEFT JOIN subjects s ON te.subject_id = s.subject_id
                LEFT JOIN classes c ON te.class_id = c.class_id
                LEFT JOIN rooms r ON te.room_id = r.room_id
                JOIN teachers t ON te.teacher_id = t.teacher_id
                WHERE te.teacher_id = :teacher_id
                    AND te.year = :year
                    AND te.calendar_week = :calendar_week
                ORDER BY te.day_of_week ASC, te.period_number ASC, te.entry_id ASC"; // KORRIGIERT: Sortiere nach entry_id für parallele
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':teacher_id' => $teacherId, ':year' => $year, ':calendar_week' => $calendarWeek]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Holt alle Vertretungen für eine Klasse in einer Woche (für Planer/Admin).
     * @param int $classId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getSubstitutionsForClassWeekAsPlaner(int $classId, int $year, int $calendarWeek): array
    {
        return $this->getSubstitutionsForWeekInternal($year, $calendarWeek, $classId, null);
    }

    /**
     * Holt alle Vertretungen für einen Lehrer in einer Woche (für Planer/Admin).
     * @param int $teacherId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getSubstitutionsForTeacherWeekAsPlaner(int $teacherId, int $year, int $calendarWeek): array
    {
        return $this->getSubstitutionsForWeekInternal($year, $calendarWeek, null, $teacherId);
    }

    /**
     * Interne Methode zum Abrufen von Vertretungen für eine Woche, gefiltert nach Klasse oder Lehrer.
     * @param int $year
     * @param int $calendarWeek
     * @param int|null $classId
     * @param int|null $teacherId
     * @return array
     */
    private function getSubstitutionsForWeekInternal(int $year, int $calendarWeek, ?int $classId, ?int $teacherId): array
    {
        [$startDate, $endDate] = $this->getWeekDateRange($year, $calendarWeek);

        // Calculate day_of_week (1=Mon, 5=Fri) using SQL DAYOFWEEK (Sunday=1, Monday=2...). Exclude weekends.
        $sql = "SELECT
                                s.*,
                                DAYOFWEEK(s.date) as day_of_week_iso, /* MySQL Sunday=1, keep for reference */
                                CASE DAYOFWEEK(s.date) WHEN 1 THEN NULL WHEN 7 THEN NULL ELSE DAYOFWEEK(s.date) - 1 END as day_of_week, /* Calculate day_of_week (1=Mon, 5=Fri) */
                                orig_s.subject_shortcut as original_subject_shortcut,
                                new_t.teacher_shortcut as new_teacher_shortcut,
                                new_s.subject_shortcut as new_subject_shortcut,
                                new_r.room_name as new_room_name,
                                c.class_name
                            FROM substitutions s
                            JOIN classes c ON s.class_id = c.class_id
                            LEFT JOIN subjects orig_s ON s.original_subject_id = orig_s.subject_id
                            LEFT JOIN teachers new_t ON s.new_teacher_id = new_t.teacher_id
                            LEFT JOIN subjects new_s ON s.new_subject_id = new_s.subject_id
                            LEFT JOIN rooms new_r ON s.new_room_id = new_r.room_id
                            WHERE s.date BETWEEN :start_date AND :end_date";

        $params = [':start_date' => $startDate, ':end_date' => $endDate];

        if ($classId !== null) {
            $sql .= " AND s.class_id = :class_id";
            $params[':class_id'] = $classId;
        } elseif ($teacherId !== null) {
            // Check if the teacher is the new teacher OR was the original teacher of the replaced lesson
            $sql .= " AND (s.new_teacher_id = :teacher_id OR EXISTS (
                                SELECT 1 FROM timetable_entries te
                                WHERE te.class_id = s.class_id
                                    AND te.year = :year
                                    AND te.calendar_week = :calendar_week
                                    AND te.day_of_week = (CASE DAYOFWEEK(s.date) WHEN 1 THEN NULL WHEN 7 THEN NULL ELSE DAYOFWEEK(s.date) - 1 END)
                                    AND te.period_number = s.period_number
                                    AND te.teacher_id = :teacher_id
                            ))";
            $params[':teacher_id'] = $teacherId;
            $params[':year'] = $year; // Add year and week for subquery
            $params[':calendar_week'] = $calendarWeek;
        }

        $sql .= " ORDER BY s.date ASC, s.period_number ASC";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($params);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    // --- Methoden zum Verwalten des Veröffentlichungsstatus ---

    /**
     * Veröffentlicht den Plan für eine Woche und Zielgruppe.
     * @param int $year
     * @param int $calendarWeek
     * @param string $targetGroup 'student' or 'teacher'
     * @param int $userId ID des veröffentlichenden Benutzers
     * @return bool Erfolg
     */
    public function publishWeek(int $year, int $calendarWeek, string $targetGroup, int $userId): bool
    {
        $sql = "INSERT INTO timetable_publish_status (year, calendar_week, target_group, published_at, publisher_user_id)
                VALUES (:year, :calendar_week, :target_group, NOW(), :user_id)
                ON DUPLICATE KEY UPDATE published_at = NOW(), publisher_user_id = VALUES(publisher_user_id)"; // Update timestamp and publisher
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':target_group' => $targetGroup,
            ':user_id' => $userId
        ]);
    }

    /**
     * Nimmt die Veröffentlichung für eine Woche und Zielgruppe zurück.
     * @param int $year
     * @param int $calendarWeek
     * @param string $targetGroup 'student' or 'teacher'
     * @return bool Erfolg
     */
    public function unpublishWeek(int $year, int $calendarWeek, string $targetGroup): bool
    {
        $sql = "DELETE FROM timetable_publish_status
                WHERE year = :year AND calendar_week = :calendar_week AND target_group = :target_group";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':target_group' => $targetGroup
        ]);
    }

    /**
     * Holt den Veröffentlichungsstatus für eine Woche.
     * @param int $year
     * @param int $calendarWeek
     * @return array ['student' => bool, 'teacher' => bool]
     */
    public function getPublishStatus(int $year, int $calendarWeek): array
    {
        $sql = "SELECT target_group FROM timetable_publish_status
                WHERE year = :year AND calendar_week = :calendar_week";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':year' => $year, ':calendar_week' => $calendarWeek]);
        $results = $stmt->fetchAll(PDO::FETCH_COLUMN);
        // Ensure both keys always exist
        return ['student' => in_array('student', $results), 'teacher' => in_array('teacher', $results)];
    }


    /**
     * Interne Hilfsfunktion zum Prüfen des Status für eine Zielgruppe.
     * @param string $targetGroup 'student' or 'teacher'
     * @param int $year
     * @param int $calendarWeek
     * @return bool True if published, False otherwise.
     */
    public function isWeekPublishedFor(string $targetGroup, int $year, int $calendarWeek): bool
    {
        $sql = "SELECT 1 FROM timetable_publish_status
                WHERE year = :year AND calendar_week = :calendar_week AND target_group = :target_group LIMIT 1";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':target_group' => $targetGroup
        ]);
        return $stmt->fetchColumn() !== false;
    }


    // --- Methoden zum Bearbeiten von Daten ---

    /**
     * Löscht einen einzelnen Stundenplaneintrag.
     * @param int $entryId
     * @return bool Erfolg
     */
    public function deleteEntry(int $entryId): bool
    {
        $sql = "DELETE FROM timetable_entries WHERE entry_id = :entry_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':entry_id' => $entryId]);
    }

    /**
     * Löscht alle Einträge, die zu einem Block gehören.
     * @param string $blockId
     * @return bool Erfolg
     */
    public function deleteEntryBlock(string $blockId): bool
    {
        $sql = "DELETE FROM timetable_entries WHERE block_id = :block_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':block_id' => $blockId]);
    }

    /**
     * Erstellt oder aktualisiert einen Stundenplaneintrag (oder Block).
     * @param array $data Daten aus dem Formular/API-Call.
     * @return array Informationen über den erstellten/aktualisierten Eintrag (z.B. block_id).
     * @throws Exception
     */
    public function createOrUpdateEntry(array $data): array
    {
        // Validate required fields
        $required = ['year', 'calendar_week', 'day_of_week', 'teacher_id', 'subject_id', 'room_id'];
        foreach ($required as $field) {
            // Check if required fields potentially holding ID '0' are missing or truly empty strings
            // IDs should usually start from 1. If '0' is not valid, add $data[$field] === 0 check.
            if (!isset($data[$field]) || $data[$field] === '') {
                throw new Exception("Fehlende Daten: Feld '{$field}' ist erforderlich und darf nicht leer sein.");
            }
        }
        
        // class_id '0' or null IS allowed for teacher-mode entries
        if (!isset($data['class_id'])) {
             throw new Exception("Fehlende Daten: Feld 'class_id' ist erforderlich.");
        }


        // Sanitize comment
        $comment = isset($data['comment']) ? trim($data['comment']) : null;
        if ($comment === '') {
            $comment = null; // Store NULL instead of empty string
        }

        $startPeriod = (int)($data['start_period_number'] ?? $data['period_number'] ?? 0);
        $endPeriod = (int)($data['end_period_number'] ?? $data['period_number'] ?? 0);
        
        // Add start/end period back to data array for checkConflicts
        $data['start_period_number'] = $startPeriod;
        $data['end_period_number'] = $endPeriod;


        if ($startPeriod <= 0 || $endPeriod <= 0 || $startPeriod > $endPeriod) {
            throw new Exception("Ungültiger Stundenbereich (Start/Ende > 0 und Start <= Ende erforderlich).");
        }
        
        // *** NEW: Check Conflicts BEFORE transaction ***
        $excludeEntryId = !empty($data['entry_id']) ? (int)$data['entry_id'] : null;
        $excludeBlockId = !empty($data['block_id']) ? (string)$data['block_id'] : null;
        
        // Note: checkConflicts will now throw an Exception if conflicts are found
        $this->checkConflicts($data, $excludeEntryId, $excludeBlockId);
        // *** END NEW CONFLICT CHECK ***


        // --- Transaction ---
        $this->pdo->beginTransaction();
        try {
            
            // *** KORREKTUR: Lösche NUR, wenn eine ID (für ein Update/Verschieben) übergeben wurde ***
            if (!empty($data['entry_id']) && filter_var($data['entry_id'], FILTER_VALIDATE_INT)) {
                $deleteSql = "DELETE FROM timetable_entries WHERE entry_id = :entry_id";
                $deleteParams = [':entry_id' => $data['entry_id']];
                $deleteStmt = $this->pdo->prepare($deleteSql);
                $deleteStmt->execute($deleteParams);
            } elseif (!empty($data['block_id'])) {
                $deleteSql = "DELETE FROM timetable_entries WHERE block_id = :block_id";
                $deleteParams = [':block_id' => $data['block_id']];
                $deleteStmt = $this->pdo->prepare($deleteSql);
                $deleteStmt->execute($deleteParams);
            }
            // *** DER 'ELSE'-BLOCK (LÖSCHEN NACH ZELLE) WURDE HIER ENTFERNT ***
            // *** DIES ERLAUBT NUN PARALLELE EINTRÄGE ***


            // Generate block_id only if it's a multi-period entry
            $blockId = ($startPeriod !== $endPeriod) ? uniqid('block_', true) : null;

            $insertSql = "INSERT INTO timetable_entries (year, calendar_week, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_id, comment)
                            VALUES (:year, :calendar_week, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_id, :comment)";

            $insertStmt = $this->pdo->prepare($insertSql);

            $insertedIds = []; // To potentially return IDs if needed
            for ($period = $startPeriod; $period <= $endPeriod; $period++) {
                $params = [
                    ':year' => $data['year'],
                    ':calendar_week' => $data['calendar_week'],
                    ':day_of_week' => $data['day_of_week'],
                    ':period_number' => $period,
                    ':class_id' => $data['class_id'], // Can be '0' for teacher mode
                    ':teacher_id' => $data['teacher_id'],
                    ':subject_id' => $data['subject_id'],
                    ':room_id' => $data['room_id'],
                    ':block_id' => $blockId,
                    ':comment' => $comment
                ];
                if (!$insertStmt->execute($params)) {
                    // Get detailed error info
                    $errorInfo = $insertStmt->errorInfo();
                    throw new PDOException("Fehler beim Einfügen von Stunde {$period}. SQLSTATE[{$errorInfo[0]}]: {$errorInfo[2]}");
                }
                $insertedIds[] = $this->pdo->lastInsertId(); // Store last insert ID
            }

            $this->pdo->commit();

            // Return relevant info
            return [
                'block_id' => $blockId,
                'entry_ids' => $insertedIds, // Return array of created entry IDs
                'periods' => range($startPeriod, $endPeriod)
            ];

        } catch (Exception $e) {
            $this->pdo->rollBack();
            // Log the detailed error
            error_log("PlanRepository::createOrUpdateEntry failed: " . $e->getMessage());
            // Rethrow a more generic error for the user, potentially including specifics if safe
            throw new Exception("Fehler beim Speichern des Stundenplaneintrags: " . $e->getMessage());
        }
    }


    /**
     * Erstellt oder aktualisiert eine Vertretung.
     * @param array $data Daten aus dem Formular/API-Call.
     * @return array Die Daten der erstellten/aktualisierten Vertretung inkl. ID.
     * @throws Exception
     */
    public function createOrUpdateSubstitution(array $data): array
    {
        // Validate required fields
        if (empty($data['date']) || empty($data['period_number']) || !isset($data['class_id']) || empty($data['substitution_type'])) {
            throw new Exception("Datum, Stunde, Klasse und Vertretungstyp sind Pflichtfelder.");
        }
        // Basic date validation
        if (DateTime::createFromFormat('Y-m-d', $data['date']) === false) {
            throw new Exception("Ungültiges Datumsformat. Bitte YYYY-MM-DD verwenden.");
        }
        
        // NEU: Konfliktprüfung für den NEUEN Lehrer (falls gesetzt)
        if (!empty($data['new_teacher_id'])) {
            // 1. Prüfe auf Doppelbuchung des Lehrers (regulärer Unterricht)
            $dateObj = new DateTime($data['date']);
            $conflictData = [
                'year' => (int)$dateObj->format('o'),
                'calendar_week' => (int)$dateObj->format('W'),
                'day_of_week' => (int)$dateObj->format('N'),
                'start_period_number' => $data['period_number'],
                'end_period_number' => $data['period_number'],
                'teacher_id' => $data['new_teacher_id'],
                'room_id' => null, // Wir prüfen nur den Lehrer
                'class_id' => $data['class_id'] // Die Klasse, in die er soll
            ];
            // Wir müssen die aktuelle Vertretungs-ID (falls vorhanden) von der Prüfung ausschließen
            // $excludeSubId = !empty($data['substitution_id']) ? (int)$data['substitution_id'] : null;
            // HINWEIS: checkConflicts prüft aktuell nur timetable_entries. Wir müssen Vertretungen separat prüfen.
            
            // checkConflicts wirft eine Exception, wenn ein Konflikt in timetable_entries gefunden wird
            try {
                $this->checkConflicts($conflictData, null, null);
            } catch (Exception $e) {
                // Passe die Fehlermeldung an
                if (str_contains($e->getMessage(), 'LEHRER-KONFLIKT')) {
                    throw new Exception("KONFLIKT: Dieser Lehrer hält bereits regulären Unterricht in einer anderen Klasse.", 409, $e);
                }
                throw $e; // Wirf andere Konflikte (z.B. Klasse) erneut
            }

            // 2. Prüfe auf Doppelbuchung (Vertretungen)
            $sqlCheckSub = "SELECT 1 FROM substitutions 
                            WHERE new_teacher_id = :teacher_id 
                                AND date = :date AND period_number = :period
                                AND substitution_id != :exclude_id
                            LIMIT 1";
            $stmtCheckSub = $this->pdo->prepare($sqlCheckSub);
            $stmtCheckSub->execute([
                ':teacher_id' => $data['new_teacher_id'],
                ':date' => $data['date'],
                ':period' => $data['period_number'],
                ':exclude_id' => $data['substitution_id'] ?? 0
            ]);
            if ($stmtCheckSub->fetchColumn()) {
                throw new Exception("KONFLIKT: Dieser Lehrer hält bereits eine andere Vertretung in dieser Stunde.", 409);
            }

            // 3. NEU: Prüfe auf Abwesenheit des NEUEN Lehrers
            $absence = $this->absenceRepo->checkAbsence($data['new_teacher_id'], $data['date']);
            if ($absence) {
                throw new Exception("KONFLIKT: Der Vertretungslehrer (ID {$data['new_teacher_id']}) ist an diesem Tag als '{$absence['reason']}' gemeldet.", 409);
            }
        }
        // --- ENDE NEUE KONFLIKTPRÜFUNG ---


        // Set fields to null if they are empty strings or '0' for foreign keys
        $nullableFields = ['original_subject_id', 'new_teacher_id', 'new_subject_id', 'new_room_id', 'comment'];
        foreach ($nullableFields as $field) {
            if (isset($data[$field])) {
                $value = trim($data[$field]);
                // Treat empty string or '0' as NULL for optional foreign keys, keep comment as empty string if intended
                if ($value === '' || ($value === '0' && $field !== 'comment')) {
                    $data[$field] = null;
                } else {
                    $data[$field] = $value; // Keep trimmed value otherwise
                }
            } else {
                $data[$field] = null; // Ensure key exists and is null if not provided
            }
        }


        if (!empty($data['substitution_id']) && filter_var($data['substitution_id'], FILTER_VALIDATE_INT)) {
            // Update existing substitution
            $sql = "UPDATE substitutions SET
                                date = :date,
                                period_number = :period_number,
                                class_id = :class_id,
                                substitution_type = :substitution_type,
                                original_subject_id = :original_subject_id,
                                new_teacher_id = :new_teacher_id,
                                new_subject_id = :new_subject_id,
                                new_room_id = :new_room_id,
                                comment = :comment
                            WHERE substitution_id = :substitution_id";
            $currentId = (int)$data['substitution_id'];
        } else {
            // Insert new substitution
            $sql = "INSERT INTO substitutions (date, period_number, class_id, substitution_type, original_subject_id, new_teacher_id, new_subject_id, new_room_id, comment)
                    VALUES (:date, :period_number, :class_id, :substitution_type, :original_subject_id, :new_teacher_id, :new_subject_id, :new_room_id, :comment)";
            $currentId = null; // Will get ID after insert
        }

        $stmt = $this->pdo->prepare($sql);

        $params = [
            ':date' => $data['date'],
            ':period_number' => $data['period_number'],
            ':class_id' => $data['class_id'], // Can be '0' if coming from teacher mode
            ':substitution_type' => $data['substitution_type'],
            ':original_subject_id' => $data['original_subject_id'],
            ':new_teacher_id' => $data['new_teacher_id'],
            ':new_subject_id' => $data['new_subject_id'],
            ':new_room_id' => $data['new_room_id'],
            ':comment' => $data['comment'], // Use sanitized value (can be null or trimmed string)
        ];

        if ($currentId !== null) {
            $params[':substitution_id'] = $currentId;
        }

        if (!$stmt->execute($params)) {
            $errorInfo = $stmt->errorInfo();
            error_log("Substitution save failed: SQLSTATE[{$errorInfo[0]}] {$errorInfo[2]}");
            throw new Exception("Fehler beim Speichern der Vertretung.");
        }

        if ($currentId === null) {
            $currentId = (int)$this->pdo->lastInsertId();
        }

        // Fetch the saved data to return it (including potentially looked up names/shortcuts)
        $savedData = $this->getSubstitutionById($currentId);
        if (!$savedData) {
            // Fallback if fetch fails, return input data with ID
            $data['substitution_id'] = $currentId;
            // Add calculated day_of_week for consistency
            try {
                $dateObj = new DateTime($data['date']);
                $dayOfWeek = $dateObj->format('N'); // 1 (Mon) - 7 (Sun)
                $data['day_of_week'] = ($dayOfWeek >= 1 && $dayOfWeek <= 5) ? $dayOfWeek : null;
                $data['day_of_week_iso'] = $dateObj->format('N'); // Keep ISO day if needed elsewhere
            } catch (Exception $e) {
                $data['day_of_week'] = null;
                $data['day_of_week_iso'] = null;
            }
            return $data;
        }
        return $savedData;
    }

    /**
     * Holt eine einzelne Vertretung anhand ihrer ID mit zusätzlichen Details.
     * @param int $substitutionId
     * @return array|false
     */
    public function getSubstitutionById(int $substitutionId): array|false
    {
        $sql = "SELECT
                                        s.*,
                                        DAYOFWEEK(s.date) as day_of_week_iso, /* MySQL Sunday=1 */
                                        CASE DAYOFWEEK(s.date) WHEN 1 THEN NULL WHEN 7 THEN NULL ELSE DAYOFWEEK(s.date) - 1 END as day_of_week, /* Calculate day_of_week (1=Mon, 5=Fri) */
                                        orig_s.subject_shortcut as original_subject_shortcut,
                                        new_t.teacher_shortcut as new_teacher_shortcut,
                                        new_s.subject_shortcut as new_subject_shortcut,
                                        new_r.room_name as new_room_name,
                                        c.class_name
                                    FROM substitutions s
                                    JOIN classes c ON s.class_id = c.class_id
                                    LEFT JOIN subjects orig_s ON s.original_subject_id = orig_s.subject_id
                                    LEFT JOIN teachers new_t ON s.new_teacher_id = new_t.teacher_id
                                    LEFT JOIN subjects new_s ON s.new_subject_id = new_s.subject_id
                                    LEFT JOIN rooms new_r ON s.new_room_id = new_r.room_id
                                    WHERE s.substitution_id = :id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':id' => $substitutionId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    /**
     * Löscht eine Vertretung.
     * @param int $substitutionId
     * @return bool Erfolg
     */
    public function deleteSubstitution(int $substitutionId): bool
    {
        $sql = "DELETE FROM substitutions WHERE substitution_id = :substitution_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':substitution_id' => $substitutionId]);
    }

    /**
     * Checks for conflicts (teacher or room double-booking) for a given timeslot.
     * @param array $data Contains year, calendar_week, day_of_week, start_period_number, end_period_number, teacher_id, room_id, class_id
     * @param int|null $excludeEntryId Entry ID to exclude (during updates)
     * @param string|null $excludeBlockId Block ID to exclude (during updates)
     * @return array List of conflict messages.
     * @throws Exception If conflicts are found (to be caught by API handler).
     */
    public function checkConflicts(array $data, ?int $excludeEntryId = null, ?string $excludeBlockId = null): array
    {
        $conflicts = [];
        $baseSql = "SELECT te.*, c.class_name, t.teacher_shortcut, r.room_name
                            FROM timetable_entries te
                            LEFT JOIN classes c ON te.class_id = c.class_id
                            LEFT JOIN teachers t ON te.teacher_id = t.teacher_id
                            LEFT JOIN rooms r ON te.room_id = r.room_id
                            WHERE te.year = :year
                                AND te.calendar_week = :calendar_week
                                AND te.day_of_week = :day_of_week
                                AND te.period_number >= :start_period
                                AND te.period_number <= :end_period";

        $params = [
            ':year' => $data['year'],
            ':calendar_week' => $data['calendar_week'],
            ':day_of_week' => $data['day_of_week'],
            ':start_period' => $data['start_period_number'],
            ':end_period' => $data['end_period_number'],
        ];

        // Add exclusion conditions if updating
        $exclusionSql = "";
        if ($excludeEntryId !== null) {
            $exclusionSql = " AND te.entry_id != :exclude_entry_id";
            $params[':exclude_entry_id'] = $excludeEntryId;
        } elseif ($excludeBlockId !== null) {
            $exclusionSql = " AND te.block_id != :exclude_block_id";
            $params[':exclude_block_id'] = $excludeBlockId;
        }
        
        // NEU: Hole das Datum für die Abwesenheitsprüfung
        $dateForAbsenceCheck = '';
        try {
            $dto = new DateTime();
            $dto->setISODate($data['year'], $data['calendar_week'], $data['day_of_week']);
            $dateForAbsenceCheck = $dto->format('Y-m-d');
        } catch (Exception $e) {
            throw new Exception("Interner Fehler: Datum für Konfliktprüfung konnte nicht berechnet werden.");
        }


        // 1. Check Teacher Conflict (booked in another class at the same time)
        if (!empty($data['teacher_id'])) {
            // 1a. NEU: Auf Abwesenheit prüfen
            $absence = $this->absenceRepo->checkAbsence($data['teacher_id'], $dateForAbsenceCheck);
            if ($absence) {
                $conflicts[] = "LEHRER-KONFLIKT: Lehrer (ID {$data['teacher_id']}) ist an diesem Tag als '{$absence['reason']}' gemeldet.";
            }

            // 1b. Auf Doppelbuchung (Stundenplan) prüfen
            $teacherSql = $baseSql . " AND te.teacher_id = :teacher_id" . $exclusionSql;
            $teacherParams = $params + [':teacher_id' => $data['teacher_id']];
            
            // Remove exclusion params if they are not in the query
            if ($excludeEntryId === null) unset($teacherParams[':exclude_entry_id']);
            if ($excludeBlockId === null) unset($teacherParams[':exclude_block_id']);

            $stmtTeacher = $this->pdo->prepare($teacherSql);
            $stmtTeacher->execute($teacherParams);
            $existingTeacherEntry = $stmtTeacher->fetch(PDO::FETCH_ASSOC);

            if ($existingTeacherEntry) {
                $shortcut = $existingTeacherEntry['teacher_shortcut'] ?: $data['teacher_id'];
                // Verständlichere Meldung:
                $conflicts[] = "LEHRER-KONFLIKT: '{$shortcut}' ist bereits in Klasse {$existingTeacherEntry['class_name']} ({$existingTeacherEntry['room_name']}) eingeteilt.";
            }
        }

        // 2. Check Room Conflict (booked by another class at the same time)
        if (!empty($data['room_id'])) {
            $roomSql = $baseSql . " AND te.room_id = :room_id" . $exclusionSql;
            $roomParams = $params + [':room_id' => $data['room_id']];
            
            if ($excludeEntryId === null) unset($roomParams[':exclude_entry_id']);
            if ($excludeBlockId === null) unset($roomParams[':exclude_block_id']);

            $stmtRoom = $this->pdo->prepare($roomSql);
            $stmtRoom->execute($roomParams);
            $existingRoomEntry = $stmtRoom->fetch(PDO::FETCH_ASSOC);
            
            if ($existingRoomEntry) {
                $name = $existingRoomEntry['room_name'] ?: $data['room_id'];
                // Verständlichere Meldung:
                $conflicts[] = "RAUM-KONFLIKT: '{$name}' ist bereits von Klasse {$existingRoomEntry['class_name']} (Lehrer: {$existingRoomEntry['teacher_shortcut']}) belegt.";
            }
        }
        
        // 3. Check Class Conflict (class booked for another lesson at the same time)
        // *** KORREKTUR: Entfernt, um parallele Einträge für dieselbe Klasse zu ermöglichen. ***
        // Der neue UNIQUE KEY in der Datenbank (idx_parallel_entry) verhindert exakte Duplikate.
        /*
        if (!empty($data['class_id']) && $data['class_id'] !== '0' && $data['class_id'] !== 0) {
            $classSql = $baseSql . " AND te.class_id = :class_id" . $exclusionSql;
            $classParams = $params + [':class_id' => $data['class_id']];
            if ($excludeEntryId === null) unset($classParams[':exclude_entry_id']);
            if ($excludeBlockId === null) unset($classParams[':exclude_block_id']);

            $stmtClass = $this->pdo->prepare($classSql);
            $stmtClass->execute($classParams);
            $existingClassEntry = $stmtClass->fetch(PDO::FETCH_ASSOC);

            if ($existingClassEntry) {
                // *** GEÄNDERTE MELDUNG (Benutzerwunsch) ***
                $conflicts[] = "KONFLIKT (Slot belegt): Die Klasse {$existingClassEntry['class_name']} hat in diesem Zeitraum bereits Unterricht.";
            }
        }
        */

        // Throw exception if conflicts found (to be caught by handleApiRequest in saveEntry)
        if (!empty($conflicts)) {
            // Wirft die erste (oder kombinierte) Meldung als Fehler
            throw new Exception(implode("\n", $conflicts));
        }

        return $conflicts; // Return empty array if no conflicts
    }

    /**
     * NEU: Kopiert Stundenplandaten von einer Woche in eine andere für eine Klasse oder einen Lehrer.
     * @param int $sourceYear
     * @param int $sourceWeek
     * @param int $targetYear
     * @param int $targetWeek
     * @param int|null $classId
     * @param int|null $teacherId
     * @return int Anzahl der kopierten Einträge.
     * @throws Exception
     */
    public function copyWeekData(int $sourceYear, int $sourceWeek, int $targetYear, int $targetWeek, ?int $classId, ?int $teacherId): int
    {
        if ($classId === null && $teacherId === null) {
            throw new Exception("Es muss entweder eine Klasse oder ein Lehrer zum Kopieren ausgewählt werden.");
        }
        if ($sourceYear === $targetYear && $sourceWeek === $targetWeek) {
            throw new Exception("Quell- und Zielwoche dürfen nicht identisch sein.");
        }

        $this->pdo->beginTransaction();
        try {
            // 1. Zieldaten löschen
            $deleteSql = "DELETE FROM timetable_entries 
                            WHERE year = :target_year AND calendar_week = :target_week";
            $deleteParams = [
                ':target_year' => $targetYear,
                ':target_week' => $targetWeek
            ];
            
            $whereField = "";
            if ($classId !== null) {
                $deleteSql .= " AND class_id = :entity_id";
                $whereField = "class_id";
                $deleteParams[':entity_id'] = $classId;
            } else {
                $deleteSql .= " AND teacher_id = :entity_id";
                $whereField = "teacher_id";
                $deleteParams[':entity_id'] = $teacherId;
            }
            
            $this->pdo->prepare($deleteSql)->execute($deleteParams);

            // 2. Quelldaten holen
            $selectSql = "SELECT * FROM timetable_entries
                            WHERE year = :source_year AND calendar_week = :source_week AND $whereField = :entity_id";
            
            $stmtSelect = $this->pdo->prepare($selectSql);
            $stmtSelect->execute([
                ':source_year' => $sourceYear,
                ':source_week' => $sourceWeek,
                ':entity_id' => $classId ?? $teacherId
            ]);
            $sourceEntries = $stmtSelect->fetchAll(PDO::FETCH_ASSOC);

            if (empty($sourceEntries)) {
                $this->pdo->rollBack(); // Rückgängig machen, da keine Daten zum Kopieren vorhanden waren
                return 0; // 0 Einträge kopiert
            }

            // 3. Neue Einträge vorbereiten und einfügen
            $insertSql = "INSERT INTO timetable_entries 
                            (year, calendar_week, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_id, comment) 
                            VALUES 
                            (:year, :calendar_week, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_id, :comment)";
            
            $stmtInsert = $this->pdo->prepare($insertSql);
            
            $copiedCount = 0;
            $blockIdMap = []; // Mappt alte block_ids auf neue

            foreach ($sourceEntries as $entry) {
                // Generiere neue block_id, falls vorhanden, und behalte sie für die Woche bei
                $newBlockId = null;
                if ($entry['block_id']) {
                    if (!isset($blockIdMap[$entry['block_id']])) {
                        $blockIdMap[$entry['block_id']] = uniqid('block_', true);
                    }
                    $newBlockId = $blockIdMap[$entry['block_id']];
                }

                $success = $stmtInsert->execute([
                    ':year' => $targetYear, // Zieljahr
                    ':calendar_week' => $targetWeek, // Zielwoche
                    ':day_of_week' => $entry['day_of_week'],
                    ':period_number' => $entry['period_number'],
                    ':class_id' => $entry['class_id'],
                    ':teacher_id' => $entry['teacher_id'],
                    ':subject_id' => $entry['subject_id'],
                    ':room_id' => $entry['room_id'],
                    ':block_id' => $newBlockId, // Neue Block-ID
                    ':comment' => $entry['comment']
                ]);
                if ($success) {
                    $copiedCount++;
                }
            }

            $this->pdo->commit();
            return $copiedCount;

        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("PlanRepository::copyWeekData failed: " . $e->getMessage());
            throw new Exception("Fehler beim Kopieren der Wochendaten: " . $e->getMessage());
        }
    }

    // --- NEUE METHODEN FÜR VORLAGEN ---

    /**
     * Erstellt eine neue Stundenplan-Vorlage aus vorhandenen Einträgen.
     * @param string $name Name der Vorlage.
     * @param string|null $description Beschreibung der Vorlage.
     * @param array $sourceEntries Die Stundenplaneinträge (z.B. aus getTimetableFor...AsPlaner).
     * @return int Die ID der neu erstellten Vorlage.
     * @throws Exception
     */
    public function createTemplate(string $name, ?string $description, array $sourceEntries): int
    {
        if (empty($name)) {
            throw new Exception("Vorlagenname darf nicht leer sein.");
        }
        if (empty($sourceEntries)) {
            throw new Exception("Vorlage muss mindestens einen Eintrag enthalten.");
        }

        // Prüfen, ob der Name bereits existiert
        $stmtCheck = $this->pdo->prepare("SELECT COUNT(*) FROM timetable_templates WHERE name = :name");
        $stmtCheck->execute([':name' => $name]);
        if ($stmtCheck->fetchColumn() > 0) {
            throw new Exception("Eine Vorlage mit dem Namen '{$name}' existiert bereits.", 409); // Use 409 for conflict
        }

        $this->pdo->beginTransaction();
        try {
            // 1. Vorlage erstellen
            $sqlTemplate = "INSERT INTO timetable_templates (name, description) VALUES (:name, :description)";
            $stmtTemplate = $this->pdo->prepare($sqlTemplate);
            $stmtTemplate->execute([':name' => $name, ':description' => $description]);
            $templateId = (int)$this->pdo->lastInsertId();

            // 2. Einträge für die Vorlage erstellen
            $sqlEntry = "INSERT INTO timetable_template_entries
                            (template_id, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_ref, comment)
                            VALUES
                            (:template_id, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_ref, :comment)";
            $stmtEntry = $this->pdo->prepare($sqlEntry);

            $blockRefMap = []; // Mappt originale block_ids zu neuen block_refs für diese Vorlage

            foreach ($sourceEntries as $entry) {
                $blockRef = null;
                if ($entry['block_id']) {
                    if (!isset($blockRefMap[$entry['block_id']])) {
                        $blockRefMap[$entry['block_id']] = uniqid('tpl_blk_', true); // Eindeutige Referenz für Blöcke in DIESER Vorlage
                    }
                    $blockRef = $blockRefMap[$entry['block_id']];
                }

                $stmtEntry->execute([
                    ':template_id' => $templateId,
                    ':day_of_week' => $entry['day_of_week'],
                    ':period_number' => $entry['period_number'],
                    ':class_id' => $entry['class_id'], // Speichert die Klasse des ursprünglichen Eintrags
                    ':teacher_id' => $entry['teacher_id'],
                    ':subject_id' => $entry['subject_id'],
                    ':room_id' => $entry['room_id'],
                    ':block_ref' => $blockRef,
                    ':comment' => $entry['comment']
                ]);
            }

            $this->pdo->commit();
            return $templateId;

        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("PlanRepository::createTemplate failed: " . $e->getMessage());
            // Rethrow specific conflict error
            if (str_contains($e->getMessage(), 'Duplicate entry') || $e->getCode() == 409) {
                throw new Exception("Eine Vorlage mit dem Namen '{$name}' existiert bereits.", 409);
            }
            throw new Exception("Fehler beim Erstellen der Vorlage: " . $e->getMessage());
        }
    }

    /**
     * Ruft alle verfügbaren Vorlagen ab.
     * @return array Array von Vorlagen [['template_id', 'name', 'description'], ...].
     */
    public function getTemplates(): array
    {
        $stmt = $this->pdo->query("SELECT template_id, name, description FROM timetable_templates ORDER BY name ASC");
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Wendet eine Vorlage auf eine spezifische Woche für eine Klasse oder einen Lehrer an.
     * Überschreibt vorhandene Einträge für diese Entität in der Zielwoche.
     * @param int $templateId ID der anzuwendenden Vorlage.
     * @param int $targetYear Zieljahr.
     * @param int $targetWeek Zielwoche.
     * @param int|null $targetClassId ID der Zielklasse (wenn Anwenden auf Klasse).
     * @param int|null $targetTeacherId ID des Ziellehrers (wenn Anwenden auf Lehrer).
     * @return int Anzahl der angewendeten Einträge.
     * @throws Exception
     */
    public function applyTemplateToWeek(int $templateId, int $targetYear, int $targetWeek, ?int $targetClassId, ?int $targetTeacherId): int
    {
        if ($targetClassId === null && $targetTeacherId === null) {
            throw new Exception("Es muss entweder eine Klasse oder ein Lehrer als Ziel angegeben werden.");
        }

        // 1. Vorlageneinträge abrufen
        $stmtFetch = $this->pdo->prepare("SELECT * FROM timetable_template_entries WHERE template_id = :template_id ORDER BY day_of_week, period_number");
        $stmtFetch->execute([':template_id' => $templateId]);
        $templateEntries = $stmtFetch->fetchAll(PDO::FETCH_ASSOC);

        if (empty($templateEntries)) {
            // Vorlage ist leer oder existiert nicht
            return 0;
        }

        $this->pdo->beginTransaction();
        try {
            // 2. Bestehende Einträge für Zielwoche/-entität löschen
            $deleteSql = "DELETE FROM timetable_entries
                            WHERE year = :target_year AND calendar_week = :target_week";
            $deleteParams = [':target_year' => $targetYear, ':target_week' => $targetWeek];

            if ($targetClassId !== null) {
                $deleteSql .= " AND class_id = :entity_id";
                $deleteParams[':entity_id'] = $targetClassId;
                $entityIdField = 'class_id';
                $entityIdValue = $targetClassId;
            } else {
                $deleteSql .= " AND teacher_id = :entity_id";
                $deleteParams[':entity_id'] = $targetTeacherId;
                $entityIdField = 'teacher_id';
                $entityIdValue = $targetTeacherId;
            }
            $this->pdo->prepare($deleteSql)->execute($deleteParams);

            // 3. Neue Einträge basierend auf Vorlage einfügen
            $insertSql = "INSERT INTO timetable_entries
                            (year, calendar_week, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_id, comment)
                            VALUES
                            (:year, :calendar_week, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_id, :comment)";
            $stmtInsert = $this->pdo->prepare($insertSql);

            $appliedCount = 0;
            $blockIdMap = []; // Mappt template block_ref zu neuer, eindeutiger block_id für die Zielwoche

            foreach ($templateEntries as $entry) {
                $newBlockId = null;
                if ($entry['block_ref']) {
                    if (!isset($blockIdMap[$entry['block_ref']])) {
                        $blockIdMap[$entry['block_ref']] = uniqid('block_', true); // Generiert eindeutige ID für die Zielwoche
                    }
                    $newBlockId = $blockIdMap[$entry['block_ref']];
                }

                // Bestimme die korrekte class_id für den neuen Eintrag
                // Wenn wir auf einen Lehrer anwenden, MUSS die class_id aus der Vorlage kommen.
                // Wenn wir auf eine Klasse anwenden, MUSS die class_id die Zielklasse sein.
                $entryClassId = ($entityIdField === 'class_id') ? $entityIdValue : $entry['class_id'];
                // Stelle sicher, dass eine class_id vorhanden ist, wenn auf Lehrer angewendet wird
                if ($entityIdField === 'teacher_id' && (empty($entryClassId) || $entryClassId == 0)) {
                    // Überspringe diesen Eintrag oder wirf einen Fehler, da Lehrer ohne Klasse nicht geplant werden kann
                    error_log("Template apply skipped: Teacher template entry missing class_id. TemplateEntryID: " . $entry['template_entry_id']);
                    continue; // Überspringe diesen Eintrag
                }


                $success = $stmtInsert->execute([
                    ':year' => $targetYear,
                    ':calendar_week' => $targetWeek,
                    ':day_of_week' => $entry['day_of_week'],
                    ':period_number' => $entry['period_number'],
                    ':class_id' => $entryClassId, // Angepasste Klassen-ID
                    ':teacher_id' => $entry['teacher_id'],
                    ':subject_id' => $entry['subject_id'],
                    ':room_id' => $entry['room_id'],
                    ':block_id' => $newBlockId, // Neue Block-ID für die Zielwoche
                    ':comment' => $entry['comment']
                ]);
                if ($success) {
                    $appliedCount++;
                } else {
                    // Optional: Fehler loggen, falls ein Eintrag fehlschlägt
                    error_log("Failed to apply template entry: " . print_r($stmtInsert->errorInfo(), true));
                }
            }

            $this->pdo->commit();
            return $appliedCount;

        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("PlanRepository::applyTemplateToWeek failed: " . $e->getMessage());
            throw new Exception("Fehler beim Anwenden der Vorlage: " . $e->getMessage());
        }
    }

    /**
     * Löscht eine Vorlage und alle zugehörigen Einträge.
     * @param int $templateId ID der zu löschenden Vorlage.
     * @return bool Erfolg.
     */
    public function deleteTemplate(int $templateId): bool
    {
        // Durch ON DELETE CASCADE in der DB werden die Einträge automatisch mitgelöscht
        $sql = "DELETE FROM timetable_templates WHERE template_id = :template_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':template_id' => $templateId]);
    }

    // --- ENDE NEUE METHODEN FÜR VORLAGEN ---

    /**
     * Lädt die Details einer Vorlage (Stammdaten und Einträge).
     *
     * @param int $templateId
     * @return array
     * @throws Exception
     */
    public function loadTemplateDetails(int $templateId): array
    {
        // 1. Vorlagen-Stammdaten abrufen
        $stmtTemplate = $this->pdo->prepare("SELECT * FROM timetable_templates WHERE template_id = :id");
        $stmtTemplate->execute([':id' => $templateId]);
        $templateInfo = $stmtTemplate->fetch(PDO::FETCH_ASSOC);

        if (!$templateInfo) {
            throw new Exception("Vorlage nicht gefunden.");
        }

        // 2. Zugehörige Einträge abrufen
        // WICHTIG: Wir holen die Roh-IDs, da der Planer-Editor die Stammdaten bereits hat
        $stmtEntries = $this->pdo->prepare("SELECT * FROM timetable_template_entries WHERE template_id = :id ORDER BY day_of_week, period_number");
        $stmtEntries->execute([':id' => $templateId]);
        $entries = $stmtEntries->fetchAll(PDO::FETCH_ASSOC);

        return [
            'template' => $templateInfo,
            'entries' => $entries
        ];
    }

    /**
     * Speichert eine Vorlage (neu oder Update) basierend auf den Editor-Daten.
     *
     * @param array $data Daten mit ['name', 'description', 'template_id' (optional), 'entries' (array)]
     * @return array Die gespeicherten Vorlagen-Stammdaten (inkl. ID)
     * @throws Exception
     */
    public function saveTemplateDetails(array $data): array
    {
        $templateId = $data['template_id'] ?? null;
        $name = trim($data['name']);
        $description = trim($data['description'] ?? '') ?: null;
        $entries = $data['entries'] ?? [];

        if (empty($name)) {
            throw new Exception("Vorlagenname darf nicht leer sein.");
        }

        $this->pdo->beginTransaction();
        try {
            // Prüfen, ob der Name (außerhalb dieser ID) bereits existiert
            $sqlCheckName = "SELECT template_id FROM timetable_templates WHERE name = :name AND (:id IS NULL OR template_id != :id)";
            $stmtCheckName = $this->pdo->prepare($sqlCheckName);
            $stmtCheckName->execute([':name' => $name, ':id' => $templateId]);
            if ($stmtCheckName->fetch()) {
                throw new Exception("Eine andere Vorlage mit diesem Namen existiert bereits.", 409);
            }

            if ($templateId) {
                // Update existing template
                $sqlTemplate = "UPDATE timetable_templates SET name = :name, description = :description WHERE template_id = :id";
                $stmtTemplate = $this->pdo->prepare($sqlTemplate);
                $stmtTemplate->execute([':name' => $name, ':description' => $description, ':id' => $templateId]);
            } else {
                // Create new template
                $sqlTemplate = "INSERT INTO timetable_templates (name, description) VALUES (:name, :description)";
                $stmtTemplate = $this->pdo->prepare($sqlTemplate);
                $stmtTemplate->execute([':name' => $name, ':description' => $description]);
                $templateId = (int)$this->pdo->lastInsertId();
            }

            // Einträge neu schreiben (Delete + Insert)
            $stmtDelete = $this->pdo->prepare("DELETE FROM timetable_template_entries WHERE template_id = :id");
            $stmtDelete->execute([':id' => $templateId]);

            if (!empty($entries)) {
                $sqlEntry = "INSERT INTO timetable_template_entries
                                (template_id, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_ref, comment)
                                VALUES
                                (:template_id, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_ref, :comment)";
                $stmtEntry = $this->pdo->prepare($sqlEntry);

                foreach ($entries as $entry) {
                    $stmtEntry->execute([
                        ':template_id' => $templateId,
                        ':day_of_week' => $entry['day_of_week'],
                        ':period_number' => $entry['period_number'],
                        ':class_id' => $entry['class_id'],
                        ':teacher_id' => $entry['teacher_id'],
                        ':subject_id' => $entry['subject_id'],
                        ':room_id' => $entry['room_id'],
                        ':block_ref' => $entry['block_ref'] ?: null,
                        ':comment' => $entry['comment'] ?: null
                    ]);
                }
            }

            $this->pdo->commit();

            return [
                'template_id' => $templateId,
                'name' => $name,
                'description' => $description
            ];

        } catch (Exception $e) {
            $this->pdo->rollBack();
            // Loggen Sie den detaillierten Fehler
            error_log("PlanRepository::saveTemplateDetails failed: " . $e->getMessage());
            // Werfen Sie den Fehler erneut, damit der Controller ihn fangen kann
            // Behalten Sie den Konflikt-Code 409 bei
            $errorCode = $e->getCode() == 409 ? 409 : 500;
            throw new Exception("Fehler beim Speichern der Vorlage: " . $e->getMessage(), $errorCode);
        }
    }


    public function findTeacherLocation(int $teacherId, string $date, int $year, int $calendarWeek, int $dayOfWeek, int $periodNumber): array
    {
        // 1. Prüfen, ob der Lehrer als NEUER Lehrer in einer Vertretung eingeteilt ist
        $sqlSubAsNew = "SELECT s.*, c.class_name, ns.subject_shortcut as new_subject_shortcut, nr.room_name as new_room_name
                        FROM substitutions s
                        JOIN classes c ON s.class_id = c.class_id
                        LEFT JOIN subjects ns ON s.new_subject_id = ns.subject_id
                        LEFT JOIN rooms nr ON s.new_room_id = nr.room_id
                        WHERE s.new_teacher_id = :teacher_id 
                            AND s.date = :date 
                            AND s.period_number = :period_number";
        
        $stmtSubAsNew = $this->pdo->prepare($sqlSubAsNew);
        $stmtSubAsNew->execute([
            ':teacher_id' => $teacherId,
            ':date' => $date,
            ':period_number' => $periodNumber
        ]);
        $subAsNew = $stmtSubAsNew->fetch(PDO::FETCH_ASSOC);

        if ($subAsNew) {
            // Der Lehrer hält aktiv eine Vertretung
            // Wir müssen den Typ der Vertretung zurückgeben (z.B. Vertretung, Sonderevent)
            return [
                'status' => $subAsNew['substitution_type'], // z.B. "Vertretung" oder "Sonderevent"
                'data' => $subAsNew
            ];
        }

        // 2. Prüfen, ob der Lehrer regulären Unterricht HÄTTE
        $sqlRegular = "SELECT te.*, s.subject_shortcut, c.class_name, r.room_name
                        FROM timetable_entries te
                        LEFT JOIN subjects s ON te.subject_id = s.subject_id
                        LEFT JOIN classes c ON te.class_id = c.class_id
                        LEFT JOIN rooms r ON te.room_id = r.room_id
                        WHERE te.teacher_id = :teacher_id
                            AND te.year = :year
                            AND te.calendar_week = :calendar_week
                            AND te.day_of_week = :day_of_week
                            AND te.period_number = :period_number";
        
        $stmtRegular = $this->pdo->prepare($sqlRegular);
        $stmtRegular->execute([
            ':teacher_id' => $teacherId,
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':day_of_week' => $dayOfWeek,
            ':period_number' => $periodNumber
        ]);
        // KORRIGIERT: fetchAll() statt fetch() verwenden, da mehrere Einträge (Kursteilung) möglich sind
        $regularEntries = $stmtRegular->fetchAll(PDO::FETCH_ASSOC);

        if (empty($regularEntries)) {
            // 3. Kein regulärer Unterricht und keine Vertretung -> Freistunde
            return [
                'status' => 'Freistunde',
                'data' => null
            ];
        }

        // 4. Regulärer Unterricht ist geplant. PRÜFE, ob DIESE Stunde(n) vertreten wird/werden.
        // Wir müssen für jeden regulären Eintrag prüfen, ob eine Vertretung existiert.
        foreach ($regularEntries as $index => $regularEntry) {
            if (empty($regularEntry['class_id'])) {
                 // Sollte nicht passieren, wenn ein Lehrer zugewiesen ist, aber zur Sicherheit
                 continue;
            }
            
            $sqlCheckSub = "SELECT s.*, c.class_name, 
                                os.subject_shortcut as original_subject_shortcut, 
                                ns.subject_shortcut as new_subject_shortcut, 
                                nr.room_name as new_room_name
                            FROM substitutions s
                            JOIN classes c ON s.class_id = c.class_id
                            LEFT JOIN subjects os ON s.original_subject_id = os.subject_id
                            LEFT JOIN subjects ns ON s.new_subject_id = ns.subject_id
                            LEFT JOIN rooms nr ON s.new_room_id = nr.room_id
                            WHERE s.date = :date 
                                AND s.period_number = :period_number
                                AND s.class_id = :class_id";
            
            $stmtCheckSub = $this->pdo->prepare($sqlCheckSub);
            $stmtCheckSub->execute([
                ':date' => $date,
                ':period_number' => $periodNumber,
                ':class_id' => $regularEntry['class_id']
            ]);
            $substitution = $stmtCheckSub->fetch(PDO::FETCH_ASSOC);

            if ($substitution) {
                // 5. Ja, die Stunde wird vertreten (z.B. Entfall, Raumänderung)
                // Der Lehrer ist also NICHT im regulären Raum.
                // Wir speichern dies im $regularEntries Array
                $regularEntries[$index]['substitution_info'] = $substitution;
            }
        }
        
        // 6. Daten aufbereiten
        // Wenn $regularEntries nur einen Eintrag hat und dieser eine Vertretung hat,
        // geben wir den Status der Vertretung zurück.
        if (count($regularEntries) === 1 && isset($regularEntries[0]['substitution_info'])) {
             return [
                'status' => $regularEntries[0]['substitution_info']['substitution_type'], // z.B. "Entfall"
                'data' => $regularEntries[0]['substitution_info']
            ];
        }

        // 7. In allen anderen Fällen (regulärer Unterricht oder mehrere parallele Kurse)
        // geben wir 'Unterricht' zurück. Das Frontend muss die Einträge (inkl. 'substitution_info') selbst interpretieren.
        return [
            'status' => 'Unterricht',
            'data' => $regularEntries // Sende alle regulären Einträge (ggf. mit Vertretungsinfos)
        ];
    }
    
    /**
     * NEU: Holt alle eindeutigen Klassen-IDs, die ein Lehrer unterrichtet.
     * @param int $teacherId
     * @return array
     */
    public function getClassesForTeacher(int $teacherId): array
    {
        // Holt Klassen aus regulären Einträgen
        $sqlEntries = "SELECT DISTINCT c.class_id, c.class_name 
                        FROM timetable_entries te
                        JOIN classes c ON te.class_id = c.class_id
                        WHERE te.teacher_id = :teacher_id AND te.class_id IS NOT NULL AND te.class_id != 0";
                        
        // Holt Klassen aus Vertretungen (wo der Lehrer der *neue* Lehrer ist)
        $sqlSubs = "SELECT DISTINCT c.class_id, c.class_name
                    FROM substitutions s
                    JOIN classes c ON s.class_id = c.class_id
                    WHERE s.new_teacher_id = :teacher_id AND s.class_id IS NOT NULL AND s.class_id != 0";

        try {
            $stmtEntries = $this->pdo->prepare($sqlEntries);
            $stmtEntries->execute([':teacher_id' => $teacherId]);
            $classesFromEntries = $stmtEntries->fetchAll(PDO::FETCH_ASSOC);
            
            $stmtSubs = $this->pdo->prepare($sqlSubs);
            $stmtSubs->execute([':teacher_id' => $teacherId]);
            $classesFromSubs = $stmtSubs->fetchAll(PDO::FETCH_ASSOC);

            // Kombiniere die Ergebnisse und entferne Duplikate (basierend auf class_id)
            $allClasses = [];
            foreach (array_merge($classesFromEntries, $classesFromSubs) as $class) {
                $allClasses[$class['class_id']] = $class; // Nutzen der ID als Schlüssel entfernt Duplikate
            }
            
            // Sortiere nach Klassen-ID
            ksort($allClasses);

            return array_values($allClasses); // Gebe nur die Werte (die Klassen-Arrays) zurück

        } catch (Exception $e) {
            error_log("Fehler beim Abrufen der Klassen für Lehrer {$teacherId}: " . $e->getMessage());
            return [];
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\PlanRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\SettingsRepository.php ---
<?php
// app/Repositories/SettingsRepository.php

namespace App\Repositories;

use PDO;
use Exception;
use App\Core\Database;

/**
 * Repository zur Verwaltung von Einstellungen in der Datenbank.
 */
class SettingsRepository
{
    private PDO $pdo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
    }

    /**
     * Lädt alle Einstellungen aus der Datenbank.
     *
     * @return array Assoziatives Array [setting_key => setting_value]
     */
    public function loadSettings(): array
    {
        try {
            $stmt = $this->pdo->query("SELECT setting_key, setting_value FROM settings");
            // Wandelt das Ergebnis [ ['setting_key' => 'k', 'setting_value' => 'v'], ... ]
            // in ein assoziatives Array [ 'k' => 'v' ] um.
            return $stmt->fetchAll(PDO::FETCH_KEY_PAIR) ?: [];
        } catch (Exception $e) {
            // Loggt den Fehler, aber fährt mit leeren DB-Einstellungen fort (Fallback auf JSON)
            error_log("Could not load settings from DB: " . $e->getMessage());
            return [];
        }
    }

    /**
     * Speichert mehrere Einstellungen in der Datenbank.
     *
     * @param array $settings Assoziatives Array [setting_key => setting_value]
     * @return bool True bei Erfolg
     * @throws Exception Bei Datenbankfehlern
     */
    public function saveSettings(array $settings): bool
    {
        // Verwendet INSERT ... ON DUPLICATE KEY UPDATE für Effizienz
        $sql = "INSERT INTO settings (setting_key, setting_value) VALUES (:key, :value)
                ON DUPLICATE KEY UPDATE setting_value = :value";
        
        try {
            $this->pdo->beginTransaction();
            $stmt = $this->pdo->prepare($sql);
            
            foreach ($settings as $key => $value) {
                // Konvertiert boolesche Werte und NULL in speicherbare Formate
                if (is_bool($value)) {
                    $value = $value ? '1' : '0';
                }
                if ($value === null) {
                    $value = ''; // Oder je nach Logik NULL, aber TEXT-Spalte kann '' sein
                }

                $stmt->execute([':key' => $key, ':value' => $value]);
            }
            
            $this->pdo->commit();
            return true;
        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("Failed to save settings: " . $e->getMessage());
            throw new Exception("Einstellungen konnten nicht gespeichert werden: " . $e->getMessage());
        }
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\SettingsRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\StammdatenRepository.php ---
<?php
// app/Repositories/StammdatenRepository.php
namespace App\Repositories;

use PDO;
use Exception; // Hinzugefügt für Zähl-Methoden

class StammdatenRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    // --- Subject Methods ---
    public function getSubjects(): array {
        $stmt = $this->pdo->prepare("SELECT * FROM subjects ORDER BY subject_name ASC");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function createSubject(string $name, string $shortcut): int {
        $sql = "INSERT INTO subjects (subject_name, subject_shortcut) VALUES (:name, :shortcut)";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':name' => $name, ':shortcut' => $shortcut]);
        return (int)$this->pdo->lastInsertId();
    }
    public function updateSubject(int $id, string $name, string $shortcut): bool {
        $sql = "UPDATE subjects SET subject_name = :name, subject_shortcut = :shortcut WHERE subject_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id, ':name' => $name, ':shortcut' => $shortcut]);
    }
    public function deleteSubject(int $id): bool {
        $sql = "DELETE FROM subjects WHERE subject_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id]);
    }
    /** NEU: Zählt die Anzahl der Fächer */
    public function countSubjects(): int {
        try {
            $stmt = $this->pdo->query("SELECT COUNT(*) FROM subjects");
            return (int)($stmt->fetchColumn() ?: 0);
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Fächer: " . $e->getMessage());
            return 0;
        }
    }

    // --- Rooms Methods ---
    public function getRooms(): array {
        $stmt = $this->pdo->prepare("SELECT * FROM rooms ORDER BY room_name ASC");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function createRoom(string $name): int {
        $sql = "INSERT INTO rooms (room_name) VALUES (:name)";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':name' => $name]);
        return (int)$this->pdo->lastInsertId();
    }
    public function updateRoom(int $id, string $name): bool {
        $sql = "UPDATE rooms SET room_name = :name WHERE room_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id, ':name' => $name]);
    }
    public function deleteRoom(int $id): bool {
        $sql = "DELETE FROM rooms WHERE room_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id]);
    }
    /** NEU: Zählt die Anzahl der Räume */
    public function countRooms(): int {
        try {
            $stmt = $this->pdo->query("SELECT COUNT(*) FROM rooms");
            return (int)($stmt->fetchColumn() ?: 0);
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Räume: " . $e->getMessage());
            return 0;
        }
    }

    // --- Teachers Methods ---
    public function getTeachers(): array {
        $stmt = $this->pdo->prepare("SELECT * FROM teachers ORDER BY last_name, first_name ASC");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function createTeacher(array $data): int {
        $sql = "INSERT INTO teachers (teacher_shortcut, first_name, last_name, email) VALUES (:shortcut, :first_name, :last_name, :email)";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($data);
        return (int)$this->pdo->lastInsertId();
    }
    public function updateTeacher(int $id, array $data): bool {
        $sql = "UPDATE teachers SET teacher_shortcut = :shortcut, first_name = :first_name, last_name = :last_name, email = :email WHERE teacher_id = :id";
        $data['id'] = $id;
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute($data);
    }
    public function deleteTeacher(int $id): bool {
        $sql = "DELETE FROM teachers WHERE teacher_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id]);
    }
    /** NEU: Zählt die Anzahl der Lehrer */
    public function countTeachers(): int {
        try {
            $stmt = $this->pdo->query("SELECT COUNT(*) FROM teachers");
            return (int)($stmt->fetchColumn() ?: 0);
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Lehrer: " . $e->getMessage());
            return 0;
        }
    }

    // --- Classes Methods (ANGEPASST) ---
    public function getClasses(): array {
        $sql = "SELECT c.class_id, c.class_name, c.class_teacher_id, CONCAT_WS(' ', t.first_name, t.last_name) as teacher_name
                FROM classes c
                LEFT JOIN teachers t ON c.class_teacher_id = t.teacher_id
                ORDER BY c.class_id ASC";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public function createClass(int $id, string $name, ?int $teacherId): bool {
        // Prüfen, ob die ID bereits existiert
        $stmtCheck = $this->pdo->prepare("SELECT COUNT(*) FROM classes WHERE class_id = :id");
        $stmtCheck->execute([':id' => $id]);
        if ($stmtCheck->fetchColumn() > 0) {
            throw new \Exception("Die Klassen-ID '{$id}' ist bereits vergeben.");
        }

        $sql = "INSERT INTO classes (class_id, class_name, class_teacher_id) VALUES (:id, :name, :teacher_id)";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id, ':name' => $name, ':teacher_id' => $teacherId]);
    }

    public function updateClass(int $id, string $name, ?int $teacherId): bool {
        // Die ID (Primärschlüssel) selbst wird hier nicht geändert.
        $sql = "UPDATE classes SET class_name = :name, class_teacher_id = :teacher_id WHERE class_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id, ':name' => $name, ':teacher_id' => $teacherId]);
    }

    public function deleteClass(int $id): bool {
        $sql = "DELETE FROM classes WHERE class_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id]);
    }
    /** NEU: Zählt die Anzahl der Klassen */
    public function countClasses(): int {
        try {
            $stmt = $this->pdo->query("SELECT COUNT(*) FROM classes");
            return (int)($stmt->fetchColumn() ?: 0);
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Klassen: " . $e->getMessage());
            return 0;
        }
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\StammdatenRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\StudentNoteRepository.php ---
<?php
// app/Repositories/StudentNoteRepository.php

namespace App\Repositories;

use PDO;
use Exception;

class StudentNoteRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Holt alle Notizen eines Schülers für eine bestimmte Woche.
     *
     * @param int $userId
     * @param int $year
     * @param int $calendarWeek
     * @return array Assoziatives Array (z.B. ["1-2" => "Notiz..."])
     */
    public function getNotesForWeek(int $userId, int $year, int $calendarWeek): array
    {
        $sql = "SELECT day_of_week, period_number, note_content
                FROM student_notes
                WHERE user_id = :user_id
                  AND year = :year
                  AND calendar_week = :calendar_week";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':user_id' => $userId,
            ':year' => $year,
            ':calendar_week' => $calendarWeek
        ]);

        $notes = [];
        // Erstellt ein einfaches Key-Value-Paar "Tag-Stunde" => "Inhalt"
        while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $key = $row['day_of_week'] . '-' . $row['period_number'];
            $notes[$key] = $row['note_content'];
        }
        
        return $notes;
    }

    /**
     * Speichert oder aktualisiert eine Notiz (UPSERT).
     *
     * @param int $userId
     * @param int $year
     * @param int $calendarWeek
     * @param int $dayOfWeek
     * @param int $periodNumber
     * @param string $content
     * @return bool
     */
    public function saveNote(int $userId, int $year, int $calendarWeek, int $dayOfWeek, int $periodNumber, string $content): bool
    {
        // Wenn der Inhalt leer ist, löschen wir den Eintrag, anstatt einen leeren String zu speichern.
        if (empty(trim($content))) {
            return $this->deleteNote($userId, $year, $calendarWeek, $dayOfWeek, $periodNumber);
        }

        $sql = "INSERT INTO student_notes (user_id, `year`, calendar_week, day_of_week, period_number, note_content)
                VALUES (:user_id, :year, :calendar_week, :day_of_week, :period_number, :note_content)
                ON DUPLICATE KEY UPDATE
                    note_content = VALUES(note_content),
                    last_updated = NOW()";
        
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':user_id' => $userId,
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':day_of_week' => $dayOfWeek,
            ':period_number' => $periodNumber,
            ':note_content' => $content
        ]);
    }

    /**
     * Löscht eine Notiz, z.B. wenn der Inhalt geleert wird.
     */
    private function deleteNote(int $userId, int $year, int $calendarWeek, int $dayOfWeek, int $periodNumber): bool
    {
         $sql = "DELETE FROM student_notes
                  WHERE user_id = :user_id
                    AND `year` = :year
                    AND calendar_week = :calendar_week
                    AND day_of_week = :day_of_week
                    AND period_number = :period_number";
        
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':user_id' => $userId,
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':day_of_week' => $dayOfWeek,
            ':period_number' => $periodNumber
        ]);
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\StudentNoteRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\TeacherAbsenceRepository.php ---
<?php
// app/Repositories/TeacherAbsenceRepository.php

namespace App\Repositories;

use PDO;
use Exception;
use DateTime;
use DateTimeZone;

class TeacherAbsenceRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Holt alle Abwesenheiten für den Kalender für einen bestimmten Zeitraum.
     * (KORRIGIERT: Akzeptiert jetzt Parameter)
     *
     * @param string $startDate (Y-m-d)
     * @param string $endDate (Y-m-d)
     * @return array
     */
    public function getAbsencesForPeriod(string $startDate, string $endDate): array
    {
        // KORREKTUR: Verwendet die übergebenen Daten anstelle eines festen Zeitraums
        $sql = "SELECT ta.*, t.teacher_shortcut, t.first_name, t.last_name
                FROM teacher_absences ta
                JOIN teachers t ON ta.teacher_id = t.teacher_id
                WHERE ta.start_date <= :end_date AND ta.end_date >= :start_date
                ORDER BY ta.start_date ASC";
                
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Holt eine einzelne Abwesenheit anhand ihrer ID.
     *
     * @param int $absenceId
     * @return array|false
     */
    public function getAbsenceById(int $absenceId): array|false
    {
        $sql = "SELECT ta.*, t.teacher_shortcut, t.first_name, t.last_name
                FROM teacher_absences ta
                JOIN teachers t ON ta.teacher_id = t.teacher_id
                WHERE ta.absence_id = :absence_id";
                
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':absence_id' => $absenceId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }


    /**
     * Speichert (Insert/Update) eine Abwesenheit.
     *
     * @param int|null $absenceId
     * @param int $teacherId
     * @param string $startDate
     * @param string $endDate
     * @param string $reason
     * @param string|null $comment
     * @return array Der gespeicherte Datensatz
     * @throws Exception
     */
    public function createAbsence(?int $absenceId, int $teacherId, string $startDate, string $endDate, string $reason, ?string $comment): array
    {
        // Validierung der Daten
        if ($startDate > $endDate) {
            throw new Exception("Das Startdatum darf nicht nach dem Enddatum liegen.");
        }
        if (empty($teacherId) || empty($reason)) {
             throw new Exception("Lehrer und Grund sind Pflichtfelder.");
        }

        if ($absenceId) {
            // Update
            $sql = "UPDATE teacher_absences SET
                        teacher_id = :teacher_id,
                        start_date = :start_date,
                        end_date = :end_date,
                        reason = :reason,
                        comment = :comment
                    WHERE absence_id = :absence_id";
            $params = [
                ':teacher_id' => $teacherId,
                ':start_date' => $startDate,
                ':end_date' => $endDate,
                ':reason' => $reason,
                ':comment' => $comment,
                ':absence_id' => $absenceId
            ];
        } else {
            // Insert
            $sql = "INSERT INTO teacher_absences (teacher_id, start_date, end_date, reason, comment)
                    VALUES (:teacher_id, :start_date, :end_date, :reason, :comment)";
            $params = [
                ':teacher_id' => $teacherId,
                ':start_date' => $startDate,
                ':end_date' => $endDate,
                ':reason' => $reason,
                ':comment' => $comment
            ];
        }
        
        $stmt = $this->pdo->prepare($sql);
        if (!$stmt->execute($params)) {
            throw new Exception("Datenbankfehler beim Speichern der Abwesenheit.");
        }

        $newId = $absenceId ?? (int)$this->pdo->lastInsertId();
        
        // Hole den gespeicherten Datensatz zurück
        $savedData = $this->getAbsenceById($newId);
        if (!$savedData) {
            throw new Exception("Fehler beim Abrufen der gespeicherten Abwesenheit.");
        }
        return $savedData;
    }

    /**
     * Löscht eine Abwesenheit.
     *
     * @param int $absenceId
     * @return bool
     * @throws Exception
     */
    public function deleteAbsence(int $absenceId): bool
    {
        $sql = "DELETE FROM teacher_absences WHERE absence_id = :absence_id";
        $stmt = $this->pdo->prepare($sql);
        
        if (!$stmt->execute([':absence_id' => $absenceId])) {
            throw new Exception("Datenbankfehler beim Löschen der Abwesenheit.");
        }
        
        return $stmt->rowCount() > 0;
    }

    /**
     * Holt Abwesenheiten für einen bestimmten Zeitraum (für den PlanController).
     *
     * @param string $startDate (Y-m-d)
     * @param string $endDate (Y-m-d)
     * @return array
     */
    public function getAbsencesForDateRange(string $startDate, string $endDate): array
    {
        $sql = "SELECT teacher_id, start_date, end_date, reason
                FROM teacher_absences
                WHERE start_date <= :end_date AND end_date >= :start_date";
                
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':start_date' => $startDate, ':end_date' => $endDate]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    /**
     * Prüft, ob ein spezifischer Lehrer an einem spezifischen Tag abwesend ist.
     *
     * @param int $teacherId
     * @param string $date (Y-m-d)
     * @return array|false Die Abwesenheitsdaten oder false
     */
    public function checkAbsence(int $teacherId, string $date)
    {
        $sql = "SELECT * FROM teacher_absences
                WHERE teacher_id = :teacher_id
                  AND :date BETWEEN start_date AND end_date
                LIMIT 1";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':teacher_id' => $teacherId, ':date' => $date]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    /**
     * Holt die definierten Abwesenheitstypen.
     * Aktuell hardcodiert, könnte später aus einer DB-Tabelle kommen.
     *
     * @return array
     */
    public function getAbsenceTypes(): array
    {
        return [
            'Krank',
            'Fortbildung',
            'Beurlaubt',
            'Sonstiges'
        ];
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\TeacherAbsenceRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\UserRepository.php ---
<?php
// app/Repositories/UserRepository.php
namespace App\Repositories;

use PDO;
use Exception;

class UserRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    // ... [findByUsernameOrEmail, getAll, findById, findClassByUserId] ...
    // (Code nicht dupliziert)
    public function findByUsernameOrEmail(string $identifier): ?array
    {
        // NEU: is_community_banned hinzugefügt
        $sql = "SELECT user_id, username, password_hash, role, ical_token, is_community_banned
                FROM users
                WHERE username = :identifier OR email = :identifier";

        $statement = $this->pdo->prepare($sql);
        $statement->execute([':identifier' => $identifier]);

        $user = $statement->fetch(PDO::FETCH_ASSOC);
        return $user ?: null;
    }

    public function getAll(): array
    {
        // NEU: u.is_community_banned hinzugefügt
        $sql = "SELECT u.user_id, u.username, u.email, u.role, u.first_name, u.last_name, u.birth_date, u.class_id, u.teacher_id, u.ical_token, u.is_community_banned, c.class_name, CONCAT(t.first_name, ' ', t.last_name) as teacher_name
                FROM users u
                LEFT JOIN classes c ON u.class_id = c.class_id
                LEFT JOIN teachers t ON u.teacher_id = t.teacher_id
                ORDER BY u.last_name, u.first_name ASC";
        $stmt = $this->pdo->query($sql);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public function findById(int $userId): ?array
    {
        // NEU: is_community_banned hinzugefügt
        $sql = "SELECT * FROM users WHERE user_id = :user_id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':user_id' => $userId]);
        $user = $stmt->fetch(PDO::FETCH_ASSOC);
        return $user ?: null;
    }

    public function findClassByUserId(int $userId): ?array
    {
        $sql = "SELECT c.class_id, c.class_name
                FROM users u
                JOIN classes c ON u.class_id = c.class_id
                WHERE u.user_id = :user_id AND u.role = 'schueler'";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':user_id' => $userId]);
        $classData = $stmt->fetch(PDO::FETCH_ASSOC);
        return $classData ?: null;
    }


    /**
     * NEU: Holt alle Schüler (user_id, first_name, last_name) für eine bestimmte Klasse.
     * @param int $classId
     * @return array
     */
    public function getStudentsByClassId(int $classId): array
    {
        $sql = "SELECT user_id, first_name, last_name 
                FROM users 
                WHERE role = 'schueler' 
                  AND class_id = :class_id 
                ORDER BY last_name ASC, first_name ASC";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':class_id' => $classId]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }


    public function create(array $data): int
    {
        // Validation
        if (empty($data['username']) || empty($data['email']) || empty($data['password']) || empty($data['role']) || empty($data['first_name']) || empty($data['last_name'])) {
            throw new Exception("Alle Felder mit * sind erforderlich.");
        }
        if ($this->findByUsernameOrEmail($data['username'])) {
            throw new Exception("Benutzername ist bereits vergeben.");
        }
        if ($this->findByUsernameOrEmail($data['email'])) {
            throw new Exception("E-Mail ist bereits vergeben.");
        }

        // Generate iCal token on creation
        $icalToken = bin2hex(random_bytes(32));

        // NEU: is_community_banned hinzugefügt
        $sql = "INSERT INTO users (username, email, password_hash, role, first_name, last_name, birth_date, class_id, teacher_id, ical_token, is_community_banned)
                VALUES (:username, :email, :password_hash, :role, :first_name, :last_name, :birth_date, :class_id, :teacher_id, :ical_token, :is_community_banned)";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':username' => $data['username'],
            ':email' => $data['email'],
            ':password_hash' => password_hash($data['password'], PASSWORD_DEFAULT),
            ':role' => $data['role'],
            ':first_name' => $data['first_name'],
            ':last_name' => $data['last_name'],
            ':birth_date' => empty($data['birth_date']) ? null : $data['birth_date'],
            ':class_id' => ($data['role'] === 'schueler' && !empty($data['class_id'])) ? $data['class_id'] : null,
            ':teacher_id' => ($data['role'] === 'lehrer' && !empty($data['teacher_id'])) ? $data['teacher_id'] : null,
            ':ical_token' => $icalToken, // Save the generated token
            // NEU: Sperrstatus setzen (nur relevant für Schüler, sonst 0)
            ':is_community_banned' => ($data['role'] === 'schueler' ? (isset($data['is_community_banned']) ? 1 : 0) : 0)
        ]);

        return (int)$this->pdo->lastInsertId();
    }

    public function update(int $userId, array $data): bool
    {
        // Check for uniqueness of email/username excluding the current user
        $sqlCheck = "SELECT user_id FROM users WHERE (username = :username OR email = :email) AND user_id != :user_id";
        $stmtCheck = $this->pdo->prepare($sqlCheck);
        $stmtCheck->execute([':username' => $data['username'], ':email' => $data['email'], ':user_id' => $userId]);
        if ($stmtCheck->fetch()) {
            throw new Exception("Benutzername oder E-Mail ist bereits von einem anderen Benutzer vergeben.");
        }

        // NEU: is_community_banned hinzugefügt
        $sql = "UPDATE users SET
                        username = :username,
                        email = :email,
                        role = :role,
                        first_name = :first_name,
                        last_name = :last_name,
                        birth_date = :birth_date,
                        class_id = :class_id,
                        teacher_id = :teacher_id,
                        is_community_banned = :is_community_banned"; // No update for ical_token here by default

        $params = [
            ':user_id' => $userId,
            ':username' => $data['username'],
            ':email' => $data['email'],
            ':role' => $data['role'],
            ':first_name' => $data['first_name'],
            ':last_name' => $data['last_name'],
            ':birth_date' => empty($data['birth_date']) ? null : $data['birth_date'],
            ':class_id' => ($data['role'] === 'schueler' && !empty($data['class_id'])) ? $data['class_id'] : null,
            ':teacher_id' => ($data['role'] === 'lehrer' && !empty($data['teacher_id'])) ? $data['teacher_id'] : null,
            // NEU: Sperrstatus aktualisieren. Wenn Rolle nicht Schüler, auf 0 setzen.
            ':is_community_banned' => ($data['role'] === 'schueler' ? (isset($data['is_community_banned']) ? 1 : 0) : 0)
        ];

        // Update password only if provided
        if (!empty($data['password'])) {
            $sql .= ", password_hash = :password_hash";
            $params[':password_hash'] = password_hash($data['password'], PASSWORD_DEFAULT);
        }

        $sql .= " WHERE user_id = :user_id";

        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute($params);
    }

    public function delete(int $userId): bool
    {
        $sql = "DELETE FROM users WHERE user_id = :user_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':user_id' => $userId]);
    }

    public function getAvailableRoles(): array
    {
        $stmt = $this->pdo->query("SHOW COLUMNS FROM users LIKE 'role'");
        $columnInfo = $stmt->fetch(PDO::FETCH_ASSOC);

        if ($columnInfo && isset($columnInfo['Type'])) {
            preg_match_all("/'([^']+)'/", $columnInfo['Type'], $matches);
            if (!empty($matches[1])) {
                return $matches[1]; 
            }
        }
        return ['schueler', 'lehrer', 'planer', 'admin'];
    }

    public function findByIcalToken(string $token): ?array
    {
        $sql = "SELECT * FROM users WHERE ical_token = :token";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':token' => $token]);
        $user = $stmt->fetch(PDO::FETCH_ASSOC);
        return $user ?: null;
    }

    public function generateOrGetIcalToken(int $userId): ?string
    {
        $user = $this->findById($userId);
        if (!$user) return null;

        if (!empty($user['ical_token'])) {
            return $user['ical_token'];
        }

        // Generate a new token
        $newToken = bin2hex(random_bytes(32));
        $sql = "UPDATE users SET ical_token = :token WHERE user_id = :user_id";
        $stmt = $this->pdo->prepare($sql);
        if ($stmt->execute([':token' => $newToken, ':user_id' => $userId])) {
            return $newToken;
        }

        error_log("Failed to update iCal token for user ID: " . $userId); // Log error
        return null; // Error updating token
    }

    /**
     * NEU: Findet einen Benutzer anhand seiner teacher_id (aus der Stammdatentabelle)
     * @param int $teacherId
     * @return array|null
     */
    public function findUserByTeacherId(int $teacherId): ?array
    {
        $sql = "SELECT * FROM users WHERE teacher_id = :teacher_id AND role = 'lehrer' LIMIT 1";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':teacher_id' => $teacherId]);
        $user = $stmt->fetch(PDO::FETCH_ASSOC);
        return $user ?: null;
    }


    public function importFromCSV(string $tmpFilePath, array $validationData): array
    {
        $successCount = 0;
        $errorMessages = [];
        $requiredHeaders = ['username', 'email', 'password', 'role', 'first_name', 'last_name'];
        // NEU: is_community_banned hinzugefügt
        $optionalHeaders = ['birth_date', 'class_id', 'teacher_id', 'is_community_banned'];

        $fileHandle = fopen($tmpFilePath, 'r');
        if ($fileHandle === false) {
            throw new Exception("Datei konnte nicht zum Lesen geöffnet werden.");
        }

        $this->pdo->beginTransaction();

        try {
            // 1. Header-Zeile lesen und validieren
            $headers = fgetcsv($fileHandle);
            if ($headers === false) {
                throw new Exception("CSV-Datei ist leer oder konnte nicht gelesen werden.");
            }
            $headers = array_map('trim', $headers); // Leerzeichen entfernen

            // Finde die Spaltenindizes
            $colMap = [];
            foreach ($requiredHeaders as $header) {
                $index = array_search($header, $headers);
                if ($index === false) {
                    throw new Exception("Fehlende erforderliche Spalte in der CSV-Vorlage: '{$header}'.");
                }
                $colMap[$header] = $index;
            }
            foreach ($optionalHeaders as $header) {
                $colMap[$header] = array_search($header, $headers); // Speichert false, wenn nicht gefunden
            }

            // NEU: is_community_banned hinzugefügt
            $insertSql = "INSERT INTO users (username, email, password_hash, role, first_name, last_name, birth_date, class_id, teacher_id, ical_token, is_community_banned)
                                VALUES (:username, :email, :password_hash, :role, :first_name, :last_name, :birth_date, :class_id, :teacher_id, :ical_token, :is_community_banned)";
            $stmt = $this->pdo->prepare($insertSql);

            $lineNumber = 1; // Beginnt bei 1 für die Header-Zeile

            // 2. Datenzeilen verarbeiten
            while (($row = fgetcsv($fileHandle)) !== false) {
                $lineNumber++;

                // Trimme alle Werte
                $row = array_map('trim', $row);

                $userData = [];
                $userData['username'] = $row[$colMap['username']] ?? null;
                $userData['email'] = $row[$colMap['email']] ?? null;
                $userData['password'] = $row[$colMap['password']] ?? null;
                $userData['role'] = $row[$colMap['role']] ?? null;
                $userData['first_name'] = $row[$colMap['first_name']] ?? null;
                $userData['last_name'] = $row[$colMap['last_name']] ?? null;
                $userData['birth_date'] = ($colMap['birth_date'] !== false && !empty($row[$colMap['birth_date']])) ? $row[$colMap['birth_date']] : null;
                $userData['class_id'] = ($colMap['class_id'] !== false && !empty($row[$colMap['class_id']])) ? $row[$colMap['class_id']] : null;
                $userData['teacher_id'] = ($colMap['teacher_id'] !== false && !empty($row[$colMap['teacher_id']])) ? $row[$colMap['teacher_id']] : null;
                // NEU: is_community_banned aus CSV lesen
                $userData['is_community_banned'] = ($colMap['is_community_banned'] !== false && !empty($row[$colMap['is_community_banned']])) ? $row[$colMap['is_community_banned']] : '0';


                // --- Validierung ---
                if (empty($userData['username']) || empty($userData['email']) || empty($userData['password']) || empty($userData['role']) || empty($userData['first_name']) || empty($userData['last_name'])) {
                    $errorMessages[] = "Zeile {$lineNumber}: Übersprungen. Es fehlen erforderliche Felder (z.B. username, email, password, role, first_name, last_name).";
                    continue;
                }
                if ($this->findByUsernameOrEmail($userData['username'])) {
                    $errorMessages[] = "Zeile {$lineNumber}: Übersprungen. Benutzername '{$userData['username']}' ist bereits vergeben.";
                    continue;
                }
                if ($this->findByUsernameOrEmail($userData['email'])) {
                    $errorMessages[] = "Zeile {$lineNumber}: Übersprungen. E-Mail '{$userData['email']}' ist bereits vergeben.";
                    continue;
                }
                if (!in_array($userData['role'], $validationData['roles'])) {
                    $errorMessages[] = "Zeile {$lineNumber}: Übersprungen. Ungültige Rolle '{$userData['role']}'.";
                    continue;
                }
                if ($userData['role'] === 'schueler' && !empty($userData['class_id']) && !in_array($userData['class_id'], $validationData['class_ids'])) {
                    $errorMessages[] = "Zeile {$lineNumber}: Übersprungen. Klassen-ID '{$userData['class_id']}' existiert nicht.";
                    continue;
                }
                if ($userData['role'] === 'lehrer' && !empty($userData['teacher_id']) && !in_array($userData['teacher_id'], $validationData['teacher_ids'])) {
                    $errorMessages[] = "Zeile {$lineNumber}: Übersprungen. Lehrer-ID '{$userData['teacher_id']}' existiert nicht.";
                    continue;
                }
                // --- Ende Validierung ---

                // Bereinige Zuweisungen basierend auf der Rolle
                $classId = ($userData['role'] === 'schueler') ? $userData['class_id'] : null;
                $teacherId = ($userData['role'] === 'lehrer') ? $userData['teacher_id'] : null;

                // Setze auf NULL, wenn die ID 0 war
                if ($classId === '0') $classId = null;
                if ($teacherId === '0') $teacherId = null;
                
                // NEU: Sperrstatus
                $isBanned = ($userData['role'] === 'schueler' && ($userData['is_community_banned'] === '1' || strtolower($userData['is_community_banned']) === 'true')) ? 1 : 0;


                // Bereite Daten für DB vor
                $params = [
                    ':username' => $userData['username'],
                    ':email' => $userData['email'],
                    ':password_hash' => password_hash($userData['password'], PASSWORD_DEFAULT),
                    ':role' => $userData['role'],
                    ':first_name' => $userData['first_name'],
                    ':last_name' => $userData['last_name'],
                    ':birth_date' => empty($userData['birth_date']) ? null : $userData['birth_date'],
                    ':class_id' => $classId,
                    ':teacher_id' => $teacherId,
                    ':ical_token' => bin2hex(random_bytes(32)), // Eindeutigen Token generieren
                    ':is_community_banned' => $isBanned // NEU
                ];

                if (!$stmt->execute($params)) {
                    $errorMessages[] = "Zeile {$lineNumber}: Technischer Fehler beim Einfügen von '{$userData['username']}'.";
                } else {
                    $successCount++;
                }
            }

            if (!empty($errorMessages)) {
                // Wenn Fehler aufgetreten sind, mache alles rückgängig
                $this->pdo->rollBack();
                fclose($fileHandle);
                // Gebe die ersten Fehler zurück, um das UI nicht zu überfluten
                $errorMessages[] = "Transaktion abgebrochen. Keine Benutzer wurden importiert.";
                return ['successCount' => 0, 'errors' => array_slice($errorMessages, 0, 50)];
            }

            // Alles erfolgreich
            $this->pdo->commit();

        } catch (Exception $e) {
            $this->pdo->rollBack();
            fclose($fileHandle);
            throw new Exception("Fehler beim Verarbeiten der CSV-Datei: " . $e->getMessage());
        }

        fclose($fileHandle);
        return ['successCount' => $successCount, 'errors' => $errorMessages];
    }

    public function countUsersByRole(): array
    {
        try {
            $stmt = $this->pdo->query("SELECT role, COUNT(*) as count FROM users GROUP BY role");
            return $stmt->fetchAll(PDO::FETCH_KEY_PAIR) ?: [];
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Benutzer nach Rolle: " . $e->getMessage());
            return [];
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\UserRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Services\AuditLogger.php ---
<?php
// app/Services/AuditLogger.php
namespace App\Services;

use App\Core\Database;
use PDO;

/**
 * Ein einfacher statischer Service zur Protokollierung von Benutzeraktionen.
 */
class AuditLogger
{
    /**
     * Protokolliert eine Aktion in der Datenbank.
     *
     * @param string $action Die durchgeführte Aktion (z.B. 'user_login', 'plan_update').
     * @param ?int $userId Die ID des Benutzers, der die Aktion ausgeführt hat. Wird automatisch aus der Session geholt, falls nicht angegeben.
     * @param ?string $targetType Der Typ der Entität, die beeinflusst wurde (z.B. 'user', 'class', 'plan_entry').
     * @param ?string $targetId Die ID der beeinflussten Entität.
     * @param ?array $details Zusätzliche Informationen (z.B. alte/neue Daten), werden als JSON gespeichert.
     */
    public static function log(string $action, ?string $targetType = null, ?string $targetId = null, ?array $details = null)
    {
        try {
            $pdo = Database::getInstance();
            
            // Hole Benutzer-ID aus der Session, falls vorhanden
            $userId = $_SESSION['user_id'] ?? null;
            // Hole IP-Adresse
            $ipAddress = $_SERVER['REMOTE_ADDR'] ?? 'UNKNOWN';

            $sql = "INSERT INTO audit_logs (user_id, ip_address, action, target_type, target_id, details)
                    VALUES (:user_id, :ip_address, :action, :target_type, :target_id, :details)";

            $stmt = $pdo->prepare($sql);
            
            $stmt->execute([
                ':user_id' => $userId,
                ':ip_address' => $ipAddress,
                ':action' => $action,
                ':target_type' => $targetType,
                ':target_id' => $targetId,
                ':details' => $details ? json_encode($details) : null
            ]);

        } catch (\Exception $e) {
            // Fehler beim Loggen sollte die Hauptanwendung nicht stoppen.
            // Fehler im PHP-Error-Log protokollieren.
            error_log("AuditLogger Fehler: Konnte Aktion '{$action}' nicht protokollieren. Fehler: " . $e->getMessage());
        }
    }
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Services\AuditLogger.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Services\AuthenticationService.php ---
<?php
// app/Services/AuthenticationService.php
namespace App\Services;

use App\Repositories\UserRepository;
use App\Repositories\LoginAttemptRepository;
use Exception;
// NEU: AuditLogger importieren
use App\Services\AuditLogger;

class AuthenticationService
{
    private UserRepository $userRepository;
    private LoginAttemptRepository $loginAttemptRepository;

    public function __construct(UserRepository $userRepository, LoginAttemptRepository $loginAttemptRepository)
    {
        $this->userRepository = $userRepository;
        $this->loginAttemptRepository = $loginAttemptRepository;
    }

    /**
     * Führt den kompletten Login-Prozess aus, inklusive Brute-Force-Schutz.
     * @param string $identifier Der eingegebene Benutzername oder die E-Mail.
     * @param string $password Das eingegebene Passwort.
     * @return array Die Benutzerdaten bei einem erfolgreichen Login.
     * @throws Exception Wenn die Anmeldedaten ungültig sind oder der Account gesperrt ist.
     */
    public function login(string $identifier, string $password): array
    {
        // Schritt 1: Prüfen, ob der Login-Versuch überhaupt erlaubt ist (Brute-Force-Schutz)
        if (!$this->loginAttemptRepository->isAllowed($identifier)) {
            // NEU: Audit-Log für gesperrten Account
            AuditLogger::log(
                'login_lockout', 
                'user', 
                $identifier, 
                ['message' => 'Zu viele Login-Versuche.']
            );
            throw new Exception("Zu viele fehlgeschlagene Login-Versuche. Ihr Account ist vorübergehend gesperrt.");
        }

        // Schritt 2: Versuche, den Benutzer in der Datenbank zu finden.
        $user = $this->userRepository->findByUsernameOrEmail($identifier);

        // Schritt 3: Prüfen, ob ein Benutzer gefunden wurde UND ob das Passwort korrekt ist.
        if ($user && password_verify($password, $user['password_hash'])) {
            // Erfolg! Login-Versuche zurücksetzen und Benutzerdaten zurückgeben.
            $this->loginAttemptRepository->clearAttempts($identifier);
            
            // NEU: Erfolgreichen Login protokollieren
            // Temporäre Session-Daten setzen, damit der Logger die User-ID findet
            $_SESSION['user_id'] = $user['user_id']; 
            AuditLogger::log(
                'login_success', 
                'user', 
                $user['user_id']
            );
            // Session-ID wird im AuthController regeneriert
            
            // NEU: Sperrstatus für Community Board in die Session laden
            $_SESSION['is_community_banned'] = (int)($user['is_community_banned'] ?? 0);


            return $user;
        }

        // Schritt 4: Wenn die Prüfung fehlschlägt, einen fehlgeschlagenen Versuch protokollieren und einen Fehler werfen.
        $this->loginAttemptRepository->recordFailure($identifier);
        
        // NEU: Fehlgeschlagenen Login protokollieren
        AuditLogger::log(
            'login_failure', 
            'user', 
            $identifier, 
            ['message' => 'Falscher Benutzername oder Passwort.']
        );
        
        throw new Exception("Benutzername oder Passwort ist falsch.");
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Services\AuthenticationService.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Services\FileUploadService.php ---
<?php
// app/Services/FileUploadService.php

namespace App\Services;

use Exception;

/**
 * Service-Klasse zur Kapselung der Logik für Datei-Uploads.
 * Stellt eine wiederverwendbare Methode zur sicheren Verarbeitung
 * und Speicherung von hochgeladenen Dateien bereit.
 */
class FileUploadService
{
    /**
     * Basis-Upload-Verzeichnis (relativ zum 'public' Ordner).
     * @var string
     */
    private string $baseUploadDir = 'uploads/';

    /**
     * Der absolute Pfad zum 'public' Verzeichnis.
     * @var string
     */
    private string $publicPath;

    public function __construct()
    {
        // Geht 3 Ebenen vom 'app/Services' Verzeichnis hoch zum Projektstamm,
        // dann in 'public'.
        $this->publicPath = dirname(__DIR__, 2) . '/public/';
    }

    /**
     * Verarbeitet einen einzelnen Datei-Upload.
     *
     * @param string $fileKey Der Schlüssel in der $_FILES-Variable (z.B. 'site_logo' oder 'attachment').
     * @param string $subDirectory Das Unterverzeichnis (z.B. 'branding' oder 'announcements').
     * @param array $allowedMimes Erlaubte MIME-Typen (Format: ['mime/type' => 'extension']).
     * @param int $maxSize (in Bytes) Die maximale Dateigröße.
     * @return string Der relative Pfad zur gespeicherten Datei (z.B. 'uploads/branding/logo_xyz.png').
     * @throws Exception Wenn der Upload fehlschlägt (Validierung, Verschieben).
     */
    public function handleUpload(string $fileKey, string $subDirectory, array $allowedMimes, int $maxSize = 5 * 1024 * 1024): string
    {
        // 1. Prüfen, ob eine Datei hochgeladen wurde und kein Fehler vorliegt
        if (!isset($_FILES[$fileKey]) || $_FILES[$fileKey]['error'] !== UPLOAD_ERR_OK) {
            throw new Exception("Keine Datei hochgeladen oder Fehler beim Upload (Code: {$_FILES[$fileKey]['error']}).", 400);
        }

        $file = $_FILES[$fileKey];

        // 2. Größe prüfen
        if ($file['size'] > $maxSize) {
            throw new Exception("Datei ist zu groß (Max: " . ($maxSize / 1024 / 1024) . "MB).", 400);
        }

        // 3. MIME-Typ validieren
        $fileType = mime_content_type($file['tmp_name']);
        if (!array_key_exists($fileType, $allowedMimes)) {
            throw new Exception("Ungültiger Dateityp. Erlaubt: " . implode(', ', array_keys($allowedMimes)), 400);
        }

        // 4. Zielverzeichnis erstellen
        $targetDirectory = $this->publicPath . $this->baseUploadDir . $subDirectory;
        if (!is_dir($targetDirectory) && !@mkdir($targetDirectory, 0775, true)) {
            error_log("Konnte Upload-Verzeichnis nicht erstellen: " . $targetDirectory);
            throw new Exception("Upload-Verzeichnis konnte nicht erstellt werden.", 500);
        }
        if (!is_writable($targetDirectory)) {
            error_log("Upload-Verzeichnis nicht beschreibbar: " . $targetDirectory);
            throw new Exception("Upload-Verzeichnis ist nicht beschreibbar.", 500);
        }

        // 5. Sicherer Dateiname generieren
        $extension = $allowedMimes[$fileType];
        // Dateiname basiert auf dem $fileKey und einer unique ID
        $fileName = $fileKey . '_' . uniqid() . '.' . $extension;
        $targetPath = $targetDirectory . DIRECTORY_SEPARATOR . $fileName;

        // 6. Datei verschieben
        if (move_uploaded_file($file['tmp_name'], $targetPath)) {
            // 7. Relativen Pfad für die DB zurückgeben
            // (Ersetze Backslashes (Windows) durch Slashes für Web-Pfade)
            $relativePath = $this->baseUploadDir . $subDirectory . '/' . $fileName;
            return str_replace(DIRECTORY_SEPARATOR, '/', $relativePath);
        } else {
            error_log("Fehler beim Verschieben der hochgeladenen Datei nach: " . $targetPath);
            throw new Exception("Fehler beim Verschieben der hochgeladenen Datei.", 500);
        }
    }

    /**
     * Löscht eine Datei basierend auf ihrem relativen Pfad.
     *
     * @param string|null $relativePath Der relative Pfad (z.B. 'uploads/branding/logo_xyz.png').
     * @return bool True bei Erfolg oder wenn $relativePath null war, False bei Fehler.
     */
    public function deleteFile(?string $relativePath): bool
    {
        if (empty($relativePath)) {
            return true; // Nichts zu tun
        }

        $absolutePath = $this->publicPath . str_replace('/', DIRECTORY_SEPARATOR, $relativePath);

        if (file_exists($absolutePath)) {
            if (@unlink($absolutePath)) {
                return true;
            } else {
                error_log("Konnte Datei nicht löschen: " . $absolutePath);
                return false; // Fehler beim Löschen, aber wir werfen keine Exception
            }
        }
        
        return true; // Datei existierte nicht, also "erfolgreich" gelöscht
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Services\FileUploadService.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Services\IcalService.php ---
<?php
// app/Services/IcalService.php

namespace App\Services;

use App\Repositories\UserRepository;
use App\Repositories\PlanRepository;
use App\Repositories\AcademicEventRepository;
use App\Core\Utils;
use PDO;
use Exception;
use DateTime;
use DateTimeImmutable;
use DateTimeZone;

/**
 * Service-Klasse zur Kapselung der Logik für die iCal-Feed-Generierung.
 * (Ausgelagert aus IcalController).
 */
class IcalService
{
    private UserRepository $userRepository;
    private PlanRepository $planRepository;
    private AcademicEventRepository $eventRepository;
    private array $settings;

    // Zeitdefinitionen (konsistent mit PdfController)
    private const PERIOD_TIMES = [
        1 => ['start' => '0800', 'end' => '0845'],
        2 => ['start' => '0855', 'end' => '0940'],
        3 => ['start' => '0940', 'end' => '1025'],
        4 => ['start' => '1035', 'end' => '1120'],
        5 => ['start' => '1120', 'end' => '1205'],
        6 => ['start' => '1305', 'end' => '1350'],
        7 => ['start' => '1350', 'end' => '1435'],
        8 => ['start' => '1445', 'end' => '1530'],
        9 => ['start' => '1530', 'end' => '1615'],
        10 => ['start' => '1625', 'end' => '1710'],
    ];

    public function __construct(
        UserRepository $userRepository,
        PlanRepository $planRepository,
        AcademicEventRepository $eventRepository,
        array $settings
    ) {
        $this->userRepository = $userRepository;
        $this->planRepository = $planRepository;
        $this->eventRepository = $eventRepository;
        $this->settings = $settings;
    }

    /**
     * Hauptmethode zur Generierung des iCal-Feeds für einen Benutzer-Token.
     *
     * @param string $token Der eindeutige iCal-Token des Benutzers.
     * @return string Der vollständige iCal-Feed als String.
     * @throws Exception Wenn der Feed deaktiviert ist, der Token ungültig ist oder Daten fehlen.
     */
    public function generateFeed(string $token): string
    {
        // 1. Prüfen, ob iCal global aktiviert ist
        if (empty($this->settings['ical_enabled'])) {
            throw new Exception("Kalender-Feeds sind derzeit systemweit deaktiviert.", 503);
        }

        // 2. Benutzer validieren
        $user = $this->userRepository->findByIcalToken($token);
        if (!$user) {
            throw new Exception("Ungültiger oder unbekannter Kalender-Feed-Token.", 404);
        }

        // 3. Benutzer-Typ bestimmen
        $userRole = $user['role'];
        $classId = ($userRole === 'schueler' && !empty($user['class_id'])) ? (int)$user['class_id'] : null;
        $teacherId = ($userRole === 'lehrer' && !empty($user['teacher_id'])) ? (int)$user['teacher_id'] : null;
        $teacherUserId = ($userRole === 'lehrer') ? (int)$user['user_id'] : null;

        if (($userRole !== 'schueler' && $userRole !== 'lehrer') || ($userRole === 'schueler' && !$classId) || ($userRole === 'lehrer' && !$teacherId)) {
            throw new Exception("Kalender-Feed nur für gültige Schüler- oder Lehrerprofile verfügbar.", 403);
        }

        // 4. Daten abrufen
        $timezone = new DateTimeZone('Europe/Berlin');
        $now = new DateTimeImmutable('now', $timezone);
        $currentWeekInfo = $this->getWeekYear($now);
        $currentYear = $currentWeekInfo['year'];
        $currentWeek = $currentWeekInfo['week'];

        $allEventsData = [];
        $rangeWeeksBefore = 1;
        $rangeWeeksAfter = $this->settings['ical_weeks_future'];

        try {
            for ($weekOffset = -$rangeWeeksBefore; $weekOffset <= $rangeWeeksAfter; $weekOffset++) {
                $dt = $now->modify('+' . ($weekOffset * 7) . ' days');
                $weekInfo = $this->getWeekYear($dt);
                $targetYear = $weekInfo['year'];
                $targetWeek = $weekInfo['week'];

                $targetGroup = ($userRole === 'schueler') ? 'student' : 'teacher';
                $academicEventsForWeek = [];

                if ($this->planRepository->isWeekPublishedFor($targetGroup, $targetYear, $targetWeek)) {
                    $timetable = [];
                    $substitutions = [];
                    if ($classId) {
                        $timetable = $this->planRepository->getPublishedTimetableForClass($classId, $targetYear, $targetWeek);
                        $substitutions = $this->planRepository->getPublishedSubstitutionsForClassWeek($classId, $targetYear, $targetWeek);
                        $academicEventsForWeek = $this->eventRepository->getEventsForClassByWeek($classId, $targetYear, $targetWeek);
                    } elseif ($teacherId && $teacherUserId) {
                        $timetable = $this->planRepository->getPublishedTimetableForTeacher($teacherId, $targetYear, $targetWeek);
                        $substitutions = $this->planRepository->getPublishedSubstitutionsForTeacherWeek($teacherId, $targetYear, $targetWeek);
                        [$startDate, $endDate] = $this->getWeekDateRange($targetYear, $targetWeek);
                        $academicEventsForWeek = $this->eventRepository->getEventsByTeacherForDateRange($teacherUserId, $startDate, $endDate);
                    }

                    $this->processWeekData($allEventsData, $timetable, $substitutions, $targetYear, $targetWeek, $timezone, $userRole);
                    $this->processAcademicEvents($allEventsData, $academicEventsForWeek, $timezone);
                }
            } // End week loop
        } catch (Exception $e) {
            error_log("iCal feed generation error for token {$token}: " . $e->getMessage());
            throw new Exception("Fehler beim Abrufen der Kalenderdaten.", 500);
        }

        // 5. Als iCalendar formatieren
        return $this->formatAsIcs($allEventsData, $user);
    }

    // --- Private Hilfsmethoden (aus IcalController übernommen) ---

    private function getWeekYear(DateTimeImmutable $date): array
    {
        $year = (int)$date->format('o'); // ISO-8601 year
        $week = (int)$date->format('W'); // ISO-8601 week number
        return ['week' => $week, 'year' => $year];
    }

    private function getWeekDateRange(int $year, int $week): array
    {
        $dto = new DateTime();
        $dto->setISODate($year, $week, 1); // Montag
        $startDate = $dto->format('Y-m-d');
        $dto->setISODate($year, $week, 7); // Sonntag
        $endDate = $dto->format('Y-m-d');
        return [$startDate, $endDate];
    }

    private function getDateForDayOfWeek(int $year, int $week, int $dayNum, DateTimeZone $timezone): DateTimeImmutable
    {
        $dt = new DateTimeImmutable("{$year}-W" . sprintf('%02d', $week) . "-{$dayNum}", $timezone);
        return $dt->setTime(0, 0, 0);
    }

    private function processWeekData(array &$events, array $timetable, array $substitutions, int $year, int $week, DateTimeZone $timezone, string $userRole): void
    {
        $processedRegularSlots = [];
        $substitutionMap = [];
        foreach ($substitutions as $sub) {
            $key = $sub['date'] . '-' . $sub['period_number'];
            $substitutionMap[$key] = $sub;
        }

        // --- Vertretungen zuerst verarbeiten ---
        foreach ($substitutions as $sub) {
            $subKey = $sub['date'] . '-' . $sub['period_number'];
            if (isset($processedRegularSlots[$subKey])) continue;

            $period = (int)$sub['period_number'];
            $times = self::PERIOD_TIMES[$period] ?? null;
            if (!$times) continue;

            try {
                $dateObj = new DateTimeImmutable($sub['date'] . ' 00:00:00', $timezone);
            } catch (Exception $e) {
                error_log("Invalid date format in substitution: " . $sub['date']);
                continue;
            }

            $dtStart = $dateObj->setTime((int)substr($times['start'], 0, 2), (int)substr($times['start'], 2, 2));
            $dtEnd = $dateObj->setTime((int)substr($times['end'], 0, 2), (int)substr($times['end'], 2, 2));

            // Auf mehrstündige Vertretungen prüfen
            $span = 1;
            while (true) {
                $nextPeriod = $period + $span;
                $nextSubKey = $sub['date'] . '-' . $nextPeriod;
                if (isset(self::PERIOD_TIMES[$nextPeriod]) && isset($substitutionMap[$nextSubKey])) {
                    $nextSub = $substitutionMap[$nextSubKey];
                    if ($nextSub['substitution_type'] === $sub['substitution_type'] &&
                        $nextSub['comment'] === $sub['comment'] &&
                        $nextSub['new_teacher_id'] === $sub['new_teacher_id'] &&
                        $nextSub['new_subject_id'] === $sub['new_subject_id'] &&
                        $nextSub['new_room_id'] === $sub['new_room_id'])
                    {
                         $nextTimes = self::PERIOD_TIMES[$nextPeriod];
                         $dtEnd = $dateObj->setTime((int)substr($nextTimes['end'], 0, 2), (int)substr($nextTimes['end'], 2, 2));
                         $processedRegularSlots[$nextSubKey] = true;
                         $span++;
                    } else {
                         break;
                    }
                } else {
                     break;
                }
            }

            // Originaleintrag für Kontext finden
            $originalEntry = null;
            if ($sub['substitution_type'] !== 'Sonderevent') {
                 $dbDayNum = $dateObj->format('N');
                 $originalEntry = array_values(array_filter($timetable,
                    fn($e) => $e['day_of_week'] == $dbDayNum && $e['period_number'] == $period
                 ))[0] ?? null;
            }

            $summary = '';
            $description = "Typ: " . $sub['substitution_type'] . "\n";
            $location = $sub['new_room_name'] ?? $originalEntry['room_name'] ?? '';
            $status = 'CONFIRMED';

            switch ($sub['substitution_type']) {
                case 'Entfall':
                    $summary = "ENTFALL: " . ($originalEntry['subject_shortcut'] ?? 'Unterricht');
                    $description .= "Ursprünglich: " . ($originalEntry['subject_shortcut'] ?? '?') . " bei " . ($originalEntry['teacher_shortcut'] ?? '?') . "\n";
                    $location = '';
                    $status = 'CANCELLED';
                    break;
                case 'Raumänderung':
                    $summary = ($originalEntry['subject_shortcut'] ?? 'Unterricht') . " in Raum " . ($sub['new_room_name'] ?? '???');
                    $description .= "Neuer Raum: " . ($sub['new_room_name'] ?? '???') . "\n";
                    $description .= "Fach: " . ($originalEntry['subject_shortcut'] ?? '?') . "\n";
                    $description .= "Lehrer/Klasse: " . ($userRole === 'schueler' ? ($originalEntry['teacher_shortcut'] ?? '?') : ($originalEntry['class_name'] ?? '?')) . "\n";
                    break;
                case 'Sonderevent':
                    $summary = $sub['comment'] ?: 'Sonderevent';
                    $location = $sub['new_room_name'] ?? '';
                    break;
                case 'Vertretung':
                default:
                    $subject = $sub['new_subject_shortcut'] ?? $originalEntry['subject_shortcut'] ?? '???';
                    $teacher = $sub['new_teacher_shortcut'] ?? '???';
                    $class = $sub['class_name'] ?? $originalEntry['class_name'] ?? '???';
                    $summary = "VERTR.: {$subject} - " . ($userRole === 'schueler' ? $teacher : $class);
                    $description .= "Fach: {$subject}\n";
                    $description .= "Lehrer: {$teacher}\n";
                    $description .= "Raum: " . ($sub['new_room_name'] ?? $originalEntry['room_name'] ?? '???') . "\n";
                    if ($originalEntry) {
                         $description .= "Ursprünglich: " . $originalEntry['subject_shortcut'] . " bei " . $originalEntry['teacher_shortcut'] . "\n";
                    }
                    break;
            }
            if ($sub['comment'] && $sub['substitution_type'] !== 'Sonderevent') {
                $description .= "Kommentar: " . $sub['comment'] . "\n";
            }

            $events[] = [
                'uid' => 'sub-' . $sub['substitution_id'],
                'dtStart' => $dtStart,
                'dtEnd' => $dtEnd,
                'summary' => $summary,
                'location' => $location,
                'description' => trim($description),
                'status' => $status,
            ];

             $processedRegularSlots[$subKey] = true;
        }

        // --- Reguläre Einträge verarbeiten ---
        foreach ($timetable as $entry) {
            $dayNum = (int)$entry['day_of_week'];
            $period = (int)$entry['period_number'];
            $regKey = $this->getDateForDayOfWeek($year, $week, $dayNum, $timezone)->format('Y-m-d') . '-' . $period;
            $blockId = $entry['block_id'];

            if (isset($substitutionMap[$regKey]) || isset($processedRegularSlots[$regKey]) || ($blockId && isset($processedRegularSlots[$blockId]))) {
                continue;
            }

            $times = self::PERIOD_TIMES[$period] ?? null;
            if (!$times) continue;

            $dateObj = $this->getDateForDayOfWeek($year, $week, $dayNum, $timezone);
            $dtStart = $dateObj->setTime((int)substr($times['start'], 0, 2), (int)substr($times['start'], 2, 2));
            $dtEnd = $dateObj->setTime((int)substr($times['end'], 0, 2), (int)substr($times['end'], 2, 2));
            $uidBase = 'entry-' . $entry['entry_id'];

            if ($blockId) {
                $blockEntries = array_filter($timetable, fn($e) => $e['block_id'] === $blockId);
                if (!empty($blockEntries)) {
                    $minPeriod = min(array_column($blockEntries, 'period_number'));
                    $maxPeriod = max(array_column($blockEntries, 'period_number'));
                    if ($period === $minPeriod) {
                         $startTime = self::PERIOD_TIMES[$minPeriod]['start'] ?? null;
                         $endTime = self::PERIOD_TIMES[$maxPeriod]['end'] ?? null;
                         if ($startTime && $endTime) {
                             $dtStart = $dateObj->setTime((int)substr($startTime, 0, 2), (int)substr($startTime, 2, 2));
                             $dtEnd = $dateObj->setTime((int)substr($endTime, 0, 2), (int)substr($endTime, 2, 2));
                         }
                         $uidBase = 'block-' . $blockId;
                         for ($p = $minPeriod; $p <= $maxPeriod; $p++) {
                             $blockKey = $dateObj->format('Y-m-d') . '-' . $p;
                             $processedRegularSlots[$blockKey] = true;
                         }
                         $processedRegularSlots[$blockId] = true;
                    } else {
                         continue;
                    }
                }
            } else {
                 $processedRegularSlots[$regKey] = true;
            }

            $summary = ($entry['subject_shortcut'] ?? '???') . " - " . ($userRole === 'schueler' ? ($entry['teacher_shortcut'] ?? '???') : ($entry['class_name'] ?? '???'));
            $description = "Fach: " . ($entry['subject_name'] ?? $entry['subject_shortcut'] ?? '???') . "\n";
            $description .= "Lehrer: " . ($entry['teacher_shortcut'] ?? '???') . "\n";
            $description .= "Klasse: " . ($entry['class_name'] ?? '???') . "\n";
            $description .= "Raum: " . ($entry['room_name'] ?? '???') . "\n";
            if (!empty($entry['comment'])) {
                $description .= "Kommentar: " . $entry['comment'] . "\n";
            }

            $events[] = [
                'uid' => $uidBase,
                'dtStart' => $dtStart,
                'dtEnd' => $dtEnd,
                'summary' => $summary,
                'location' => $entry['room_name'] ?? '',
                'description' => trim($description),
                'status' => 'CONFIRMED',
            ];
        }
    }

    private function processAcademicEvents(array &$events, array $academicEvents, DateTimeZone $timezone): void
    {
        foreach ($academicEvents as $event) {
            try {
                $dateObj = new DateTimeImmutable($event['due_date'] . ' 00:00:00', $timezone);
            } catch (Exception $e) {
                error_log("Invalid date format in academic event: " . $event['due_date']);
                continue;
            }

            // KORREKTUR: period_number existiert nicht mehr im academic_events Schema (V10)
            // $period = $event['period_number'] ? (int)$event['period_number'] : null;
            // $times = $period ? (self::PERIOD_TIMES[$period] ?? null) : null;
            $times = null; // Events sind jetzt immer ganztägig

            if ($times) {
                // (Dieser Block wird nicht mehr ausgeführt)
                $dtStart = $dateObj->setTime((int)substr($times['start'], 0, 2), (int)substr($times['start'], 2, 2));
                $dtEnd = $dateObj->setTime((int)substr($times['end'], 0, 2), (int)substr($times['end'], 2, 2));
                $dtStartFormat = 'Ymd\THis';
                $dtEndFormat = 'Ymd\THis';
                // $timeInfo = " ({$period}. Std.)"; // Veraltet
                $timeInfo = ""; // NEU
            } else {
                // Ganztägiges Event
                $dtStart = $dateObj;
                $dtEnd = $dateObj->modify('+1 day');
                $dtStartFormat = 'Ymd';
                $dtEndFormat = 'Ymd';
                $timeInfo = "";
            }

            $icon = 'ℹ️'; $prefix = 'Info';
            if ($event['event_type'] === 'klausur') { $icon = '🎓'; $prefix = 'Klausur'; }
            if ($event['event_type'] === 'aufgabe') { $icon = '📚'; $prefix = 'Aufgabe'; }

            $summary = "{$icon} {$prefix}: " . ($event['title'] ?? 'Eintrag');
            if ($event['subject_shortcut']) {
                $summary .= " (" . $event['subject_shortcut'] . ")";
            }

            $description = "Typ: " . ucfirst($event['event_type']) . "\n";
            $description .= "Fach: " . ($event['subject_shortcut'] ?? '-') . "\n";
            if (isset($event['teacher_first_name'])) {
                 $description .= "Lehrer: " . $event['teacher_first_name'] . ' ' . $event['teacher_last_name'] . "\n";
            }
            if (isset($event['class_name'])) {
                 $description .= "Klasse: " . $event['class_name'] . "\n";
            }
            $description .= "Datum: " . $dateObj->format('d.m.Y') . $timeInfo . "\n";
            if ($event['description']) {
                $description .= "\nBeschreibung:\n" . $event['description'];
            }

            $events[] = [
                'uid' => 'acad-' . $event['event_id'],
                'dtStart' => $dtStart,
                'dtEnd' => $dtEnd,
                'dtStartFormat' => $dtStartFormat,
                'dtEndFormat' => $dtEndFormat,
                'summary' => $summary,
                'location' => '',
                'description' => trim($description),
                'status' => 'CONFIRMED',
            ];
        }
    }

    private function formatAsIcs(array $events, array $user): string
    {
        $ics = "BEGIN:VCALENDAR\r\n";
        $ics .= "VERSION:2.0\r\n";
        $ics .= "PRODID:-//PMI//PAUSE Stundenplan v1.0//DE\r\n";
        $ics .= "CALSCALE:GREGORIAN\r\n";
        $ics .= "METHOD:PUBLISH\r\n";
        $ics .= "X-WR-CALNAME:PAUSE Stundenplan (" . $this->escapeIcsString($user['username']) . ")\r\n";
        $ics .= "X-WR-TIMEZONE:Europe/Berlin\r\n";
        $ics .= "X-PUBLISHED-TTL:PT1H\r\n";

        $ics .= "BEGIN:VTIMEZONE\r\n";
        $ics .= "TZID:Europe/Berlin\r\n";
        $ics .= "X-LIC-LOCATION:Europe/Berlin\r\n";
        $ics .= "BEGIN:DAYLIGHT\r\n";
        $ics .= "TZOFFSETFROM:+0100\r\n";
        $ics .= "TZOFFSETTO:+0200\r\n";
        $ics .= "TZNAME:CEST\r\n";
        $ics .= "DTSTART:19700329T020000\r\n";
        $ics .= "RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\n";
        $ics .= "END:DAYLIGHT\r\n";
        $ics .= "BEGIN:STANDARD\r\n";
        $ics .= "TZOFFSETFROM:+0200\r\n";
        $ics .= "TZOFFSETTO:+0100\r\n";
        $ics .= "TZNAME:CET\r\n";
        $ics .= "DTSTART:19701025T030000\r\n";
        $ics .= "RRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\n";
        $ics .= "END:STANDARD\r\n";
        $ics .= "END:VTIMEZONE\r\n";

        $nowUtc = gmdate('Ymd\THis\Z');

        foreach ($events as $event) {
            $dtStart = $event['dtStart'];
            $dtEnd = $event['dtEnd'];
            $dtStartFormat = $event['dtStartFormat'] ?? 'Ymd\THis';
            $dtEndFormat = $event['dtEndFormat'] ?? 'Ymd\THis';
            $dtStartString = $dtStart->format($dtStartFormat);
            $dtEndString = $dtEnd->format($dtEndFormat);
            $datePrefix = ($dtStartFormat === 'Ymd') ? ';VALUE=DATE' : ';TZID=Europe/Berlin';

            $ics .= "BEGIN:VEVENT\r\n";
            $ics .= "UID:" . $event['uid'] . '-' . $dtStart->format('YmdHis') . "@pause.pmi\r\n";
            $ics .= "DTSTAMP:" . $nowUtc . "\r\n";
            $ics .= "DTSTART{$datePrefix}:" . $dtStartString . "\r\n";
            $ics .= "DTEND{$datePrefix}:" . $dtEndString . "\r\n";
            $ics .= "SUMMARY:" . $this->escapeIcsString($event['summary']) . "\r\n";
            if (!empty($event['location'])) {
                $ics .= "LOCATION:" . $this->escapeIcsString($event['location']) . "\r\n";
            }
            if (!empty($event['description'])) {
                $ics .= "DESCRIPTION:" . $this->escapeIcsString($event['description']) . "\r\n";
            }
            $ics .= "STATUS:" . $event['status'] . "\r\n";
            $ics .= ($dtStartFormat === 'Ymd') ? "TRANSP:TRANSPARENT\r\n" : "TRANSP:OPAQUE\r\n";
            $ics .= "END:VEVENT\r\n";
        }

        $ics .= "END:VCALENDAR\r\n";
        return $ics;
    }

    private function escapeIcsString(?string $string): string
    {
        