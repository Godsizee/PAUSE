--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Cache.php ---
<?php
namespace App\Core; 
class Cache
{
    private static function getCacheDir(): string
    {
        return dirname(__DIR__, 2) . '/cache/';
    }
    public static function clearAll(): array
    {
        $cacheDir = self::getCacheDir();
        if (!is_dir($cacheDir)) {
            return ['success' => true, 'message' => 'Cache-Verzeichnis existiert nicht, nichts zu tun.'];
        }
        $files = glob($cacheDir . '*.cache');
        $successCount = 0;
        $failCount = 0;
        if ($files === false) {
            error_log("Fehler beim Lesen des Cache-Verzeichnisses: " . $cacheDir);
            return ['success' => false, 'message' => 'Fehler beim Lesen des Cache-Verzeichnisses.'];
        }
        foreach ($files as $file) {
            if (is_file($file)) {
                if (@unlink($file)) { 
                    $successCount++;
                } else {
                    $failCount++;
                    error_log("Konnte Cache-Datei nicht löschen: " . $file);
                }
            }
        }
        if ($failCount > 0) {
            return [
                'success' => false,
                'message' => "Konnte $failCount von " . ($successCount + $failCount) . " Cache-Dateien nicht löschen. Details im Server-Log."
            ];
        }
        if ($successCount === 0) {
            return ['success' => true, 'message' => 'App-Cache war bereits leer.'];
        }
        return ['success' => true, 'message' => "Erfolgreich $successCount App-Cache-Datei(en) gelöscht."];
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Cache.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Database.php ---
<?php
namespace App\Core;
use PDO;
use PDOException;
use RuntimeException;
class Database
{
    private static ?PDO $instance = null;
    private static array $config = [];
    private function __construct() {}
    private function __clone() {}
    public static function getConfig(): array
    {
        if (empty(self::$config)) {
            self::$config = require __DIR__ . '/../../config/database_access.php';
        }
        return self::$config;
    }
    public static function getInstance(): PDO
    {
        if (self::$instance === null) {
            $config = self::getConfig();
            $dsn = "mysql:host={$config['db_host']};port={$config['db_port']};dbname={$config['db_name']};charset={$config['db_charset']}";
            $options = [
                PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                PDO::ATTR_EMULATE_PREPARES   => true,
            ];
            try {
                self::$instance = new PDO($dsn, $config['db_user'], $config['db_pass'], $options);
            } catch (PDOException $e) {
                error_log("Database connection error: " . $e->getMessage());
                throw new RuntimeException("Database connection could not be established.");
            }
        }
        return self::$instance;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Database.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Router.php ---
<?php
namespace App\Core;
class Router
{
    private array $routes = [];
    public function add(string $pattern, $handler): void
    {
        $this->routes[$pattern] = $handler;
    }
    public function resolve(string $uri): ?array
    {
        foreach ($this->routes as $pattern => $handler) {
            if (preg_match($pattern, $uri, $matches)) {
                array_shift($matches); 
                return [
                    'handler' => $handler,
                    'matches' => $matches
                ];
            }
        }
        return null;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Router.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Security.php ---
<?php
namespace App\Core;
use Exception; 
class Security
{
    public static function requireLogin(): void
    {
        if (!isset($_SESSION['user_id'])) {
            header("Location: " . Utils::url('login'));
            exit();
        }
    }
    public static function requireRole($requiredRoles): void
    {
        self::requireLogin();
        if (!is_array($requiredRoles)) {
            $requiredRoles = [$requiredRoles];
        }
        $userRole = $_SESSION['user_role'] ?? '';
        if (!in_array($userRole, $requiredRoles)) {
            http_response_code(403);
            die("Zugriff verweigert. Sie haben nicht die erforderliche Rolle (" . htmlspecialchars($userRole) . "). Benötigt: " . implode(', ', $requiredRoles));
        }
    }
    public static function getCsrfToken(): string
    {
        if (empty($_SESSION['csrf_token'])) {
            $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
        }
        return $_SESSION['csrf_token'];
    }
    public static function verifyCsrfToken(): void
    {
        $submittedToken = $_POST['_csrf_token'] ?? $_SERVER['HTTP_X_CSRF_TOKEN'] ?? null;
        $sessionToken = $_SESSION['csrf_token'] ?? null;
        if (!$submittedToken || !$sessionToken || !hash_equals($sessionToken, $submittedToken)) {
             http_response_code(403); 
             error_log("CSRF token validation failed. Submitted: " . ($submittedToken ?? 'NULL') . ", Session: " . ($sessionToken ?? 'NULL') . ", IP: " . ($_SERVER['REMOTE_ADDR'] ?? 'UNKNOWN'));
             if (!empty($_SERVER['HTTP_X_REQUESTED_WITH']) && strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) == 'xmlhttprequest') {
                 header('Content-Type: application/json');
                 throw new Exception("Sicherheitsüberprüfung fehlgeschlagen (CSRF-Token ungültig oder fehlt).");
             } else {
                 throw new Exception("Sicherheitsüberprüfung fehlgeschlagen (CSRF). Bitte gehen Sie zurück und versuchen Sie es erneut.");
             }
        }
    }
    public static function csrfInput(): void
    {
        echo '<input type="hidden" name="_csrf_token" value="' . htmlspecialchars(self::getCsrfToken()) . '">';
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Security.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Utils.php ---
<?php
namespace App\Core;
use App\Repositories\SettingsRepository; 
use Exception; 
class Utils
{
    private static ?array $settingsCache = null; 
    public static function url(string $path): string
    {
        $base_url = rtrim(Database::getConfig()['base_url'], '/');
        if (empty($path) || $path === '/') {
            return $base_url . '/';
        }
        return $base_url . '/' . ltrim($path, '/');
    }
    public static function getSettings(): array
    {
        if (self::$settingsCache !== null) {
            return self::$settingsCache;
        }
        $defaultSettings = [
            'site_title' => 'PAUSE Portal',
            'maintenance_mode' => '0', 
            'maintenance_message' => 'Die Anwendung wird gerade gewartet. Bitte versuchen Sie es später erneut.',
            'maintenance_whitelist_ips' => "127.0.0.1, ::1", 
            'default_start_hour' => 1,
            'default_end_hour' => 10,
            'max_login_attempts' => 5,
            'lockout_minutes' => 15,
            'site_logo_path' => null,
            'site_favicon_path' => null,
            'default_theme' => 'light',
            'ical_enabled' => '1',
            'ical_weeks_future' => 8,
            'pdf_footer_text' => 'PAUSE Portal - PMI - Ein Produkt des PMI.',
            'community_board_enabled' => '1', 
        ];
        try {
            $settingsRepo = new SettingsRepository();
            $dbSettings = $settingsRepo->loadSettings();
        } catch (Exception $e) {
            error_log("Hinweis: Konnte Einstellungen nicht aus der DB laden, verwende Standardwerte. Fehler: " . $e->getMessage());
            $dbSettings = [];
        }
        $finalSettings = array_merge($defaultSettings, $dbSettings);
        $finalSettings['maintenance_mode'] = (($finalSettings['maintenance_mode'] ?? '0') === '1' || ($finalSettings['maintenance_mode'] ?? false) === true);
        $finalSettings['default_start_hour'] = (int)($finalSettings['default_start_hour'] ?? 1);
        $finalSettings['default_end_hour'] = (int)($finalSettings['default_end_hour'] ?? 10);
        $finalSettings['max_login_attempts'] = (int)($finalSettings['max_login_attempts'] ?? 5);
        $finalSettings['lockout_minutes'] = (int)($finalSettings['lockout_minutes'] ?? 15);
        $finalSettings['ical_enabled'] = (($finalSettings['ical_enabled'] ?? '1') === '1' || ($finalSettings['ical_enabled'] ?? false) === true);
        $finalSettings['ical_weeks_future'] = (int)($finalSettings['ical_weeks_future'] ?? 8);
        $finalSettings['community_board_enabled'] = (($finalSettings['community_board_enabled'] ?? '1') === '1' || ($finalSettings['community_board_enabled'] ?? false) === true);
        self::$settingsCache = $finalSettings;
        return $finalSettings;
    }
    public static function clearSettingsCache(): void
    {
        self::$settingsCache = null;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Utils.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\AnnouncementController.php ---
<?php
namespace App\Http\Controllers\Admin;
use App\Core\Database;
use App\Core\Security;
use App\Repositories\AnnouncementRepository;
use App\Repositories\StammdatenRepository;
use App\Repositories\UserRepository;
use Exception;
use PDO;
use \Parsedown; 
class AnnouncementController
{
    private PDO $pdo;
    private AnnouncementRepository $announcementRepo;
    private StammdatenRepository $stammdatenRepo;
    private UserRepository $userRepo;
    private Parsedown $parsedown; 
    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->announcementRepo = new AnnouncementRepository($this->pdo);
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
        $this->parsedown = new Parsedown(); 
        $this->parsedown->setSafeMode(true); 
    }
    public function index()
    {
        Security::requireRole(['admin', 'planer', 'lehrer']);
        global $config;
        $config = Database::getConfig();
        $page_title = 'Ankündigungsverwaltung';
        $body_class = 'admin-dashboard-body';
        try {
             $userRole = $_SESSION['user_role'] ?? 'Unbekannt';
             $userId = $_SESSION['user_id'] ?? null;
             $user = $userId ? $this->userRepo->findById($userId) : null;
             $allAnnouncements = $this->announcementRepo->getAllAnnouncementsWithDetails();
             $availableClasses = [];
             if (in_array($userRole, ['admin', 'planer'])) {
                 $availableClasses = $this->stammdatenRepo->getClasses();
             } elseif ($userRole === 'lehrer' && $user && isset($user['teacher_id'])) {
                 $availableClasses = $this->stammdatenRepo->getClasses(); 
             }
             foreach ($allAnnouncements as &$announcement) {
                 $announcement['content_html'] = $this->parsedown->text($announcement['content'] ?? '');
                if (!empty($announcement['file_path'])) {
                    $announcement['file_url'] = rtrim($config['base_url'], '/') . '/' . ltrim($announcement['file_path'], '/');
                } else {
                    $announcement['file_url'] = null;
                }
             }
             unset($announcement); 
            Security::getCsrfToken();
            include_once dirname(__DIR__, 4) .'/pages/admin/announcements.php';
        } catch (Exception $e) {
             error_log("Error loading announcement admin page: " . $e->getMessage());
             http_response_code(500);
             die("Ein Fehler ist beim Laden der Seite aufgetreten: " . $e->getMessage());
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\AnnouncementController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\AuditLogController.php ---
<?php
namespace App\Http\Controllers\Admin;
use App\Core\Security;
use App\Core\Database;
use App\Repositories\AuditLogRepository;
use App\Repositories\UserRepository;
use PDO;
use Exception;
use App\Http\Traits\ApiHandlerTrait; // NEU

class AuditLogController
{
    use ApiHandlerTrait; // NEU

    private PDO $pdo;
    private AuditLogRepository $logRepo;
    private UserRepository $userRepo;
    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->logRepo = new AuditLogRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
    }

    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();
        $page_title = 'Audit Log (Protokoll)';
        $body_class = 'admin-dashboard-body';
        try {
            $availableUsers = $this->userRepo->getAll();
            $availableActions = $this->logRepo->getDistinctActions();
            $availableTargetTypes = $this->logRepo->getDistinctTargetTypes();
            include_once dirname(__DIR__, 4) .'/pages/admin/audit_logs.php';
        } catch (Exception $e) {
            error_log("Fehler beim Laden der Audit-Log-Seite: " . $e->getMessage());
            http_response_code(500);
            die("Ein kritischer Fehler ist aufgetreten: " . $e->getMessage());
        }
    }

    public function getLogsApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von $_GET
            $page = filter_var($data['page'] ?? 1, FILTER_VALIDATE_INT, ['options' => ['default' => 1, 'min_range' => 1]]);
            $limit = 20;
            $filters = [
                'user_id' => filter_var($data['user_id'] ?? null, FILTER_VALIDATE_INT) ?: null,
                'action' => filter_var($data['action'] ?? null, FILTER_UNSAFE_RAW) ?: null,
                'target_type' => filter_var($data['target_type'] ?? null, FILTER_UNSAFE_RAW) ?: null,
                'start_date' => filter_var($data['start_date'] ?? null, FILTER_UNSAFE_RAW) ?: null,
                'end_date' => filter_var($data['end_date'] ?? null, FILTER_UNSAFE_RAW) ?: null,
            ];
            $filters = array_filter($filters, function($value) {
                return $value !== null && $value !== '';
            });

            $logs = $this->logRepo->getLogs($page, $limit, $filters);
            $totalCount = $this->logRepo->getLogsCount($filters);
            $totalPages = ceil($totalCount / $limit);
            
            echo json_encode([
                'success' => true,
                'logs' => $logs,
                'pagination' => [
                    'currentPage' => $page,
                    'totalPages' => $totalPages,
                    'totalCount' => $totalCount,
                    'limit' => $limit
                ]
            ], JSON_THROW_ON_ERROR);

            return ['is_get_request' => true]; // Signal an Trait, nicht doppelt zu encoden
        }, [
            'inputType' => 'get',
            'checkRole' => 'admin'
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\AuditLogController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\CommunityController.php ---
<?php
namespace App\Http\Controllers\Admin;
use App\Core\Database;
use App\Core\Security;
use App\Repositories\CommunityPostRepository;
use Exception;
use PDO;
use \Parsedown; 
class CommunityController
{
    private PDO $pdo;
    private CommunityPostRepository $postRepo;
    private Parsedown $parsedown; 
    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->postRepo = new CommunityPostRepository($this->pdo);
        $this->parsedown = new Parsedown(); 
        $this->parsedown->setSafeMode(true);
    }
    public function index()
    {
        Security::requireRole(['admin', 'planer']); 
        global $config;
        $config = Database::getConfig();
        $page_title = 'Moderation Schwarzes Brett';
        $body_class = 'admin-dashboard-body';
        try {
            $pendingPosts = $this->postRepo->getPostsByStatus('pending');
            foreach ($pendingPosts as &$post) {
                $post['content_html'] = $this->parsedown->text($post['content'] ?? '');
            }
            unset($post); 
            $approvedPosts = $this->postRepo->getPostsByStatus('approved');
            foreach ($approvedPosts as &$post) {
                $post['content_html'] = $this->parsedown->text($post['content'] ?? '');
            }
            unset($post); 
            Security::getCsrfToken();
            include_once dirname(__DIR__, 4) .'/pages/admin/community_moderation.php';
        } catch (Exception $e) {
            error_log("Fehler beim Laden der Moderationsseite: " . $e->getMessage());
            http_response_code(500);
            die("Ein Fehler ist beim Laden der Seite aufgetreten: " . $e->getMessage());
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\CommunityController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\CsvTemplateController.php ---
<?php
namespace App\Http\Controllers\Admin;
use App\Core\Security;
use App\Core\Database;
use Exception;
class CsvTemplateController
{
    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();
        $page_title = 'CSV Importvorlage';
        $body_class = 'admin-dashboard-body';
        $templateData = $this->loadCsvTemplate();
        include_once dirname(__DIR__, 4) . '/pages/admin/csv_template.php';
    }
    private function loadCsvTemplate(): array
    {
        $templatePath = dirname(__DIR__, 4) . '/public/assets/templates/user_import_template.csv';
        $csvData = [
            'headers' => [],
            'rows' => []
        ];
        if (!file_exists($templatePath)) {
            $csvData['error'] = "Vorlagendatei nicht gefunden unter: " . htmlspecialchars($templatePath);
            return $csvData;
        }
        if (($handle = fopen($templatePath, "r")) !== FALSE) {
            if (($headers = fgetcsv($handle, 1000, ",")) !== FALSE) {
                $csvData['headers'] = $headers;
            }
            while (($data = fgetcsv($handle, 1000, ",")) !== FALSE) {
                $csvData['rows'][] = $data;
            }
            fclose($handle);
        } else {
             $csvData['error'] = "Vorlagendatei konnte nicht gelesen werden.";
        }
        return $csvData;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\CsvTemplateController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\DashboardController.php ---
<?php
namespace App\Http\Controllers\Admin;
use App\Core\Security;
use App\Core\Database;
use App\Core\Utils;
use App\Repositories\UserRepository;
use App\Repositories\StammdatenRepository;
use App\Repositories\AuditLogRepository;
use App\Repositories\PlanRepository;
use PDO;
use Exception;
use DateTime;
class DashboardController
{
    private PDO $pdo;
    private UserRepository $userRepo;
    private StammdatenRepository $stammdatenRepo;
    private AuditLogRepository $auditRepo;
    private PlanRepository $planRepo;
    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->userRepo = new UserRepository($this->pdo);
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
        $this->auditRepo = new AuditLogRepository($this->pdo);
        $this->planRepo = new PlanRepository($this->pdo);
    }
    private function performSystemChecks(): array
    {
        $checks = [];
        $basePublicDir = dirname(__DIR__, 4) . '/public/';
        $checks['database'] = [
            'label' => 'Datenbank-Verbindung',
            'status' => true,
            'message' => 'OK',
            'tooltip' => 'Die Verbindung zur MySQL-Datenbank ist aktiv.'
        ];
        $checks['config_file'] = [
            'label' => 'Konfigurationsdatei',
            'status' => true,
            'message' => 'OK',
            'tooltip' => 'Datei: database_access.php (Geladen)'
        ];
        $checks['ext_pdo_mysql'] = [
            'label' => 'PHP Extension: pdo_mysql',
            'status' => extension_loaded('pdo_mysql'),
            'message' => extension_loaded('pdo_mysql') ? 'OK' : 'Fehlt!', 
            'tooltip' => extension_loaded('pdo_mysql') ? 'Erweiterung ist geladen.' : 'Erforderlich für die Datenbankverbindung.'
        ];
        $checks['ext_gd'] = [
            'label' => 'PHP Extension: GD',
            'status' => extension_loaded('gd'),
            'message' => extension_loaded('gd') ? 'OK' : 'Optional', 
            'tooltip' => extension_loaded('gd') ? 'Erweiterung ist geladen.' : 'Optional (wird für zukünftige Bildverarbeitung genutzt).'
        ];
        $uploadDirs = [
            'upload_dir_announcements' => 'uploads/announcements/',
            'upload_dir_branding' => 'uploads/branding/'
        ];
        foreach ($uploadDirs as $key => $dir) {
            $fullPath = $basePublicDir . $dir;
            $label = 'Verzeichnis: ' . basename($dir); 
            $tooltip = 'Pfad: ' . $dir; 
            if (!is_dir($fullPath)) {
                if (!@mkdir($fullPath, 0775, true)) {
                     $checks[$key] = [
                        'label' => $label,
                        'status' => false,
                        'message' => 'Fehler (Erstellen)',
                        'tooltip' => $tooltip . ' - Nicht gefunden & konnte nicht erstellt werden.'
                     ];
                } else {
                     $checks[$key] = [
                        'label' => $label,
                        'status' => true,
                        'message' => 'OK',
                        'tooltip' => $tooltip . ' (OK, wurde gerade erstellt)'
                     ];
                }
            } else {
                $testFile = $fullPath . 'write_test_' . uniqid() . '.tmp';
                if (@file_put_contents($testFile, 'test') !== false) {
                    @unlink($testFile);
                    $checks[$key] = [
                        'label' => $label,
                        'status' => true,
                        'message' => 'OK',
                        'tooltip' => $tooltip . ' (Beschreibbar)'
                    ];
                } else {
                    $checks[$key] = [
                        'label' => $label,
                        'status' => false,
                        'message' => 'Fehler (Schreibrechte)',
                        'tooltip' => $tooltip . ' - Nicht beschreibbar! (Berechtigungen prüfen)'
                    ];
                }
            }
        }
        return $checks;
    }
    public function index()
    {
        Security::requireRole('admin');
        global $config; 
        $config = Database::getConfig();
        $page_title = 'Admin Dashboard';
        $body_class = 'admin-dashboard-body'; 
        $dashboardData = [];
        try {
            $dashboardData['userCounts'] = $this->userRepo->countUsersByRole();
            $dashboardData['totalUsers'] = array_sum($dashboardData['userCounts']);
            $dashboardData['classCount'] = $this->stammdatenRepo->countClasses();
            $dashboardData['teacherCount'] = $this->stammdatenRepo->countTeachers();
            $dashboardData['subjectCount'] = $this->stammdatenRepo->countSubjects();
            $dashboardData['roomCount'] = $this->stammdatenRepo->countRooms();
            $dashboardData['latestLogs'] = $this->auditRepo->getLogs(1, 5); 
            $dashboardData['settings'] = Utils::getSettings();
            $dashboardData['systemInfo']['php'] = phpversion();
            $dashboardData['systemInfo']['db'] = $this->pdo->getAttribute(PDO::ATTR_SERVER_VERSION);
            $dashboardData['systemInfo']['webserver'] = $_SERVER['SERVER_SOFTWARE'] ?? 'N/A';
            $dashboardData['systemChecks'] = $this->performSystemChecks();
            $currentYear = (int)date('o');
            $currentWeek = (int)date('W');
            $nextWeekDate = new DateTime('+1 week');
            $nextYear = (int)$nextWeekDate->format('o');
            $nextWeek = (int)$nextWeekDate->format('W');
            $dashboardData['publishStatus']['currentWeekNum'] = $currentWeek;
            $dashboardData['publishStatus']['nextWeekNum'] = $nextWeek;
            $dashboardData['publishStatus']['current'] = $this->planRepo->getPublishStatus($currentYear, $currentWeek);
            $dashboardData['publishStatus']['next'] = $this->planRepo->getPublishStatus($nextYear, $nextWeek);
        } catch (Exception $e) {
            error_log("Fehler beim Laden der Admin-Dashboard-Daten: " . $e->getMessage());
            $dashboardData['userCounts'] = [];
            $dashboardData['totalUsers'] = 0;
            $dashboardData['classCount'] = 0;
            $dashboardData['teacherCount'] = 0;
            $dashboardData['subjectCount'] = 0;
            $dashboardData['roomCount'] = 0;
            $dashboardData['latestLogs'] = [];
            $dashboardData['settings'] = Utils::getSettings(); 
            $dashboardData['systemInfo'] = ['php' => 'N/A', 'db' => 'N/A', 'webserver' => 'N/A'];
            $dashboardData['systemChecks'] = []; 
            $dashboardData['publishStatus'] = ['current' => [], 'next' => [], 'currentWeekNum' => (int)date('W'), 'nextWeekNum' => (int)(new DateTime('+1 week'))->format('W')];
            $dashboardData['error'] = "Einige Dashboard-Daten konnten nicht geladen werden.";
        }
        Security::getCsrfToken();
        require_once dirname(__DIR__, 4) . '/pages/admin/dashboard.php';
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\DashboardController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\SettingsController.php ---
<?php
namespace App\Http\Controllers\Admin;
use App\Core\Security;
use App\Core\Database;
use App\Core\Utils;
use App\Core\Cache;
use App\Repositories\SettingsRepository;
use App\Services\AuditLogger;
use Exception;
use PDO;
use App\Http\Traits\ApiHandlerTrait;

class SettingsController
{
    use ApiHandlerTrait;

    private SettingsRepository $settingsRepo;
    private string $uploadDir;
    public function __construct()
    {
        $this->settingsRepo = new SettingsRepository();
        $this->uploadDir = dirname(__DIR__, 4) . '/public/uploads/branding/';
    }

    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();
        $page_title = 'Anwendungs-Einstellungen';
        $body_class = 'admin-dashboard-body';
        $currentSettings = Utils::getSettings();
        if (!is_dir($this->uploadDir)) {
            @mkdir($this->uploadDir, 0775, true);
        }
        Security::getCsrfToken();
        include_once dirname(__DIR__, 4) . '/pages/admin/settings.php';
    }

    // KORREKTUR: Akzeptiert jetzt $files ($_FILES) und $postData ($_POST) vom Trait
    private function handleFileUpload(string $fileKey, array $allowedMimes, ?string $currentPath, array $files, array $postData): ?string
    {
        if (isset($files[$fileKey]) && $files[$fileKey]['error'] === UPLOAD_ERR_OK) {
            $file = $files[$fileKey];
            $fileType = mime_content_type($file['tmp_name']);
            if (!array_key_exists($fileType, $allowedMimes)) {
                throw new Exception("Ungültiger Dateityp für '{$fileKey}'. Erlaubt: " . implode(', ', array_keys($allowedMimes)), 400);
            }
            if (!is_dir($this->uploadDir) && !@mkdir($this->uploadDir, 0775, true)) {
                throw new Exception("Upload-Verzeichnis konnte nicht erstellt werden.", 500);
            }
            if (!is_writable($this->uploadDir)) {
                throw new Exception("Upload-Verzeichnis ist nicht beschreibbar.", 500);
            }
            $extension = $allowedMimes[$fileType];
            $fileName = $fileKey . '_' . uniqid() . '.' . $extension;
            $targetPath = $this->uploadDir . $fileName;
            if (move_uploaded_file($file['tmp_name'], $targetPath)) {
                if ($currentPath && file_exists(dirname(__DIR__, 4) . '/public/' . $currentPath)) {
                    @unlink(dirname(__DIR__, 4) . '/public/' . $currentPath);
                }
                return 'uploads/branding/' . $fileName;
            } else {
                throw new Exception("Fehler beim Verschieben der hochgeladenen Datei.", 500);
            }
        }

        // KORREKTUR: Verwendet $postData (das $data aus dem Callback ist) statt $_POST
        if (isset($postData['remove_' . $fileKey]) && $postData['remove_' . $fileKey] === '1') {
            if ($currentPath && file_exists(dirname(__DIR__, 4) . '/public/' . $currentPath)) {
                @unlink(dirname(__DIR__, 4) . '/public/' . $currentPath);
            }
            return null;
        }
        return $currentPath;
    }

    public function save()
    {
        // KORREKTUR: Callback akzeptiert jetzt $data ($_POST) und $files ($_FILES)
        $this->handleApiRequest(function($data, $files) {
            $oldSettings = Utils::getSettings();
            $startHour = filter_var($data['default_start_hour'] ?? 1, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 12]]);
            $endHour = filter_var($data['default_end_hour'] ?? 10, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 12]]);
            if ($startHour === false || $endHour === false || $startHour >= $endHour) {
                throw new Exception("Ungültiger Stundenbereich (1-12, Start < Ende).", 400);
            }
            $maxAttempts = filter_var($data['max_login_attempts'] ?? 5, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 100]]);
            $lockoutMinutes = filter_var($data['lockout_minutes'] ?? 15, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 1440]]);
            if ($maxAttempts === false || $lockoutMinutes === false) {
                throw new Exception("Ungültige Werte für Login-Sperre.", 400);
            }
            $defaultTheme = $data['default_theme'] ?? 'light';
            if (!in_array($defaultTheme, ['light', 'dark'])) {
                $defaultTheme = 'light';
            }
            $icalWeeksFuture = filter_var($data['ical_weeks_future'] ?? 8, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 52]]);
            if ($icalWeeksFuture === false) {
                throw new Exception("Ungültige Anzahl an iCal-Wochen (1-52).", 400);
            }
            $whitelistIPs = $data['maintenance_whitelist_ips'] ?? '';
            $whitelistIPs = preg_replace('/[^0-9a-fA-F:.,\s]/', '', $whitelistIPs);
            $whitelistIPs = preg_replace('/[\s,]+/', ',', $whitelistIPs);
            $whitelistIPs = trim($whitelistIPs, ',');
           
            // KORREKTUR: $files und $data werden explizit an handleFileUpload übergeben
            $logoPath = $this->handleFileUpload(
                'site_logo',
                ['image/png' => 'png', 'image/jpeg' => 'jpg', 'image/svg+xml' => 'svg', 'image/gif' => 'gif'],
                $oldSettings['site_logo_path'] ?? null,
                $files, // <-- Hinzugefügt
                $data // <-- Hinzugefügt
            );
            $faviconPath = $this->handleFileUpload(
                'site_favicon',
                ['image/x-icon' => 'ico', 'image/png' => 'png', 'image/svg+xml' => 'svg'],
                $oldSettings['site_favicon_path'] ?? null,
                $files, // <-- Hinzugefügt
                $data // <-- Hinzugefügt
            );

            $settingsToSave = [
                'site_title' => trim($data['site_title'] ?? 'PAUSE Portal'),
                'maintenance_mode' => (isset($data['maintenance_mode']) && ($data['maintenance_mode'] === 'on' || $data['maintenance_mode'] === '1')) ? '1' : '0',
                'maintenance_message' => trim($data['maintenance_message'] ?? ''),
                'maintenance_whitelist_ips' => $whitelistIPs,
                'default_start_hour' => $startHour,
                'default_end_hour' => $endHour,
                'max_login_attempts' => $maxAttempts,
                'lockout_minutes' => $lockoutMinutes,
                'site_logo_path' => $logoPath,
                'site_favicon_path' => $faviconPath,
                'default_theme' => $defaultTheme,
                'ical_enabled' => (isset($data['ical_enabled']) && ($data['ical_enabled'] === 'on' || $data['ical_enabled'] === '1')) ? '1' : '0',
                'ical_weeks_future' => $icalWeeksFuture,
                'pdf_footer_text' => trim($data['pdf_footer_text'] ?? ''),
                'community_board_enabled' => (isset($data['community_board_enabled']) && ($data['community_board_enabled'] === 'on' || $data['community_board_enabled'] === '1')) ? '1' : '0',
            ];
            $this->settingsRepo->saveSettings($settingsToSave);
            $changedDetails = [];
            foreach ($settingsToSave as $key => $newValue) {
                $oldValue = $oldSettings[$key];
                if ($key === 'maintenance_mode' || $key === 'ical_enabled' || $key === 'community_board_enabled') {
                    $newValueForCompare = $newValue === '1';
                } else if (is_numeric($newValue)) {
                    $newValueForCompare = (int)$newValue;
                } else {
                    $newValueForCompare = $newValue;
                }
                if ($newValueForCompare != $oldValue) {
                    if ($key === 'site_logo_path' || $key === 'site_favicon_path') {
                        if ($newValue === null && $oldValue !== null) $changedDetails[$key] = 'entfernt';
                        elseif ($newValue !== null && $oldValue === null) $changedDetails[$key] = 'hinzugefügt';
                        elseif ($newValue !== $oldValue) $changedDetails[$key] = 'geändert';
                    } else {
                        $changedDetails[$key] = ['old' => $oldValue, 'new' => $newValueForCompare];
                    }
                }
            }
            $changedDetails = array_filter($changedDetails);
           
            Utils::clearSettingsCache();

            echo json_encode([
                'success' => true,
                'message' => 'Einstellungen erfolgreich gespeichert.',
                'data' => [
                    'site_logo_path' => $logoPath,
                    'site_favicon_path' => $faviconPath,
                    'default_theme' => $defaultTheme
                ]
            ]);

            return [
                'log_action' => 'update_settings',
                'log_target_type' => 'system',
                'log_details' => $changedDetails
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function clearCacheApi()
    {
        // KORREKTUR: Signatur an Trait angepasst
        $this->handleApiRequest(function($data, $files) {
            Utils::clearSettingsCache();
            $settingsMessage = 'Einstellungen-Cache geleert.';
            $appCacheResult = Cache::clearAll();
            $appMessage = $appCacheResult['message'];
            if (!$appCacheResult['success']) {
                throw new Exception("Fehler beim Leeren des App-Caches: " . $appMessage);
            }

            echo json_encode([
                'success' => true,
                'message' => "Erfolgreich! $settingsMessage. $appMessage"
            ]);
           
            return [
                'log_action' => 'clear_cache',
                'log_target_type' => 'system',
                'log_details' => ['cache_type' => 'all_application_caches']
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\SettingsController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\StammdatenController.php ---
<?php
namespace App\Http\Controllers\Admin;
use App\Core\Security;
use App\Core\Database;
use App\Repositories\StammdatenRepository;
use Exception;
use PDO;
use App\Services\AuditLogger;
use App\Http\Traits\ApiHandlerTrait; // NEU

class StammdatenController
{
    use ApiHandlerTrait; // NEU

    private PDO $pdo;
    private StammdatenRepository $repository;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->repository = new StammdatenRepository($this->pdo);
    }

    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();
        $page_title = 'Stammdatenverwaltung';
        $body_class = 'admin-dashboard-body';
        Security::getCsrfToken();
        include_once dirname(__DIR__, 4) . '/pages/admin/stammdaten.php';
    }

    // ENTFERNT: Lokale handleApiRequest Methode

    public function getSubjects()
    {
        $this->handleApiRequest(function($data) {
            $subjects = $this->repository->getSubjects();
            echo json_encode(['success' => true, 'data' => $subjects], JSON_THROW_ON_ERROR);
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => 'admin'
        ]);
    }

    public function createSubject()
    {
        $this->handleApiRequest(function($data) { // $data kommt von $_POST
            $name = trim($data['subject_name'] ?? '');
            $shortcut = trim($data['subject_shortcut'] ?? '');
            if (empty($name) || empty($shortcut)) {
                throw new Exception("Fachname und Kürzel dürfen nicht leer sein.");
            }
            $newId = $this->repository->createSubject($name, $shortcut);
            $newSubject = ['subject_id' => $newId, 'subject_name' => $name, 'subject_shortcut' => $shortcut];

            return [
                'json_response' => ['success' => true, 'message' => 'Fach erfolgreich erstellt.', 'data' => $newSubject],
                'log_action' => 'create_subject',
                'log_target_type' => 'subject',
                'log_target_id' => $newId,
                'log_details' => ['name' => $name, 'shortcut' => $shortcut]
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function updateSubject()
    {
        $this->handleApiRequest(function($data) {
            $id = filter_var($data['subject_id'] ?? null, FILTER_VALIDATE_INT);
            $name = trim($data['subject_name'] ?? '');
            $shortcut = trim($data['subject_shortcut'] ?? '');
            if (!$id || empty($name) || empty($shortcut)) {
                throw new Exception("Ungültige Daten für das Update.");
            }
            $this->repository->updateSubject($id, $name, $shortcut);
            $updatedSubject = ['subject_id' => $id, 'subject_name' => $name, 'subject_shortcut' => $shortcut];

            return [
                'json_response' => ['success' => true, 'message' => 'Fach erfolgreich aktualisiert.', 'data' => $updatedSubject],
                'log_action' => 'update_subject',
                'log_target_type' => 'subject',
                'log_target_id' => $id,
                'log_details' => ['name' => $name, 'shortcut' => $shortcut]
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function deleteSubject()
    {
        $this->handleApiRequest(function($data) {
            $id = filter_var($data['subject_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$id) {
                throw new Exception("Ungültige ID.");
            }
            $this->repository->deleteSubject($id);

            return [
                'json_response' => ['success' => true, 'message' => 'Fach erfolgreich gelöscht.'],
                'log_action' => 'delete_subject',
                'log_target_type' => 'subject',
                'log_target_id' => $id,
                'log_details' => ['id' => $id]
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function getRooms() {
        $this->handleApiRequest(function($data) {
            echo json_encode(['success' => true, 'data' => $this->repository->getRooms()], JSON_THROW_ON_ERROR);
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => 'admin'
        ]);
    }

    public function createRoom() {
        $this->handleApiRequest(function($data) {
            $name = trim($data['room_name'] ?? '');
            if (empty($name)) throw new Exception("Raumname darf nicht leer sein.");
            $newId = $this->repository->createRoom($name);
            $newRoom = ['room_id' => $newId, 'room_name' => $name];

            return [
                'json_response' => ['success' => true, 'message' => 'Raum erfolgreich erstellt.', 'data' => $newRoom],
                'log_action' => 'create_room',
                'log_target_type' => 'room',
                'log_target_id' => $newId,
                'log_details' => ['name' => $name]
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function updateRoom() {
        $this->handleApiRequest(function($data) {
            $id = filter_var($data['room_id'] ?? null, FILTER_VALIDATE_INT);
            $name = trim($data['room_name'] ?? '');
            if (!$id || empty($name)) throw new Exception("Ungültige Daten.");
            $this->repository->updateRoom($id, $name);
            $updatedRoom = ['room_id' => $id, 'room_name' => $name];

            return [
                'json_response' => ['success' => true, 'message' => 'Raum erfolgreich aktualisiert.', 'data' => $updatedRoom],
                'log_action' => 'update_room',
                'log_target_type' => 'room',
                'log_target_id' => $id,
                'log_details' => ['name' => $name]
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function deleteRoom() {
        $this->handleApiRequest(function($data) {
            $id = filter_var($data['room_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$id) throw new Exception("Ungültige ID.");
            $this->repository->deleteRoom($id);

            return [
                'json_response' => ['success' => true, 'message' => 'Raum erfolgreich gelöscht.'],
                'log_action' => 'delete_room',
                'log_target_type' => 'room',
                'log_target_id' => $id
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function getTeachers() {
        $this->handleApiRequest(function($data) {
            echo json_encode(['success' => true, 'data' => $this->repository->getTeachers()], JSON_THROW_ON_ERROR);
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => 'admin'
        ]);
    }

    public function createTeacher() {
        $this->handleApiRequest(function($data) {
            $teacherData = [
                'shortcut' => trim($data['teacher_shortcut'] ?? ''),
                'first_name' => trim($data['first_name'] ?? ''),
                'last_name' => trim($data['last_name'] ?? ''),
                'email' => empty(trim($data['email'] ?? '')) ? null : trim($data['email'])
            ];
            if (empty($teacherData['shortcut']) || empty($teacherData['first_name']) || empty($teacherData['last_name'])) {
                throw new Exception("Kürzel, Vorname und Nachname sind Pflichtfelder.");
            }
            $newId = $this->repository->createTeacher($teacherData);
            $newTeacher = array_merge(['teacher_id' => $newId], $teacherData);

            return [
                'json_response' => ['success' => true, 'message' => 'Lehrer erfolgreich erstellt.', 'data' => $newTeacher],
                'log_action' => 'create_teacher',
                'log_target_type' => 'teacher',
                'log_target_id' => $newId,
                'log_details' => $teacherData
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function updateTeacher() {
        $this->handleApiRequest(function($data) {
            $id = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $teacherData = [
                'shortcut' => trim($data['teacher_shortcut'] ?? ''),
                'first_name' => trim($data['first_name'] ?? ''),
                'last_name' => trim($data['last_name'] ?? ''),
                'email' => empty(trim($data['email'] ?? '')) ? null : trim($data['email'])
            ];
            if (!$id || empty($teacherData['shortcut']) || empty($teacherData['first_name']) || empty($teacherData['last_name'])) {
                throw new Exception("Ungültige Daten.");
            }
            $this->repository->updateTeacher($id, $teacherData);
            $updatedTeacher = array_merge(['teacher_id' => $id], $teacherData);

            return [
                'json_response' => ['success' => true, 'message' => 'Lehrer erfolgreich aktualisiert.', 'data' => $updatedTeacher],
                'log_action' => 'update_teacher',
                'log_target_type' => 'teacher',
                'log_target_id' => $id,
                'log_details' => $teacherData
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function deleteTeacher() {
        $this->handleApiRequest(function($data) {
            $id = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$id) throw new Exception("Ungültige ID.");
            $this->repository->deleteTeacher($id);

            return [
                'json_response' => ['success' => true, 'message' => 'Lehrer erfolgreich gelöscht.'],
                'log_action' => 'delete_teacher',
                'log_target_type' => 'teacher',
                'log_target_id' => $id
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function getClasses() {
        $this->handleApiRequest(function($data) {
            echo json_encode(['success' => true, 'data' => $this->repository->getClasses()], JSON_THROW_ON_ERROR);
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => 'admin'
        ]);
    }

    public function createClass() {
        $this->handleApiRequest(function($data) {
            $id = filter_var($data['class_id_input'] ?? null, FILTER_VALIDATE_INT); // Vom Formular
            $name = trim($data['class_name'] ?? '');
            $teacherId = filter_var($data['class_teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $teacherId = ($teacherId === 0 || $teacherId === false) ? null : $teacherId;
            if (empty($name) || !$id || $id <= 0) {
                throw new Exception("Klassen-ID (positiv) und Klassenname dürfen nicht leer sein.");
            }
            $this->repository->createClass($id, $name, $teacherId);
            $newClass = ['class_id' => $id, 'class_name' => $name, 'class_teacher_id' => $teacherId];

            return [
                'json_response' => ['success' => true, 'message' => 'Klasse erfolgreich erstellt.', 'data' => $newClass],
                'log_action' => 'create_class',
                'log_target_type' => 'class',
                'log_target_id' => $id,
                'log_details' => ['name' => $name, 'teacher_id' => $teacherId]
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function updateClass() {
        $this->handleApiRequest(function($data) {
            $id = filter_var($data['class_id_hidden'] ?? null, FILTER_VALIDATE_INT); // Vom Formular
            $name = trim($data['class_name'] ?? '');
            $teacherId = filter_var($data['class_teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $teacherId = ($teacherId === 0 || $teacherId === false) ? null : $teacherId;
            if (!$id || empty($name)) {
                throw new Exception("Ungültige Daten für Update (ID und Name benötigt).");
            }
            $this->repository->updateClass($id, $name, $teacherId);
            $updatedClass = ['class_id' => $id, 'class_name' => $name, 'class_teacher_id' => $teacherId];

            return [
                'json_response' => ['success' => true, 'message' => 'Klasse erfolgreich aktualisiert.', 'data' => $updatedClass],
                'log_action' => 'update_class',
                'log_target_type' => 'class',
                'log_target_id' => $id,
                'log_details' => ['name' => $name, 'teacher_id' => $teacherId]
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }

    public function deleteClass() {
        $this->handleApiRequest(function($data) {
            $id = filter_var($data['class_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$id) throw new Exception("Ungültige ID.");
            $this->repository->deleteClass($id);

            return [
                'json_response' => ['success' => true, 'message' => 'Klasse erfolgreich gelöscht.'],
                'log_action' => 'delete_class',
                'log_target_type' => 'class',
                'log_target_id' => $id
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => 'admin'
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\StammdatenController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\SystemHealthController.php ---
<?php
namespace App\Http\Controllers\Admin;
use App\Core\Security;
use App\Core\Utils;
use App\Core\Database;
class SystemHealthController
{
    public function __construct()
    {
        Security::requireRole('admin');
    }
    public function index()
    {
        global $config;
        $config = Database::getConfig();
        $page_title = 'System-Status';
        $body_class = 'admin-dashboard-body';
        $data = [
            'phpVersion' => phpversion(),
            'serverSoftware' => $_SERVER['SERVER_SOFTWARE'] ?? 'N/A',
            'dbStatus' => $this->checkDbStatus(),
            'extensions' => $this->checkExtensions(),
            'directoryStatus' => $this->checkDirectories(),
            'settings' => Utils::getSettings() 
        ];
        include_once dirname(__DIR__, 4) . '/pages/admin/system_health.php';
    }
    private function checkDbStatus(): array
    {
        try {
            $pdo = Database::getInstance();
            $pdo->query("SELECT 1");
            return ['status' => 'ok', 'message' => 'Verbunden'];
        } catch (\PDOException $e) {
            return ['status' => 'error', 'message' => 'Nicht verbunden'];
        }
    }
    private function checkExtensions(): array
    {
        $required = ['pdo_mysql', 'openssl', 'gd', 'mbstring', 'json', 'intl'];
        $status = [];
        foreach ($required as $ext) {
            $status[$ext] = extension_loaded($ext);
        }
        return $status;
    }
    private function checkDirectories(): array
    {
        $projectRoot = dirname(__DIR__, 4);
        $dirs = [
            'cache' => $projectRoot . '/cache',
            'uploads/announcements' => $projectRoot . '/public/uploads/announcements',
            'uploads/branding' => $projectRoot . '/public/uploads/branding'
        ];
        $status = [];
        foreach ($dirs as $name => $path) {
            $isDir = is_dir($path);
            $isWritable = $isDir && is_writable($path);
            if (!$isDir) {
                $status[$name] = ['status' => 'error', 'message' => 'Verzeichnis existiert nicht'];
            } elseif (!$isWritable) {
                $status[$name] = ['status' => 'error', 'message' => 'Nicht beschreibbar'];
            } else {
                $status[$name] = ['status' => 'ok', 'message' => 'OK'];
            }
        }
        return $status;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\SystemHealthController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\UserController.php ---
<?php
namespace App\Http\Controllers\Admin;
use App\Core\Security;
use App\Core\Database;
use App\Core\Utils;
use App\Repositories\UserRepository;
use App\Repositories\StammdatenRepository;
use App\Repositories\LoginAttemptRepository;
use App\Services\AuthenticationService;
use Exception;
use PDO;
use App\Services\AuditLogger;
use App\Http\Traits\ApiHandlerTrait; // NEU

class UserController
{
    use ApiHandlerTrait; // NEU

    private PDO $pdo;
    private UserRepository $userRepository;
    private StammdatenRepository $stammdatenRepository;
    private AuthenticationService $authService;
    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->userRepository = new UserRepository($this->pdo);
        $this->stammdatenRepository = new StammdatenRepository($this->pdo);
        $loginAttemptRepository = new LoginAttemptRepository($this->pdo);
        $this->authService = new AuthenticationService($this->userRepository, $loginAttemptRepository);
    }
    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();
        $page_title = 'Benutzerverwaltung';
        $body_class = 'admin-dashboard-body';
        Security::getCsrfToken();
        include_once dirname(__DIR__, 4) . '/pages/admin/users.php';
    }

    // ENTFERNT: Lokale handleApiRequest Methode

    public function getUsers()
    {
        $this->handleApiRequest(function($data) {
            $users = $this->userRepository->getAll();
            $roles = $this->userRepository->getAvailableRoles();
            $classes = $this->stammdatenRepository->getClasses();
            $teachers = $this->stammdatenRepository->getTeachers();
            echo json_encode(['success' => true, 'data' => [
                'users' => $users,
                'roles' => $roles,
                'classes' => $classes,
                'teachers' => $teachers
            ]], JSON_THROW_ON_ERROR);
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => 'admin'
        ]);
    }

    public function createUser()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $newUserId = $this->userRepository->create($data);
            $newUser = $this->userRepository->findById($newUserId);
            $details = $data;
            unset($details['password']);

            return [
                'json_response' => ['success' => true, 'message' => 'Benutzer erfolgreich erstellt.', 'data' => $newUser],
                'log_action' => 'create_user',
                'log_target_type' => 'user',
                'log_target_id' => $newUserId,
                'log_details' => $details
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => 'admin'
        ]);
    }

    public function updateUser()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $id = $data['user_id'] ?? null;
            if (!$id) {
                throw new Exception("Ungültige Benutzer-ID.");
            }
            $this->userRepository->update($id, $data);
            $updatedUser = $this->userRepository->findById($id);
            $details = $data;
            unset($details['password']);

            return [
                'json_response' => ['success' => true, 'message' => 'Benutzer erfolgreich aktualisiert.', 'data' => $updatedUser],
                'log_action' => 'update_user',
                'log_target_type' => 'user',
                'log_target_id' => $id,
                'log_details' => $details
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => 'admin'
        ]);
    }

    public function deleteUser()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $id = $data['user_id'] ?? null;
            if (!$id) {
                throw new Exception("Ungültige ID.");
            }
            $this->userRepository->delete($id);

            return [
                'json_response' => ['success' => true, 'message' => 'Benutzer erfolgreich gelöscht.'],
                'log_action' => 'delete_user',
                'log_target_type' => 'user',
                'log_target_id' => $id
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => 'admin'
        ]);
    }

    public function importUsers()
    {
        $this->handleApiRequest(function($data) { // $data (aus $_POST) wird ignoriert, wir verwenden $_FILES
            if (!isset($_FILES['csv_file']) || $_FILES['csv_file']['error'] !== UPLOAD_ERR_OK) {
                throw new Exception('Keine CSV-Datei hochgeladen oder Fehler beim Upload.');
            }
            $tmpFilePath = $_FILES['csv_file']['tmp_name'];
            $fileType = mime_content_type($tmpFilePath);
            $fileExtension = strtolower(pathinfo($_FILES['csv_file']['name'], PATHINFO_EXTENSION));
            if (!in_array($fileType, ['text/plain', 'text/csv', 'application/csv']) && $fileExtension !== 'csv') {
                throw new Exception('Ungültiger Dateityp. Bitte laden Sie eine CSV-Datei hoch.');
            }

            $validClasses = $this->stammdatenRepository->getClasses();
            $validTeachers = $this->stammdatenRepository->getTeachers();
            $validRoles = $this->userRepository->getAvailableRoles();
            $validationData = [
                'class_ids' => array_column($validClasses, 'class_id'),
                'teacher_ids' => array_column($validTeachers, 'teacher_id'),
                'roles' => $validRoles
            ];

            $result = $this->userRepository->importFromCSV($tmpFilePath, $validationData);

            echo json_encode(['success' => true, 'message' => 'Import abgeschlossen.', 'data' => $result]);

            return [
                'log_action' => 'import_users_csv',
                'log_target_type' => 'system',
                'log_target_id' => null,
                'log_details' => [
                    'filename' => $_FILES['csv_file']['name'],
                    'success_count' => $result['success_count'],
                    'failure_count' => $result['failure_count'],
                    'errors' => $result['errors']
                ]
            ];
        }, [
            'inputType' => 'form', // 'form' nutzen, um CSRF-Token-Prüfung auszulösen
            'checkRole' => 'admin'
        ]);
    }

    public function impersonateUserApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $targetUserId = $data['user_id'] ?? null;
            if (!$targetUserId) {
                throw new Exception("Keine Benutzer-ID zum Imitieren angegeben.", 400);
            }
            $currentAdminId = $_SESSION['user_id'];
            if ($targetUserId == $currentAdminId) {
                throw new Exception("Sie können sich nicht selbst imitieren.", 400);
            }
            $targetUser = $this->userRepository->findById($targetUserId);
            if (!$targetUser) {
                throw new Exception("Zielbenutzer nicht gefunden.", 404);
            }
            
            $_SESSION['impersonator_id'] = $currentAdminId;
            session_regenerate_id(true);
            $_SESSION['user_id'] = $targetUser['user_id'];
            $_SESSION['username'] = $targetUser['username'];
            $_SESSION['user_role'] = $targetUser['role'];
            $_SESSION['impersonator_id'] = $currentAdminId;
            Security::getCsrfToken(); // Neuen Token für die imitierte Sitzung generieren

            echo json_encode(['success' => true, 'redirectUrl' => Utils::url('dashboard')]);

            return [
                'log_action' => 'impersonate_start',
                'log_target_type' => 'user',
                'log_target_id' => $currentAdminId,
                'log_details' => ['target_user_id' => $targetUserId, 'target_username' => $targetUser['username']]
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => 'admin'
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\UserController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Auth\AuthController.php ---
<?php
namespace App\Http\Controllers\Auth;
use App\Core\Database;
use App\Core\Utils;
use App\Core\Security; 
use App\Repositories\UserRepository;
use App\Services\AuthenticationService;
use App\Services\AuditLogger; 
use Exception;
use PDO;
class AuthController
{
    private PDO $pdo;
    private UserRepository $userRepository; 
    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->userRepository = new UserRepository($this->pdo); 
    }
    public function handleLogin()
    {
        try {
            Security::verifyCsrfToken(); 
        } catch (Exception $e) {
            $message = $e->getMessage();
            $page_title = 'Login';
             Security::getCsrfToken(); 
            include_once dirname(__DIR__, 4) . '/pages/auth/login.php';
            return; 
        }
        $identifier = $_POST['identifier'] ?? '';
        $password = $_POST['password'] ?? '';
        try {
            $loginAttemptRepository = new \App\Repositories\LoginAttemptRepository($this->pdo);
            $authService = new AuthenticationService($this->userRepository, $loginAttemptRepository);
            $userData = $authService->login($identifier, $password);
            session_regenerate_id(true); 
            $_SESSION['user_id'] = $userData['user_id'];
            $_SESSION['username'] = $userData['username'];
            $_SESSION['user_role'] = $userData['role'];
            Security::getCsrfToken();
            header("Location: " . Utils::url('dashboard'));
            exit();
        } catch (Exception $e) {
            $message = $e->getMessage();
            $page_title = 'Login';
             Security::getCsrfToken();
            include_once dirname(__DIR__, 4) . '/pages/auth/login.php';
        }
    }
    public function showLogin()
    {
        global $config; 
        $config = Database::getConfig();
        $page_title = 'Login';
        $message = $_SESSION['flash_message'] ?? '';
        unset($_SESSION['flash_message']);
        Security::getCsrfToken();
        include_once dirname(__DIR__, 4) . '/pages/auth/login.php';
    }
    public function logout()
    {
        $_SESSION = [];
        session_destroy();
        session_start(); 
        $_SESSION['flash_message'] = "Sie wurden erfolgreich abgemeldet.";
        header("Location: " . Utils::url('login'));
        exit();
    }
    public function revertImpersonation()
    {
        if (session_status() !== PHP_SESSION_ACTIVE || empty($_SESSION['impersonator_id'])) {
            $this->logout();
            return;
        }
        $impersonatedUserId = $_SESSION['user_id'] ?? 0;
        $adminUserId = $_SESSION['impersonator_id'];
        $_SESSION = [];
        session_destroy();
        session_start(); 
        session_regenerate_id(true);
        try {
            $adminUser = $this->userRepository->findById($adminUserId);
            if (!$adminUser || $adminUser['role'] !== 'admin') {
                throw new Exception("Ursprünglicher Benutzer ist kein Admin.");
            }
            $_SESSION['user_id'] = $adminUser['user_id'];
            $_SESSION['username'] = $adminUser['username'];
            $_SESSION['user_role'] = $adminUser['role'];
            Security::getCsrfToken();
            AuditLogger::log(
                'impersonate_revert',
                'user',
                $adminUserId, 
                ['reverted_from_user_id' => $impersonatedUserId]
            );
            header("Location: " . Utils::url('admin/users'));
            exit();
        } catch (Exception $e) {
            error_log("Fehler bei revertImpersonation: " . $e->getMessage());
            $this->logout(); 
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Auth\AuthController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Planer\AbsenceController.php ---
<?php
namespace App\Http\Controllers\Planer;
use App\Core\Database;
use App\Core\Security;
use App\Repositories\TeacherAbsenceRepository;
use App\Repositories\StammdatenRepository;
use App\Services\AuditLogger;
use Exception;
use PDO;
use DateTime;
use DateTimeZone;
use App\Http\Traits\ApiHandlerTrait; // NEU

class AbsenceController
{
    use ApiHandlerTrait; // NEU

    private PDO $pdo;
    private TeacherAbsenceRepository $absenceRepo;
    private StammdatenRepository $stammdatenRepo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->absenceRepo = new TeacherAbsenceRepository($this->pdo);
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
    }

    public function index()
    {
        Security::requireRole(['admin', 'planer']);
        global $config;
        $config = Database::getConfig();
        $page_title = 'Lehrer-Abwesenheiten';
        $body_class = 'planer-dashboard-body';
        try {
            $availableTeachers = $this->stammdatenRepo->getTeachers();
            $absenceTypes = $this->absenceRepo->getAbsenceTypes();
            Security::getCsrfToken();
            include_once dirname(__DIR__, 4) .'/pages/planer/absences.php';
        } catch (Exception $e) {
            error_log("Fehler beim Laden der Abwesenheits-Seite: " . $e->getMessage());
            http_response_code(500);
            die("Ein Fehler ist beim Laden der Seite aufgetreten: " . $e->getMessage());
        }
    }

    public function getAbsencesApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von $_GET
            $startDate = filter_var($data['start'] ?? null, FILTER_UNSAFE_RAW);
            $endDate = filter_var($data['end'] ?? null, FILTER_UNSAFE_RAW);

            if (!$startDate || !$endDate) {
                $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                $startDate = $today->format('Y-m-01');
                $endDate = $today->format('Y-m-t');
            }
            if (DateTime::createFromFormat('Y-m-d', $startDate) === false || DateTime::createFromFormat('Y-m-d', $endDate) === false) {
                throw new Exception("Ungültiges Datumsformat.", 400);
            }
            $absences = $this->absenceRepo->getAbsencesForPeriod($startDate, $endDate);
            echo json_encode(['success' => true, 'data' => $absences]);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => ['admin', 'planer']
        ]);
    }

    public function saveAbsenceApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $absenceId = filter_var($data['absence_id'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $teacherId = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $startDate = $data['start_date'] ?? null;
            $endDate = $data['end_date'] ?? null;
            $reason = trim($data['reason'] ?? '');
            $comment = isset($data['comment']) ? trim($data['comment']) : null;
            if (!$teacherId || !$startDate || !$endDate || empty($reason)) {
                throw new Exception("Fehlende Daten: Lehrer, Start, Ende und Grund sind erforderlich.", 400);
            }
            if (DateTime::createFromFormat('Y-m-d', $startDate) === false || DateTime::createFromFormat('Y-m-d', $endDate) === false) {
                throw new Exception("Ungültiges Datumsformat.", 400);
            }
            if ($endDate < $startDate) {
                throw new Exception("Enddatum muss nach dem Startdatum liegen.", 400);
            }
            $validTypes = $this->absenceRepo->getAbsenceTypes();
            if (!in_array($reason, $validTypes)) {
                throw new Exception("Ungültiger Abwesenheitsgrund.", 400);
            }
            $savedAbsence = $this->absenceRepo->createAbsence($absenceId, $teacherId, $startDate, $endDate, $reason, $comment);
            $newId = $savedAbsence['absence_id'];

            echo json_encode(['success' => true, 'message' => 'Abwesenheit gespeichert.', 'data' => $savedAbsence]);

            return [
                'log_action' => $absenceId ? 'update_absence' : 'create_absence',
                'log_target_type' => 'teacher_absence',
                'log_target_id' => $newId,
                'log_details' => [
                    'teacher_id' => $teacherId,
                    'start_date' => $startDate,
                    'end_date' => $endDate,
                    'reason' => $reason
                ]
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => ['admin', 'planer']
        ]);
    }

    public function deleteAbsenceApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $absenceId = filter_var($data['absence_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$absenceId) {
                throw new Exception("Fehlende Abwesenheits-ID.", 400);
            }
            $absence = $this->absenceRepo->getAbsenceById($absenceId);
            if (!$absence) {
                throw new Exception("Abwesenheit nicht gefunden.", 404);
            }
            $success = $this->absenceRepo->deleteAbsence($absenceId);
            if ($success) {
                echo json_encode(['success' => true, 'message' => 'Abwesenheit gelöscht.']);
                return [
                    'log_action' => 'delete_absence',
                    'log_target_type' => 'teacher_absence',
                    'log_target_id' => $absenceId,
                    'log_details' => [
                        'teacher_id' => $absence['teacher_id'],
                        'reason' => $absence['reason'],
                        'start_date' => $absence['start_date']
                    ]
                ];
            } else {
                throw new Exception("Abwesenheit konnte nicht gelöscht werden.", 500);
            }
        }, [
            'inputType' => 'json',
            'checkRole' => ['admin', 'planer']
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Planer\AbsenceController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Planer\PlanController.php ---
<?php
namespace App\Http\Controllers\Planer;
use App\Core\Security;
use App\Core\Database;
use App\Repositories\PlanRepository;
use App\Repositories\StammdatenRepository;
use App\Repositories\TeacherAbsenceRepository;
use Exception;
use PDO;
use DateTime;
use DateTimeZone;
use App\Services\AuditLogger;
use App\Http\Traits\ApiHandlerTrait; // NEU

class PlanController
{
    use ApiHandlerTrait; // NEU

    private PDO $pdo;
    private PlanRepository $planRepository;
    private StammdatenRepository $stammdatenRepository;
    private TeacherAbsenceRepository $absenceRepo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->planRepository = new PlanRepository($this->pdo);
        $this->stammdatenRepository = new StammdatenRepository($this->pdo);
        $this->absenceRepo = new TeacherAbsenceRepository($this->pdo);
    }

    public function index()
    {
        Security::requireRole(['planer', 'admin']);
        global $config;
        $config = Database::getConfig();
        $page_title = 'Stundenplan-Verwaltung';
        $body_class = 'planer-dashboard-body';
        Security::getCsrfToken();
        include_once dirname(__DIR__, 4) . '/pages/planer/dashboard.php';
    }

    // ENTFERNT: Lokale handleApiRequest Methode

    public function getTimetableData()
    {
        $this->handleApiRequest(function($data) { // $data kommt von $_GET
            $classId = filter_var($data['class_id'] ?? null, FILTER_VALIDATE_INT);
            $teacherId = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $calendarWeek = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);
            $date = $data['date'] ?? null;
            if ($date && (DateTime::createFromFormat('Y-m-d', $date) === false)) {
                throw new Exception("Ungültiges Datumsformat. Bitte YYYY-MM-DD verwenden.");
            }
            $baseData = [];
            $absencesData = [];
            if (!$classId && !$teacherId && !$year && !$calendarWeek) {
                $baseData = [
                    'classes' => $this->stammdatenRepository->getClasses(),
                    'teachers' => $this->stammdatenRepository->getTeachers(),
                    'subjects' => $this->stammdatenRepository->getSubjects(),
                    'rooms' => $this->stammdatenRepository->getRooms(),
                    'templates' => $this->planRepository->getTemplates(),
                ];
                $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                $startDate = $today->format('Y-m-01');
                $endDate = $today->modify('+3 months')->format('Y-m-t');
                $absencesData = $this->absenceRepo->getAbsencesForDateRange($startDate, $endDate);
                $baseData['absences'] = $absencesData;
            }
            $timetable = [];
            $substitutions = [];
            $publishStatus = ['student' => false, 'teacher' => false];
            if (($classId || $teacherId) && $year && $calendarWeek) {
                $publishStatus = $this->planRepository->getPublishStatus($year, $calendarWeek);
                if ($classId) {
                    $timetable = $this->planRepository->getTimetableForClassAsPlaner($classId, $year, $calendarWeek);
                    $substitutions = $this->planRepository->getSubstitutionsForClassWeekAsPlaner($classId, $year, $calendarWeek);
                } elseif ($teacherId) {
                    $timetable = $this->planRepository->getTimetableForTeacherAsPlaner($teacherId, $year, $calendarWeek);
                    $substitutions = $this->planRepository->getSubstitutionsForTeacherWeekAsPlaner($teacherId, $year, $calendarWeek);
                }
                $dto = new DateTime();
                $dto->setISODate($year, $calendarWeek, 1);
                $startDate = $dto->format('Y-m-d');
                $dto->setISODate($year, $calendarWeek, 7);
                $endDate = $dto->format('Y-m-d');
                $absencesData = $this->absenceRepo->getAbsencesForDateRange($startDate, $endDate);
            } elseif (($classId || $teacherId) && (!$year || !$calendarWeek)) {
                $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                $year = (int)$today->format('o');
                $calendarWeek = (int)$today->format('W');
                $publishStatus = $this->planRepository->getPublishStatus($year, $calendarWeek);
                if ($classId) {
                    $timetable = $this->planRepository->getTimetableForClassAsPlaner($classId, $year, $calendarWeek);
                    $substitutions = $this->planRepository->getSubstitutionsForClassWeekAsPlaner($classId, $year, $calendarWeek);
                } elseif ($teacherId) {
                    $timetable = $this->planRepository->getTimetableForTeacherAsPlaner($teacherId, $year, $calendarWeek);
                    $substitutions = $this->planRepository->getSubstitutionsForTeacherWeekAsPlaner($teacherId, $year, $calendarWeek);
                }
                $dto = new DateTime();
                $dto->setISODate($year, $calendarWeek, 1);
                $startDate = $dto->format('Y-m-d');
                $dto->setISODate($year, $calendarWeek, 7);
                $endDate = $dto->format('Y-m-d');
                $absencesData = $this->absenceRepo->getAbsencesForDateRange($startDate, $endDate);
            }
            echo json_encode(['success' => true, 'data' => array_merge($baseData, [
                'timetable' => $timetable,
                'substitutions' => $substitutions,
                'publishStatus' => $publishStatus,
                'absences' => $absencesData
            ])], JSON_THROW_ON_ERROR);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function saveEntry()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            if (!$data) throw new Exception("Ungültige Daten empfangen.");
            $resultData = $this->planRepository->createOrUpdateEntry($data);
            return [
                'json_response' => ['success' => true, 'message' => 'Eintrag erfolgreich gespeichert.', 'data' => $resultData],
                'log_action' => 'save_entry',
                'log_target_type' => 'timetable_entry',
                'log_target_id' => $data['entry_id'] ?? $resultData['entry_ids'][0] ?? null,
                'log_details' => $data
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function deleteEntry()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $entryId = $data['entry_id'] ?? null;
            $blockId = $data['block_id'] ?? null;
            $logTargetId = null;
            $logDetails = $data;
            if ($blockId) {
                $this->planRepository->deleteEntryBlock($blockId);
                $message = 'Block erfolgreich gelöscht.';
                $logTargetId = $blockId;
            } elseif ($entryId && filter_var($entryId, FILTER_VALIDATE_INT)) {
                $this->planRepository->deleteEntry((int)$entryId);
                $message = 'Eintrag erfolgreich gelöscht.';
                $logTargetId = $entryId;
            } else {
                throw new Exception("Ungültige Eintrags- oder Block-ID.");
            }
            return [
                'json_response' => ['success' => true, 'message' => $message],
                'log_action' => 'delete_entry',
                'log_target_type' => 'timetable_entry',
                'log_target_id' => $logTargetId,
                'log_details' => $logDetails
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function saveSubstitution()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            if (!$data) throw new Exception("Ungültige Daten empfangen.");
            $resultData = $this->planRepository->createOrUpdateSubstitution($data);
            return [
                'json_response' => ['success' => true, 'message' => 'Vertretung erfolgreich gespeichert.', 'data' => $resultData],
                'log_action' => 'save_substitution',
                'log_target_type' => 'substitution',
                'log_target_id' => $resultData['substitution_id'] ?? $data['substitution_id'] ?? null,
                'log_details' => $data
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function deleteSubstitution()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $id = $data['substitution_id'] ?? null;
            if (!filter_var($id, FILTER_VALIDATE_INT)) throw new Exception("Ungültige Vertretungs-ID.");
            $this->planRepository->deleteSubstitution((int)$id);
            return [
                'json_response' => ['success' => true, 'message' => 'Vertretung erfolgreich gelöscht.'],
                'log_action' => 'delete_substitution',
                'log_target_type' => 'substitution',
                'log_target_id' => $id,
                'log_details' => $data
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function publish()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $week = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);
            $target = $data['target'] ?? null;
            $userId = $_SESSION['user_id'];
            if (!$year || !$week || !in_array($target, ['student', 'teacher'])) {
                throw new Exception("Ungültige Parameter für Veröffentlichung.");
            }
            $success = $this->planRepository->publishWeek($year, $week, $target, $userId);
            if ($success) {
                $newStatus = $this->planRepository->getPublishStatus($year, $week);
                return [
                    'json_response' => [
                        'success' => true,
                        'message' => "Stundenplan KW $week/$year für " . ($target === 'student' ? 'Schüler' : 'Lehrer') . " veröffentlicht.",
                        'data' => ['publishStatus' => $newStatus]
                    ],
                    'log_action' => 'publish_week',
                    'log_target_type' => 'system',
                    'log_details' => ['year' => $year, 'week' => $week, 'target' => $target]
                ];
            } else {
                throw new Exception("Veröffentlichung fehlgeschlagen.");
            }
        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function unpublish()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $week = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);
            $target = $data['target'] ?? null;
            if (!$year || !$week || !in_array($target, ['student', 'teacher'])) {
                throw new Exception("Ungültige Parameter.");
            }
            $success = $this->planRepository->unpublishWeek($year, $week, $target);
            if ($success) {
                $newStatus = $this->planRepository->getPublishStatus($year, $week);
                return [
                    'json_response' => [
                        'success' => true,
                        'message' => "Veröffentlichung KW $week/$year für " . ($target === 'student' ? 'Schüler' : 'Lehrer') . " zurückgenommen.",
                        'data' => ['publishStatus' => $newStatus]
                    ],
                    'log_action' => 'unpublish_week',
                    'log_target_type' => 'system',
                    'log_details' => ['year' => $year, 'week' => $week, 'target' => $target]
                ];
            } else {
                throw new Exception("Zurücknahme fehlgeschlagen.");
            }
        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function getStatus() {
        $this->handleApiRequest(function($data) { // $data kommt von $_GET
            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $week = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);
            if (!$year || !$week) {
                throw new Exception("Jahr und Woche erforderlich.");
            }
            $status = $this->planRepository->getPublishStatus($year, $week);
            echo json_encode(['success' => true, 'data' => ['publishStatus' => $status]], JSON_THROW_ON_ERROR);
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function checkConflictsApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            if (!$data) {
                throw new Exception("Keine Daten für Konfliktprüfung empfangen.");
            }
            if (empty($data['year']) || empty($data['calendar_week']) || empty($data['day_of_week']) || empty($data['start_period_number']) || empty($data['end_period_number'])) {
                throw new Exception("Unvollständige Daten für Konfliktprüfung.");
            }
            if (!isset($data['class_id'])) {
                throw new Exception("Fehlende class_id für Konfliktprüfung.");
            }
            $excludeEntryId = !empty($data['entry_id']) ? (int)$data['entry_id'] : null;
            $excludeBlockId = !empty($data['block_id']) ? (string)$data['block_id'] : null;
            
            // Die checkConflicts Methode wirft eine Exception bei Konflikten
            $this->planRepository->checkConflicts($data, $excludeEntryId, $excludeBlockId);
            
            // Wenn wir hier ankommen, gab es keine Konflikte
            return [
                'json_response' => ['success' => true, 'conflicts' => []]
                // Kein Logging für reine Prüfungen
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function copyWeek()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $sourceYear = filter_var($data['sourceYear'] ?? null, FILTER_VALIDATE_INT);
            $sourceWeek = filter_var($data['sourceWeek'] ?? null, FILTER_VALIDATE_INT);
            $targetYear = filter_var($data['targetYear'] ?? null, FILTER_VALIDATE_INT);
            $targetWeek = filter_var($data['targetWeek'] ?? null, FILTER_VALIDATE_INT);
            $classId = filter_var($data['classId'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $teacherId = filter_var($data['teacherId'] ?? null, FILTER_VALIDATE_INT) ?: null;
            if (!$sourceYear || !$sourceWeek || !$targetYear || !$targetWeek) {
                throw new Exception("Quell- und Zielwoche sind erforderlich.");
            }
            if ($classId === null && $teacherId === null) {
                throw new Exception("Klasse oder Lehrer erforderlich.");
            }
            $copiedCount = $this->planRepository->copyWeekData(
                $sourceYear,
                $sourceWeek,
                $targetYear,
                $targetWeek,
                $classId,
                $teacherId
            );
            return [
                'json_response' => [
                    'success' => true,
                    'message' => "Woche erfolgreich kopiert. {$copiedCount} Einträge wurden in KW {$targetWeek}/{$targetYear} eingefügt.",
                    'copiedCount' => $copiedCount
                ],
                'log_action' => 'copy_week',
                'log_target_type' => 'system',
                'log_details' => $data
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function getTemplates()
    {
        $this->handleApiRequest(function() {
            $templates = $this->planRepository->getTemplates();
            echo json_encode(['success' => true, 'data' => $templates], JSON_THROW_ON_ERROR);
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function createTemplate()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $name = trim($data['name'] ?? '');
            $description = trim($data['description'] ?? '') ?: null;
            $sourceYear = filter_var($data['sourceYear'] ?? null, FILTER_VALIDATE_INT);
            $sourceWeek = filter_var($data['sourceWeek'] ?? null, FILTER_VALIDATE_INT);
            $sourceClassId = filter_var($data['sourceClassId'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $sourceTeacherId = filter_var($data['sourceTeacherId'] ?? null, FILTER_VALIDATE_INT) ?: null;
            if (empty($name) || !$sourceYear || !$sourceWeek || ($sourceClassId === null && $sourceTeacherId === null)) {
                throw new Exception("Ungültige Daten zum Erstellen der Vorlage.");
            }
            $sourceEntries = [];
            if ($sourceClassId) {
                $sourceEntries = $this->planRepository->getTimetableForClassAsPlaner($sourceClassId, $sourceYear, $sourceWeek);
            } elseif ($sourceTeacherId) {
                $sourceEntries = $this->planRepository->getTimetableForTeacherAsPlaner($sourceTeacherId, $sourceYear, $sourceWeek);
            }
            if (empty($sourceEntries)) {
                throw new Exception("Keine Stundenplandaten in der Quellwoche gefunden, um die Vorlage zu erstellen.");
            }
            $newTemplateId = $this->planRepository->createTemplate($name, $description, $sourceEntries);
            return [
                'json_response' => [
                    'success' => true,
                    'message' => "Vorlage '{$name}' erfolgreich erstellt.",
                    'data' => ['template_id' => $newTemplateId, 'name' => $name, 'description' => $description]
                ],
                'log_action' => 'create_template_from_week',
                'log_target_type' => 'template',
                'log_target_id' => $newTemplateId,
                'log_details' => $data
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function applyTemplate()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $templateId = filter_var($data['templateId'] ?? null, FILTER_VALIDATE_INT);
            $targetYear = filter_var($data['targetYear'] ?? null, FILTER_VALIDATE_INT);
            $targetWeek = filter_var($data['targetWeek'] ?? null, FILTER_VALIDATE_INT);
            $targetClassId = filter_var($data['targetClassId'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $targetTeacherId = filter_var($data['targetTeacherId'] ?? null, FILTER_VALIDATE_INT) ?: null;
            if (!$templateId || !$targetYear || !$targetWeek || ($targetClassId === null && $targetTeacherId === null)) {
                throw new Exception("Ungültige Daten zum Anwenden der Vorlage.");
            }
            $appliedCount = $this->planRepository->applyTemplateToWeek(
                $templateId,
                $targetYear,
                $targetWeek,
                $targetClassId,
                $targetTeacherId
            );
            return [
                'json_response' => [
                    'success' => true,
                    'message' => "Vorlage erfolgreich angewendet. {$appliedCount} Einträge wurden in KW {$targetWeek}/{$targetYear} eingefügt.",
                    'appliedCount' => $appliedCount
                ],
                'log_action' => 'apply_template',
                'log_target_type' => 'template',
                'log_target_id' => $templateId,
                'log_details' => $data
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function deleteTemplate()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $templateId = filter_var($data['templateId'] ?? null, FILTER_VALIDATE_INT);
            if (!$templateId) {
                throw new Exception("Ungültige Vorlagen-ID.");
            }
            $success = $this->planRepository->deleteTemplate($templateId);
            if ($success) {
                return [
                    'json_response' => ['success' => true, 'message' => 'Vorlage erfolgreich gelöscht.'],
                    'log_action' => 'delete_template',
                    'log_target_type' => 'template',
                    'log_target_id' => $templateId,
                    'log_details' => $data
                ];
            } else {
                throw new Exception("Fehler beim Löschen der Vorlage.");
            }
        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function getTemplateDetails(int $templateId)
    {
        $this->handleApiRequest(function() use ($templateId) {
            $details = $this->planRepository->loadTemplateDetails($templateId);
            echo json_encode(['success' => true, 'data' => $details], JSON_THROW_ON_ERROR);
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => ['planer', 'admin']
        ]);
    }

    public function saveTemplateDetails()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            if (empty($data['name'])) {
                throw new Exception("Vorlagenname darf nicht leer sein.");
            }
            $savedTemplate = $this->planRepository->saveTemplateDetails($data);
            $action = empty($data['template_id']) ? 'create_template' : 'update_template';
            return [
                'json_response' => [
                    'success' => true,
                    'message' => 'Vorlage erfolgreich gespeichert.',
                    'data' => $savedTemplate
                ],
                'log_action' => 'save_template_details',
                'log_target_type' => 'template',
                'log_target_id' => $savedTemplate['template_id'],
                'log_details' => [
                    'name' => $savedTemplate['name'],
                    'description' => $savedTemplate['description'],
                    'entries_count' => count($data['entries'] ?? [])
                ]
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => ['planer', 'admin']
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Planer\PlanController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\AcademicEventController.php ---
<?php
namespace App\Http\Controllers;
use App\Core\Database;
use App\Core\Security;
use App\Repositories\AcademicEventRepository;
use App\Repositories\UserRepository;
use App\Repositories\StammdatenRepository;
use App\Services\AuditLogger;
use Exception;
use PDO;
use DateTime;
use DateTimeZone;
use App\Http\Traits\ApiHandlerTrait; // NEU

class AcademicEventController
{
    use ApiHandlerTrait; // NEU

    private PDO $pdo;
    private AcademicEventRepository $eventRepo;
    private UserRepository $userRepo;
    private StammdatenRepository $stammdatenRepo;
    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->eventRepo = new AcademicEventRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
    }

    public function getForStudent()
    {
        $this->handleApiRequest(function($data) { // $data kommt von $_GET
            $userId = $_SESSION['user_id'];
            $user = $this->userRepo->findById($userId);
            if (!$user || !$user['class_id']) {
                throw new Exception("Schülerdaten unvollständig (Klasse fehlt).", 400);
            }
            $classId = $user['class_id'];
            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $week = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);
            if (!$year || !$week) {
                $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                $year = (int)$today->format('o');
                $week = (int)$today->format('W');
            }
            $events = $this->eventRepo->getEventsForClassByWeek($classId, $year, $week);
            echo json_encode(['success' => true, 'data' => $events]);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => 'schueler'
        ]);
    }

    public function getForTeacher()
    {
        $this->handleApiRequest(function($data) {
            $userId = $_SESSION['user_id'];
            $daysInFuture = 14;
            $events = $this->eventRepo->getEventsByTeacher($userId, $daysInFuture);
            echo json_encode(['success' => true, 'data' => $events]);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => 'lehrer'
        ]);
    }

    public function createOrUpdate()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $userId = $_SESSION['user_id'];
            $user = $this->userRepo->findById($userId);
            if (!$user || !$user['teacher_id']) {
                throw new Exception("Lehrerprofil nicht gefunden.", 403);
            }
            $teacherId = $user['teacher_id'];
            
            $eventId = filter_var($data['event_id'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $classId = filter_var($data['class_id'] ?? null, FILTER_VALIDATE_INT);
            $subjectId = filter_var($data['subject_id'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $eventType = $data['event_type'] ?? null;
            $title = trim($data['title'] ?? '');
            $dueDate = $data['due_date'] ?? null;
            $description = isset($data['description']) ? trim($data['description']) : null;
            if (!$classId || !$eventType || empty($title) || !$dueDate || !in_array($eventType, ['aufgabe', 'klausur', 'info'])) {
                throw new Exception("Fehlende oder ungültige Pflichtfelder (Typ, Klasse, Titel, Datum).", 400);
            }
            if (DateTime::createFromFormat('Y-m-d', $dueDate) === false) {
                throw new Exception("Ungültiges Datumsformat. Bitte YYYY-MM-DD verwenden.", 400);
            }
            if (!$this->eventRepo->checkTeacherAuthorization($teacherId, $classId, $dueDate)) {
                error_log("Hinweis: Lehrer {$userId} erstellt Event für Klasse {$classId} an Datum {$dueDate} ohne expliziten Unterrichtsnachweis.");
            }
            $savedEvent = $this->eventRepo->saveEvent(
                $eventId,
                $userId,
                $classId,
                $subjectId,
                $eventType,
                $title,
                $dueDate,
                $description
            );
            $action = $eventId ? 'update_event' : 'create_event';
            
            echo json_encode([
                'success' => true,
                'message' => 'Eintrag erfolgreich ' . ($eventId ? 'aktualisiert' : 'erstellt') . '.',
                'data' => $savedEvent
            ]);

            return [
                'log_action' => $action,
                'log_target_type' => 'academic_event',
                'log_target_id' => $savedEvent['event_id'],
                'log_details' => [
                    'type' => $eventType,
                    'title' => $title,
                    'class_id' => $classId,
                    'due_date' => $dueDate
                ]
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => 'lehrer'
        ]);
    }

    public function delete()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $userId = $_SESSION['user_id'];
            $eventId = filter_var($data['event_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$eventId) {
                throw new Exception("Keine Event-ID angegeben.", 400);
            }
            $eventToDelete = $this->eventRepo->getEventById($eventId);
            $success = $this->eventRepo->deleteEvent($eventId, $userId);
            if ($success) {
                echo json_encode(['success' => true, 'message' => 'Eintrag erfolgreich gelöscht.']);
                return [
                    'log_action' => 'delete_event',
                    'log_target_type' => 'academic_event',
                    'log_target_id' => $eventId,
                    'log_details' => [
                        'title' => $eventToDelete['title'] ?? 'N/A',
                        'type' => $eventToDelete['event_type'] ?? 'N/A',
                        'class_id' => $eventToDelete['class_id'] ?? 'N/A',
                        'due_date' => $eventToDelete['due_date'] ?? 'N/A'
                    ]
                ];
            } else {
                throw new Exception("Eintrag konnte nicht gelöscht werden (nicht gefunden oder keine Berechtigung).", 404);
            }
        }, [
            'inputType' => 'json',
            'checkRole' => 'lehrer'
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\AcademicEventController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\AnnouncementController.php ---
<?php
namespace App\Http\Controllers;
use App\Core\Database;
use App\Core\Security;
use App\Repositories\AnnouncementRepository;
use App\Repositories\UserRepository;
use Exception;
use PDO;
use \Parsedown;
use App\Services\AuditLogger;
use App\Http\Traits\ApiHandlerTrait; // NEU

class AnnouncementController
{
    use ApiHandlerTrait; // NEU

    private PDO $pdo;
    private AnnouncementRepository $announcementRepo;
    private UserRepository $userRepo;
    private Parsedown $parsedown;
    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->announcementRepo = new AnnouncementRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
        $this->parsedown = new Parsedown();
        $this->parsedown->setSafeMode(true);
    }

    // ENTFERNT: Lokale handleApiRequest Methode

    public function getAnnouncements()
    {
        $this->handleApiRequest(function($data) {
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $user = $this->userRepo->findById($userId);
            if (!$user) {
                throw new Exception("Benutzer nicht gefunden.");
            }
            $classId = ($userRole === 'schueler' && isset($user['class_id'])) ? $user['class_id'] : null;
            $announcements = $this->announcementRepo->getVisibleAnnouncements($userRole, $classId);
            foreach ($announcements as &$announcement) {
                $author = $this->userRepo->findById($announcement['user_id']);
                $announcement['author_name'] = $author ? ($author['first_name'] . ' ' . $author['last_name']) : 'Unbekannt';
                $announcement['content_html'] = $this->parsedown->text($announcement['content'] ?? '');
                if (!empty($announcement['file_path'])) {
                    $announcement['file_url'] = rtrim(Database::getConfig()['base_url'], '/') . '/' . ltrim($announcement['file_path'], '/');
                } else {
                    $announcement['file_url'] = null;
                }
                $announcement['visibility'] = $announcement['is_global'] ? 'global' : 'class';
            }
            unset($announcement);
            echo json_encode(['success' => true, 'data' => $announcements], JSON_THROW_ON_ERROR);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin'] // Entspricht requireLogin()
        ]);
    }

    public function createAnnouncement()
    {
        $this->handleApiRequest(function($data) { // $data kommt von $_POST
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $title = trim($data['title'] ?? '');
            $content = trim($data['content'] ?? '');
            if (empty($title) || empty($content)) {
                throw new Exception("Titel und Inhalt dürfen nicht leer sein.");
            }
            $targetRole = 'all';
            $targetClassId = null;
            if ($userRole === 'lehrer') {
                $targetClassId = filter_var($data['target_class_id'] ?? null, FILTER_VALIDATE_INT);
                if (!$targetClassId) { throw new Exception("Lehrer müssen eine Klasse auswählen."); }
                $targetRole = 'schueler';
            }
            elseif (in_array($userRole, ['admin', 'planer'])) {
                $isGlobal = isset($data['target_global']) && $data['target_global'] === '1';
                $isTeacher = isset($data['target_teacher']) && $data['target_teacher'] === '1';
                $isPlaner = isset($data['target_planer']) && $data['target_planer'] === '1';
                $selectedClassId = filter_var($data['target_class_id'] ?? null, FILTER_VALIDATE_INT);
                $selectedClassId = ($selectedClassId === false || $selectedClassId === 0) ? null : $selectedClassId;
                $checkedCount = ($isGlobal ? 1 : 0) + ($isTeacher ? 1 : 0) + ($isPlaner ? 1 : 0);
                if ($checkedCount > 1) { throw new Exception("Bitte nur eine Zielgruppen-Checkbox auswählen."); }
                elseif ($checkedCount === 1) {
                    if ($isGlobal) $targetRole = 'all'; elseif ($isTeacher) $targetRole = 'lehrer'; elseif ($isPlaner) $targetRole = 'planer';
                    $targetClassId = null;
                } elseif ($selectedClassId !== null) {
                    $targetRole = 'schueler'; $targetClassId = $selectedClassId;
                } else { $targetRole = 'all'; $targetClassId = null; }
            } else { throw new Exception("Unbekannte Benutzerrolle."); }

            $attachmentPath = null;
            if (isset($_FILES['attachment']) && $_FILES['attachment']['error'] === UPLOAD_ERR_OK) {
                if (!in_array($userRole, ['admin', 'planer'])) { throw new Exception("Nur Admins und Planer dürfen Dateien anhängen."); }
                $uploadDir = dirname(__DIR__, 2) . '/public/uploads/announcements/';
                if (!is_dir($uploadDir)) { if (!mkdir($uploadDir, 0775, true)) { throw new Exception("Upload-Verzeichnis konnte nicht erstellt werden."); } }
                $fileName = uniqid('', true) . '_' . basename($_FILES['attachment']['name']); $targetFile = $uploadDir . $fileName;
                $allowedTypes = ['image/jpeg', 'image/png', 'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
                $fileType = mime_content_type($_FILES['attachment']['tmp_name']);
                if (!in_array($fileType, $allowedTypes)) { throw new Exception("Ungültiger Dateityp."); }
                if ($_FILES['attachment']['size'] > 5 * 1024 * 1024) { throw new Exception("Datei ist zu groß (max. 5MB)."); }
                if (move_uploaded_file($_FILES['attachment']['tmp_name'], $targetFile)) { $attachmentPath = 'uploads/announcements/' . $fileName; }
                else { throw new Exception("Fehler beim Hochladen der Datei."); }
            }

            $newId = $this->announcementRepo->createAnnouncement(
                $userId,
                $title,
                $content,
                $targetRole,
                $targetClassId,
                $attachmentPath
            );
            $newAnnouncement = $this->announcementRepo->getAnnouncementById($newId);
            if ($newAnnouncement) {
                $newAnnouncement['content_html'] = $this->parsedown->text($newAnnouncement['content'] ?? '');
                $author = $this->userRepo->findById($newAnnouncement['user_id']);
                $newAnnouncement['author_name'] = $author ? ($author['first_name'] . ' ' . $author['last_name']) : 'Unbekannt';
                if (!empty($newAnnouncement['file_path'])) {
                    $newAnnouncement['file_url'] = rtrim(Database::getConfig()['base_url'], '/') . '/' . ltrim($newAnnouncement['file_path'], '/');
                } else {
                    $newAnnouncement['file_url'] = null;
                }
                $newAnnouncement['visibility'] = $newAnnouncement['is_global'] ? 'global' : 'class';
            }

            echo json_encode(['success' => true, 'message' => 'Ankündigung erfolgreich erstellt.', 'data' => $newAnnouncement], JSON_THROW_ON_ERROR);

            return [
                'log_action' => 'create_announcement',
                'log_target_type' => 'announcement',
                'log_target_id' => $newId,
                'log_details' => [
                    'title' => $title,
                    'target_role' => $targetRole,
                    'target_class_id' => $targetClassId,
                    'has_attachment' => !empty($attachmentPath)
                ]
            ];
        }, [
            'inputType' => 'form', // Wegen $_FILES
            'checkRole' => ['admin', 'planer', 'lehrer']
        ]);
    }

    public function deleteAnnouncement()
    {
        $this->handleApiRequest(function($data) { // $data von $_POST
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $announcementId = filter_var($data['announcement_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$announcementId) { throw new Exception("Ungültige Ankündigungs-ID."); }
            $announcement = $this->announcementRepo->getAnnouncementById($announcementId);
            if (!$announcement) { throw new Exception("Ankündigung nicht gefunden."); }
            if ($userRole === 'lehrer' && $announcement['user_id'] !== $userId) {
                throw new Exception("Sie sind nicht berechtigt, diese Ankündigung zu löschen.");
            }
            $success = $this->announcementRepo->deleteAnnouncement($announcementId);
            if ($success) {
                echo json_encode(['success' => true, 'message' => 'Ankündigung erfolgreich gelöscht.'], JSON_THROW_ON_ERROR);
            }
            else {
                throw new Exception("Fehler beim Löschen der Ankündigung.");
            }
            
            return [
                'log_action' => 'delete_announcement',
                'log_target_type' => 'announcement',
                'log_target_id' => $announcementId,
                'log_details' => ['title' => $announcement['title'] ?? 'N/A']
            ];
        }, [
            'inputType' => 'form',
            'checkRole' => ['admin', 'planer', 'lehrer']
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\AnnouncementController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\CommunityController.php ---
<?php
namespace App\Http\Controllers;
use App\Core\Database;
use App\Core\Security;
use App\Repositories\CommunityPostRepository;
use App\Services\AuditLogger;
use Exception;
use PDO;
use \Parsedown;
use App\Http\Traits\ApiHandlerTrait; // NEU

class CommunityController
{
    use ApiHandlerTrait; // NEU

    private PDO $pdo;
    private CommunityPostRepository $postRepo;
    private Parsedown $parsedown;
    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->postRepo = new CommunityPostRepository($this->pdo);
        $this->parsedown = new Parsedown();
        $this->parsedown->setSafeMode(true);
    }

    public function getPostsApi()
    {
        $this->handleApiRequest(function($data) {
            $posts = $this->postRepo->getApprovedPostsWithAuthorEmail(50);
            foreach ($posts as &$post) {
                $post['content_html'] = $this->parsedown->text($post['content'] ?? '');
            }
            unset($post);
            echo json_encode(['success' => true, 'data' => $posts]);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin'] // requireLogin
        ]);
    }

    public function getMyPostsApi()
    {
        $this->handleApiRequest(function($data) {
            $userId = $_SESSION['user_id'];
            $posts = $this->postRepo->getPostsByUserId($userId);
            foreach ($posts as &$post) {
                $post['content_html'] = $this->parsedown->text($post['content'] ?? '');
            }
            unset($post);
            echo json_encode(['success' => true, 'data' => $posts]);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin'] // requireLogin
        ]);
    }

    public function createPostApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $title = trim($data['title'] ?? '');
            $content = trim($data['content'] ?? '');
            if (empty($title) || empty($content)) {
                throw new Exception("Titel und Inhalt dürfen nicht leer sein.", 400);
            }
            $allowedToAutoApprove = ['admin', 'planer', 'lehrer'];
            $initialStatus = in_array($userRole, $allowedToAutoApprove) ? 'approved' : 'pending';
            $newPostId = $this->postRepo->createPost($userId, $title, $content, $initialStatus);
            
            $message = ($initialStatus === 'approved')
                ? 'Beitrag erfolgreich veröffentlicht.'
                : 'Beitrag wurde zur Moderation eingereicht.';
                
            echo json_encode(['success' => true, 'message' => $message, 'status' => $initialStatus]);

            return [
                'log_action' => 'create_community_post',
                'log_target_type' => 'community_post',
                'log_target_id' => $newPostId,
                'log_details' => [
                    'title' => $title,
                    'status' => $initialStatus
                ]
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin'] // requireLogin
        ]);
    }

    public function updatePostApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $postId = filter_var($data['post_id'] ?? null, FILTER_VALIDATE_INT);
            $title = trim($data['title'] ?? '');
            $content = trim($data['content'] ?? '');
            if (!$postId || empty($title) || empty($content)) {
                throw new Exception("ID, Titel und Inhalt dürfen nicht leer sein.", 400);
            }
            $post = $this->postRepo->getPostById($postId);
            if (!$post) {
                throw new Exception("Beitrag nicht gefunden.", 404);
            }
            $isOwner = ($post['user_id'] == $userId);
            $isModerator = in_array($userRole, ['admin', 'planer']);
            if (!$isOwner && !$isModerator) {
                throw new Exception("Sie sind nicht berechtigt, diesen Beitrag zu bearbeiten.", 403);
            }
            $newStatus = $post['status'];
            if ($isOwner && !$isModerator) {
                $newStatus = 'pending';
            }
            $moderatorId = $isModerator ? $userId : null;
            $success = $this->postRepo->updatePost($postId, $title, $content, $newStatus, $moderatorId);
            if ($success) {
                $message = ($newStatus === 'pending')
                    ? 'Beitrag aktualisiert und zur erneuten Moderation eingereicht.'
                    : 'Beitrag erfolgreich aktualisiert.';
                
                echo json_encode(['success' => true, 'message' => $message, 'new_status' => $newStatus]);
                
                return [
                    'log_action' => 'update_community_post',
                    'log_target_type' => 'community_post',
                    'log_target_id' => $postId,
                    'log_details' => [
                        'title' => $title,
                        'new_status' => $newStatus
                    ]
                ];
            } else {
                throw new Exception("Beitrag konnte nicht aktualisiert werden.", 500);
            }
        }, [
            'inputType' => 'json',
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin'] // requireLogin
        ]);
    }

    public function approvePostApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $moderatorId = $_SESSION['user_id'];
            $postId = filter_var($data['post_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$postId) {
                throw new Exception("Ungültige Beitrags-ID.", 400);
            }
            $success = $this->postRepo->updatePostStatus($postId, 'approved', $moderatorId);
            if ($success) {
                echo json_encode(['success' => true, 'message' => 'Beitrag freigegeben.']);
                return [
                    'log_action' => 'approve_community_post',
                    'log_target_type' => 'community_post',
                    'log_target_id' => $postId
                ];
            } else {
                throw new Exception("Beitrag konnte nicht freigegeben werden (vielleicht schon moderiert?).", 404);
            }
        }, [
            'inputType' => 'json',
            'checkRole' => ['admin', 'planer']
        ]);
    }

    public function rejectPostApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $moderatorId = $_SESSION['user_id'];
            $postId = filter_var($data['post_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$postId) {
                throw new Exception("Ungültige Beitrags-ID.", 400);
            }
            $post = $this->postRepo->getPostById($postId);
            $success = $this->postRepo->updatePostStatus($postId, 'rejected', $moderatorId);
            if ($success) {
                echo json_encode(['success' => true, 'message' => 'Beitrag abgelehnt.']);
                return [
                    'log_action' => 'reject_community_post',
                    'log_target_type' => 'community_post',
                    'log_target_id' => $postId,
                    'log_details' => ['title' => $post['title'] ?? 'N/A']
                ];
            } else {
                throw new Exception("Beitrag konnte nicht abgelehnt werden (vielleicht schon moderiert?).", 404);
            }
        }, [
            'inputType' => 'json',
            'checkRole' => ['admin', 'planer']
        ]);
    }

    public function deletePostApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $postId = filter_var($data['post_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$postId) {
                throw new Exception("Ungültige Beitrags-ID.", 400);
            }
            $post = $this->postRepo->getPostById($postId);
            if (!$post) {
                throw new Exception("Beitrag nicht gefunden.", 404);
            }
            $isOwner = ($post['user_id'] == $userId);
            $isModerator = in_array($userRole, ['admin', 'planer']);
            if (!$isOwner && !$isModerator) {
                throw new Exception("Sie sind nicht berechtigt, diesen Beitrag zu löschen.", 403);
            }
            $success = $this->postRepo->deletePost($postId);
            if ($success) {
                echo json_encode(['success' => true, 'message' => 'Beitrag erfolgreich gelöscht.']);
                return [
                    'log_action' => 'delete_community_post',
                    'log_target_type' => 'community_post',
                    'log_target_id' => $postId,
                    'log_details' => [
                        'title' => $post['title'] ?? 'N/A',
                        'deleted_by' => $userRole
                    ]
                ];
            } else {
                throw new Exception("Beitrag konnte nicht gelöscht werden.", 500);
            }
        }, [
            'inputType' => 'json',
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin'] // requireLogin
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\CommunityController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\DashboardController.php ---
<?php
namespace App\Http\Controllers;
use App\Core\Security;
use App\Core\Utils;
use App\Core\Database;
use App\Repositories\PlanRepository;
use App\Repositories\UserRepository;
use App\Repositories\AppointmentRepository;
use App\Repositories\StudentNoteRepository;
use App\Services\AuditLogger;
use Exception;
use PDO;
use DateTime;
use DateTimeZone;
use App\Http\Traits\ApiHandlerTrait;

class DashboardController
{
    use ApiHandlerTrait;

    private PDO $pdo;
    private UserRepository $userRepository;
    private PlanRepository $planRepository;
    private AppointmentRepository $appointmentRepo;
    private StudentNoteRepository $noteRepo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->userRepository = new UserRepository($this->pdo);
        $this->planRepository = new PlanRepository($this->pdo);
        $this->appointmentRepo = new AppointmentRepository($this->pdo);
        $this->noteRepo = new StudentNoteRepository($this->pdo);
    }

    public function index()
    {
        Security::requireLogin();
        $userId = $_SESSION['user_id'];
        $role = $_SESSION['user_role'] ?? 'Unbekannt';

        global $config;
        $config = Database::getConfig();

        if ($role === 'admin') {
            header("Location: " . Utils::url('admin/dashboard'));
            exit();
        }
        if ($role === 'planer') {
            header("Location: " . Utils::url('planer/dashboard'));
            exit();
        }

        $icalSubscriptionUrl = null;
        $user = null;

        if (in_array($role, ['schueler', 'lehrer'])) {
            try {
                $user = $this->userRepository->findById($userId);
                if ($user) {
                    $token = $this->userRepository->generateOrGetIcalToken($userId);
                    if ($token) {
                        $baseUrl = rtrim($config['base_url'], '/');
                        $icalPath = 'ical/' . $token;
                        $protocol = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off' || $_SERVER['SERVER_PORT'] == 443) ? "https://" : "http://";
                        $host = $_SERVER['HTTP_HOST'];
                        $icalSubscriptionUrl = $protocol . $host . Utils::url($icalPath);
                    } else {
                        error_log("Could not generate or get iCal token for user ID: " . $userId);
                    }
                } else {
                    error_log("User not found for ID: " . $userId . " in DashboardController");
                }
            } catch (Exception $e) {
                error_log("Error fetching iCal token: " . $e->getMessage());
            }
        }

        $page_title = 'Mein Stundenplan';
        $body_class = 'dashboard-body';
        $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
        $dayOfWeekName = [
            1 => 'Montag', 2 => 'Dienstag', 3 => 'Mittwoch', 4 => 'Donnerstag', 5 => 'Freitag', 6 => 'Samstag', 7 => 'Sonntag'
        ][$today->format('N')] ?? 'Unbekannt';
        $dateFormatted = $today->format('d.m.Y');
        
        require_once dirname(__DIR__, 3) . '/pages/dashboard.php';
    }

    public function getWeeklyData()
    {
        $this->handleApiRequest(function($data) { // $data kommt von $_GET
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $calendarWeek = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);

            if (!$year || !$calendarWeek) {
                $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                $year = (int)$today->format('o');
                $calendarWeek = (int)$today->format('W');
            }

            $monday = new DateTime();
            $monday->setISODate($year, $calendarWeek, 1);
            $startDate = $monday->format('Y-m-d');
            $sunday = new DateTime();
            $sunday->setISODate($year, $calendarWeek, 7);
            $endDate = $sunday->format('Y-m-d');

            $user = $this->userRepository->findById($userId);
            if (!$user) {
                throw new Exception("Benutzer nicht gefunden.");
            }

            $regularTimetable = [];
            $substitutions = [];
            $appointments = [];
            $notes = [];
            $targetGroup = null;

            if ($userRole === 'schueler' && !empty($user['class_id'])) {
                $targetGroup = 'student';
                if ($this->planRepository->isWeekPublishedFor($targetGroup, $year, $calendarWeek)) {
                    $regularTimetable = $this->planRepository->getPublishedTimetableForClass($user['class_id'], $year, $calendarWeek);
                    $substitutions = $this->planRepository->getPublishedSubstitutionsForClassWeek($user['class_id'], $year, $calendarWeek);
                    $appointments = $this->appointmentRepo->getAppointmentsForStudent($userId, $startDate, $endDate);
                    $notes = $this->noteRepo->getNotesForWeek($userId, $year, $calendarWeek);
                }
            } elseif ($userRole === 'lehrer' && !empty($user['teacher_id'])) {
                $targetGroup = 'teacher';
                if ($this->planRepository->isWeekPublishedFor($targetGroup, $year, $calendarWeek)) {
                    $regularTimetable = $this->planRepository->getPublishedTimetableForTeacher($user['teacher_id'], $year, $calendarWeek);
                    $substitutions = $this->planRepository->getPublishedSubstitutionsForTeacherWeek($user['teacher_id'], $year, $calendarWeek);
                    $appointments = $this->appointmentRepo->getAppointmentsForTeacher($userId, $startDate, $endDate);
                }
            }

            echo json_encode(['success' => true, 'data' => [
                'timetable' => $regularTimetable,
                'substitutions' => $substitutions,
                'appointments' => $appointments,
                'notes' => $notes
            ]]);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => ['schueler', 'lehrer', 'planer', 'admin'] // requireLogin
        ]);
    }

    public function saveNoteApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $userId = $_SESSION['user_id'];
            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $calendarWeek = filter_var($data['calendar_week'] ?? null, FILTER_VALIDATE_INT);
            $dayOfWeek = filter_var($data['day_of_week'] ?? null, FILTER_VALIDATE_INT);
            $periodNumber = filter_var($data['period_number'] ?? null, FILTER_VALIDATE_INT);
            $content = $data['note_content'] ?? '';

            if (!$year || !$calendarWeek || !$dayOfWeek || !$periodNumber) {
                throw new Exception("Fehlende Kontextdaten (Woche, Tag oder Stunde).", 400);
            }

            $success = $this->noteRepo->saveNote(
                $userId,
                $year,
                $calendarWeek,
                $dayOfWeek,
                $periodNumber,
                $content
            );
            
            if ($success) {
                echo json_encode(['success' => true, 'message' => 'Notiz gespeichert.']);
                return [
                    'log_action' => 'save_student_note',
                    'log_target_type' => 'student_note',
                    'log_details' => [
                        'year' => $year,
                        'week' => $calendarWeek,
                        'day' => $dayOfWeek,
                        'period' => $periodNumber,
                        'action' => empty(trim($content)) ? 'deleted' : 'saved'
                    ]
                ];
            } else {
                throw new Exception("Notiz konnte nicht gespeichert werden.");
            }
        }, [
            'inputType' => 'json',
            'checkRole' => 'schueler'
        ]);
    }

    public function getUpcomingSlotsApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von $_GET
            $teacherId = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$teacherId) {
                throw new Exception("Ungültige Lehrer-ID.", 400);
            }
            
            $teacherUser = $this->userRepository->findUserByTeacherId($teacherId);
            if (!$teacherUser) {
                throw new Exception("Lehrerprofil (Benutzer) nicht gefunden.", 404);
            }
            $teacherUserId = $teacherUser['user_id'];

            $daysInFuture = 14;
            $slots = $this->appointmentRepo->getUpcomingAvailableSlots($teacherUserId, $daysInFuture);
            
            echo json_encode(['success' => true, 'data' => $slots]);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => 'schueler'
        ]);
    }
    
    public function bookAppointmentApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $studentUserId = $_SESSION['user_id'];
            $teacherId = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $availabilityId = filter_var($data['availability_id'] ?? null, FILTER_VALIDATE_INT);
            $date = $data['date'] ?? null;
            $time = $data['time'] ?? null;
            $duration = filter_var($data['duration'] ?? null, FILTER_VALIDATE_INT);
            $location = isset($data['location']) ? trim($data['location']) : null;
            $notes = isset($data['notes']) ? trim($data['notes']) : null;

            if (!$teacherId || !$availabilityId || !$date || !$time || !$duration || $location === null) {
                throw new Exception("Fehlende Daten für die Buchung (Lehrer, Slot, Datum, Zeit, Dauer oder Ort).", 400);
            }
            
            $teacherUser = $this->userRepository->findUserByTeacherId($teacherId);
            if (!$teacherUser) {
                throw new Exception("Lehrerprofil (Benutzer) nicht gefunden.", 404);
            }
            $teacherUserId = $teacherUser['user_id'];
            
            $today = (new DateTime('now', new DateTimeZone('Europe/Berlin')))->format('Y-m-d');
            if ($date < $today) {
                throw new Exception("Termine können nicht in der Vergangenheit gebucht werden.", 400);
            }

            $newId = $this->appointmentRepo->bookAppointment(
                $studentUserId,
                $teacherUserId,
                $availabilityId,
                $date,
                $time,
                $duration,
                $location,
                $notes
            );
            
            echo json_encode(['success' => true, 'message' => 'Sprechstunde erfolgreich gebucht!']);

            return [
                'log_action' => 'book_appointment',
                'log_target_type' => 'appointment',
                'log_target_id' => $newId,
                'log_details' => [
                    'teacher_user_id' => $teacherUserId,
                    'date' => $date,
                    'time' => $time,
                    'location' => $location
                ]
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => 'schueler'
        ]);
    }

    public function cancelAppointmentApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $userId = $_SESSION['user_id'];
            $role = $_SESSION['user_role'];
            $appointmentId = filter_var($data['appointment_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$appointmentId) {
                throw new Exception("Keine Termin-ID angegeben.", 400);
            }

            $success = $this->appointmentRepo->cancelAppointment($appointmentId, $userId, $role);
            
            if ($success) {
                echo json_encode(['success' => true, 'message' => 'Termin erfolgreich storniert.']);
                return [
                    'log_action' => 'cancel_appointment',
                    'log_target_type' => 'appointment',
                    'log_target_id' => $appointmentId,
                    'log_details' => ['cancelled_by_role' => $role]
                ];
            }
            // cancelAppointment wirft bereits eine Exception, wenn es fehlschlägt
        }, [
            'inputType' => 'json',
            'checkRole' => ['schueler', 'lehrer'] // requireLogin, aber spezifischer
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\DashboardController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\IcalController.php ---
<?php
namespace App\Http\Controllers;
use App\Core\Database;
use App\Core\Utils;
use App\Repositories\UserRepository;
use App\Repositories\PlanRepository;
use App\Repositories\AcademicEventRepository;
use App\Repositories\AppointmentRepository; // NEU
use App\Services\IcalService; 
use Exception;
use PDO;

class IcalController
{
    private IcalService $icalService; 

    public function __construct()
    {
        
        $pdo = Database::getInstance();
        $userRepository = new UserRepository($pdo);
        $planRepository = new PlanRepository($pdo);
        $eventRepository = new AcademicEventRepository($pdo);
        $appointmentRepository = new AppointmentRepository($pdo); // NEU
        $settings = Utils::getSettings();
        
        // Service mit allen benötigten Repositories instanziieren
        $this->icalService = new IcalService(
            $userRepository, 
            $planRepository, 
            $eventRepository, 
            $appointmentRepository, // NEU
            $settings
        );
    }

    /**
     * Generiert den iCal-Feed für einen bestimmten Benutzer-Token.
     * Delegiert die gesamte Logik an den IcalService.
     */
    public function generateFeed(string $token)
    {
        try {
            // Logik an Service delegieren
            $icsContent = $this->icalService->generateFeed($token);

            // HTTP-Header für iCal-Feed setzen
            header('Content-Type: text/calendar; charset=utf-8');
            header('Content-Disposition: inline; filename="pause_stundenplan.ics"');
            header('Cache-Control: no-cache, no-store, must-revalidate');
            header('Pragma: no-cache');
            header('Expires: 0');
            
            echo $icsContent;
            exit;

        } catch (Exception $e) {
            // Fehlerbehandlung für Exceptions aus dem Service
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            header('Content-Type: text/plain');
            echo $e->getMessage();
            exit;
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\IcalController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\PdfController.php ---
<?php
namespace App\Http\Controllers;
use App\Core\Database;
use App\Core\Security;
use App\Core\Utils;
use App\Repositories\PlanRepository;
use App\Repositories\UserRepository;
use App\Services\PdfService; 
use Exception;
class PdfController
{
    private PdfService $pdfService; 
    private array $config; 
    public function __construct()
    {
      
        $pdo = Database::getInstance();
        $this->config = Database::getConfig();
        $settings = Utils::getSettings();
        $planRepository = new PlanRepository($pdo);
        $userRepository = new UserRepository($pdo);
        $this->pdfService = new PdfService($planRepository, $userRepository, $settings);
    }
    public function generateTimetablePdf(int $year, int $week)
    {
        try {
            Security::requireLogin();
            $userId = $_SESSION['user_id'] ?? null;
            $userRole = $_SESSION['user_role'] ?? null;
            // NEU: Logik an Service delegieren
            $pdfOutput = $this->pdfService->generateTimetablePdf($userId, $userRole, $year, $week);
            $filename = sprintf(
                'Stundenplan_KW%02d_%d.pdf',
                $week,
                $year
            );
            header('Content-Type: application/pdf');
            header('Content-Disposition: inline; filename="' . $filename . '"');
            header('Cache-Control: no-cache, no-store, must-revalidate');
            header('Pragma: no-cache');
            header('Expires: 0');
            echo $pdfOutput;
            exit;
        } catch (Exception $e) {
            // NEU: Fehlerbehandlung für Exceptions aus dem Service
            http_response_code($e->getCode() ?: 500);
            $projectRoot = dirname(__DIR__, 3);
            $headerPath = $projectRoot . DIRECTORY_SEPARATOR . 'pages' . DIRECTORY_SEPARATOR . 'partials' . DIRECTORY_SEPARATOR . 'header.php';
            $footerPath = $projectRoot . DIRECTORY_SEPARATOR . 'pages' . DIRECTORY_SEPARATOR . 'partials' . DIRECTORY_SEPARATOR . 'footer.php';
            global $config;
            $config = $this->config;
            $page_title = "PDF Fehler";
            if (file_exists($headerPath)) {
                include_once $headerPath;
            } else {
                echo "<!DOCTYPE html><html><head><title>Fehler</title></head><body>";
                error_log("Error page header not found: " . $headerPath);
            }
            echo '<div class="container message error" style="margin-top: 50px;">';
            echo '<h1>PDF Generierungsfehler</h1>';
            $errorMessage = htmlspecialchars($e->getMessage());
            if (str_contains($e->getMessage(), 'Could not include font definition file') || str_contains($e->getMessage(), 'Font file not found')) {
                $errorMessage = 'Ein Fehler ist beim Laden der Schriftarten für das PDF aufgetreten (' . $errorMessage . '). Stellen Sie sicher, dass die .ttf-Dateien (und ggf. generierte .php/.z-Dateien) im korrekten Verzeichnis (`libs/tfpdf/font/unifont/`) liegen und lesbar sind. Kontaktieren Sie ggf. den Administrator.';
                error_log("PDF Generation Font Error: " . $e->getMessage() . " | Trace: " . $e->getTraceAsString());
            }
            echo '<p>' . $errorMessage . '</p>';
            echo '<p><a href="' . Utils::url('dashboard') . '" class="btn btn-primary">Zurück zum Dashboard</a></p>';
            echo '</div>';
            if (file_exists($footerPath)) {
                include_once $footerPath;
            } else {
                echo "</body></html>";
                error_log("Error page footer not found: " . $footerPath);
            }
            exit;
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\PdfController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\SingleEventController.php ---
<?php
namespace App\Http\Controllers;
use App\Core\Database;
use App\Core\Security;
use App\Repositories\AcademicEventRepository;
use App\Repositories\PlanRepository;
use DateTimeImmutable;
use DateTimeZone;
use Exception;
use PDO;
class SingleEventController
{
    private PDO $pdo;
    private AcademicEventRepository $eventRepo;
    private PlanRepository $planRepo;
    private DateTimeZone $timezone;
    private const PERIOD_TIMES = [
        1 => ['start' => '0800', 'end' => '0845'],
        2 => ['start' => '0855', 'end' => '0940'],
        3 => ['start' => '0940', 'end' => '1025'],
        4 => ['start' => '1035', 'end' => '1120'],
        5 => ['start' => '1120', 'end' => '1205'],
        6 => ['start' => '1305', 'end' => '1350'],
        7 => ['start' => '1350', 'end' => '1435'],
        8 => ['start' => '1445', 'end' => '1530'],
        9 => ['start' => '1530', 'end' => '1615'],
        10 => ['start' => '1625', 'end' => '1710'],
    ];
    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->eventRepo = new AcademicEventRepository($this->pdo);
        $this->planRepo = new PlanRepository($this->pdo);
        $this->timezone = new DateTimeZone('Europe/Berlin');
    }
    public function generateIcs(string $type, int $id)
    {
        try {
            Security::requireLogin(); 
            $eventData = null;
            if ($type === 'acad') {
                $eventData = $this->getAcademicEventData($id);
            } elseif ($type === 'sub') {
                $eventData = $this->getSubstitutionEventData($id);
            } else {
                throw new Exception("Ungültiger Event-Typ.", 400);
            }
            if (!$eventData) {
                throw new Exception("Termin nicht gefunden.", 404);
            }
            $icsContent = $this->formatAsIcs($eventData);
            $filename = str_replace(' ', '_', $eventData['summary'] ?? 'termin') . '.ics';
            header('Content-Type: text/calendar; charset=utf-8');
            header('Content-Disposition: attachment; filename="' . $filename . '"');
            header('Cache-Control: no-cache, no-store, must-revalidate');
            header('Pragma: no-cache');
            header('Expires: 0');
            echo $icsContent;
            exit;
        } catch (Exception $e) {
            http_response_code($e->getCode() ?: 500);
            die("Fehler beim Erstellen der Kalenderdatei: " . htmlspecialchars($e->getMessage()));
        }
    }
    private function getAcademicEventData(int $id): ?array
    {
        $event = $this->eventRepo->getEventById($id); 
        if (!$event) return null;
        $dateObj = new DateTimeImmutable($event['due_date'] . ' 00:00:00', $this->timezone);
        $dtStart = $dateObj;
        $dtEnd = $dateObj->modify('+1 day');
        $dtStartFormat = 'Ymd';
        $dtEndFormat = 'Ymd';
        $timeInfo = "";
        $location = ""; 
        $icon = 'ℹ️'; $prefix = 'Info';
        if ($event['event_type'] === 'klausur') { $icon = '🎓'; $prefix = 'Klausur'; }
        if ($event['event_type'] === 'aufgabe') { $icon = '📚'; $prefix = 'Aufgabe'; }
        $summary = "{$icon} {$prefix}: " . ($event['title'] ?? 'Eintrag');
        if ($event['subject_shortcut']) {
            $summary .= " (" . $event['subject_shortcut'] . ")";
        }
        $description = "Typ: " . ucfirst($event['event_type']) . "\n";
        $description .= "Fach: " . ($event['subject_shortcut'] ?? '-') . "\n";
        $description .= "Klasse: " . ($event['class_name'] ?? '?') . "\n";
        $description .= "Datum: " . $dateObj->format('d.m.Y') . $timeInfo . "\n";
        if ($event['description']) {
            $description .= "\nBeschreibung:\n" . $event['description'];
        }
        return [
            'uid' => 'acad-' . $event['event_id'],
            'dtStart' => $dtStart,
            'dtEnd' => $dtEnd,
            'dtStartFormat' => $dtStartFormat,
            'dtEndFormat' => $dtEndFormat,
            'summary' => $summary,
            'location' => $location,
            'description' => trim($description),
            'status' => 'CONFIRMED',
        ];
    }
    private function getSubstitutionEventData(int $id): ?array
    {
        $sub = $this->planRepo->getSubstitutionById($id); 
        if (!$sub || $sub['substitution_type'] !== 'Sonderevent') {
            return null; 
        }
        $dateObj = new DateTimeImmutable($sub['date'] . ' 00:00:00', $this->timezone);
        $period = (int)$sub['period_number'];
        $times = self::PERIOD_TIMES[$period] ?? null;
        if (!$times) {
            throw new Exception("Ungültige Zeit für Sonderevent.");
        }
        $dtStart = $dateObj->setTime((int)substr($times['start'], 0, 2), (int)substr($times['start'], 2, 2));
        $dtEnd = $dateObj->setTime((int)substr($times['end'], 0, 2), (int)substr($times['end'], 2, 2));
        $dtStartFormat = 'Ymd\THis';
        $dtEndFormat = 'Ymd\THis';
        $summary = "Sonderevent: " . ($sub['comment'] ?: $sub['new_subject_shortcut'] ?: 'Termin');
        $location = $sub['new_room_name'] ?? '';
        $description = "Sonderevent\n";
        $description .= "Klasse: " . ($sub['class_name'] ?? '?') . "\n";
        $description .= "Raum: " . ($location ?: '?') . "\n";
        if ($sub['comment']) {
            $description .= "Details: " . $sub['comment'];
        }
        return [
            'uid' => 'sub-' . $sub['substitution_id'],
            'dtStart' => $dtStart,
            'dtEnd' => $dtEnd,
            'dtStartFormat' => $dtStartFormat,
            'dtEndFormat' => $dtEndFormat,
            'summary' => $summary,
            'location' => $location,
            'description' => trim($description),
            'status' => 'CONFIRMED',
        ];
    }
    private function formatAsIcs(array $event): string
    {
        $ics = "BEGIN:VCALENDAR\r\n";
        $ics .= "VERSION:2.0\r\n";
        $ics .= "PRODID:-//PMI//PAUSE Einzeltermin v1.0//DE\r\n";
        $ics .= "CALSCALE:GREGORIAN\r\n";
        $ics .= "METHOD:PUBLISH\r\n";
        $ics .= "BEGIN:VTIMEZONE\r\n";
        $ics .= "TZID:Europe/Berlin\r\n";
        $ics .= "X-LIC-LOCATION:Europe/Berlin\r\n";
        $ics .= "BEGIN:DAYLIGHT\r\n";
        $ics .= "TZOFFSETFROM:+0100\r\n";
        $ics .= "TZOFFSETTO:+0200\r\n";
        $ics .= "TZNAME:CEST\r\n";
        $ics .= "DTSTART:19700329T020000\r\n";
        $ics .= "RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\n";
        $ics .= "END:DAYLIGHT\r\n";
        $ics .= "BEGIN:STANDARD\r\n";
        $ics .= "TZOFFSETFROM:+0200\r\n";
        $ics .= "TZOFFSETTO:+0100\r\n";
        $ics .= "TZNAME:CET\r\n";
        $ics .= "DTSTART:19701025T030000\r\n";
        $ics .= "RRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\n";
        $ics .= "END:STANDARD\r\n";
        $ics .= "END:VTIMEZONE\r\n";
        $nowUtc = gmdate('Ymd\THis\Z');
        $dtStart = $event['dtStart'];
        $dtEnd = $event['dtEnd'];
        $dtStartFormat = $event['dtStartFormat'] ?? 'Ymd\THis';
        $dtEndFormat = $event['dtEndFormat'] ?? 'Ymd\THis';
        $dtStartString = $dtStart->format($dtStartFormat);
        $dtEndString = $dtEnd->format($dtEndFormat);
        $datePrefix = ($dtStartFormat === 'Ymd') ? ';VALUE=DATE' : ';TZID=Europe/Berlin';
        if ($dtStartFormat === 'Ymd\THis' && $dtEndFormat === 'Ymd') {
             $dtEndString = $dtEnd->format('Ymd\THis'); 
        }
        $ics .= "BEGIN:VEVENT\r\n";
        $ics .= "UID:" . $event['uid'] . '-' . $dtStart->format('YmdHis') . "@pause.pmi\r\n";
        $ics .= "DTSTAMP:" . $nowUtc . "\r\n";
        $ics .= "DTSTART{$datePrefix}:" . $dtStartString . "\r\n";
        $ics .= "DTEND{$datePrefix}:" . $dtEndString . "\r\n";
        $ics .= "SUMMARY:" . $this->escapeIcsString($event['summary']) . "\r\n";
        if (!empty($event['location'])) {
            $ics .= "LOCATION:" . $this->escapeIcsString($event['location']) . "\r\n";
        }
        if (!empty($event['description'])) {
            $ics .= "DESCRIPTION:" . $this->escapeIcsString($event['description']) . "\r\n";
        }
        $ics .= "STATUS:" . $event['status'] . "\r\n";
        $ics .= ($dtStartFormat === 'Ymd') ? "TRANSP:TRANSPARENT\r\n" : "TRANSP:OPAQUE\r\n";
        $ics .= "END:VEVENT\r\n";
        $ics .= "END:VCALENDAR\r\n";
        return $ics;
    }
    private function escapeIcsString(?string $string): string {
        if ($string === null) return '';
        $string = str_replace('\\', '\\\\', $string);
        $string = str_replace(';', '\;', $string);
        $string = str_replace(',', '\,', $string);
        $string = str_replace("\r", '', $string);
        $string = str_replace("\n", '\n', $string);
        return $string;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\SingleEventController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\TeacherController.php ---
<?php
namespace App\Http\Controllers;
use App\Core\Database;
use App\Core\Security;
use App\Core\Utils;
use App\Repositories\StammdatenRepository;
use App\Repositories\PlanRepository;
use App\Repositories\UserRepository;
use App\Repositories\AttendanceRepository;
use App\Repositories\AppointmentRepository;
use App\Services\AuditLogger;
use Exception;
use PDO;
use DateTime;
use DateTimeZone;
use App\Http\Traits\ApiHandlerTrait;

class TeacherController
{
    use ApiHandlerTrait;

    private PDO $pdo;
    private StammdatenRepository $stammdatenRepo;
    private PlanRepository $planRepo;
    private UserRepository $userRepo;
    private AttendanceRepository $attendanceRepo;
    private AppointmentRepository $appointmentRepo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
        $this->planRepo = new PlanRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
        $this->attendanceRepo = new AttendanceRepository($this->pdo);
        $this->appointmentRepo = new AppointmentRepository($this->pdo);
    }

    public function searchColleaguesApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von $_GET
            $query = filter_var($data['query'] ?? '', FILTER_UNSAFE_RAW);
            
            $allTeachers = $this->stammdatenRepo->getTeachers();
            $filteredTeachers = [];

            if (!empty($query)) {
                $filteredTeachers = array_filter($allTeachers, function($teacher) use ($query) {
                    $fullName = $teacher['first_name'] . ' ' . $teacher['last_name'];
                    return stripos($fullName, $query) !== false ||
                           stripos($teacher['teacher_shortcut'], $query) !== false;
                });
            } else {
                $filteredTeachers = array_slice($allTeachers, 0, 10);
            }
            
            echo json_encode(['success' => true, 'data' => array_values($filteredTeachers)]);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => ['lehrer', 'schueler']
        ]);
    }

    public function findColleagueApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von $_GET
            $teacherId = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            if (!$teacherId) {
                throw new Exception("Keine Lehrer-ID angegeben.", 400);
            }
            
            $now = new DateTime('now', new DateTimeZone('Europe/Berlin'));
            $currentDate = $now->format('Y-m-d');
            $currentYear = (int)$now->format('o');
            $currentWeek = (int)$now->format('W');
            $currentDayOfWeek = (int)$now->format('N');
            $currentHourMinute = (int)$now->format('Hi');
            $currentPeriod = $this->getCurrentPeriod($currentHourMinute);

            if ($currentDayOfWeek > 5 || $currentPeriod === null) {
                echo json_encode(['success' => true, 'data' => [
                    'status' => 'Außerhalb der Zeit',
                    'message' => 'Der Kollege befindet sich wahrscheinlich nicht im Unterricht (Wochenende oder außerhalb der Unterrichtszeit).'
                ]]);
                return ['is_get_request' => true];
            }

            $lessonInfo = $this->planRepo->findTeacherLocation(
                $teacherId,
                $currentDate,
                $currentYear,
                $currentWeek,
                $currentDayOfWeek,
                $currentPeriod
            );

            $message = $this->formatLessonInfo($lessonInfo);
            
            echo json_encode(['success' => true, 'data' => [
                'status' => $lessonInfo['status'],
                'message' => $message,
                'details' => $lessonInfo['data'] ?? null
            ]]);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => 'lehrer'
        ]);
    }

    public function getCurrentLessonWithStudentsApi()
    {
        $this->handleApiRequest(function($data) {
            $user = $this->userRepo->findById($_SESSION['user_id']);
            if (!$user || !$user['teacher_id']) {
                throw new Exception("Kein gültiges Lehrerprofil gefunden.", 403);
            }
            $teacherId = $user['teacher_id'];

            $now = new DateTime('now', new DateTimeZone('Europe/Berlin'));
            $currentDate = $now->format('Y-m-d');
            $currentYear = (int)$now->format('o');
            $currentWeek = (int)$now->format('W');
            $currentDayOfWeek = (int)$now->format('N');
            $currentHourMinute = (int)$now->format('Hi');
            $currentPeriod = $this->getCurrentPeriod($currentHourMinute);

            if ($currentDayOfWeek > 5 || $currentPeriod === null) {
                echo json_encode(['success' => true, 'data' => ['status' => 'Außerhalb der Zeit', 'lesson' => null, 'students' => []]]);
                return ['is_get_request' => true];
            }

            $lessonInfo = $this->planRepo->findTeacherLocation(
                $teacherId,
                $currentDate,
                $currentYear,
                $currentWeek,
                $currentDayOfWeek,
                $currentPeriod
            );

            if ($lessonInfo['status'] === 'Unterricht' || $lessonInfo['status'] === 'Vertretung') {
                $lessonData = $lessonInfo['data'];
                $classId = $lessonData['class_id'];
                $students = $this->userRepo->getStudentsByClassId($classId);
                $attendance = $this->attendanceRepo->getAttendance($classId, $currentDate, $currentPeriod);
                
                echo json_encode(['success' => true, 'data' => [
                    'status' => $lessonInfo['status'],
                    'lesson' => $lessonData,
                    'students' => $students,
                    'attendance' => $attendance,
                    'context' => ['date' => $currentDate, 'period' => $currentPeriod]
                ]]);
            } else {
                echo json_encode(['success' => true, 'data' => ['status' => $lessonInfo['status'], 'lesson' => null, 'students' => []]]);
            }
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => 'lehrer'
        ]);
    }

    public function saveAttendanceApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $user = $this->userRepo->findById($_SESSION['user_id']);
            if (!$user || !$user['teacher_id']) {
                throw new Exception("Kein gültiges Lehrerprofil gefunden.", 403);
            }
            $teacherUserId = $user['user_id'];
            
            $classId = filter_var($data['class_id'] ?? null, FILTER_VALIDATE_INT);
            $date = $data['date'] ?? null;
            $period = filter_var($data['period_number'] ?? null, FILTER_VALIDATE_INT);
            $students = $data['students'] ?? [];

            if (!$classId || !$date || !$period || empty($students) || !is_array($students)) {
                throw new Exception("Fehlende oder ungültige Daten (Klasse, Datum, Stunde oder Schülerliste).", 400);
            }

            $success = $this->attendanceRepo->saveAttendance(
                $teacherUserId,
                $classId,
                $date,
                $period,
                $students
            );
            
            if ($success) {
                echo json_encode(['success' => true, 'message' => 'Anwesenheit gespeichert!']);
                return [
                    'log_action' => 'save_attendance',
                    'log_target_type' => 'class',
                    'log_target_id' => $classId,
                    'log_details' => [
                        'date' => $date,
                        'period' => $period,
                        'student_count' => count($students)
                    ]
                ];
            } else {
                throw new Exception("Anwesenheit konnte nicht gespeichert werden.");
            }
        }, [
            'inputType' => 'json',
            'checkRole' => 'lehrer'
        ]);
    }
    
    public function getPrerequisitesApi()
    {
        $this->handleApiRequest(function($data) {
            $user = $this->userRepo->findById($_SESSION['user_id']);
            if (!$user || !$user['teacher_id']) {
                throw new Exception("Kein gültiges Lehrerprofil gefunden.", 403);
            }
            $teacherId = $user['teacher_id'];

            $subjects = $this->stammdatenRepo->getSubjects();
            $classes = $this->planRepo->getClassesForTeacher($teacherId);

            echo json_encode([
                'success' => true,
                'data' => [
                    'subjects' => $subjects,
                    'classes' => $classes
                ]
            ]);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => 'lehrer'
        ]);
    }

    public function getOfficeHoursApi()
    {
        $this->handleApiRequest(function($data) {
            $teacherUserId = $_SESSION['user_id'];
            $availabilities = $this->appointmentRepo->getAvailabilities($teacherUserId);
            echo json_encode(['success' => true, 'data' => $availabilities]);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => 'lehrer'
        ]);
    }

    public function saveOfficeHoursApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $teacherUserId = $_SESSION['user_id'];
            $dayOfWeek = filter_var($data['day_of_week'] ?? null, FILTER_VALIDATE_INT);
            $startTime = $data['start_time'] ?? null;
            $endTime = $data['end_time'] ?? null;
            $slotDuration = filter_var($data['slot_duration'] ?? 15, FILTER_VALIDATE_INT);
            $location = isset($data['location']) ? trim($data['location']) : null;

            if (!$dayOfWeek || !$startTime || !$endTime || !$slotDuration || $dayOfWeek < 1 || $dayOfWeek > 5 || $slotDuration < 5 || empty($location)) {
                throw new Exception("Ungültige Eingabedaten. Alle Felder (Tag, Zeiten, Dauer, Ort) sind erforderlich.", 400);
            }

            $newId = $this->appointmentRepo->createAvailability($teacherUserId, $dayOfWeek, $startTime, $endTime, $slotDuration, $location);
            
            echo json_encode(['success' => true, 'message' => 'Sprechzeit erfolgreich gespeichert.', 'data' => ['availability_id' => $newId]]);

            return [
                'log_action' => 'create_office_hours',
                'log_target_type' => 'teacher_availability',
                'log_target_id' => $newId,
                'log_details' => $data
            ];
        }, [
            'inputType' => 'json',
            'checkRole' => 'lehrer'
        ]);
    }

    public function deleteOfficeHoursApi()
    {
        $this->handleApiRequest(function($data) { // $data kommt von JSON
            $teacherUserId = $_SESSION['user_id'];
            $availabilityId = filter_var($data['availability_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$availabilityId) {
                throw new Exception("Keine ID angegeben.", 400);
            }

            $success = $this->appointmentRepo->deleteAvailability($availabilityId, $teacherUserId);
            
            if ($success) {
                echo json_encode(['success' => true, 'message' => 'Sprechzeit erfolgreich gelöscht.']);
                return [
                    'log_action' => 'delete_office_hours',
                    'log_target_type' => 'teacher_availability',
                    'log_target_id' => $availabilityId
                ];
            } else {
                throw new Exception("Sprechzeit nicht gefunden oder keine Berechtigung.", 404);
            }
        }, [
            'inputType' => 'json',
            'checkRole' => 'lehrer'
        ]);
    }

    public function getAllAppointmentsApi()
    {
        $this->handleApiRequest(function($data) {
            $teacherUserId = $_SESSION['user_id'];
            $now = (new DateTime('now', new DateTimeZone('Europe/Berlin')))->format('Y-m-d H:i:s');
            
            // Zukünftige/Heutige Termine (Neueste zuerst -> DESC)
            $allAppointments = $this->appointmentRepo->getAllAppointmentsForTeacher($teacherUserId, 'DESC');
            
            $futureAppointments = array_filter($allAppointments, fn($app) => $app['appointment_date'] . ' ' . $app['appointment_time'] >= $now);
            $pastAppointments = array_filter($allAppointments, fn($app) => $app['appointment_date'] . ' ' . $app['appointment_time'] < $now);

            echo json_encode(['success' => true, 'data' => [
                'future' => array_values($futureAppointments),
                'past' => array_values($pastAppointments)
            ]]);
            
            return ['is_get_request' => true];
        }, [
            'inputType' => 'get',
            'checkRole' => 'lehrer'
        ]);
    }

    private function getCurrentPeriod(int $hourMinute): ?int
    {
        if ($hourMinute >= 800 && $hourMinute <= 845) return 1;
        if ($hourMinute >= 855 && $hourMinute <= 940) return 2;
        if ($hourMinute >= 940 && $hourMinute <= 1025) return 3;
        if ($hourMinute >= 1035 && $hourMinute <= 1120) return 4;
        if ($hourMinute >= 1120 && $hourMinute <= 1205) return 5;
        if ($hourMinute >= 1305 && $hourMinute <= 1350) return 6;
        if ($hourMinute >= 1350 && $hourMinute <= 1435) return 7;
        if ($hourMinute >= 1445 && $hourMinute <= 1530) return 8;
        if ($hourMinute >= 1530 && $hourMinute <= 1615) return 9;
        if ($hourMinute >= 1625 && $hourMinute <= 1710) return 10;
        return null;
    }

    private function formatLessonInfo(array $info): string
    {
        $data = $info['data'] ?? null;
        switch ($info['status']) {
            case 'Unterricht':
                return sprintf(
                    "Hält regulären Unterricht (%s) in Klasse %s in Raum %s.",
                    htmlspecialchars($data['subject_shortcut'] ?? '?'),
                    htmlspecialchars($data['class_name'] ?? '?'),
                    htmlspecialchars($data['room_name'] ?? '?')
                );
            case 'Vertretung':
                return sprintf(
                    "Ist als Vertretung (%s) in Klasse %s in Raum %s.",
                    htmlspecialchars($data['new_subject_shortcut'] ?? '?'),
                    htmlspecialchars($data['class_name'] ?? '?'),
                    htmlspecialchars($data['new_room_name'] ?? '?')
                );
            case 'Entfall':
                return sprintf(
                    "Die Stunde (%s, Klasse %s) entfällt. Der Kollege ist voraussichtlich frei.",
                    htmlspecialchars($data['original_subject_shortcut'] ?? '?'),
                    htmlspecialchars($data['class_name'] ?? '?')
                );
            case 'Raumänderung':
                return sprintf(
                    "Die Stunde (%s, Klasse %s) wurde nach Raum %s verlegt.",
                    htmlspecialchars($data['original_subject_shortcut'] ?? '?'),
                    htmlspecialchars($data['class_name'] ?? '?'),
                    htmlspecialchars($data['new_room_name'] ?? '?')
                );
            case 'Sonderevent':
                return sprintf(
                    "Nimmt am Sonderevent '%s' (Klasse %s) in Raum %s teil.",
                    htmlspecialchars($data['comment'] ?? 'Event'),
                    htmlspecialchars($data['class_name'] ?? '?'),
                    htmlspecialchars($data['new_room_name'] ?? '?')
                );
            case 'Freistunde':
                return "Hat laut Plan jetzt eine Freistunde (FU).";
            default:
                return "Status unbekannt.";
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\TeacherController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Traits\ApiHandlerTrait.php ---
<?php
namespace App\Http\Traits;
use App\Core\Security;
use App\Services\AuditLogger;
use Exception;
use PDOException; // Sicherstellen, dass PDOException importiert ist

trait ApiHandlerTrait
{
    protected function handleApiRequest(callable $callback, array $options = []): void
    {
        $inputType = $options['inputType'] ?? 'json';
        $roleToCheck = $options['checkRole'] ?? null;
        if (!headers_sent()) {
            header('Content-Type: application/json');
        }
        $data = [];
        try {
            if ($roleToCheck) {
                Security::requireRole($roleToCheck);
            }
            if ($inputType !== 'get') {
                Security::verifyCsrfToken();
            }
            switch ($inputType) {
                case 'json':
                    $input = file_get_contents('php://input');
                    $data = json_decode($input, true);
                    if (json_last_error() !== JSON_ERROR_NONE && !empty($input)) {
                        throw new Exception("Ungültige JSON-Daten empfangen.", 400);
                    }
                    break;
                case 'form':
                    $data = $_POST;
                    break;
                case 'get':
                    $data = $_GET;
                    break;
            }
           
            // Für 'form' Input (wie bei SettingsController), übergeben wir auch $_FILES
            $files = ($inputType === 'form') ? $_FILES : [];
            $result = $callback($data, $files); // $data ist $_POST, $files ist $_FILES

            if (isset($result['is_get_request']) && $result['is_get_request'] === true) {
                // GET-Anfrage hat bereits per echo ausgegeben
            } elseif (isset($result['json_response'])) {
                // Standard-Antwortstruktur
                if (isset($result['log_action'])) {
                    AuditLogger::log(
                        $result['log_action'],
                        $result['log_target_type'] ?? null,
                        $result['log_target_id'] ?? null,
                        $result['log_details'] ?? null
                    );
                }
                echo json_encode($result['json_response'], JSON_THROW_ON_ERROR);
            } else {
                // Manueller echo-Fall (wie in SettingsController)
                if (isset($result['log_action'])) {
                    AuditLogger::log(
                        $result['log_action'],
                        $result['log_target_type'] ?? null,
                        $result['log_target_id'] ?? null,
                        $result['log_details'] ?? null
                    );
                }
            }
        } catch (\Throwable $e) { // GEÄNDERT: Von Exception zu Throwable
            $statusCode = 500;
            if ($e instanceof PDOException) {
                if ($e->errorInfo[1] == 1062) {
                    $statusCode = 409;
                } else {
                    $statusCode = 500;
                }
            } elseif (is_int($e->getCode()) && $e->getCode() >= 400 && $e->getCode() < 600) {
                $statusCode = $e->getCode();
            } elseif (str_contains($e->getMessage(), 'CSRF')) {
                $statusCode = 403;
            } elseif (str_contains($e->getMessage(), 'Berechtigung') || str_contains($e->getMessage(), 'Rolle')) {
                $statusCode = 403;
            }
            http_response_code($statusCode);
            if ($statusCode >= 500) {
                error_log("API Fehler (Trait): " . $e->getMessage() . "\n" . $e->getTraceAsString());
            }
            echo json_encode([
                'success' => false,
                'message' => $e->getMessage()
            ], JSON_THROW_ON_ERROR);
        }
        exit();
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Traits\ApiHandlerTrait.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AcademicEventRepository.php ---
<?php
namespace App\Repositories;
use PDO;
use Exception;
use DateTime; 
class AcademicEventRepository
{
    private PDO $pdo;
    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }
    public function getEventsForClassByWeek(int $classId, int $year, int $week): array
    {
        $monday = new DateTime();
        $monday->setISODate($year, $week, 1); 
        $startDate = $monday->format('Y-m-d');
        $sunday = new DateTime();
        $sunday->setISODate($year, $week, 7); 
        $endDate = $sunday->format('Y-m-d');
        return $this->getEventsForClassByDateRange($classId, $startDate, $endDate);
    }
    public function getEventsForClassByDateRange(int $classId, string $startDate, string $endDate): array
    {
        $sql = "SELECT
                    ae.*,
                    s.subject_shortcut,
                    u.first_name AS teacher_first_name,
                    u.last_name AS teacher_last_name
                FROM academic_events ae
                LEFT JOIN subjects s ON ae.subject_id = s.subject_id
                JOIN users u ON ae.user_id = u.user_id
                WHERE ae.class_id = :class_id
                  AND ae.due_date BETWEEN :start_date AND :end_date
                ORDER BY ae.due_date ASC, ae.event_type ASC";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':class_id' => $classId,
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function getEventsByTeacher(int $teacherUserId, int $daysInFuture = 14): array
    {
        $startDate = (new DateTime('now', new \DateTimeZone('Europe/Berlin')))->format('Y-m-d');
        $endDate = (new DateTime('now', new \DateTimeZone('Europe/Berlin')))->modify("+{$daysInFuture} days")->format('Y-m-d');
        return $this->getEventsByTeacherForDateRange($teacherUserId, $startDate, $endDate);
    }
    public function getEventsByTeacherForDateRange(int $teacherUserId, string $startDate, string $endDate): array
    {
         $sql = "SELECT
                    ae.*,
                    s.subject_shortcut,
                    c.class_name
                FROM academic_events ae
                LEFT JOIN subjects s ON ae.subject_id = s.subject_id
                JOIN classes c ON ae.class_id = c.class_id
                WHERE ae.user_id = :teacher_user_id
                  AND ae.due_date BETWEEN :start_date AND :end_date
                ORDER BY ae.due_date ASC, c.class_name ASC";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':teacher_user_id' => $teacherUserId,
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function checkTeacherAuthorization(int $teacherId, int $classId, string $date): bool
    {
        try {
            $dateObj = new DateTime($date);
            $year = (int)$dateObj->format('o');
            $week = (int)$dateObj->format('W');
            $dayOfWeek = (int)$dateObj->format('N'); 
            $sqlRegular = "SELECT 1 FROM timetable_entries
                           WHERE teacher_id = :teacher_id
                             AND class_id = :class_id
                             AND year = :year
                             AND calendar_week = :week
                             AND day_of_week = :day_of_week
                           LIMIT 1";
            $stmtRegular = $this->pdo->prepare($sqlRegular);
            $stmtRegular->execute([
                ':teacher_id' => $teacherId,
                ':class_id' => $classId,
                ':year' => $year,
                ':week' => $week,
                ':day_of_week' => $dayOfWeek
            ]);
            if ($stmtRegular->fetchColumn()) {
                return true; 
            }
            $sqlSub = "SELECT 1 FROM substitutions
                       WHERE new_teacher_id = :teacher_id
                         AND class_id = :class_id
                         AND date = :date
                       LIMIT 1";
            $stmtSub = $this->pdo->prepare($sqlSub);
            $stmtSub->execute([
                ':teacher_id' => $teacherId,
                ':class_id' => $classId,
                ':date' => $date
            ]);
            if ($stmtSub->fetchColumn()) {
                return true; 
            }
            return false; 
        } catch (Exception $e) {
            error_log("Fehler bei checkTeacherAuthorization: " . $e->getMessage());
            return false; 
        }
    }
    public function saveEvent(?int $eventId, int $teacherUserId, int $classId, ?int $subjectId, string $eventType, string $title, string $dueDate, ?string $description): array
    {
        if ($eventId) {
            $sql = "UPDATE academic_events SET
                        class_id = :class_id,
                        subject_id = :subject_id,
                        event_type = :event_type,
                        title = :title,
                        due_date = :due_date,
                        description = :description
                    WHERE event_id = :event_id AND user_id = :teacher_user_id";
            $params = [
                ':event_id' => $eventId,
                ':teacher_user_id' => $teacherUserId,
                ':class_id' => $classId,
                ':subject_id' => $subjectId,
                ':event_type' => $eventType,
                ':title' => $title,
                ':due_date' => $dueDate,
                ':description' => $description
            ];
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute($params);
        } else {
            $sql = "INSERT INTO academic_events
                        (user_id, class_id, subject_id, event_type, title, due_date, description)
                    VALUES
                        (:teacher_user_id, :class_id, :subject_id, :event_type, :title, :due_date, :description)";
            $params = [
                ':teacher_user_id' => $teacherUserId,
                ':class_id' => $classId,
                ':subject_id' => $subjectId,
                ':event_type' => $eventType,
                ':title' => $title,
                ':due_date' => $dueDate,
                ':description' => $description
            ];
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute($params);
            $eventId = (int)$this->pdo->lastInsertId();
        }
        $savedEvent = $this->getEventById($eventId);
        if (!$savedEvent) {
            throw new Exception("Fehler beim Abrufen des gespeicherten Events.");
        }
        return $savedEvent;
    }
    public function deleteEvent(int $eventId, int $teacherUserId): bool
    {
        $sql = "DELETE FROM academic_events
                WHERE event_id = :event_id AND user_id = :teacher_user_id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':event_id' => $eventId,
            ':teacher_user_id' => $teacherUserId
        ]);
        return $stmt->rowCount() > 0;
    }
    public function getEventById(int $eventId)
    {
         $sql = "SELECT
                    ae.*,
                    s.subject_shortcut,
                    c.class_name,
                    u.first_name AS teacher_first_name,
                    u.last_name AS teacher_last_name
                FROM academic_events ae
                LEFT JOIN subjects s ON ae.subject_id = s.subject_id
                JOIN classes c ON ae.class_id = c.class_id
                JOIN users u ON ae.user_id = u.user_id
                WHERE ae.event_id = :event_id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':event_id' => $eventId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AcademicEventRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AnnouncementRepository.php ---
<?php
namespace App\Repositories;
use PDO;
use Exception; 
class AnnouncementRepository
{
    private PDO $pdo;
    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }
    public function createAnnouncement(int $userId, string $title, string $content, string $targetRole, ?int $targetClassId, ?string $attachmentPath): int
    {
        $isGlobal = !($targetRole === 'schueler' && $targetClassId !== null);
        $dbClassId = ($targetRole === 'schueler' && $targetClassId !== null) ? $targetClassId : null;
        $sql = "INSERT INTO announcements (user_id, title, content, is_global, class_id, file_path, created_at) 
                VALUES (:user_id, :title, :content, :is_global, :class_id, :file_path, NOW())";
        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([
            ':user_id' => $userId,
            ':title' => $title,
            ':content' => $content,
            ':is_global' => $isGlobal ? 1 : 0,
            ':class_id' => $dbClassId,
            ':file_path' => $attachmentPath 
        ]);
        if (!$success) {
            error_log("Announcement creation failed: " . print_r($stmt->errorInfo(), true));
            throw new Exception("Fehler beim Erstellen der Ankündigung.");
        }
        return (int)$this->pdo->lastInsertId();
    }
    public function getVisibleAnnouncements(string $userRole, ?int $classId): array
    {
        $sql = "SELECT a.*, CONCAT(u.first_name, ' ', u.last_name) as author_name, c.class_name as target_class_name
                FROM announcements a
                JOIN users u ON a.user_id = u.user_id
                LEFT JOIN classes c ON a.class_id = c.class_id
                WHERE (
                    a.is_global = 1"; 
        $params = [];
        if ($userRole === 'schueler' && $classId !== null) {
            $sql .= " OR (a.is_global = 0 AND a.class_id = :class_id)";
            $params[':class_id'] = $classId;
        }
        $sql .= " ) ORDER BY a.created_at DESC LIMIT 20";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($params);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function getAllAnnouncementsWithDetails(): array
    {
        $sql = "SELECT a.*, CONCAT(u.first_name, ' ', u.last_name) as author_name, c.class_name as target_class_name
                FROM announcements a
                JOIN users u ON a.user_id = u.user_id
                LEFT JOIN classes c ON a.class_id = c.class_id
                ORDER BY a.created_at DESC";
        $stmt = $this->pdo->query($sql);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function getAnnouncementById(int $announcementId): array|false
    {
        $sql = "SELECT a.*, CONCAT(u.first_name, ' ', u.last_name) as author_name, c.class_name as target_class_name
                FROM announcements a
                JOIN users u ON a.user_id = u.user_id
                LEFT JOIN classes c ON a.class_id = c.class_id
                WHERE a.announcement_id = :id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':id' => $announcementId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    public function deleteAnnouncement(int $announcementId): bool
    {
        $announcement = $this->getAnnouncementById($announcementId);
        $sql = "DELETE FROM announcements WHERE announcement_id = :id";
        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([':id' => $announcementId]);
        if ($success && $announcement && !empty($announcement['file_path'])) {
             $filePath = dirname(__DIR__, 2) . '/public/' . $announcement['file_path'];
            if (file_exists($filePath)) {
                @unlink($filePath);
            }
        }
        return $success;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AnnouncementRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AppointmentRepository.php ---
<?php
namespace App\Repositories;
use PDO;
use Exception;
use DateTime;
use DateTimeZone;
use DateInterval;
use DatePeriod;

class AppointmentRepository
{
    private PDO $pdo;
    private DateTimeZone $timezone;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
        $this->timezone = new DateTimeZone('Europe/Berlin');
    }

    public function createAvailability(int $teacherUserId, int $dayOfWeek, string $startTime, string $endTime, int $slotDuration, ?string $location): int
    {
        $sql = "INSERT INTO teacher_availability (teacher_user_id, day_of_week, start_time, end_time, slot_duration, location)
              VALUES (:teacher_user_id, :day_of_week, :start_time, :end_time, :slot_duration, :location)";
        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([
            ':teacher_user_id' => $teacherUserId,
            ':day_of_week' => $dayOfWeek,
            ':start_time' => $startTime,
            ':end_time' => $endTime,
            ':slot_duration' => $slotDuration,
            ':location' => $location
        ]);
        if (!$success) {
            throw new Exception("Sprechzeit konnte nicht gespeichert werden (eventuell überlappend?).");
        }
        return (int)$this->pdo->lastInsertId();
    }

    public function deleteAvailability(int $availabilityId, int $teacherUserId): bool
    {
        $this->pdo->beginTransaction();
        try {
            // Zukünftige gebuchte Termine löschen, die zu diesem Fenster gehören
            $sqlDeleteAppointments = "DELETE a FROM appointments a
                                      JOIN teacher_availability ta ON a.teacher_user_id = ta.teacher_user_id
                                      WHERE a.teacher_user_id = :teacher_user_id
                                        AND a.availability_id = :availability_id
                                        AND a.appointment_date >= CURDATE()
                                        AND a.status = 'booked'";

            $stmtDelApp = $this->pdo->prepare($sqlDeleteAppointments);
            $stmtDelApp->execute([
                ':teacher_user_id' => $teacherUserId,
                ':availability_id' => $availabilityId
            ]);
            
            // Das Verfügbarkeitsfenster selbst löschen
            $sqlDeleteAvailability = "DELETE FROM teacher_availability
                                      WHERE availability_id = :availability_id AND teacher_user_id = :teacher_user_id";
            $stmt = $this->pdo->prepare($sqlDeleteAvailability);
            $stmt->execute([
                ':availability_id' => $availabilityId,
                ':teacher_user_id' => $teacherUserId
            ]);
            
            $this->pdo->commit();
            return $stmt->rowCount() > 0;
        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("Fehler beim Löschen der Sprechzeit: " . $e->getMessage());
            return false;
        }
    }

    public function getAvailabilities(int $teacherUserId): array
    {
        $sql = "SELECT * FROM teacher_availability WHERE teacher_user_id = :teacher_user_id ORDER BY day_of_week, start_time";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':teacher_user_id' => $teacherUserId]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    /**
     * Holt alle verfügbaren (nicht gebuchten) Slots für einen Lehrer in einem zukünftigen Zeitraum.
     */
    public function getUpcomingAvailableSlots(int $teacherUserId, int $daysInFuture = 14): array
    {
        // 1. Alle Verfügbarkeitsfenster des Lehrers holen
        $availabilities = $this->getAvailabilities($teacherUserId);
        if (empty($availabilities)) {
            return [];
        }

        $today = new DateTime('now', $this->timezone);
        $today->setTime(0, 0, 0);
        $endDate = (new DateTime('now', $this->timezone))->modify("+{$daysInFuture} days");

        // 2. Alle gebuchten Termine in diesem Zeitraum holen
        $sqlBooked = "SELECT appointment_date, appointment_time FROM appointments
                           WHERE teacher_user_id = :teacher_user_id
                             AND appointment_date BETWEEN :start_date AND :end_date
                             AND status = 'booked'";
        $stmtBooked = $this->pdo->prepare($sqlBooked);
        $stmtBooked->execute([
            ':teacher_user_id' => $teacherUserId,
            ':start_date' => $today->format('Y-m-d'),
            ':end_date' => $endDate->format('Y-m-d')
        ]);
        
        $bookedSlots = [];
        foreach ($stmtBooked->fetchAll(PDO::FETCH_ASSOC) as $row) {
            $bookedSlots[$row['appointment_date'] . '_' . $row['appointment_time']] = true;
        }

        // 3. Alle Slots generieren und gegen gebuchte Slots prüfen
        $availableSlots = [];
        $currentDate = $today;
        $dateInterval = new DateInterval('P1D');
        $dateRange = new DatePeriod($currentDate, $dateInterval, $endDate->modify('+1 day')); // +1, damit der letzte Tag inklusiv ist

        foreach ($dateRange as $date) {
            $dayOfWeek = (int)$date->format('N'); // 1 (Mon) - 7 (Son)
            
            // Überspringe Wochenenden
            if ($dayOfWeek > 5) {
                continue;
            }

            // Finde passende Fenster für diesen Wochentag
            $windowsForDay = array_filter($availabilities, fn($av) => $av['day_of_week'] == $dayOfWeek);
            $dateString = $date->format('Y-m-d');

            foreach ($windowsForDay as $window) {
                $start = new DateTime($dateString . ' ' . $window['start_time'], $this->timezone);
                $end = new DateTime($dateString . ' ' . $window['end_time'], $this->timezone);
                $duration = $window['slot_duration'];
                $interval = new DateInterval("PT{$duration}M");
                $slotPeriod = new DatePeriod($start, $interval, $end);

                foreach ($slotPeriod as $slotStart) {
                    $timeString = $slotStart->format('H:i:s');
                    $timeStringShort = $slotStart->format('H:i');
                    
                    // Prüfen, ob Slot bereits gebucht ist
                    if (!isset($bookedSlots[$dateString . '_' . $timeString])) {
                        $availableSlots[] = [
                            'date' => $dateString,
                            'time' => $timeString,
                            'display' => $timeStringShort,
                            'duration' => $duration,
                            'location' => $window['location'] ?? 'N/A', // Standort hinzufügen
                            'availability_id' => $window['availability_id'] // ID des Fensters hinzufügen
                        ];
                    }
                }
            }
        }
        
        return $availableSlots;
    }

    public function bookAppointment(int $studentUserId, int $teacherUserId, int $availabilityId, string $date, string $time, int $duration, ?string $location, ?string $notes): int
    {
        $sql = "INSERT INTO appointments (student_user_id, teacher_user_id, availability_id, appointment_date, appointment_time, duration, location, notes, status)
              VALUES (:student_user_id, :teacher_user_id, :availability_id, :date, :time, :duration, :location, :notes, 'booked')";
        
        try {
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute([
                ':student_user_id' => $studentUserId,
                ':teacher_user_id' => $teacherUserId,
                ':availability_id' => $availabilityId,
                ':date' => $date,
                ':time' => $time,
                ':duration' => $duration,
                ':location' => $location,
                ':notes' => $notes
            ]);
            return (int)$this->pdo->lastInsertId();
        } catch (\PDOException $e) {
            if ($e->errorInfo[1] == 1062) { // Duplicate entry
                throw new Exception("Dieser Termin wurde gerade von jemand anderem gebucht. Bitte wählen Sie einen anderen Slot.", 409);
            } else {
                error_log("Fehler bei Terminbuchung: " . $e->getMessage());
                throw new Exception("Ein Fehler ist bei der Buchung aufgetreten.", 500);
            }
        }
    }

    public function getAppointmentsForStudent(int $studentUserId, string $startDate, string $endDate): array
    {
        $sql = "SELECT a.*, CONCAT(t.first_name, ' ', t.last_name) as teacher_name, t.teacher_shortcut, a.location
                FROM appointments a
                JOIN users u ON a.teacher_user_id = u.user_id
                JOIN teachers t ON u.teacher_id = t.teacher_id
                WHERE a.student_user_id = :student_user_id
                  AND a.status = 'booked'
                  AND a.appointment_date BETWEEN :start_date AND :end_date
                ORDER BY a.appointment_date, a.appointment_time";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':student_user_id' => $studentUserId,
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public function getAppointmentsForTeacher(int $teacherUserId, string $startDate, string $endDate): array
    {
        $sql = "SELECT a.*, CONCAT(u.first_name, ' ', u.last_name) as student_name, c.class_name, c.class_id, a.location
                FROM appointments a
                JOIN users u ON a.student_user_id = u.user_id
                LEFT JOIN classes c ON u.class_id = c.class_id
                WHERE a.teacher_user_id = :teacher_user_id
                  AND a.status = 'booked'
                  AND a.appointment_date BETWEEN :start_date AND :end_date
                ORDER BY a.appointment_date, a.appointment_time";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':teacher_user_id' => $teacherUserId,
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public function cancelAppointment(int $appointmentId, int $userId, string $role): bool
    {
        $sql = "UPDATE appointments SET status = :status
                WHERE appointment_id = :appointment_id AND ";

        if ($role === 'schueler') {
            $sql .= "student_user_id = :user_id";
            $newStatus = 'cancelled_by_student';
        } elseif ($role === 'lehrer') {
            $sql .= "teacher_user_id = :user_id";
            $newStatus = 'cancelled_by_teacher';
        } else {
            throw new Exception("Nur Schüler oder Lehrer können Termine stornieren.", 403);
        }

        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([
            ':status' => $newStatus,
            ':appointment_id' => $appointmentId,
            ':user_id' => $userId
        ]);

        if ($stmt->rowCount() === 0) {
            throw new Exception("Termin nicht gefunden oder keine Berechtigung zum Stornieren.", 404);
        }
        
        return $success;
    }

    public function getAllAppointmentsForTeacher(int $teacherUserId, string $sortOrder = 'DESC'): array
    {
        // NEU: a.notes und a.location hinzugefügt
        $sql = "SELECT a.*, CONCAT(u.first_name, ' ', u.last_name) as student_name, c.class_name, c.class_id, a.notes, a.location
                FROM appointments a
                JOIN users u ON a.student_user_id = u.user_id
                LEFT JOIN classes c ON u.class_id = c.class_id
                WHERE a.teacher_user_id = :teacher_user_id
                  AND a.status = 'booked'
                ORDER BY a.appointment_date " . ($sortOrder === 'DESC' ? 'DESC' : 'ASC') . ", a.appointment_time " . ($sortOrder === 'DESC' ? 'DESC' : 'ASC');
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':teacher_user_id' => $teacherUserId
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AppointmentRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AttendanceRepository.php ---
<?php
namespace App\Repositories;
use PDO;
use Exception;
use PDOException;
class AttendanceRepository
{
    private PDO $pdo;
    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }
    public function saveAttendance(int $teacherUserId, int $classId, string $date, int $periodNumber, array $studentsStatus): bool
    {
        $sql = "INSERT INTO attendance_logs (date, period_number, class_id, student_user_id, teacher_user_id, status)
                VALUES (:date, :period_number, :class_id, :student_user_id, :teacher_user_id, :status)
                ON DUPLICATE KEY UPDATE 
                    teacher_user_id = VALUES(teacher_user_id), 
                    status = VALUES(status)";
        try {
            $this->pdo->beginTransaction();
            $stmt = $this->pdo->prepare($sql);
            foreach ($studentsStatus as $student) {
                if (!isset($student['student_id']) || !isset($student['status'])) {
                    throw new Exception("Ungültige Studentendaten im Batch.");
                }
                $stmt->execute([
                    ':date' => $date,
                    ':period_number' => $periodNumber,
                    ':class_id' => $classId,
                    ':student_user_id' => $student['student_id'],
                    ':teacher_user_id' => $teacherUserId,
                    ':status' => $student['status']
                ]);
            }
            return $this->pdo->commit();
        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("Fehler beim Speichern der Anwesenheit: " . $e->getMessage());
            throw new Exception("Fehler beim Speichern der Anwesenheit: " . $e->getMessage());
        }
    }
    public function getAttendance(int $classId, string $date, int $periodNumber): array
    {
        $sql = "SELECT student_user_id, status 
                FROM attendance_logs
                WHERE class_id = :class_id 
                  AND date = :date 
                  AND period_number = :period_number";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':class_id' => $classId,
            ':date' => $date,
            ':period_number' => $periodNumber
        ]);
        return $stmt->fetchAll(PDO::FETCH_KEY_PAIR) ?: [];
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AttendanceRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AuditLogRepository.php ---
<?php
namespace App\Repositories;
use PDO;
class AuditLogRepository
{
    private PDO $pdo;
    public function __construct(PDO $pdo) { $this->pdo = $pdo; }
    public function getLogs(int $page = 1, int $limit = 20, array $filters = []): array
    {
        $offset = ($page - 1) * $limit;
        $sql = "SELECT l.*, u.username, u.first_name, u.last_name
                FROM audit_logs l
                LEFT JOIN users u ON l.user_id = u.user_id";
        list($whereClause, $params) = $this->buildWhereClause($filters);
        $sql .= $whereClause;
        $sql .= " ORDER BY l.timestamp DESC";
        $sql .= " LIMIT :limit OFFSET :offset";
        $stmt = $this->pdo->prepare($sql);
        $params[':limit'] = $limit;
        $params[':offset'] = $offset;
        $this->bindValues($stmt, $params);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function getLogsCount(array $filters = []): int
    {
        $sql = "SELECT COUNT(*) FROM audit_logs l"; 
        list($whereClause, $params) = $this->buildWhereClause($filters);
        $sql .= $whereClause;
        $stmt = $this->pdo->prepare($sql);
        $this->bindValues($stmt, $params);
        $stmt->execute();
        return (int)$stmt->fetchColumn();
    }
    private function buildWhereClause(array $filters): array
    {
        $where = [];
        $params = [];
        if (!empty($filters['user_id'])) {
            $where[] = "l.user_id = :user_id"; 
            $params[':user_id'] = $filters['user_id'];
        }
        if (!empty($filters['action'])) {
            $where[] = "l.action LIKE :action";
            $params[':action'] = '%' . $filters['action'] . '%';
        }
        if (!empty($filters['target_type'])) {
            $where[] = "l.target_type = :target_type";
            $params[':target_type'] = $filters['target_type'];
        }
        if (!empty($filters['start_date'])) {
            $where[] = "l.timestamp >= :start_date";
            $params[':start_date'] = $filters['start_date'];
        }
        if (!empty($filters['end_date'])) {
            $where[] = "l.timestamp <= :end_date";
            $params[':end_date'] = $filters['end_date'] . ' 23:59:59';
        }
        $whereClause = !empty($where) ? ' WHERE ' . implode(' AND ', $where) : '';
        return [$whereClause, $params];
    }
    private function bindValues(\PDOStatement $stmt, array $params): void
    {
        foreach ($params as $key => $val) {
            if ($key === ':limit' || $key === ':offset' || $key === ':user_id') {
                $stmt->bindValue($key, $val, PDO::PARAM_INT);
            } else {
                $stmt->bindValue($key, $val, PDO::PARAM_STR);
            }
        }
    }
    public function getDistinctActions(): array
    {
        $sql = "SELECT DISTINCT action FROM audit_logs WHERE action IS NOT NULL AND action != '' ORDER BY action ASC";
        $stmt = $this->pdo->query($sql);
        return $stmt->fetchAll(PDO::FETCH_COLUMN);
    }
    public function getDistinctTargetTypes(): array
    {
        $sql = "SELECT DISTINCT target_type FROM audit_logs WHERE target_type IS NOT NULL AND target_type != '' ORDER BY target_type ASC";
        $stmt = $this->pdo->query($sql);
        return $stmt->fetchAll(PDO::FETCH_COLUMN);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AuditLogRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\CommunityPostRepository.php ---
<?php
namespace App\Repositories;
use PDO;
use Exception;
class CommunityPostRepository
{
    private PDO $pdo;
    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }
    public function createPost(int $userId, string $title, string $content, string $initialStatus = 'pending'): int
    {
        $sql = "INSERT INTO community_posts (user_id, title, content, status, created_at)
                VALUES (:user_id, :title, :content, :status, NOW())";
        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([
            ':user_id' => $userId,
            ':title' => $title,
            ':content' => $content,
            ':status' => $initialStatus
        ]);
        if (!$success) {
            throw new Exception("Beitrag konnte nicht erstellt werden.");
        }
        return (int)$this->pdo->lastInsertId();
    }
    public function updatePost(int $postId, int $userId, string $title, string $content, string $newStatus): bool
    {
        $sql = "UPDATE community_posts SET
                    title = :title,
                    content = :content,
                    status = :status,
                    moderated_at = NULL,
                    moderator_id = NULL
                WHERE post_id = :post_id AND user_id = :user_id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':title' => $title,
            ':content' => $content,
            ':status' => $newStatus,
            ':post_id' => $postId,
            ':user_id' => $userId
        ]);
        return $stmt->rowCount() > 0;
    }
    public function getPostsByStatus(string $status, int $limit = 50): array
    {
        $sql = "SELECT p.*, u.username, u.first_name, u.last_name
                FROM community_posts p
                JOIN users u ON p.user_id = u.user_id
                WHERE p.status = :status
                ORDER BY p.created_at DESC
                LIMIT :limit";
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindParam(':status', $status, PDO::PARAM_STR);
        $stmt->bindParam(':limit', $limit, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function getPostsByUserId(int $userId): array
    {
        $sql = "SELECT *
                FROM community_posts
                WHERE user_id = :user_id
                ORDER BY
                    CASE status
                        WHEN 'pending' THEN 1
                        WHEN 'approved' THEN 2
                        WHEN 'rejected' THEN 3
                        ELSE 4
                    END,
                    created_at DESC";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function getApprovedPostsWithAuthorEmail(int $limit = 50): array
    {
        $sql = "SELECT p.*, u.username, u.first_name, u.last_name, u.email
                FROM community_posts p
                JOIN users u ON p.user_id = u.user_id
                WHERE p.status = 'approved'
                ORDER BY p.created_at DESC
                LIMIT :limit";
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindParam(':limit', $limit, PDO::PARAM_INT);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function getPostById(int $postId)
    {
        $sql = "SELECT * FROM community_posts WHERE post_id = :post_id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':post_id' => $postId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    public function updatePostStatus(int $postId, string $newStatus, int $moderatorUserId): bool
    {
        if (!in_array($newStatus, ['approved', 'rejected'])) {
            return false; 
        }
        $sql = "UPDATE community_posts SET
                    status = :status,
                    moderator_id = :moderator_id,
                    moderated_at = NOW()
                WHERE post_id = :post_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':status' => $newStatus,
            ':moderator_id' => $moderatorUserId,
            ':post_id' => $postId
        ]);
    }
    public function deletePost(int $postId): bool
    {
        $sql = "DELETE FROM community_posts WHERE post_id = :post_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':post_id' => $postId]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\CommunityPostRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\LoginAttemptRepository.php ---
<?php
namespace App\Repositories;
use App\Core\Utils; 
use PDO;
class LoginAttemptRepository
{
    private PDO $pdo;
    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }
    public function isAllowed(string $identifier): bool
    {
        $settings = Utils::getSettings();
        $maxAttempts = $settings['max_login_attempts'];
        $lockoutMinutes = $settings['lockout_minutes'];
        $sql = "SELECT COUNT(*) FROM login_attempts
                WHERE identifier = :identifier
                AND attempt_time > (NOW() - INTERVAL :lockout MINUTE)";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':identifier' => $identifier,
            ':lockout' => $lockoutMinutes 
        ]);
        $attempts = (int)$stmt->fetchColumn();
        return $attempts < $maxAttempts; 
    }
    public function recordFailure(string $identifier): void
    {
        $sql = "INSERT INTO login_attempts (identifier, ip_address, attempt_time)
                VALUES (:identifier, :ip_address, NOW())";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':identifier' => $identifier,
            ':ip_address' => $_SERVER['REMOTE_ADDR'] ?? 'UNKNOWN'
        ]);
    }
    public function clearAttempts(string $identifier): void
    {
        $sql = "DELETE FROM login_attempts WHERE identifier = :identifier";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':identifier' => $identifier]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\LoginAttemptRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\PlanRepository.php ---
<?php
namespace App\Repositories;
use PDO;
use Exception;
use DateTime;
use DateTimeZone; 
use PDOException; 
use App\Repositories\TeacherAbsenceRepository; 
class PlanRepository
{
    private PDO $pdo;
    private TeacherAbsenceRepository $absenceRepo; 
    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
        $this->absenceRepo = new TeacherAbsenceRepository($pdo); 
    }
    private function getWeekDateRange(int $year, int $week): array
    {
        $dto = new DateTime();
        $dto->setISODate($year, $week, 1); 
        $startDate = $dto->format('Y-m-d');
        $dto->setISODate($year, $week, 5); 
        $endDate = $dto->format('Y-m-d');
        return [$startDate, $endDate];
    }
    public function getPublishedTimetableForClass(int $classId, int $year, int $calendarWeek): array
    {
        if (!$this->isWeekPublishedFor('student', $year, $calendarWeek)) {
            return []; 
        }
        return $this->getTimetableForClassAsPlaner($classId, $year, $calendarWeek);
    }
    public function getPublishedTimetableForTeacher(int $teacherId, int $year, int $calendarWeek): array
    {
        if (!$this->isWeekPublishedFor('teacher', $year, $calendarWeek)) {
            return []; 
        }
        return $this->getTimetableForTeacherAsPlaner($teacherId, $year, $calendarWeek);
    }
    public function getPublishedSubstitutionsForClassWeek(int $classId, int $year, int $calendarWeek): array
    {
        if (!$this->isWeekPublishedFor('student', $year, $calendarWeek)) {
            return [];
        }
        return $this->getSubstitutionsForClassWeekAsPlaner($classId, $year, $calendarWeek);
    }
    public function getPublishedSubstitutionsForTeacherWeek(int $teacherId, int $year, int $calendarWeek): array
    {
        if (!$this->isWeekPublishedFor('teacher', $year, $calendarWeek)) {
            return [];
        }
        return $this->getSubstitutionsForTeacherWeekAsPlaner($teacherId, $year, $calendarWeek);
    }
    public function getTimetableForClassAsPlaner(int $classId, int $year, int $calendarWeek): array
    {
        $sql = "SELECT te.*, s.subject_shortcut, s.subject_name, t.teacher_shortcut, r.room_name, c.class_name
                FROM timetable_entries te
                LEFT JOIN subjects s ON te.subject_id = s.subject_id
                LEFT JOIN teachers t ON te.teacher_id = t.teacher_id
                LEFT JOIN rooms r ON te.room_id = r.room_id
                LEFT JOIN classes c ON te.class_id = c.class_id
                WHERE te.class_id = :class_id
                    AND te.year = :year
                    AND te.calendar_week = :calendar_week
                ORDER BY te.day_of_week ASC, te.period_number ASC, te.entry_id ASC"; 
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':class_id' => $classId, ':year' => $year, ':calendar_week' => $calendarWeek]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function getTimetableForTeacherAsPlaner(int $teacherId, int $year, int $calendarWeek): array
    {
        $sql = "SELECT te.*, s.subject_shortcut, s.subject_name, c.class_name, r.room_name, t.teacher_shortcut
                FROM timetable_entries te
                LEFT JOIN subjects s ON te.subject_id = s.subject_id
                LEFT JOIN classes c ON te.class_id = c.class_id
                LEFT JOIN rooms r ON te.room_id = r.room_id
                JOIN teachers t ON te.teacher_id = t.teacher_id
                WHERE te.teacher_id = :teacher_id
                    AND te.year = :year
                    AND te.calendar_week = :calendar_week
                ORDER BY te.day_of_week ASC, te.period_number ASC, te.entry_id ASC"; 
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':teacher_id' => $teacherId, ':year' => $year, ':calendar_week' => $calendarWeek]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function getSubstitutionsForClassWeekAsPlaner(int $classId, int $year, int $calendarWeek): array
    {
        return $this->getSubstitutionsForWeekInternal($year, $calendarWeek, $classId, null);
    }
    public function getSubstitutionsForTeacherWeekAsPlaner(int $teacherId, int $year, int $calendarWeek): array
    {
        return $this->getSubstitutionsForWeekInternal($year, $calendarWeek, null, $teacherId);
    }
    private function getSubstitutionsForWeekInternal(int $year, int $calendarWeek, ?int $classId, ?int $teacherId): array
    {
        [$startDate, $endDate] = $this->getWeekDateRange($year, $calendarWeek);
        $sql = "SELECT
                                s.*,
                                DAYOFWEEK(s.date) as day_of_week_iso, 
                                CASE DAYOFWEEK(s.date) WHEN 1 THEN NULL WHEN 7 THEN NULL ELSE DAYOFWEEK(s.date) - 1 END as day_of_week, 
                                orig_s.subject_shortcut as original_subject_shortcut,
                                new_t.teacher_shortcut as new_teacher_shortcut,
                                new_s.subject_shortcut as new_subject_shortcut,
                                new_r.room_name as new_room_name,
                                c.class_name
                            FROM substitutions s
                            JOIN classes c ON s.class_id = c.class_id
                            LEFT JOIN subjects orig_s ON s.original_subject_id = orig_s.subject_id
                            LEFT JOIN teachers new_t ON s.new_teacher_id = new_t.teacher_id
                            LEFT JOIN subjects new_s ON s.new_subject_id = new_s.subject_id
                            LEFT JOIN rooms new_r ON s.new_room_id = new_r.room_id
                            WHERE s.date BETWEEN :start_date AND :end_date";
        $params = [':start_date' => $startDate, ':end_date' => $endDate];
        if ($classId !== null) {
            $sql .= " AND s.class_id = :class_id";
            $params[':class_id'] = $classId;
        } elseif ($teacherId !== null) {
            $sql .= " AND (s.new_teacher_id = :teacher_id OR EXISTS (
                                SELECT 1 FROM timetable_entries te
                                WHERE te.class_id = s.class_id
                                    AND te.year = :year
                                    AND te.calendar_week = :calendar_week
                                    AND te.day_of_week = (CASE DAYOFWEEK(s.date) WHEN 1 THEN NULL WHEN 7 THEN NULL ELSE DAYOFWEEK(s.date) - 1 END)
                                    AND te.period_number = s.period_number
                                    AND te.teacher_id = :teacher_id
                            ))";
            $params[':teacher_id'] = $teacherId;
            $params[':year'] = $year; 
            $params[':calendar_week'] = $calendarWeek;
        }
        $sql .= " ORDER BY s.date ASC, s.period_number ASC";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($params);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function publishWeek(int $year, int $calendarWeek, string $targetGroup, int $userId): bool
    {
        $sql = "INSERT INTO timetable_publish_status (year, calendar_week, target_group, published_at, publisher_user_id)
                VALUES (:year, :calendar_week, :target_group, NOW(), :user_id)
                ON DUPLICATE KEY UPDATE published_at = NOW(), publisher_user_id = VALUES(publisher_user_id)"; 
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':target_group' => $targetGroup,
            ':user_id' => $userId
        ]);
    }
    public function unpublishWeek(int $year, int $calendarWeek, string $targetGroup): bool
    {
        $sql = "DELETE FROM timetable_publish_status
                WHERE year = :year AND calendar_week = :calendar_week AND target_group = :target_group";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':target_group' => $targetGroup
        ]);
    }
    public function getPublishStatus(int $year, int $calendarWeek): array
    {
        $sql = "SELECT target_group FROM timetable_publish_status
                WHERE year = :year AND calendar_week = :calendar_week";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':year' => $year, ':calendar_week' => $calendarWeek]);
        $results = $stmt->fetchAll(PDO::FETCH_COLUMN);
        return ['student' => in_array('student', $results), 'teacher' => in_array('teacher', $results)];
    }
    public function isWeekPublishedFor(string $targetGroup, int $year, int $calendarWeek): bool
    {
        $sql = "SELECT 1 FROM timetable_publish_status
                WHERE year = :year AND calendar_week = :calendar_week AND target_group = :target_group LIMIT 1";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':target_group' => $targetGroup
        ]);
        return $stmt->fetchColumn() !== false;
    }
    public function deleteEntry(int $entryId): bool
    {
        $sql = "DELETE FROM timetable_entries WHERE entry_id = :entry_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':entry_id' => $entryId]);
    }
    public function deleteEntryBlock(string $blockId): bool
    {
        $sql = "DELETE FROM timetable_entries WHERE block_id = :block_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':block_id' => $blockId]);
    }
    public function createOrUpdateEntry(array $data): array
    {
        $required = ['year', 'calendar_week', 'day_of_week', 'teacher_id', 'subject_id', 'room_id'];
        foreach ($required as $field) {
            if (!isset($data[$field]) || $data[$field] === '') {
                throw new Exception("Fehlende Daten: Feld '{$field}' ist erforderlich und darf nicht leer sein.");
            }
        }
        if (!isset($data['class_id'])) {
             throw new Exception("Fehlende Daten: Feld 'class_id' ist erforderlich.");
        }
        $comment = isset($data['comment']) ? trim($data['comment']) : null;
        if ($comment === '') {
            $comment = null; 
        }
        $startPeriod = (int)($data['start_period_number'] ?? $data['period_number'] ?? 0);
        $endPeriod = (int)($data['end_period_number'] ?? $data['period_number'] ?? 0);
        $data['start_period_number'] = $startPeriod;
        $data['end_period_number'] = $endPeriod;
        if ($startPeriod <= 0 || $endPeriod <= 0 || $startPeriod > $endPeriod) {
            throw new Exception("Ungültiger Stundenbereich (Start/Ende > 0 und Start <= Ende erforderlich).");
        }
        $excludeEntryId = !empty($data['entry_id']) ? (int)$data['entry_id'] : null;
        $excludeBlockId = !empty($data['block_id']) ? (string)$data['block_id'] : null;
        $this->checkConflicts($data, $excludeEntryId, $excludeBlockId);
        $this->pdo->beginTransaction();
        try {
            if (!empty($data['entry_id']) && filter_var($data['entry_id'], FILTER_VALIDATE_INT)) {
                $deleteSql = "DELETE FROM timetable_entries WHERE entry_id = :entry_id";
                $deleteParams = [':entry_id' => $data['entry_id']];
                $deleteStmt = $this->pdo->prepare($deleteSql);
                $deleteStmt->execute($deleteParams);
            } elseif (!empty($data['block_id'])) {
                $deleteSql = "DELETE FROM timetable_entries WHERE block_id = :block_id";
                $deleteParams = [':block_id' => $data['block_id']];
                $deleteStmt = $this->pdo->prepare($deleteSql);
                $deleteStmt->execute($deleteParams);
            }
            $blockId = ($startPeriod !== $endPeriod) ? uniqid('block_', true) : null;
            $insertSql = "INSERT INTO timetable_entries (year, calendar_week, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_id, comment)
                            VALUES (:year, :calendar_week, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_id, :comment)";
            $insertStmt = $this->pdo->prepare($insertSql);
            $insertedIds = []; 
            for ($period = $startPeriod; $period <= $endPeriod; $period++) {
                $params = [
                    ':year' => $data['year'],
                    ':calendar_week' => $data['calendar_week'],
                    ':day_of_week' => $data['day_of_week'],
                    ':period_number' => $period,
                    ':class_id' => $data['class_id'], 
                    ':teacher_id' => $data['teacher_id'],
                    ':subject_id' => $data['subject_id'],
                    ':room_id' => $data['room_id'],
                    ':block_id' => $blockId,
                    ':comment' => $comment
                ];
                if (!$insertStmt->execute($params)) {
                    $errorInfo = $insertStmt->errorInfo();
                    throw new PDOException("Fehler beim Einfügen von Stunde {$period}. SQLSTATE[{$errorInfo[0]}]: {$errorInfo[2]}");
                }
                $insertedIds[] = $this->pdo->lastInsertId(); 
            }
            $this->pdo->commit();
            return [
                'block_id' => $blockId,
                'entry_ids' => $insertedIds, 
                'periods' => range($startPeriod, $endPeriod)
            ];
        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("PlanRepository::createOrUpdateEntry failed: " . $e->getMessage());
            throw new Exception("Fehler beim Speichern des Stundenplaneintrags: " . $e->getMessage());
        }
    }
    public function createOrUpdateSubstitution(array $data): array
    {
        if (empty($data['date']) || empty($data['period_number']) || !isset($data['class_id']) || empty($data['substitution_type'])) {
            throw new Exception("Datum, Stunde, Klasse und Vertretungstyp sind Pflichtfelder.");
        }
        if (DateTime::createFromFormat('Y-m-d', $data['date']) === false) {
            throw new Exception("Ungültiges Datumsformat. Bitte YYYY-MM-DD verwenden.");
        }
        if (!empty($data['new_teacher_id'])) {
            $dateObj = new DateTime($data['date']);
            $conflictData = [
                'year' => (int)$dateObj->format('o'),
                'calendar_week' => (int)$dateObj->format('W'),
                'day_of_week' => (int)$dateObj->format('N'),
                'start_period_number' => $data['period_number'],
                'end_period_number' => $data['period_number'],
                'teacher_id' => $data['new_teacher_id'],
                'room_id' => null, 
                'class_id' => $data['class_id'] 
            ];
            try {
                $this->checkConflicts($conflictData, null, null);
            } catch (Exception $e) {
                if (str_contains($e->getMessage(), 'LEHRER-KONFLIKT')) {
                    throw new Exception("KONFLIKT: Dieser Lehrer hält bereits regulären Unterricht in einer anderen Klasse.", 409, $e);
                }
                throw $e; 
            }
            $sqlCheckSub = "SELECT 1 FROM substitutions 
                            WHERE new_teacher_id = :teacher_id 
                                AND date = :date AND period_number = :period
                                AND substitution_id != :exclude_id
                            LIMIT 1";
            $stmtCheckSub = $this->pdo->prepare($sqlCheckSub);
            $stmtCheckSub->execute([
                ':teacher_id' => $data['new_teacher_id'],
                ':date' => $data['date'],
                ':period' => $data['period_number'],
                ':exclude_id' => $data['substitution_id'] ?? 0
            ]);
            if ($stmtCheckSub->fetchColumn()) {
                throw new Exception("KONFLIKT: Dieser Lehrer hält bereits eine andere Vertretung in dieser Stunde.", 409);
            }
            $absence = $this->absenceRepo->checkAbsence($data['new_teacher_id'], $data['date']);
            if ($absence) {
                throw new Exception("KONFLIKT: Der Vertretungslehrer (ID {$data['new_teacher_id']}) ist an diesem Tag als '{$absence['reason']}' gemeldet.", 409);
            }
        }
        $nullableFields = ['original_subject_id', 'new_teacher_id', 'new_subject_id', 'new_room_id', 'comment'];
        foreach ($nullableFields as $field) {
            if (isset($data[$field])) {
                $value = trim($data[$field]);
                if ($value === '' || ($value === '0' && $field !== 'comment')) {
                    $data[$field] = null;
                } else {
                    $data[$field] = $value; 
                }
            } else {
                $data[$field] = null; 
            }
        }
        if (!empty($data['substitution_id']) && filter_var($data['substitution_id'], FILTER_VALIDATE_INT)) {
            $sql = "UPDATE substitutions SET
                                date = :date,
                                period_number = :period_number,
                                class_id = :class_id,
                                substitution_type = :substitution_type,
                                original_subject_id = :original_subject_id,
                                new_teacher_id = :new_teacher_id,
                                new_subject_id = :new_subject_id,
                                new_room_id = :new_room_id,
                                comment = :comment
                            WHERE substitution_id = :substitution_id";
            $currentId = (int)$data['substitution_id'];
        } else {
            $sql = "INSERT INTO substitutions (date, period_number, class_id, substitution_type, original_subject_id, new_teacher_id, new_subject_id, new_room_id, comment)
                    VALUES (:date, :period_number, :class_id, :substitution_type, :original_subject_id, :new_teacher_id, :new_subject_id, :new_room_id, :comment)";
            $currentId = null; 
        }
        $stmt = $this->pdo->prepare($sql);
        $params = [
            ':date' => $data['date'],
            ':period_number' => $data['period_number'],
            ':class_id' => $data['class_id'], 
            ':substitution_type' => $data['substitution_type'],
            ':original_subject_id' => $data['original_subject_id'],
            ':new_teacher_id' => $data['new_teacher_id'],
            ':new_subject_id' => $data['new_subject_id'],
            ':new_room_id' => $data['new_room_id'],
            ':comment' => $data['comment'], 
        ];
        if ($currentId !== null) {
            $params[':substitution_id'] = $currentId;
        }
        if (!$stmt->execute($params)) {
            $errorInfo = $stmt->errorInfo();
            error_log("Substitution save failed: SQLSTATE[{$errorInfo[0]}] {$errorInfo[2]}");
            throw new Exception("Fehler beim Speichern der Vertretung.");
        }
        if ($currentId === null) {
            $currentId = (int)$this->pdo->lastInsertId();
        }
        $savedData = $this->getSubstitutionById($currentId);
        if (!$savedData) {
            $data['substitution_id'] = $currentId;
            try {
                $dateObj = new DateTime($data['date']);
                $dayOfWeek = $dateObj->format('N'); 
                $data['day_of_week'] = ($dayOfWeek >= 1 && $dayOfWeek <= 5) ? $dayOfWeek : null;
                $data['day_of_week_iso'] = $dateObj->format('N'); 
            } catch (Exception $e) {
                $data['day_of_week'] = null;
                $data['day_of_week_iso'] = null;
            }
            return $data;
        }
        return $savedData;
    }
    public function getSubstitutionById(int $substitutionId): array|false
    {
        $sql = "SELECT
                                        s.*,
                                        DAYOFWEEK(s.date) as day_of_week_iso, 
                                        CASE DAYOFWEEK(s.date) WHEN 1 THEN NULL WHEN 7 THEN NULL ELSE DAYOFWEEK(s.date) - 1 END as day_of_week, 
                                        orig_s.subject_shortcut as original_subject_shortcut,
                                        new_t.teacher_shortcut as new_teacher_shortcut,
                                        new_s.subject_shortcut as new_subject_shortcut,
                                        new_r.room_name as new_room_name,
                                        c.class_name
                                    FROM substitutions s
                                    JOIN classes c ON s.class_id = c.class_id
                                    LEFT JOIN subjects orig_s ON s.original_subject_id = orig_s.subject_id
                                    LEFT JOIN teachers new_t ON s.new_teacher_id = new_t.teacher_id
                                    LEFT JOIN subjects new_s ON s.new_subject_id = new_s.subject_id
                                    LEFT JOIN rooms new_r ON s.new_room_id = new_r.room_id
                                    WHERE s.substitution_id = :id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':id' => $substitutionId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    public function deleteSubstitution(int $substitutionId): bool
    {
        $sql = "DELETE FROM substitutions WHERE substitution_id = :substitution_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':substitution_id' => $substitutionId]);
    }
    public function checkConflicts(array $data, ?int $excludeEntryId = null, ?string $excludeBlockId = null): array
    {
        $conflicts = [];
        $baseSql = "SELECT te.*, c.class_name, t.teacher_shortcut, r.room_name
                            FROM timetable_entries te
                            LEFT JOIN classes c ON te.class_id = c.class_id
                            LEFT JOIN teachers t ON te.teacher_id = t.teacher_id
                            LEFT JOIN rooms r ON te.room_id = r.room_id
                            WHERE te.year = :year
                                AND te.calendar_week = :calendar_week
                                AND te.day_of_week = :day_of_week
                                AND te.period_number >= :start_period
                                AND te.period_number <= :end_period";
        $params = [
            ':year' => $data['year'],
            ':calendar_week' => $data['calendar_week'],
            ':day_of_week' => $data['day_of_week'],
            ':start_period' => $data['start_period_number'],
            ':end_period' => $data['end_period_number'],
        ];
        $exclusionSql = "";
        if ($excludeEntryId !== null) {
            $exclusionSql = " AND te.entry_id != :exclude_entry_id";
            $params[':exclude_entry_id'] = $excludeEntryId;
        } elseif ($excludeBlockId !== null) {
            $exclusionSql = " AND te.block_id != :exclude_block_id";
            $params[':exclude_block_id'] = $excludeBlockId;
        }
        $dateForAbsenceCheck = '';
        try {
            $dto = new DateTime();
            $dto->setISODate($data['year'], $data['calendar_week'], $data['day_of_week']);
            $dateForAbsenceCheck = $dto->format('Y-m-d');
        } catch (Exception $e) {
            throw new Exception("Interner Fehler: Datum für Konfliktprüfung konnte nicht berechnet werden.");
        }
        if (!empty($data['teacher_id'])) {
            $absence = $this->absenceRepo->checkAbsence($data['teacher_id'], $dateForAbsenceCheck);
            if ($absence) {
                $conflicts[] = "LEHRER-KONFLIKT: Lehrer (ID {$data['teacher_id']}) ist an diesem Tag als '{$absence['reason']}' gemeldet.";
            }
            $teacherSql = $baseSql . " AND te.teacher_id = :teacher_id" . $exclusionSql;
            $teacherParams = $params + [':teacher_id' => $data['teacher_id']];
            if ($excludeEntryId === null) unset($teacherParams[':exclude_entry_id']);
            if ($excludeBlockId === null) unset($teacherParams[':exclude_block_id']);
            $stmtTeacher = $this->pdo->prepare($teacherSql);
            $stmtTeacher->execute($teacherParams);
            $existingTeacherEntry = $stmtTeacher->fetch(PDO::FETCH_ASSOC);
            if ($existingTeacherEntry) {
                $shortcut = $existingTeacherEntry['teacher_shortcut'] ?: $data['teacher_id'];
                $conflicts[] = "LEHRER-KONFLIKT: '{$shortcut}' ist bereits in Klasse {$existingTeacherEntry['class_name']} ({$existingTeacherEntry['room_name']}) eingeteilt.";
            }
        }
        if (!empty($data['room_id'])) {
            $roomSql = $baseSql . " AND te.room_id = :room_id" . $exclusionSql;
            $roomParams = $params + [':room_id' => $data['room_id']];
            if ($excludeEntryId === null) unset($roomParams[':exclude_entry_id']);
            if ($excludeBlockId === null) unset($roomParams[':exclude_block_id']);
            $stmtRoom = $this->pdo->prepare($roomSql);
            $stmtRoom->execute($roomParams);
            $existingRoomEntry = $stmtRoom->fetch(PDO::FETCH_ASSOC);
            if ($existingRoomEntry) {
                $name = $existingRoomEntry['room_name'] ?: $data['room_id'];
                $conflicts[] = "RAUM-KONFLIKT: '{$name}' ist bereits von Klasse {$existingRoomEntry['class_name']} (Lehrer: {$existingRoomEntry['teacher_shortcut']}) belegt.";
            }
        }
        if (!empty($conflicts)) {
            throw new Exception(implode("\n", $conflicts));
        }
        return $conflicts; 
    }
    public function copyWeekData(int $sourceYear, int $sourceWeek, int $targetYear, int $targetWeek, ?int $classId, ?int $teacherId): int
    {
        if ($classId === null && $teacherId === null) {
            throw new Exception("Es muss entweder eine Klasse oder ein Lehrer zum Kopieren ausgewählt werden.");
        }
        if ($sourceYear === $targetYear && $sourceWeek === $targetWeek) {
            throw new Exception("Quell- und Zielwoche dürfen nicht identisch sein.");
        }
        $this->pdo->beginTransaction();
        try {
            $deleteSql = "DELETE FROM timetable_entries 
                            WHERE year = :target_year AND calendar_week = :target_week";
            $deleteParams = [
                ':target_year' => $targetYear,
                ':target_week' => $targetWeek
            ];
            $whereField = "";
            if ($classId !== null) {
                $deleteSql .= " AND class_id = :entity_id";
                $whereField = "class_id";
                $deleteParams[':entity_id'] = $classId;
            } else {
                $deleteSql .= " AND teacher_id = :entity_id";
                $whereField = "teacher_id";
                $deleteParams[':entity_id'] = $teacherId;
            }
            $this->pdo->prepare($deleteSql)->execute($deleteParams);
            $selectSql = "SELECT * FROM timetable_entries
                            WHERE year = :source_year AND calendar_week = :source_week AND $whereField = :entity_id";
            $stmtSelect = $this->pdo->prepare($selectSql);
            $stmtSelect->execute([
                ':source_year' => $sourceYear,
                ':source_week' => $sourceWeek,
                ':entity_id' => $classId ?? $teacherId
            ]);
            $sourceEntries = $stmtSelect->fetchAll(PDO::FETCH_ASSOC);
            if (empty($sourceEntries)) {
                $this->pdo->rollBack(); 
                return 0; 
            }
            $insertSql = "INSERT INTO timetable_entries 
                            (year, calendar_week, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_id, comment) 
                            VALUES 
                            (:year, :calendar_week, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_id, :comment)";
            $stmtInsert = $this->pdo->prepare($insertSql);
            $copiedCount = 0;
            $blockIdMap = []; 
            foreach ($sourceEntries as $entry) {
                $newBlockId = null;
                if ($entry['block_id']) {
                    if (!isset($blockIdMap[$entry['block_id']])) {
                        $blockIdMap[$entry['block_id']] = uniqid('block_', true);
                    }
                    $newBlockId = $blockIdMap[$entry['block_id']];
                }
                $success = $stmtInsert->execute([
                    ':year' => $targetYear, 
                    ':calendar_week' => $targetWeek, 
                    ':day_of_week' => $entry['day_of_week'],
                    ':period_number' => $entry['period_number'],
                    ':class_id' => $entry['class_id'],
                    ':teacher_id' => $entry['teacher_id'],
                    ':subject_id' => $entry['subject_id'],
                    ':room_id' => $entry['room_id'],
                    ':block_id' => $newBlockId, 
                    ':comment' => $entry['comment']
                ]);
                if ($success) {
                    $copiedCount++;
                }
            }
            $this->pdo->commit();
            return $copiedCount;
        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("PlanRepository::copyWeekData failed: " . $e->getMessage());
            throw new Exception("Fehler beim Kopieren der Wochendaten: " . $e->getMessage());
        }
    }
    public function createTemplate(string $name, ?string $description, array $sourceEntries): int
    {
        if (empty($name)) {
            throw new Exception("Vorlagenname darf nicht leer sein.");
        }
        if (empty($sourceEntries)) {
            throw new Exception("Vorlage muss mindestens einen Eintrag enthalten.");
        }
        $stmtCheck = $this->pdo->prepare("SELECT COUNT(*) FROM timetable_templates WHERE name = :name");
        $stmtCheck->execute([':name' => $name]);
        if ($stmtCheck->fetchColumn() > 0) {
            throw new Exception("Eine Vorlage mit dem Namen '{$name}' existiert bereits.", 409); 
        }
        $this->pdo->beginTransaction();
        try {
            $sqlTemplate = "INSERT INTO timetable_templates (name, description) VALUES (:name, :description)";
            $stmtTemplate = $this->pdo->prepare($sqlTemplate);
            $stmtTemplate->execute([':name' => $name, ':description' => $description]);
            $templateId = (int)$this->pdo->lastInsertId();
            $sqlEntry = "INSERT INTO timetable_template_entries
                            (template_id, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_ref, comment)
                            VALUES
                            (:template_id, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_ref, :comment)";
            $stmtEntry = $this->pdo->prepare($sqlEntry);
            $blockRefMap = []; 
            foreach ($sourceEntries as $entry) {
                $blockRef = null;
                if ($entry['block_id']) {
                    if (!isset($blockRefMap[$entry['block_id']])) {
                        $blockRefMap[$entry['block_id']] = uniqid('tpl_blk_', true); 
                    }
                    $blockRef = $blockRefMap[$entry['block_id']];
                }
                $stmtEntry->execute([
                    ':template_id' => $templateId,
                    ':day_of_week' => $entry['day_of_week'],
                    ':period_number' => $entry['period_number'],
                    ':class_id' => $entry['class_id'], 
                    ':teacher_id' => $entry['teacher_id'],
                    ':subject_id' => $entry['subject_id'],
                    ':room_id' => $entry['room_id'],
                    ':block_ref' => $blockRef,
                    ':comment' => $entry['comment']
                ]);
            }
            $this->pdo->commit();
            return $templateId;
        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("PlanRepository::createTemplate failed: " . $e->getMessage());
            if (str_contains($e->getMessage(), 'Duplicate entry') || $e->getCode() == 409) {
                throw new Exception("Eine Vorlage mit dem Namen '{$name}' existiert bereits.", 409);
            }
            throw new Exception("Fehler beim Erstellen der Vorlage: " . $e->getMessage());
        }
    }
    public function getTemplates(): array
    {
        $stmt = $this->pdo->query("SELECT template_id, name, description FROM timetable_templates ORDER BY name ASC");
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function applyTemplateToWeek(int $templateId, int $targetYear, int $targetWeek, ?int $targetClassId, ?int $targetTeacherId): int
    {
        if ($targetClassId === null && $targetTeacherId === null) {
            throw new Exception("Es muss entweder eine Klasse oder ein Lehrer als Ziel angegeben werden.");
        }
        $stmtFetch = $this->pdo->prepare("SELECT * FROM timetable_template_entries WHERE template_id = :template_id ORDER BY day_of_week, period_number");
        $stmtFetch->execute([':template_id' => $templateId]);
        $templateEntries = $stmtFetch->fetchAll(PDO::FETCH_ASSOC);
        if (empty($templateEntries)) {
            return 0;
        }
        $this->pdo->beginTransaction();
        try {
            $deleteSql = "DELETE FROM timetable_entries
                            WHERE year = :target_year AND calendar_week = :target_week";
            $deleteParams = [':target_year' => $targetYear, ':target_week' => $targetWeek];
            if ($targetClassId !== null) {
                $deleteSql .= " AND class_id = :entity_id";
                $deleteParams[':entity_id'] = $targetClassId;
                $entityIdField = 'class_id';
                $entityIdValue = $targetClassId;
            } else {
                $deleteSql .= " AND teacher_id = :entity_id";
                $deleteParams[':entity_id'] = $targetTeacherId;
                $entityIdField = 'teacher_id';
                $entityIdValue = $targetTeacherId;
            }
            $this->pdo->prepare($deleteSql)->execute($deleteParams);
            $insertSql = "INSERT INTO timetable_entries
                            (year, calendar_week, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_id, comment)
                            VALUES
                            (:year, :calendar_week, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_id, :comment)";
            $stmtInsert = $this->pdo->prepare($insertSql);
            $appliedCount = 0;
            $blockIdMap = []; 
            foreach ($templateEntries as $entry) {
                $newBlockId = null;
                if ($entry['block_ref']) {
                    if (!isset($blockIdMap[$entry['block_ref']])) {
                        $blockIdMap[$entry['block_ref']] = uniqid('block_', true); 
                    }
                    $newBlockId = $blockIdMap[$entry['block_ref']];
                }
                $entryClassId = ($entityIdField === 'class_id') ? $entityIdValue : $entry['class_id'];
                if ($entityIdField === 'teacher_id' && (empty($entryClassId) || $entryClassId == 0)) {
                    error_log("Template apply skipped: Teacher template entry missing class_id. TemplateEntryID: " . $entry['template_entry_id']);
                    continue; 
                }
                $success = $stmtInsert->execute([
                    ':year' => $targetYear,
                    ':calendar_week' => $targetWeek,
                    ':day_of_week' => $entry['day_of_week'],
                    ':period_number' => $entry['period_number'],
                    ':class_id' => $entryClassId, 
                    ':teacher_id' => $entry['teacher_id'],
                    ':subject_id' => $entry['subject_id'],
                    ':room_id' => $entry['room_id'],
                    ':block_id' => $newBlockId, 
                    ':comment' => $entry['comment']
                ]);
                if ($success) {
                    $appliedCount++;
                } else {
                    error_log("Failed to apply template entry: " . print_r($stmtInsert->errorInfo(), true));
                }
            }
            $this->pdo->commit();
            return $appliedCount;
        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("PlanRepository::applyTemplateToWeek failed: " . $e->getMessage());
            throw new Exception("Fehler beim Anwenden der Vorlage: " . $e->getMessage());
        }
    }
    public function deleteTemplate(int $templateId): bool
    {
        $sql = "DELETE FROM timetable_templates WHERE template_id = :template_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':template_id' => $templateId]);
    }
    public function loadTemplateDetails(int $templateId): array
    {
        $stmtTemplate = $this->pdo->prepare("SELECT * FROM timetable_templates WHERE template_id = :id");
        $stmtTemplate->execute([':id' => $templateId]);
        $templateInfo = $stmtTemplate->fetch(PDO::FETCH_ASSOC);
        if (!$templateInfo) {
            throw new Exception("Vorlage nicht gefunden.");
        }
        $stmtEntries = $this->pdo->prepare("SELECT * FROM timetable_template_entries WHERE template_id = :id ORDER BY day_of_week, period_number");
        $stmtEntries->execute([':id' => $templateId]);
        $entries = $stmtEntries->fetchAll(PDO::FETCH_ASSOC);
        return [
            'template' => $templateInfo,
            'entries' => $entries
        ];
    }
    public function saveTemplateDetails(array $data): array
    {
        $templateId = $data['template_id'] ?? null;
        $name = trim($data['name']);
        $description = trim($data['description'] ?? '') ?: null;
        $entries = $data['entries'] ?? [];
        if (empty($name)) {
            throw new Exception("Vorlagenname darf nicht leer sein.");
        }
        $this->pdo->beginTransaction();
        try {
            $sqlCheckName = "SELECT template_id FROM timetable_templates WHERE name = :name AND (:id IS NULL OR template_id != :id)";
            $stmtCheckName = $this->pdo->prepare($sqlCheckName);
            $stmtCheckName->execute([':name' => $name, ':id' => $templateId]);
            if ($stmtCheckName->fetch()) {
                throw new Exception("Eine andere Vorlage mit diesem Namen existiert bereits.", 409);
            }
            if ($templateId) {
                $sqlTemplate = "UPDATE timetable_templates SET name = :name, description = :description WHERE template_id = :id";
                $stmtTemplate = $this->pdo->prepare($sqlTemplate);
                $stmtTemplate->execute([':name' => $name, ':description' => $description, ':id' => $templateId]);
            } else {
                $sqlTemplate = "INSERT INTO timetable_templates (name, description) VALUES (:name, :description)";
                $stmtTemplate = $this->pdo->prepare($sqlTemplate);
                $stmtTemplate->execute([':name' => $name, ':description' => $description]);
                $templateId = (int)$this->pdo->lastInsertId();
            }
            $stmtDelete = $this->pdo->prepare("DELETE FROM timetable_template_entries WHERE template_id = :id");
            $stmtDelete->execute([':id' => $templateId]);
            if (!empty($entries)) {
                $sqlEntry = "INSERT INTO timetable_template_entries
                                (template_id, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_ref, comment)
                                VALUES
                                (:template_id, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_ref, :comment)";
                $stmtEntry = $this->pdo->prepare($sqlEntry);
                foreach ($entries as $entry) {
                    $stmtEntry->execute([
                        ':template_id' => $templateId,
                        ':day_of_week' => $entry['day_of_week'],
                        ':period_number' => $entry['period_number'],
                        ':class_id' => $entry['class_id'],
                        ':teacher_id' => $entry['teacher_id'],
                        ':subject_id' => $entry['subject_id'],
                        ':room_id' => $entry['room_id'],
                        ':block_ref' => $entry['block_ref'] ?: null,
                        ':comment' => $entry['comment'] ?: null
                    ]);
                }
            }
            $this->pdo->commit();
            return [
                'template_id' => $templateId,
                'name' => $name,
                'description' => $description
            ];
        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("PlanRepository::saveTemplateDetails failed: " . $e->getMessage());
            $errorCode = $e->getCode() == 409 ? 409 : 500;
            throw new Exception("Fehler beim Speichern der Vorlage: " . $e->getMessage(), $errorCode);
        }
    }
    public function findTeacherLocation(int $teacherId, string $date, int $year, int $calendarWeek, int $dayOfWeek, int $periodNumber): array
    {
        $sqlSubAsNew = "SELECT s.*, c.class_name, ns.subject_shortcut as new_subject_shortcut, nr.room_name as new_room_name
                        FROM substitutions s
                        JOIN classes c ON s.class_id = c.class_id
                        LEFT JOIN subjects ns ON s.new_subject_id = ns.subject_id
                        LEFT JOIN rooms nr ON s.new_room_id = nr.room_id
                        WHERE s.new_teacher_id = :teacher_id 
                            AND s.date = :date 
                            AND s.period_number = :period_number";
        $stmtSubAsNew = $this->pdo->prepare($sqlSubAsNew);
        $stmtSubAsNew->execute([
            ':teacher_id' => $teacherId,
            ':date' => $date,
            ':period_number' => $periodNumber
        ]);
        $subAsNew = $stmtSubAsNew->fetch(PDO::FETCH_ASSOC);
        if ($subAsNew) {
            return [
                'status' => $subAsNew['substitution_type'], 
                'data' => $subAsNew
            ];
        }
        $sqlRegular = "SELECT te.*, s.subject_shortcut, c.class_name, r.room_name
                        FROM timetable_entries te
                        LEFT JOIN subjects s ON te.subject_id = s.subject_id
                        LEFT JOIN classes c ON te.class_id = c.class_id
                        LEFT JOIN rooms r ON te.room_id = r.room_id
                        WHERE te.teacher_id = :teacher_id
                            AND te.year = :year
                            AND te.calendar_week = :calendar_week
                            AND te.day_of_week = :day_of_week
                            AND te.period_number = :period_number";
        $stmtRegular = $this->pdo->prepare($sqlRegular);
        $stmtRegular->execute([
            ':teacher_id' => $teacherId,
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':day_of_week' => $dayOfWeek,
            ':period_number' => $periodNumber
        ]);
        $regularEntries = $stmtRegular->fetchAll(PDO::FETCH_ASSOC);
        if (empty($regularEntries)) {
            return [
                'status' => 'Freistunde',
                'data' => null
            ];
        }
        foreach ($regularEntries as $index => $regularEntry) {
            if (empty($regularEntry['class_id'])) {
                 continue;
            }
            $sqlCheckSub = "SELECT s.*, c.class_name, 
                                os.subject_shortcut as original_subject_shortcut, 
                                ns.subject_shortcut as new_subject_shortcut, 
                                nr.room_name as new_room_name
                            FROM substitutions s
                            JOIN classes c ON s.class_id = c.class_id
                            LEFT JOIN subjects os ON s.original_subject_id = os.subject_id
                            LEFT JOIN subjects ns ON s.new_subject_id = ns.subject_id
                            LEFT JOIN rooms nr ON s.new_room_id = nr.room_id
                            WHERE s.date = :date 
                                AND s.period_number = :period_number
                                AND s.class_id = :class_id";
            $stmtCheckSub = $this->pdo->prepare($sqlCheckSub);
            $stmtCheckSub->execute([
                ':date' => $date,
                ':period_number' => $periodNumber,
                ':class_id' => $regularEntry['class_id']
            ]);
            $substitution = $stmtCheckSub->fetch(PDO::FETCH_ASSOC);
            if ($substitution) {
                $regularEntries[$index]['substitution_info'] = $substitution;
            }
        }
        if (count($regularEntries) === 1 && isset($regularEntries[0]['substitution_info'])) {
             return [
                'status' => $regularEntries[0]['substitution_info']['substitution_type'], 
                'data' => $regularEntries[0]['substitution_info']
            ];
        }
        return [
            'status' => 'Unterricht',
            'data' => $regularEntries 
        ];
    }
    public function getClassesForTeacher(int $teacherId): array
    {
        $sqlEntries = "SELECT DISTINCT c.class_id, c.class_name 
                        FROM timetable_entries te
                        JOIN classes c ON te.class_id = c.class_id
                        WHERE te.teacher_id = :teacher_id AND te.class_id IS NOT NULL AND te.class_id != 0";
        $sqlSubs = "SELECT DISTINCT c.class_id, c.class_name
                    FROM substitutions s
                    JOIN classes c ON s.class_id = c.class_id
                    WHERE s.new_teacher_id = :teacher_id AND s.class_id IS NOT NULL AND s.class_id != 0";
        try {
            $stmtEntries = $this->pdo->prepare($sqlEntries);
            $stmtEntries->execute([':teacher_id' => $teacherId]);
            $classesFromEntries = $stmtEntries->fetchAll(PDO::FETCH_ASSOC);
            $stmtSubs = $this->pdo->prepare($sqlSubs);
            $stmtSubs->execute([':teacher_id' => $teacherId]);
            $classesFromSubs = $stmtSubs->fetchAll(PDO::FETCH_ASSOC);
            $allClasses = [];
            foreach (array_merge($classesFromEntries, $classesFromSubs) as $class) {
                $allClasses[$class['class_id']] = $class; 
            }
            ksort($allClasses);
            return array_values($allClasses); 
        } catch (Exception $e) {
            error_log("Fehler beim Abrufen der Klassen für Lehrer {$teacherId}: " . $e->getMessage());
            return [];
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\PlanRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\SettingsRepository.php ---
<?php
namespace App\Repositories;
use PDO;
use Exception;
use App\Core\Database;
class SettingsRepository
{
    private PDO $pdo;
    public function __construct()
    {
        $this->pdo = Database::getInstance();
    }
    public function loadSettings(): array
    {
        try {
            $stmt = $this->pdo->query("SELECT setting_key, setting_value FROM settings");
            return $stmt->fetchAll(PDO::FETCH_KEY_PAIR) ?: [];
        } catch (Exception $e) {
            error_log("Could not load settings from DB: " . $e->getMessage());
            return [];
        }
    }
    public function saveSettings(array $settings): bool
    {
        $sql = "INSERT INTO settings (setting_key, setting_value) VALUES (:key, :value)
                ON DUPLICATE KEY UPDATE setting_value = :value";
        try {
            $this->pdo->beginTransaction();
            $stmt = $this->pdo->prepare($sql);
            foreach ($settings as $key => $value) {
                if (is_bool($value)) {
                    $value = $value ? '1' : '0';
                }
                if ($value === null) {
                    $value = ''; 
                }
                $stmt->execute([':key' => $key, ':value' => $value]);
            }
            $this->pdo->commit();
            return true;
        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("Failed to save settings: " . $e->getMessage());
            throw new Exception("Einstellungen konnten nicht gespeichert werden: " . $e->getMessage());
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\SettingsRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\StammdatenRepository.php ---
<?php
namespace App\Repositories;
use PDO;
use Exception; 
class StammdatenRepository
{
    private PDO $pdo;
    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }
    public function getSubjects(): array {
        $stmt = $this->pdo->prepare("SELECT * FROM subjects ORDER BY subject_name ASC");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function createSubject(string $name, string $shortcut): int {
        $sql = "INSERT INTO subjects (subject_name, subject_shortcut) VALUES (:name, :shortcut)";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':name' => $name, ':shortcut' => $shortcut]);
        return (int)$this->pdo->lastInsertId();
    }
    public function updateSubject(int $id, string $name, string $shortcut): bool {
        $sql = "UPDATE subjects SET subject_name = :name, subject_shortcut = :shortcut WHERE subject_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id, ':name' => $name, ':shortcut' => $shortcut]);
    }
    public function deleteSubject(int $id): bool {
        $sql = "DELETE FROM subjects WHERE subject_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id]);
    }
    public function countSubjects(): int {
        try {
            $stmt = $this->pdo->query("SELECT COUNT(*) FROM subjects");
            return (int)($stmt->fetchColumn() ?: 0);
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Fächer: " . $e->getMessage());
            return 0;
        }
    }
    public function getRooms(): array {
        $stmt = $this->pdo->prepare("SELECT * FROM rooms ORDER BY room_name ASC");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function createRoom(string $name): int {
        $sql = "INSERT INTO rooms (room_name) VALUES (:name)";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':name' => $name]);
        return (int)$this->pdo->lastInsertId();
    }
    public function updateRoom(int $id, string $name): bool {
        $sql = "UPDATE rooms SET room_name = :name WHERE room_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id, ':name' => $name]);
    }
    public function deleteRoom(int $id): bool {
        $sql = "DELETE FROM rooms WHERE room_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id]);
    }
    public function countRooms(): int {
        try {
            $stmt = $this->pdo->query("SELECT COUNT(*) FROM rooms");
            return (int)($stmt->fetchColumn() ?: 0);
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Räume: " . $e->getMessage());
            return 0;
        }
    }
    public function getTeachers(): array {
        $stmt = $this->pdo->prepare("SELECT * FROM teachers ORDER BY last_name, first_name ASC");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function createTeacher(array $data): int {
        $sql = "INSERT INTO teachers (teacher_shortcut, first_name, last_name, email) VALUES (:shortcut, :first_name, :last_name, :email)";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($data);
        return (int)$this->pdo->lastInsertId();
    }
    public function updateTeacher(int $id, array $data): bool {
        $sql = "UPDATE teachers SET teacher_shortcut = :shortcut, first_name = :first_name, last_name = :last_name, email = :email WHERE teacher_id = :id";
        $data['id'] = $id;
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute($data);
    }
    public function deleteTeacher(int $id): bool {
        $sql = "DELETE FROM teachers WHERE teacher_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id]);
    }
    public function countTeachers(): int {
        try {
            $stmt = $this->pdo->query("SELECT COUNT(*) FROM teachers");
            return (int)($stmt->fetchColumn() ?: 0);
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Lehrer: " . $e->getMessage());
            return 0;
        }
    }
    public function getClasses(): array {
        $sql = "SELECT c.class_id, c.class_name, c.class_teacher_id, CONCAT_WS(' ', t.first_name, t.last_name) as teacher_name
                FROM classes c
                LEFT JOIN teachers t ON c.class_teacher_id = t.teacher_id
                ORDER BY c.class_id ASC";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function createClass(int $id, string $name, ?int $teacherId): bool {
        $stmtCheck = $this->pdo->prepare("SELECT COUNT(*) FROM classes WHERE class_id = :id");
        $stmtCheck->execute([':id' => $id]);
        if ($stmtCheck->fetchColumn() > 0) {
            throw new \Exception("Die Klassen-ID '{$id}' ist bereits vergeben.");
        }
        $sql = "INSERT INTO classes (class_id, class_name, class_teacher_id) VALUES (:id, :name, :teacher_id)";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id, ':name' => $name, ':teacher_id' => $teacherId]);
    }
    public function updateClass(int $id, string $name, ?int $teacherId): bool {
        $sql = "UPDATE classes SET class_name = :name, class_teacher_id = :teacher_id WHERE class_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id, ':name' => $name, ':teacher_id' => $teacherId]);
    }
    public function deleteClass(int $id): bool {
        $sql = "DELETE FROM classes WHERE class_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id]);
    }
    public function countClasses(): int {
        try {
            $stmt = $this->pdo->query("SELECT COUNT(*) FROM classes");
            return (int)($stmt->fetchColumn() ?: 0);
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Klassen: " . $e->getMessage());
            return 0;
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\StammdatenRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\StudentNoteRepository.php ---
<?php
namespace App\Repositories;
use PDO;
use Exception;
class StudentNoteRepository
{
    private PDO $pdo;
    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }
    public function getNotesForWeek(int $userId, int $year, int $calendarWeek): array
    {
        $sql = "SELECT day_of_week, period_number, note_content
                FROM student_notes
                WHERE user_id = :user_id
                  AND year = :year
                  AND calendar_week = :calendar_week";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':user_id' => $userId,
            ':year' => $year,
            ':calendar_week' => $calendarWeek
        ]);
        $notes = [];
        while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $key = $row['day_of_week'] . '-' . $row['period_number'];
            $notes[$key] = $row['note_content'];
        }
        return $notes;
    }
    public function saveNote(int $userId, int $year, int $calendarWeek, int $dayOfWeek, int $periodNumber, string $content): bool
    {
        if (empty(trim($content))) {
            return $this->deleteNote($userId, $year, $calendarWeek, $dayOfWeek, $periodNumber);
        }
        $sql = "INSERT INTO student_notes (user_id, `year`, calendar_week, day_of_week, period_number, note_content)
                VALUES (:user_id, :year, :calendar_week, :day_of_week, :period_number, :note_content)
                ON DUPLICATE KEY UPDATE
                    note_content = VALUES(note_content),
                    last_updated = NOW()";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':user_id' => $userId,
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':day_of_week' => $dayOfWeek,
            ':period_number' => $periodNumber,
            ':note_content' => $content
        ]);
    }
    private function deleteNote(int $userId, int $year, int $calendarWeek, int $dayOfWeek, int $periodNumber): bool
    {
         $sql = "DELETE FROM student_notes
                  WHERE user_id = :user_id
                    AND `year` = :year
                    AND calendar_week = :calendar_week
                    AND day_of_week = :day_of_week
                    AND period_number = :period_number";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':user_id' => $userId,
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':day_of_week' => $dayOfWeek,
            ':period_number' => $periodNumber
        ]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\StudentNoteRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\TeacherAbsenceRepository.php ---
<?php
namespace App\Repositories;
use PDO;
use Exception;
use DateTime;
use DateTimeZone;
class TeacherAbsenceRepository
{
    private PDO $pdo;
    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }
    public function getAbsencesForPeriod(string $startDate, string $endDate): array
    {
        $sql = "SELECT ta.*, t.teacher_shortcut, t.first_name, t.last_name
                FROM teacher_absences ta
                JOIN teachers t ON ta.teacher_id = t.teacher_id
                WHERE ta.start_date <= :end_date AND ta.end_date >= :start_date
                ORDER BY ta.start_date ASC";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function getAbsenceById(int $absenceId): array|false
    {
        $sql = "SELECT ta.*, t.teacher_shortcut, t.first_name, t.last_name
                FROM teacher_absences ta
                JOIN teachers t ON ta.teacher_id = t.teacher_id
                WHERE ta.absence_id = :absence_id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':absence_id' => $absenceId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    public function createAbsence(?int $absenceId, int $teacherId, string $startDate, string $endDate, string $reason, ?string $comment): array
    {
        if ($startDate > $endDate) {
            throw new Exception("Das Startdatum darf nicht nach dem Enddatum liegen.");
        }
        if (empty($teacherId) || empty($reason)) {
             throw new Exception("Lehrer und Grund sind Pflichtfelder.");
        }
        if ($absenceId) {
            $sql = "UPDATE teacher_absences SET
                        teacher_id = :teacher_id,
                        start_date = :start_date,
                        end_date = :end_date,
                        reason = :reason,
                        comment = :comment
                    WHERE absence_id = :absence_id";
            $params = [
                ':teacher_id' => $teacherId,
                ':start_date' => $startDate,
                ':end_date' => $endDate,
                ':reason' => $reason,
                ':comment' => $comment,
                ':absence_id' => $absenceId
            ];
        } else {
            $sql = "INSERT INTO teacher_absences (teacher_id, start_date, end_date, reason, comment)
                    VALUES (:teacher_id, :start_date, :end_date, :reason, :comment)";
            $params = [
                ':teacher_id' => $teacherId,
                ':start_date' => $startDate,
                ':end_date' => $endDate,
                ':reason' => $reason,
                ':comment' => $comment
            ];
        }
        $stmt = $this->pdo->prepare($sql);
        if (!$stmt->execute($params)) {
            throw new Exception("Datenbankfehler beim Speichern der Abwesenheit.");
        }
        $newId = $absenceId ?? (int)$this->pdo->lastInsertId();
        $savedData = $this->getAbsenceById($newId);
        if (!$savedData) {
            throw new Exception("Fehler beim Abrufen der gespeicherten Abwesenheit.");
        }
        return $savedData;
    }
    public function deleteAbsence(int $absenceId): bool
    {
        $sql = "DELETE FROM teacher_absences WHERE absence_id = :absence_id";
        $stmt = $this->pdo->prepare($sql);
        if (!$stmt->execute([':absence_id' => $absenceId])) {
            throw new Exception("Datenbankfehler beim Löschen der Abwesenheit.");
        }
        return $stmt->rowCount() > 0;
    }
    public function getAbsencesForDateRange(string $startDate, string $endDate): array
    {
        $sql = "SELECT teacher_id, start_date, end_date, reason
                FROM teacher_absences
                WHERE start_date <= :end_date AND end_date >= :start_date";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':start_date' => $startDate, ':end_date' => $endDate]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function checkAbsence(int $teacherId, string $date)
    {
        $sql = "SELECT * FROM teacher_absences
                WHERE teacher_id = :teacher_id
                  AND :date BETWEEN start_date AND end_date
                LIMIT 1";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':teacher_id' => $teacherId, ':date' => $date]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
    public function getAbsenceTypes(): array
    {
        return [
            'Krank',
            'Fortbildung',
            'Beurlaubt',
            'Sonstiges'
        ];
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\TeacherAbsenceRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\UserRepository.php ---
<?php
namespace App\Repositories;
use PDO;
use Exception;
class UserRepository
{
    private PDO $pdo;
    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }
    public function findByUsernameOrEmail(string $identifier): ?array
    {
        $sql = "SELECT user_id, username, password_hash, role, ical_token, is_community_banned
                FROM users
                WHERE username = :identifier OR email = :identifier";
        $statement = $this->pdo->prepare($sql);
        $statement->execute([':identifier' => $identifier]);
        $user = $statement->fetch(PDO::FETCH_ASSOC);
        return $user ?: null;
    }
    public function getAll(): array
    {
        $sql = "SELECT u.user_id, u.username, u.email, u.role, u.first_name, u.last_name, u.birth_date, u.class_id, u.teacher_id, u.ical_token, u.is_community_banned, c.class_name, CONCAT(t.first_name, ' ', t.last_name) as teacher_name
                FROM users u
                LEFT JOIN classes c ON u.class_id = c.class_id
                LEFT JOIN teachers t ON u.teacher_id = t.teacher_id
                ORDER BY u.last_name, u.first_name ASC";
        $stmt = $this->pdo->query($sql);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function findById(int $userId): ?array
    {
        $sql = "SELECT * FROM users WHERE user_id = :user_id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':user_id' => $userId]);
        $user = $stmt->fetch(PDO::FETCH_ASSOC);
        return $user ?: null;
    }
    public function findClassByUserId(int $userId): ?array
    {
        $sql = "SELECT c.class_id, c.class_name
                FROM users u
                JOIN classes c ON u.class_id = c.class_id
                WHERE u.user_id = :user_id AND u.role = 'schueler'";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':user_id' => $userId]);
        $classData = $stmt->fetch(PDO::FETCH_ASSOC);
        return $classData ?: null;
    }
    public function getStudentsByClassId(int $classId): array
    {
        $sql = "SELECT user_id, first_name, last_name 
                FROM users 
                WHERE role = 'schueler' 
                  AND class_id = :class_id 
                ORDER BY last_name ASC, first_name ASC";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':class_id' => $classId]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function create(array $data): int
    {
        if (empty($data['username']) || empty($data['email']) || empty($data['password']) || empty($data['role']) || empty($data['first_name']) || empty($data['last_name'])) {
            throw new Exception("Alle Felder mit * sind erforderlich.");
        }
        if ($this->findByUsernameOrEmail($data['username'])) {
            throw new Exception("Benutzername ist bereits vergeben.");
        }
        if ($this->findByUsernameOrEmail($data['email'])) {
            throw new Exception("E-Mail ist bereits vergeben.");
        }
        $icalToken = bin2hex(random_bytes(32));
        $sql = "INSERT INTO users (username, email, password_hash, role, first_name, last_name, birth_date, class_id, teacher_id, ical_token, is_community_banned)
                VALUES (:username, :email, :password_hash, :role, :first_name, :last_name, :birth_date, :class_id, :teacher_id, :ical_token, :is_community_banned)";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':username' => $data['username'],
            ':email' => $data['email'],
            ':password_hash' => password_hash($data['password'], PASSWORD_DEFAULT),
            ':role' => $data['role'],
            ':first_name' => $data['first_name'],
            ':last_name' => $data['last_name'],
            ':birth_date' => empty($data['birth_date']) ? null : $data['birth_date'],
            ':class_id' => ($data['role'] === 'schueler' && !empty($data['class_id'])) ? $data['class_id'] : null,
            ':teacher_id' => ($data['role'] === 'lehrer' && !empty($data['teacher_id'])) ? $data['teacher_id'] : null,
            ':ical_token' => $icalToken, 
            ':is_community_banned' => ($data['role'] === 'schueler' ? (isset($data['is_community_banned']) ? 1 : 0) : 0)
        ]);
        return (int)$this->pdo->lastInsertId();
    }
    public function update(int $userId, array $data): bool
    {
        $sqlCheck = "SELECT user_id FROM users WHERE (username = :username OR email = :email) AND user_id != :user_id";
        $stmtCheck = $this->pdo->prepare($sqlCheck);
        $stmtCheck->execute([':username' => $data['username'], ':email' => $data['email'], ':user_id' => $userId]);
        if ($stmtCheck->fetch()) {
            throw new Exception("Benutzername oder E-Mail ist bereits von einem anderen Benutzer vergeben.");
        }
        $sql = "UPDATE users SET
                        username = :username,
                        email = :email,
                        role = :role,
                        first_name = :first_name,
                        last_name = :last_name,
                        birth_date = :birth_date,
                        class_id = :class_id,
                        teacher_id = :teacher_id,
                        is_community_banned = :is_community_banned"; 
        $params = [
            ':user_id' => $userId,
            ':username' => $data['username'],
            ':email' => $data['email'],
            ':role' => $data['role'],
            ':first_name' => $data['first_name'],
            ':last_name' => $data['last_name'],
            ':birth_date' => empty($data['birth_date']) ? null : $data['birth_date'],
            ':class_id' => ($data['role'] === 'schueler' && !empty($data['class_id'])) ? $data['class_id'] : null,
            ':teacher_id' => ($data['role'] === 'lehrer' && !empty($data['teacher_id'])) ? $data['teacher_id'] : null,
            ':is_community_banned' => ($data['role'] === 'schueler' ? (isset($data['is_community_banned']) ? 1 : 0) : 0)
        ];
        if (!empty($data['password'])) {
            $sql .= ", password_hash = :password_hash";
            $params[':password_hash'] = password_hash($data['password'], PASSWORD_DEFAULT);
        }
        $sql .= " WHERE user_id = :user_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute($params);
    }
    public function delete(int $userId): bool
    {
        $sql = "DELETE FROM users WHERE user_id = :user_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':user_id' => $userId]);
    }
    public function getAvailableRoles(): array
    {
        $stmt = $this->pdo->query("SHOW COLUMNS FROM users LIKE 'role'");
        $columnInfo = $stmt->fetch(PDO::FETCH_ASSOC);
        if ($columnInfo && isset($columnInfo['Type'])) {
            preg_match_all("/'([^']+)'/", $columnInfo['Type'], $matches);
            if (!empty($matches[1])) {
                return $matches[1]; 
            }
        }
        return ['schueler', 'lehrer', 'planer', 'admin'];
    }
    public function findByIcalToken(string $token): ?array
    {
        $sql = "SELECT * FROM users WHERE ical_token = :token";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':token' => $token]);
        $user = $stmt->fetch(PDO::FETCH_ASSOC);
        return $user ?: null;
    }
    public function generateOrGetIcalToken(int $userId): ?string
    {
        $user = $this->findById($userId);
        if (!$user) return null;
        if (!empty($user['ical_token'])) {
            return $user['ical_token'];
        }
        $newToken = bin2hex(random_bytes(32));
        $sql = "UPDATE users SET ical_token = :token WHERE user_id = :user_id";
        $stmt = $this->pdo->prepare($sql);
        if ($stmt->execute([':token' => $newToken, ':user_id' => $userId])) {
            return $newToken;
        }
        error_log("Failed to update iCal token for user ID: " . $userId); 
        return null; 
    }
    public function findUserByTeacherId(int $teacherId): ?array
    {
        $sql = "SELECT * FROM users WHERE teacher_id = :teacher_id AND role = 'lehrer' LIMIT 1";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':teacher_id' => $teacherId]);
        $user = $stmt->fetch(PDO::FETCH_ASSOC);
        return $user ?: null;
    }
    public function importFromCSV(string $tmpFilePath, array $validationData): array
    {
        $successCount = 0;
        $errorMessages = [];
        $requiredHeaders = ['username', 'email', 'password', 'role', 'first_name', 'last_name'];
        $optionalHeaders = ['birth_date', 'class_id', 'teacher_id', 'is_community_banned'];
        $fileHandle = fopen($tmpFilePath, 'r');
        if ($fileHandle === false) {
            throw new Exception("Datei konnte nicht zum Lesen geöffnet werden.");
        }
        $this->pdo->beginTransaction();
        try {
            $headers = fgetcsv($fileHandle);
            if ($headers === false) {
                throw new Exception("CSV-Datei ist leer oder konnte nicht gelesen werden.");
            }
            $headers = array_map('trim', $headers); 
            $colMap = [];
            foreach ($requiredHeaders as $header) {
                $index = array_search($header, $headers);
                if ($index === false) {
                    throw new Exception("Fehlende erforderliche Spalte in der CSV-Vorlage: '{$header}'.");
                }
                $colMap[$header] = $index;
            }
            foreach ($optionalHeaders as $header) {
                $colMap[$header] = array_search($header, $headers); 
            }
            $insertSql = "INSERT INTO users (username, email, password_hash, role, first_name, last_name, birth_date, class_id, teacher_id, ical_token, is_community_banned)
                                VALUES (:username, :email, :password_hash, :role, :first_name, :last_name, :birth_date, :class_id, :teacher_id, :ical_token, :is_community_banned)";
            $stmt = $this->pdo->prepare($insertSql);
            $lineNumber = 1; 
            while (($row = fgetcsv($fileHandle)) !== false) {
                $lineNumber++;
                $row = array_map('trim', $row);
                $userData = [];
                $userData['username'] = $row[$colMap['username']] ?? null;
                $userData['email'] = $row[$colMap['email']] ?? null;
                $userData['password'] = $row[$colMap['password']] ?? null;
                $userData['role'] = $row[$colMap['role']] ?? null;
                $userData['first_name'] = $row[$colMap['first_name']] ?? null;
                $userData['last_name'] = $row[$colMap['last_name']] ?? null;
                $userData['birth_date'] = ($colMap['birth_date'] !== false && !empty($row[$colMap['birth_date']])) ? $row[$colMap['birth_date']] : null;
                $userData['class_id'] = ($colMap['class_id'] !== false && !empty($row[$colMap['class_id']])) ? $row[$colMap['class_id']] : null;
                $userData['teacher_id'] = ($colMap['teacher_id'] !== false && !empty($row[$colMap['teacher_id']])) ? $row[$colMap['teacher_id']] : null;
                $userData['is_community_banned'] = ($colMap['is_community_banned'] !== false && !empty($row[$colMap['is_community_banned']])) ? $row[$colMap['is_community_banned']] : '0';
                if (empty($userData['username']) || empty($userData['email']) || empty($userData['password']) || empty($userData['role']) || empty($userData['first_name']) || empty($userData['last_name'])) {
                    $errorMessages[] = "Zeile {$lineNumber}: Übersprungen. Es fehlen erforderliche Felder (z.B. username, email, password, role, first_name, last_name).";
                    continue;
                }
                if ($this->findByUsernameOrEmail($userData['username'])) {
                    $errorMessages[] = "Zeile {$lineNumber}: Übersprungen. Benutzername '{$userData['username']}' ist bereits vergeben.";
                    continue;
                }
                if ($this->findByUsernameOrEmail($userData['email'])) {
                    $errorMessages[] = "Zeile {$lineNumber}: Übersprungen. E-Mail '{$userData['email']}' ist bereits vergeben.";
                    continue;
                }
                if (!in_array($userData['role'], $validationData['roles'])) {
                    $errorMessages[] = "Zeile {$lineNumber}: Übersprungen. Ungültige Rolle '{$userData['role']}'.";
                    continue;
                }
                if ($userData['role'] === 'schueler' && !empty($userData['class_id']) && !in_array($userData['class_id'], $validationData['class_ids'])) {
                    $errorMessages[] = "Zeile {$lineNumber}: Übersprungen. Klassen-ID '{$userData['class_id']}' existiert nicht.";
                    continue;
                }
                if ($userData['role'] === 'lehrer' && !empty($userData['teacher_id']) && !in_array($userData['teacher_id'], $validationData['teacher_ids'])) {
                    $errorMessages[] = "Zeile {$lineNumber}: Übersprungen. Lehrer-ID '{$userData['teacher_id']}' existiert nicht.";
                    continue;
                }
                $classId = ($userData['role'] === 'schueler') ? $userData['class_id'] : null;
                $teacherId = ($userData['role'] === 'lehrer') ? $userData['teacher_id'] : null;
                if ($classId === '0') $classId = null;
                if ($teacherId === '0') $teacherId = null;
                $isBanned = ($userData['role'] === 'schueler' && ($userData['is_community_banned'] === '1' || strtolower($userData['is_community_banned']) === 'true')) ? 1 : 0;
                $params = [
                    ':username' => $userData['username'],
                    ':email' => $userData['email'],
                    ':password_hash' => password_hash($userData['password'], PASSWORD_DEFAULT),
                    ':role' => $userData['role'],
                    ':first_name' => $userData['first_name'],
                    ':last_name' => $userData['last_name'],
                    ':birth_date' => empty($userData['birth_date']) ? null : $userData['birth_date'],
                    ':class_id' => $classId,
                    ':teacher_id' => $teacherId,
                    ':ical_token' => bin2hex(random_bytes(32)), 
                    ':is_community_banned' => $isBanned 
                ];
                if (!$stmt->execute($params)) {
                    $errorMessages[] = "Zeile {$lineNumber}: Technischer Fehler beim Einfügen von '{$userData['username']}'.";
                } else {
                    $successCount++;
                }
            }
            if (!empty($errorMessages)) {
                $this->pdo->rollBack();
                fclose($fileHandle);
                $errorMessages[] = "Transaktion abgebrochen. Keine Benutzer wurden importiert.";
                return ['successCount' => 0, 'errors' => array_slice($errorMessages, 0, 50)];
            }
            $this->pdo->commit();
        } catch (Exception $e) {
            $this->pdo->rollBack();
            fclose($fileHandle);
            throw new Exception("Fehler beim Verarbeiten der CSV-Datei: " . $e->getMessage());
        }
        fclose($fileHandle);
        return ['successCount' => $successCount, 'errors' => $errorMessages];
    }
    public function countUsersByRole(): array
    {
        try {
            $stmt = $this->pdo->query("SELECT role, COUNT(*) as count FROM users GROUP BY role");
            return $stmt->fetchAll(PDO::FETCH_KEY_PAIR) ?: [];
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Benutzer nach Rolle: " . $e->getMessage());
            return [];
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\UserRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Services\AppointmentService.php ---
<?php
namespace App\Services;
use DateTime;
use DateTimeZone;
use Exception;
class AppointmentService
{
    private $timezone;
    public function __construct($timezone = 'Europe/Berlin')
    {
        try {
            $this->timezone = new DateTimeZone($timezone);
        } catch (Exception $e) {
            $this->timezone = new DateTimeZone('UTC');
            error_log("Ungültige Zeitzone angegeben: $timezone. Fallback auf UTC.");
        }
    }
    public function formatAppointments(array $appointments): array
    {
        $formatted = [];
        foreach ($appointments as $app) {
            $formatted[] = $this->formatAppointment($app);
        }
        return $formatted;
    }
    public function formatAppointment(array $appointment): array
    {
        $formatted = $appointment;
        try {
            if (isset($appointment['start_time'])) {
                $startTime = new DateTime($appointment['start_time'], new DateTimeZone('UTC'));
                $startTime->setTimezone($this->timezone);
                $formatted['formatted_date'] = $this->formatDate($startTime);
                $formatted['formatted_start_time'] = $startTime->format('H:i');
                $formatted['relative_time'] = $this->getRelativeTime($startTime);
                if (isset($appointment['end_time'])) {
                    $endTime = new DateTime($appointment['end_time'], new DateTimeZone('UTC'));
                    $endTime->setTimezone($this->timezone);
                    $formatted['formatted_end_time'] = $endTime->format('H:i');
                    $formatted['formatted_duration'] = $this->formatDuration($startTime, $endTime);
                } else {
                    $formatted['formatted_end_time'] = '';
                    $formatted['formatted_duration'] = '';
                }
            } else {
                $formatted['formatted_date'] = 'Unbekannt';
                $formatted['formatted_start_time'] = '';
                $formatted['relative_time'] = 'Unbekannt';
                $formatted['formatted_end_time'] = '';
                $formatted['formatted_duration'] = '';
            }
        } catch (Exception $e) {
            $appointmentId = $appointment['appointment_id'] ?? 'unbekannt';
            error_log("Fehler bei der Formatierung des Termins (ID: {$appointmentId}): " . $e->getMessage());
            $formatted['formatted_date'] = 'Fehler';
            $formatted['formatted_start_time'] = 'Fehler';
            $formatted['relative_time'] = 'Fehler';
            $formatted['formatted_end_time'] = 'Fehler';
            $formatted['formatted_duration'] = 'Fehler';
        }
        if (isset($formatted['title'])) {
            $formatted['title'] = htmlspecialchars($formatted['title'], ENT_QUOTES, 'UTF-8');
        }
        if (isset($formatted['description'])) {
            $formatted['description'] = htmlspecialchars($formatted['description'], ENT_QUOTES, 'UTF-8');
        }
        return $formatted;
    }
    private function formatDate(DateTime $date): string
    {
        $now = new DateTime('now', $this->timezone);
        $dateOnly = (new DateTime($date->format('Y-m-d'), $this->timezone));
        $nowOnly = (new DateTime($now->format('Y-m-d'), $this->timezone));
        $diff = $nowOnly->diff($dateOnly);
        $daysDiff = (int)$diff->days;
        $isFuture = $diff->invert === 0;
        if ($daysDiff === 0) {
            return 'Heute';
        } elseif ($daysDiff === 1 && $isFuture) {
            return 'Morgen';
        } elseif ($daysDiff === 1 && !$isFuture) {
             return 'Gestern'; 
        }
        $tage = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
        $wochentag = $tage[$date->format('w')];
        $monate = [
            'Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun',
            'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'
        ];
        $monatName = $monate[$date->format('n') - 1];
        return $wochentag . ', ' . $date->format('d.') . ' ' . $monatName;
    }
    private function getRelativeTime(DateTime $date): string
    {
        $now = new DateTime('now', $this->timezone);
        $interval = $now->diff($date);
        $isPast = $interval->invert; 
        $prefix = $isPast ? 'vor' : 'in';
        $suffix = ''; 
        if ($interval->y) {
            return $prefix . ' ' . $interval->y . ' ' . ($interval->y > 1 ? 'Jahren' : 'Jahr') . $suffix;
        }
        if ($interval->m) {
            return $prefix . ' ' . $interval->m . ' ' . ($interval->m > 1 ? 'Monaten' : 'Monat') . $suffix;
        }
        if ($interval->d) {
            return $prefix . ' ' . $interval->d . ' ' . ($interval->d > 1 ? 'Tagen' : 'Tag') . $suffix;
        }
        if ($interval->h) {
            return $prefix . ' ' . $interval->h . ' ' . ($interval->h > 1 ? 'Stunden' : 'Stunde') . $suffix;
        }
        if ($interval->i) {
            return $prefix . ' ' . $interval->i . ' ' . ($interval->i > 1 ? 'Minuten' : 'Minute') . $suffix;
        }
        return $isPast ? 'gerade eben' : 'jetzt gleich';
    }
    private function formatDuration(DateTime $start, DateTime $end): string
    {
        $duration = $start->diff($end);
        $formatted = '';
        if ($duration->h > 0) {
            $formatted .= $duration->h . 'h';
        }
        if ($duration->i > 0) {
            if ($formatted !== '') {
                $formatted .= ' '; 
            }
            $formatted .= $duration->i . 'm';
        }
        if ($formatted === '') {
            if ($duration->s > 0 && $duration->h == 0 && $duration->i == 0) {
                 return $duration->s . 's'; 
            }
            return '0m'; 
        }
        return $formatted;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Services\AppointmentService.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Services\AuditLogger.php ---
<?php
namespace App\Services;
use App\Core\Database;
use PDO;
class AuditLogger
{
    public static function log(string $action, ?string $targetType = null, ?string $targetId = null, ?array $details = null)
    {
        try {
            $pdo = Database::getInstance();
            $userId = $_SESSION['user_id'] ?? null;
            $ipAddress = $_SERVER['REMOTE_ADDR'] ?? 'UNKNOWN';
            $sql = "INSERT INTO audit_logs (user_id, ip_address, action, target_type, target_id, details)
                    VALUES (:user_id, :ip_address, :action, :target_type, :target_id, :details)";
            $stmt = $pdo->prepare($sql);
            $stmt->execute([
                ':user_id' => $userId,
                ':ip_address' => $ipAddress,
                ':action' => $action,
                ':target_type' => $targetType,
                ':target_id' => $targetId,
                ':details' => $details ? json_encode($details) : null
            ]);
        } catch (\Exception $e) {
            error_log("AuditLogger Fehler: Konnte Aktion '{$action}' nicht protokollieren. Fehler: " . $e->getMessage());
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Services\AuditLogger.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Services\AuthenticationService.php ---
<?php
namespace App\Services;
use App\Repositories\UserRepository;
use App\Repositories\LoginAttemptRepository;
use Exception;
use App\Services\AuditLogger;
class AuthenticationService
{
    private UserRepository $userRepository;
    private LoginAttemptRepository $loginAttemptRepository;
    public function __construct(UserRepository $userRepository, LoginAttemptRepository $loginAttemptRepository)
    {
        $this->userRepository = $userRepository;
        $this->loginAttemptRepository = $loginAttemptRepository;
    }
    public function login(string $identifier, string $password): array
    {
        if (!$this->loginAttemptRepository->isAllowed($identifier)) {
            AuditLogger::log(
                'login_lockout', 
                'user', 
                $identifier, 
                ['message' => 'Zu viele Login-Versuche.']
            );
            throw new Exception("Zu viele fehlgeschlagene Login-Versuche. Ihr Account ist vorübergehend gesperrt.");
        }
        $user = $this->userRepository->findByUsernameOrEmail($identifier);
        if ($user && password_verify($password, $user['password_hash'])) {
            $this->loginAttemptRepository->clearAttempts($identifier);
            $_SESSION['user_id'] = $user['user_id']; 
            AuditLogger::log(
                'login_success', 
                'user', 
                $user['user_id']
            );
            $_SESSION['is_community_banned'] = (int)($user['is_community_banned'] ?? 0);
            return $user;
        }
        $this->loginAttemptRepository->recordFailure($identifier);
        AuditLogger::log(
            'login_failure', 
            'user', 
            $identifier, 
            ['message' => 'Falscher Benutzername oder Passwort.']
        );
        throw new Exception("Benutzername oder Passwort ist falsch.");
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Services\AuthenticationService.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Services\FileUploadService.php ---
<?php
namespace App\Services;
use Exception;
class FileUploadService
{
    private string $baseUploadDir = 'uploads/';
    private string $publicPath;
    public function __construct()
    {
        $this->publicPath = dirname(__DIR__, 2) . '/public/';
    }
    public function handleUpload(string $fileKey, string $subDirectory, array $allowedMimes, int $maxSize = 5 * 1024 * 1024): string
    {
        if (!isset($_FILES[$fileKey]) || $_FILES[$fileKey]['error'] !== UPLOAD_ERR_OK) {
            throw new Exception("Keine Datei hochgeladen oder Fehler beim Upload (Code: {$_FILES[$fileKey]['error']}).", 400);
        }
        $file = $_FILES[$fileKey];
        if ($file['size'] > $maxSize) {
            throw new Exception("Datei ist zu groß (Max: " . ($maxSize / 1024 / 1024) . "MB).", 400);
        }
        $fileType = mime_content_type($file['tmp_name']);
        if (!array_key_exists($fileType, $allowedMimes)) {
            throw new Exception("Ungültiger Dateityp. Erlaubt: " . implode(', ', array_keys($allowedMimes)), 400);
        }
        $targetDirectory = $this->publicPath . $this->baseUploadDir . $subDirectory;
        if (!is_dir($targetDirectory) && !@mkdir($targetDirectory, 0775, true)) {
            error_log("Konnte Upload-Verzeichnis nicht erstellen: " . $targetDirectory);
            throw new Exception("Upload-Verzeichnis konnte nicht erstellt werden.", 500);
        }
        if (!is_writable($targetDirectory)) {
            error_log("Upload-Verzeichnis nicht beschreibbar: " . $targetDirectory);
            throw new Exception("Upload-Verzeichnis ist nicht beschreibbar.", 500);
        }
        $extension = $allowedMimes[$fileType];
        $fileName = $fileKey . '_' . uniqid() . '.' . $extension;
        $targetPath = $targetDirectory . DIRECTORY_SEPARATOR . $fileName;
        if (move_uploaded_file($file['tmp_name'], $targetPath)) {
            $relativePath = $this->baseUploadDir . $subDirectory . '/' . $fileName;
            return str_replace(DIRECTORY_SEPARATOR, '/', $relativePath);
        } else {
            error_log("Fehler beim Verschieben der hochgeladenen Datei nach: " . $targetPath);
            throw new Exception("Fehler beim Verschieben der hochgeladenen Datei.", 500);
        }
    }
    public function deleteFile(?string $relativePath): bool
    {
        if (empty($relativePath)) {
            return true; 
        }
        $absolutePath = $this->publicPath . str_replace('/', DIRECTORY_SEPARATOR, $relativePath);
        if (file_exists($absolutePath)) {
            if (@unlink($absolutePath)) {
                return true;
            } else {
                error_log("Konnte Datei nicht löschen: " . $absolutePath);
                return false; 
            }
        }
        return true; 
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Services\FileUploadService.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Services\IcalService.php ---
<?php
namespace App\Services;
use App\Repositories\UserRepository;
use App\Repositories\PlanRepository;
use App\Repositories\AcademicEventRepository;
use App\Repositories\AppointmentRepository; // NEU
use App\Core\Utils;
use PDO;
use Exception;
use DateTime;
use DateTimeImmutable;
use DateTimeZone;

class IcalService
{
    private UserRepository $userRepository;
    private PlanRepository $planRepository;
    private AcademicEventRepository $eventRepository;
    private AppointmentRepository $appointmentRepository; // NEU
    private array $settings;
    private const PERIOD_TIMES = [
        1 => ['start' => '0800', 'end' => '0845'],
        2 => ['start' => '0855', 'end' => '0940'],
        3 => ['start' => '0940', 'end' => '1025'],
        4 => ['start' => '1035', 'end' => '1120'],
        5 => ['start' => '1120', 'end' => '1205'],
        6 => ['start' => '1305', 'end' => '1350'],
        7 => ['start' => '1350', 'end' => '1435'],
        8 => ['start' => '1445', 'end' => '1530'],
        9 => ['start' => '1530', 'end' => '1615'],
        10 => ['start' => '1625', 'end' => '1710'],
    ];

    public function __construct(
        UserRepository $userRepository,
        PlanRepository $planRepository,
        AcademicEventRepository $eventRepository,
        AppointmentRepository $appointmentRepository, // NEU
        array $settings
    ) {
        $this->userRepository = $userRepository;
        $this->planRepository = $planRepository;
        $this->eventRepository = $eventRepository;
        $this->appointmentRepository = $appointmentRepository; // NEU
        $this->settings = $settings;
    }

    public function generateFeed(string $token): string
    {
        if (empty($this->settings['ical_enabled'])) {
            throw new Exception("Kalender-Feeds sind derzeit systemweit deaktiviert.", 503);
        }

        $user = $this->userRepository->findByIcalToken($token);
        if (!$user) {
            throw new Exception("Ungültiger oder unbekannter Kalender-Feed-Token.", 404);
        }

        $userRole = $user['role'];
        $userId = (int)$user['user_id']; // NEU: user_id holen
        $classId = ($userRole === 'schueler' && !empty($user['class_id'])) ? (int)$user['class_id'] : null;
        $teacherId = ($userRole === 'lehrer' && !empty($user['teacher_id'])) ? (int)$user['teacher_id'] : null;
        $teacherUserId = ($userRole === 'lehrer') ? (int)$user['user_id'] : null; // $teacherUserId ist $userId

        if (($userRole !== 'schueler' && $userRole !== 'lehrer') || ($userRole === 'schueler' && !$classId) || ($userRole === 'lehrer' && !$teacherId)) {
            throw new Exception("Kalender-Feed nur für gültige Schüler- oder Lehrerprofile verfügbar.", 403);
        }

        $timezone = new DateTimeZone('Europe/Berlin');
        $now = new DateTimeImmutable('now', $timezone);
        $currentWeekInfo = $this->getWeekYear($now);
        $currentYear = $currentWeekInfo['year'];
        $currentWeek = $currentWeekInfo['week'];

        $allEventsData = [];
        $rangeWeeksBefore = 1; 
        $rangeWeeksAfter = $this->settings['ical_weeks_future'];

        try {
            for ($weekOffset = -$rangeWeeksBefore; $weekOffset <= $rangeWeeksAfter; $weekOffset++) {
                $dt = $now->modify('+' . ($weekOffset * 7) . ' days');
                $weekInfo = $this->getWeekYear($dt);
                $targetYear = $weekInfo['year'];
                $targetWeek = $weekInfo['week'];

                $targetGroup = ($userRole === 'schueler') ? 'student' : 'teacher';
                $academicEventsForWeek = [];
                $appointmentsForWeek = []; // NEU
                
                // Datumsbereich für Abfragen (Mo-So der Zielwoche)
                [$startDate, $endDate] = $this->getWeekDateRange($targetYear, $targetWeek); 

                if ($this->planRepository->isWeekPublishedFor($targetGroup, $targetYear, $targetWeek)) {
                    $timetable = [];
                    $substitutions = [];
                    
                    if ($classId) { // Schüler
                        $timetable = $this->planRepository->getPublishedTimetableForClass($classId, $targetYear, $targetWeek);
                        $substitutions = $this->planRepository->getPublishedSubstitutionsForClassWeek($classId, $targetYear, $targetWeek);
                        $academicEventsForWeek = $this->eventRepository->getEventsForClassByWeek($classId, $targetYear, $targetWeek);
                        // NEU: Termine für Schüler abrufen
                        $appointmentsForWeek = $this->appointmentRepository->getAppointmentsForStudent($userId, $startDate, $endDate); 
                    } elseif ($teacherId && $teacherUserId) { // Lehrer
                        $timetable = $this->planRepository->getPublishedTimetableForTeacher($teacherId, $targetYear, $targetWeek);
                        $substitutions = $this->planRepository->getPublishedSubstitutionsForTeacherWeek($teacherId, $targetYear, $targetWeek);
                        $academicEventsForWeek = $this->eventRepository->getEventsByTeacherForDateRange($teacherUserId, $startDate, $endDate);
                        // NEU: Termine für Lehrer abrufen
                        $appointmentsForWeek = $this->appointmentRepository->getAppointmentsForTeacher($userId, $startDate, $endDate); 
                    }
                    
                    $this->processWeekData($allEventsData, $timetable, $substitutions, $targetYear, $targetWeek, $timezone, $userRole);
                    $this->processAcademicEvents($allEventsData, $academicEventsForWeek, $timezone);
                    $this->processAppointments($allEventsData, $appointmentsForWeek, $timezone, $userRole); // NEU
                }
            } 
        } catch (Exception $e) {
            error_log("iCal feed generation error for token {$token}: " . $e->getMessage());
            throw new Exception("Fehler beim Abrufen der Kalenderdaten.", 500);
        }

        return $this->formatAsIcs($allEventsData, $user);
    }

    private function getWeekYear(DateTimeImmutable $date): array
    {
        $year = (int)$date->format('o'); 
        $week = (int)$date->format('W'); 
        return ['week' => $week, 'year' => $year];
    }

    private function getWeekDateRange(int $year, int $week): array
    {
        $dto = new DateTime();
        $dto->setISODate($year, $week, 1); 
        $startDate = $dto->format('Y-m-d');
        $dto->setISODate($year, $week, 7); // Bis Sonntag
        $endDate = $dto->format('Y-m-d');
        return [$startDate, $endDate];
    }

    private function getDateForDayOfWeek(int $year, int $week, int $dayNum, DateTimeZone $timezone): DateTimeImmutable
    {
        $dt = new DateTimeImmutable("{$year}-W" . sprintf('%02d', $week) . "-{$dayNum}", $timezone);
        return $dt->setTime(0, 0, 0);
    }

    private function processWeekData(array &$events, array $timetable, array $substitutions, int $year, int $week, DateTimeZone $timezone, string $userRole): void
    {
        $processedRegularSlots = [];
        $substitutionMap = [];
        foreach ($substitutions as $sub) {
            $key = $sub['date'] . '-' . $sub['period_number'];
            $substitutionMap[$key] = $sub;
        }

        // Vertretungen zuerst verarbeiten
        foreach ($substitutions as $sub) {
            $subKey = $sub['date'] . '-' . $sub['period_number'];
            if (isset($processedRegularSlots[$subKey])) continue; // Bereits als Teil eines Blocks verarbeitet

            $period = (int)$sub['period_number'];
            $times = self::PERIOD_TIMES[$period] ?? null;
            if (!$times) continue;

            try {
                $dateObj = new DateTimeImmutable($sub['date'] . ' 00:00:00', $timezone);
            } catch (Exception $e) {
                error_log("Invalid date format in substitution: " . $sub['date']);
                continue;
            }
            
            $dtStart = $dateObj->setTime((int)substr($times['start'], 0, 2), (int)substr($times['start'], 2, 2));
            $dtEnd = $dateObj->setTime((int)substr($times['end'], 0, 2), (int)substr($times['end'], 2, 2));

            // Blockbildung für Vertretungen
            $span = 1;
            while (true) {
                $nextPeriod = $period + $span;
                $nextSubKey = $sub['date'] . '-' . $nextPeriod;
                if (isset(self::PERIOD_TIMES[$nextPeriod]) && isset($substitutionMap[$nextSubKey])) {
                    $nextSub = $substitutionMap[$nextSubKey];
                    // Prüfen, ob die nächste Stunde der gleiche Vertretungstyp ist
                    if ($nextSub['substitution_type'] === $sub['substitution_type'] &&
                        $nextSub['comment'] === $sub['comment'] &&
                        $nextSub['new_teacher_id'] === $sub['new_teacher_id'] &&
                        $nextSub['new_subject_id'] === $sub['new_subject_id'] &&
                        $nextSub['new_room_id'] === $sub['new_room_id']) 
                    {
                        $nextTimes = self::PERIOD_TIMES[$nextPeriod];
                        $dtEnd = $dateObj->setTime((int)substr($nextTimes['end'], 0, 2), (int)substr($nextTimes['end'], 2, 2));
                        $processedRegularSlots[$nextSubKey] = true;
                        $span++;
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }

            $originalEntry = null;
            if ($sub['substitution_type'] !== 'Sonderevent') {
                 $dbDayNum = $dateObj->format('N');
                 $originalEntry = array_values(array_filter($timetable,
                    fn($e) => $e['day_of_week'] == $dbDayNum && $e['period_number'] == $period
                 ))[0] ?? null;
            }

            $summary = '';
            $description = "Typ: " . $sub['substitution_type'] . "\n";
            $location = $sub['new_room_name'] ?? $originalEntry['room_name'] ?? '';
            $status = 'CONFIRMED';

            switch ($sub['substitution_type']) {
                case 'Entfall':
                    $summary = "ENTFALL: " . ($originalEntry['subject_shortcut'] ?? 'Unterricht');
                    $description .= "Ursprünglich: " . ($originalEntry['subject_shortcut'] ?? '?') . " bei " . ($originalEntry['teacher_shortcut'] ?? '?') . "\n";
                    $location = ''; 
                    $status = 'CANCELLED';
                    break;
                case 'Raumänderung':
                    $summary = ($originalEntry['subject_shortcut'] ?? 'Unterricht') . " in Raum " . ($sub['new_room_name'] ?? '???');
                    $description .= "Neuer Raum: " . ($sub['new_room_name'] ?? '???') . "\n";
                    $description .= "Fach: " . ($originalEntry['subject_shortcut'] ?? '?') . "\n";
                    $description .= "Lehrer/Klasse: " . ($userRole === 'schueler' ? ($originalEntry['teacher_shortcut'] ?? '?') : ($originalEntry['class_name'] ?? '?')) . "\n";
                    break;
                case 'Sonderevent':
                    $summary = $sub['comment'] ?: 'Sonderevent';
                    $location = $sub['new_room_name'] ?? '';
                    break;
                case 'Vertretung':
                default:
                    $subject = $sub['new_subject_shortcut'] ?? $originalEntry['subject_shortcut'] ?? '???';
                    $teacher = $sub['new_teacher_shortcut'] ?? '???';
                    $class = $sub['class_name'] ?? $originalEntry['class_name'] ?? '???';
                    $summary = "VERTR.: {$subject} - " . ($userRole === 'schueler' ? $teacher : $class);
                    $description .= "Fach: {$subject}\n";
                    $description .= "Lehrer: {$teacher}\n";
                    $description .= "Raum: " . ($sub['new_room_name'] ?? $originalEntry['room_name'] ?? '???') . "\n";
                    if ($originalEntry) {
                         $description .= "Ursprünglich: " . $originalEntry['subject_shortcut'] . " bei " . $originalEntry['teacher_shortcut'] . "\n";
                    }
                    break;
            }

            if ($sub['comment'] && $sub['substitution_type'] !== 'Sonderevent') {
                $description .= "Kommentar: " . $sub['comment'] . "\n";
            }

            $events[] = [
                'uid' => 'sub-' . $sub['substitution_id'],
                'dtStart' => $dtStart,
                'dtEnd' => $dtEnd,
                'summary' => $summary,
                'location' => $location,
                'description' => trim($description),
                'status' => $status,
            ];

             $processedRegularSlots[$subKey] = true;
        }

        // Reguläre Stunden verarbeiten
        foreach ($timetable as $entry) {
            $dayNum = (int)$entry['day_of_week'];
            $period = (int)$entry['period_number'];
            $regKey = $this->getDateForDayOfWeek($year, $week, $dayNum, $timezone)->format('Y-m-d') . '-' . $period;
            $blockId = $entry['block_id'];
            
            // Überspringen, wenn von Vertretung betroffen oder Teil eines bereits verarbeiteten Blocks
            if (isset($substitutionMap[$regKey]) || isset($processedRegularSlots[$regKey]) || ($blockId && isset($processedRegularSlots[$blockId]))) {
                continue;
            }

            $times = self::PERIOD_TIMES[$period] ?? null;
            if (!$times) continue;

            $dateObj = $this->getDateForDayOfWeek($year, $week, $dayNum, $timezone);
            $dtStart = $dateObj->setTime((int)substr($times['start'], 0, 2), (int)substr($times['start'], 2, 2));
            $dtEnd = $dateObj->setTime((int)substr($times['end'], 0, 2), (int)substr($times['end'], 2, 2));
            
            $uidBase = 'entry-' . $entry['entry_id'];

            if ($blockId) {
                // Dies ist der Start eines Blocks, der noch nicht verarbeitet wurde
                $blockEntries = array_filter($timetable, fn($e) => $e['block_id'] === $blockId);
                if (!empty($blockEntries)) {
                    $minPeriod = min(array_column($blockEntries, 'period_number'));
                    $maxPeriod = max(array_column($blockEntries, 'period_number'));
                    
                    if ($period === $minPeriod) { // Nur den ersten Eintrag des Blocks verarbeiten
                         $startTime = self::PERIOD_TIMES[$minPeriod]['start'] ?? null;
                         $endTime = self::PERIOD_TIMES[$maxPeriod]['end'] ?? null;
                         if ($startTime && $endTime) {
                             $dtStart = $dateObj->setTime((int)substr($startTime, 0, 2), (int)substr($startTime, 2, 2));
                             $dtEnd = $dateObj->setTime((int)substr($endTime, 0, 2), (int)substr($endTime, 2, 2));
                         }
                         $uidBase = 'block-' . $blockId;
                         // Alle Slots dieses Blocks als verarbeitet markieren
                         for ($p = $minPeriod; $p <= $maxPeriod; $p++) {
                             $blockKey = $dateObj->format('Y-m-d') . '-' . $p;
                             $processedRegularSlots[$blockKey] = true;
                         }
                         $processedRegularSlots[$blockId] = true; // Block-ID selbst markieren
                    } else {
                         continue; // Nicht der Start-Eintrag des Blocks
                    }
                } else {
                     $processedRegularSlots[$regKey] = true; // Als Einzelstunde markieren
                }
            } else {
                $processedRegularSlots[$regKey] = true; // Als Einzelstunde markieren
            }

            $summary = ($entry['subject_shortcut'] ?? '???') . " - " . ($userRole === 'schueler' ? ($entry['teacher_shortcut'] ?? '???') : ($entry['class_name'] ?? '???'));
            $description = "Fach: " . ($entry['subject_name'] ?? $entry['subject_shortcut'] ?? '???') . "\n";
            $description .= "Lehrer: " . ($entry['teacher_shortcut'] ?? '???') . "\n";
            $description .= "Klasse: " . ($entry['class_name'] ?? '???') . "\n";
            $description .= "Raum: " . ($entry['room_name'] ?? '???') . "\n";
            if (!empty($entry['comment'])) {
                $description .= "Kommentar: " . $entry['comment'] . "\n";
            }

            $events[] = [
                'uid' => $uidBase,
                'dtStart' => $dtStart,
                'dtEnd' => $dtEnd,
                'summary' => $summary,
                'location' => $entry['room_name'] ?? '',
                'description' => trim($description),
                'status' => 'CONFIRMED',
            ];
        }
    }

    private function processAcademicEvents(array &$events, array $academicEvents, DateTimeZone $timezone): void
    {
        foreach ($academicEvents as $event) {
            try {
                $dateObj = new DateTimeImmutable($event['due_date'] . ' 00:00:00', $timezone);
            } catch (Exception $e) {
                error_log("Invalid date format in academic event: " . $event['due_date']);
                continue;
            }

            $times = null; 

            if ($times) {
                // Logik für zeitbasierte Events (derzeit nicht verwendet)
                $dtStart = $dateObj->setTime((int)substr($times['start'], 0, 2), (int)substr($times['start'], 2, 2));
                $dtEnd = $dateObj->setTime((int)substr($times['end'], 0, 2), (int)substr($times['end'], 2, 2));
                $dtStartFormat = 'Ymd\THis';
                $dtEndFormat = 'Ymd\THis';
                $timeInfo = ""; 
            } else {
                // Ganztägiges Event
                $dtStart = $dateObj;
                $dtEnd = $dateObj->modify('+1 day');
                $dtStartFormat = 'Ymd';
                $dtEndFormat = 'Ymd';
                $timeInfo = "";
            }

            $icon = 'ℹ️'; $prefix = 'Info';
            if ($event['event_type'] === 'klausur') { $icon = '🎓'; $prefix = 'Klausur'; }
            if ($event['event_type'] === 'aufgabe') { $icon = '📚'; $prefix = 'Aufgabe'; }

            $summary = "{$icon} {$prefix}: " . ($event['title'] ?? 'Eintrag');
            if ($event['subject_shortcut']) {
                $summary .= " (" . $event['subject_shortcut'] . ")";
            }

            $description = "Typ: " . ucfirst($event['event_type']) . "\n";
            $description .= "Fach: " . ($event['subject_shortcut'] ?? '-') . "\n";
            if (isset($event['teacher_first_name'])) {
                 $description .= "Lehrer: " . $event['teacher_first_name'] . ' ' . $event['teacher_last_name'] . "\n";
            }
            if (isset($event['class_name'])) {
                 $description .= "Klasse: " . $event['class_name'] . "\n";
            }
            $description .= "Datum: " . $dateObj->format('d.m.Y') . $timeInfo . "\n";
            if ($event['description']) {
                $description .= "\nBeschreibung:\n" . $event['description'];
            }

            $events[] = [
                'uid' => 'acad-' . $event['event_id'],
                'dtStart' => $dtStart,
                'dtEnd' => $dtEnd,
                'dtStartFormat' => $dtStartFormat,
                'dtEndFormat' => $dtEndFormat,
                'summary' => $summary,
                'location' => '',
                'description' => trim($description),
                'status' => 'CONFIRMED',
            ];
        }
    }

    // NEU: Verarbeitet gebuchte Sprechstunden
    private function processAppointments(array &$events, array $appointments, DateTimeZone $timezone, string $userRole): void
    {
        foreach ($appointments as $app) {
            try {
                // Termin-Zeit berechnen
                $dateObj = new DateTimeImmutable($app['appointment_date'] . ' ' . $app['appointment_time'], $timezone);
                $dtStart = $dateObj;
                $dtEnd = $dateObj->modify('+' . intval($app['duration'] ?? 15) . ' minutes');
                $dtStartFormat = 'Ymd\THis';
                $dtEndFormat = 'Ymd\THis';

                $summary = '🗣️ Sprechstunde';
                $description = "Sprechstunde\n";
                $location = $app['location'] ?? 'N/A';

                if ($userRole === 'schueler') {
                    $summary .= ' bei ' . ($app['teacher_shortcut'] ?? $app['teacher_name'] ?? 'Lehrer');
                    $description .= "Lehrer: " . ($app['teacher_name'] ?? 'N/A') . "\n";
                    if (!empty($app['notes'])) {
                        $description .= "Deine Notiz: " . $app['notes'] . "\n";
                    }
                } else { // lehrer
                    $summary .= ' mit ' . ($app['student_name'] ?? 'Schüler');
                    $description .= "Schüler: " . ($app['student_name'] ?? 'N/A') . "\n";
                    if (!empty($app['class_name'])) {
                        $description .= "Klasse: " . $app['class_name'] . "\n";
                    }
                    if (!empty($app['notes'])) {
                        $description .= "Notiz des Schülers: " . $app['notes'] . "\n";
                    }
                }
                $description .= "Ort: " . $location . "\n";
                $description .= "Status: Gebucht";

                $events[] = [
                    'uid' => 'appt-' . $app['appointment_id'],
                    'dtStart' => $dtStart,
                    'dtEnd' => $dtEnd,
                    'dtStartFormat' => $dtStartFormat,
                    'dtEndFormat' => $dtEndFormat,
                    'summary' => $summary,
                    'location' => $location,
                    'description' => trim($description),
                    'status' => 'CONFIRMED',
                ];
            } catch (Exception $e) {
                error_log("Fehler beim Verarbeiten von Termin (ID: {$app['appointment_id']}): " . $e->getMessage());
            }
        }
    }

    private function formatAsIcs(array $events, array $user): string
    {
        $ics = "BEGIN:VCALENDAR\r\n";
        $ics .= "VERSION:2.0\r\n";
        $ics .= "PRODID:-//PMI//PAUSE Stundenplan v1.0//DE\r\n";
        $ics .= "CALSCALE:GREGORIAN\r\n";
        $ics .= "METHOD:PUBLISH\r\n";
        $ics .= "X-WR-CALNAME:PAUSE Stundenplan (" . $this->escapeIcsString($user['username']) . ")\r\n";
        $ics .= "X-WR-TIMEZONE:Europe/Berlin\r\n";
        $ics .= "X-PUBLISHED-TTL:PT1H\r\n"; // 1 Stunde Cache

        // VTIMEZONE Definition für Europe/Berlin
        $ics .= "BEGIN:VTIMEZONE\r\n";
        $ics .= "TZID:Europe/Berlin\r\n";
        $ics .= "X-LIC-LOCATION:Europe/Berlin\r\n";
        $ics .= "BEGIN:DAYLIGHT\r\n";
        $ics .= "TZOFFSETFROM:+0100\r\n";
        $ics .= "TZOFFSETTO:+0200\r\n";
        $ics .= "TZNAME:CEST\r\n";
        $ics .= "DTSTART:19700329T020000\r\n";
        $ics .= "RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\n";
        $ics .= "END:DAYLIGHT\r\n";
        $ics .= "BEGIN:STANDARD\r\n";
        $ics .= "TZOFFSETFROM:+0200\r\n";
        $ics .= "TZOFFSETTO:+0100\r\n";
        $ics .= "TZNAME:CET\r\n";
        $ics .= "DTSTART:19701025T030000\r\n";
        $ics .= "RRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\n";
        $ics .= "END:STANDARD\r\n";
        $ics .= "END:VTIMEZONE\r\n";

        $nowUtc = gmdate('Ymd\THis\Z');

        foreach ($events as $event) {
            $dtStart = $event['dtStart'];
            $dtEnd = $event['dtEnd'];
            
            $dtStartFormat = $event['dtStartFormat'] ?? 'Ymd\THis';
            $dtEndFormat = $event['dtEndFormat'] ?? 'Ymd\THis';

            $dtStartString = $dtStart->format($dtStartFormat);
            $dtEndString = $dtEnd->format($dtEndFormat);

            $datePrefix = ($dtStartFormat === 'Ymd') ? ';VALUE=DATE' : ';TZID=Europe/Berlin';

            if ($dtStartFormat === 'Ymd\THis' && $dtEndFormat === 'Ymd') {
                 $dtEndString = $dtEnd->format('Ymd\THis'); 
            }

            $ics .= "BEGIN:VEVENT\r\n";
            $ics .= "UID:" . $event['uid'] . '-' . $dtStart->format('YmdHis') . "@pause.pmi\r\n";
            $ics .= "DTSTAMP:" . $nowUtc . "\r\n";
            $ics .= "DTSTART{$datePrefix}:" . $dtStartString . "\r\n";
            $ics .= "DTEND{$datePrefix}:" . $dtEndString . "\r\n";
            $ics .= "SUMMARY:" . $this->escapeIcsString($event['summary']) . "\r\n";

            if (!empty($event['location'])) {
                $ics .= "LOCATION:" . $this->escapeIcsString($event['location']) . "\r\n";
            }
            if (!empty($event['description'])) {
                $ics .= "DESCRIPTION:" . $this->escapeIcsString($event['description']) . "\r\n";
            }

            $ics .= "STATUS:" . $event['status'] . "\r\n";
            $ics .= ($dtStartFormat === 'Ymd') ? "TRANSP:TRANSPARENT\r\n" : "TRANSP:OPAQUE\r\n";
            $ics .= "END:VEVENT\r\n";
        }

        $ics .= "END:VCALENDAR\r\n";
        return $ics;
    }

    private function escapeIcsString(?string $string): string
    {
        if ($string === null) return '';
        $string = str_replace('\\', '\\\\', $string);
        $string = str_replace(';', '\;', $string);
        $string = str_replace(',', '\,', $string);
        $string = str_replace("\r", '', $string); 
        $string = str_replace("\n", '\n', $string); 
        return $string;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Services\IcalService.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Services\ImpersonationService.php ---
<?php
namespace App\Services;
use App\Repositories\UserRepository;
use App\Core\Security;
use App\Core\Utils;
use Exception;
class ImpersonationService
{
    private UserRepository $userRepository;
    public function __construct(UserRepository $userRepository)
    {
        $this->userRepository = $userRepository;
    }
    public function start(int $targetUserId, int $adminUserId): array
    {
        if ($targetUserId == $adminUserId) {
            throw new Exception("Sie können sich nicht selbst imitieren.", 400);
        }
        $targetUser = $this->userRepository->findById($targetUserId);
        if (!$targetUser) {
            throw new Exception("Zielbenutzer nicht gefunden.", 404);
        }
        $_SESSION['impersonator_id'] = $adminUserId;
        session_regenerate_id(true);
        $_SESSION['user_id'] = $targetUser['user_id'];
        $_SESSION['username'] = $targetUser['username'];
        $_SESSION['user_role'] = $targetUser['role'];
        $_SESSION['is_community_banned'] = (int)($targetUser['is_community_banned'] ?? 0);
        $_SESSION['impersonator_id'] = $adminUserId;
        Security::getCsrfToken();
        return $targetUser;
    }
    public function revert(): array
    {
        if (session_status() !== PHP_SESSION_ACTIVE || empty($_SESSION['impersonator_id'])) {
            throw new Exception("Keine aktive Impersonation-Sitzung gefunden.", 400);
        }
        $impersonatedUserId = $_SESSION['user_id'] ?? 0;
        $adminUserId = $_SESSION['impersonator_id'];
        $_SESSION = [];
        session_destroy();
        session_start();
        session_regenerate_id(true);
        $adminUser = $this->userRepository->findById($adminUserId);
        if (!$adminUser || !in_array($adminUser['role'], ['admin', 'planer'])) { 
            error_log("Impersonation Revert Failed: Original user {$adminUserId} is no longer an admin/planer.");
            throw new Exception("Ursprünglicher Benutzer konnte nicht wiederhergestellt werden.", 403);
        }
        $_SESSION['user_id'] = $adminUser['user_id'];
        $_SESSION['username'] = $adminUser['username'];
        $_SESSION['user_role'] = $adminUser['role'];
        $_SESSION['is_community_banned'] = 0; 
        Security::getCsrfToken();
        return [
            'adminUser' => $adminUser,
            'impersonatedUserId' => $impersonatedUserId
        ];
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Services\ImpersonationService.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Services\PdfService.php ---
<?php
namespace App\Services;
use App\Repositories\PlanRepository;
use App\Repositories\UserRepository;
use App\Core\Utils; 
use Exception;
use DateTime;
use DateTimeZone;
if (!defined('FPDF_FONTPATH')) {
    define('FPDF_FONTPATH', dirname(__DIR__, 2) . DIRECTORY_SEPARATOR . 'libs' . DIRECTORY_SEPARATOR . 'tfpdf' . DIRECTORY_SEPARATOR . 'font' . DIRECTORY_SEPARATOR);
}
require_once dirname(__DIR__, 2) . '/libs/tfpdf/tfpdf.php';
class PdfService extends \tFPDF
{
    private PlanRepository $planRepository;
    private UserRepository $userRepository;
    private array $settings;
    private ?array $userData = null; 
    private int $targetYear;
    private int $targetWeek;
    private array $timetableData = [];
    private array $substitutionData = [];
    private array $cellWidths = [];
    private float $headerHeight = 7;
    private float $totalWidth = 277; 
    private string $fontBody = 'Arial';
    private string $fontDisplay = 'Arial';
    private array $colors = [
        'border' => [200, 200, 200],
        'headerBg' => [240, 240, 240],
        'headerText' => [50, 50, 50],
        'cellBg' => [255, 255, 255],
        'cellText' => [0, 0, 0],
        'substBorderVertretung' => [220, 53, 69],
        'substBorderRaum' => [255, 193, 7],
        'substBorderEvent' => [13, 110, 253],
        'substBorderEntfall' => [108, 117, 125],
        'substTextEntfall' => [108, 117, 125],
        'commentText' => [108, 117, 125],
    ];
    public function __construct(
        PlanRepository $planRepository,
        UserRepository $userRepository,
        array $settings
    ) {
        $this->planRepository = $planRepository;
        $this->userRepository = $userRepository;
        $this->settings = $settings;
    }
    public function generateTimetablePdf(int $userId, string $userRole, int $year, int $week): string
    {
        $this->userData = $this->userRepository->findById($userId);
        if (!$this->userData || !in_array($userRole, ['schueler', 'lehrer'])) {
            throw new Exception("PDF Export nur für Schüler und Lehrer verfügbar.", 403);
        }
        $this->targetYear = $year;
        $this->targetWeek = $week;
        $targetGroup = ($userRole === 'schueler') ? 'student' : 'teacher';
        if (!$this->planRepository->isWeekPublishedFor($targetGroup, $year, $week)) {
            throw new Exception("Der Stundenplan für diese Woche ist noch nicht veröffentlicht.", 403);
        }
        if ($userRole === 'schueler' && !empty($this->userData['class_id'])) {
            $classId = $this->userData['class_id'];
            $this->timetableData = $this->planRepository->getPublishedTimetableForClass($classId, $year, $week);
            $this->substitutionData = $this->planRepository->getPublishedSubstitutionsForClassWeek($classId, $year, $week);
        } elseif ($userRole === 'lehrer' && !empty($this->userData['teacher_id'])) {
            $teacherId = $this->userData['teacher_id'];
            $this->timetableData = $this->planRepository->getPublishedTimetableForTeacher($teacherId, $year, $week);
            $this->substitutionData = $this->planRepository->getPublishedSubstitutionsForTeacherWeek($teacherId, $year, $week);
        } else {
            throw new Exception("Benutzerdaten unvollständig (Klasse/Lehrer fehlt).", 400);
        }
        parent::__construct('L', 'mm', 'A4'); 
        try {
            if (!file_exists(FPDF_FONTPATH . 'unifont' . DIRECTORY_SEPARATOR . 'Oswald-Regular.ttf')) throw new Exception("Font file not found: Oswald-Regular.ttf");
            if (!file_exists(FPDF_FONTPATH . 'unifont' . DIRECTORY_SEPARATOR . 'Oswald-Bold.ttf')) throw new Exception("Font file not found: Oswald-Bold.ttf");
            $this->AddFont('Oswald', '', 'Oswald-Regular.ttf', true);
            $this->AddFont('Oswald', 'B', 'Oswald-Bold.ttf', true);
            $this->fontBody = 'Arial';
            $this->fontDisplay = 'Oswald';
        } catch (Exception $fontEx) {
            error_log("Fehler beim Laden der PDF-Schriftarten: " . $fontEx->getMessage() . " - Fallback auf Arial.");
            $this->fontBody = 'Arial';
            $this->fontDisplay = 'Arial';
        }
        $this->AliasNbPages();
        $this->AddPage();
        $this->SetMargins(10, 10, 10);
        $this->SetAutoPageBreak(false);
        $this->drawPdfHeader();
        $this->drawTimetableGrid();
        return $this->Output('S');
    }
    private function drawPdfHeader(): float
    {
        $monday = $this->getDateOfISOWeek($this->targetWeek, $this->targetYear);
        $friday = (new DateTime())->setTimestamp($monday->getTimestamp() + 4 * 24 * 60 * 60);
        $className = '';
        if($this->userData['role'] === 'schueler') {
            $classData = $this->userRepository->findClassByUserId($this->userData['user_id']);
            if ($classData) {
                $className = 'Klasse ' . ($classData['class_name'] ?? $classData['class_id']);
            }
        }
        $title = sprintf(
            'Stundenplan %s %s',
            $this->userData['username'] ?? 'Benutzer',
            $className ? '(' . $className . ')' : ''
        );
        $subTitle = sprintf(
            'Kalenderwoche %d / %d (%s - %s)',
            $this->targetWeek,
            $this->targetYear,
            $monday->format('d.m.Y'),
            $friday->format('d.m.Y')
        );
        $this->SetFont($this->fontDisplay, 'B', 16);
        $this->SetTextColor(0, 0, 0);
        $this->Cell(0, 8, $title, 0, 1, 'C');
        $this->SetFont($this->fontBody, '', 10);
        $this->Cell(0, 6, $subTitle, 0, 1, 'C');
        $this->Ln(5);
        return 19; 
    }
    private function drawTimetableGrid()
    {
        $timeColWidth = 18;
        $dayColWidth = ($this->totalWidth - $timeColWidth) / 5;
        $this->cellWidths = [$timeColWidth, $dayColWidth, $dayColWidth, $dayColWidth, $dayColWidth, $dayColWidth];
        $this->SetFont($this->fontBody, 'B', 8);
        $this->SetFillColor(...$this->colors['headerBg']);
        $this->SetTextColor(...$this->colors['headerText']);
        $this->SetDrawColor(...$this->colors['border']);
        $this->SetLineWidth(0.2);
        $this->Cell($this->cellWidths[0], $this->headerHeight, 'Zeit', 1, 0, 'C', true);
        $daysOfWeek = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag'];
        foreach ($daysOfWeek as $i => $day) {
            $this->Cell($this->cellWidths[$i + 1], $this->headerHeight, $day, 1, 0, 'C', true);
        }
        $this->Ln($this->headerHeight);
        $headerAreaHeight = 19; 
        $drawableHeight = $this->h - $this->tMargin - 10; 
        $gridBodyHeight = $drawableHeight - $headerAreaHeight - $this->headerHeight; 
        $timeSlotsDisplay = [
            "08:00\n08:45", "08:55\n09:40", "09:40\n10:25", "10:35\n11:20",
            "11:20\n12:05", "13:05\n13:50", "13:50\n14:35", "14:45\n15:30",
            "15:30\n16:15", "16:25\n17:10"
        ];
        $numRows = count($timeSlotsDisplay);
        $calculatedRowHeight = $gridBodyHeight / $numRows; 
        $timeCellLineHeight = 3.5;
        $timetableByCell = $this->prepareTimetableData();
        foreach ($timeSlotsDisplay as $period => $timeLabel) {
            $currentPeriod = $period + 1;
            $rowStartY = $this->GetY();
            $this->SetFillColor(...$this->colors['headerBg']);
            $this->SetTextColor(...$this->colors['headerText']);
            $periodLabel = $currentPeriod . ".";
            $timeLabelParts = explode("\n", $timeLabel);
            $timeLabelFormatted = $timeLabelParts[0] . ' - ' . $timeLabelParts[1];
            $totalTextHeight = $timeCellLineHeight * 2;
            $cellCenterY = $rowStartY + ($calculatedRowHeight / 2);
            $textStartY = $cellCenterY - ($totalTextHeight / 2);
            $this->SetXY(10, $rowStartY); 
            $this->Cell($this->cellWidths[0], $calculatedRowHeight, '', 1, 0, 'C', true);
            $this->SetXY(10, $textStartY);
            $this->SetFont($this->fontBody, 'B', 8);
            $this->Cell($this->cellWidths[0], $timeCellLineHeight, $periodLabel, 0, 1, 'C', false);
            $this->SetFont($this->fontBody, '', 7);
            $this->SetX(10);
            $this->Cell($this->cellWidths[0], $timeCellLineHeight, $timeLabelFormatted, 0, 1, 'C', false);
            $this->SetY($rowStartY);
            for ($dayNum = 1; $dayNum <= 5; $dayNum++) {
                $currentX = 10 + $this->cellWidths[0] + (($dayNum - 1) * $this->cellWidths[$dayNum]);
                $this->SetX($currentX);
                $cellKey = $dayNum . '-' . $currentPeriod;
                $entry = $timetableByCell[$cellKey] ?? null;
                $this->drawTimetableCell($entry, $this->cellWidths[$dayNum], $calculatedRowHeight, $this->fontBody, $currentPeriod);
            }
            $this->Ln($calculatedRowHeight);
        }
    }
    private function prepareTimetableData(): array
    {
        $map = [];
        $userRole = $this->userData['role']; 
        foreach ($this->timetableData as $entry) {
            $key = $entry['day_of_week'] . '-' . $entry['period_number'];
            $map[$key] = [
                'type' => 'regular',
                'subject' => $entry['subject_shortcut'] ?? '---',
                'mainText' => $userRole === 'schueler' ? ($entry['teacher_shortcut'] ?? '---') : ($entry['class_name'] ?? '---'),
                'room' => $entry['room_name'] ?? '',
                'comment' => $entry['comment'] ?? '',
                'original' => $entry
            ];
        }
        foreach ($this->substitutionData as $sub) {
            try {
                $subDate = new DateTime($sub['date']);
                $dayNum = $subDate->format('N');
            } catch (Exception $e) { continue; }
            if ($dayNum < 1 || $dayNum > 5) continue;
            $key = $dayNum . '-' . $sub['period_number'];
            $regularEntryForKey = $map[$key]['original'] ?? null;
            $map[$key] = [
                'type' => $sub['substitution_type'],
                'subject' => $sub['new_subject_shortcut'] ?? $regularEntryForKey['subject_shortcut'] ?? ($sub['substitution_type'] === 'Sonderevent' ? 'EVENT' : ($sub['substitution_type'] === 'Entfall' ? ($regularEntryForKey['subject_shortcut'] ?? '---') : '---')),
                'mainText' => $sub['substitution_type'] === 'Vertretung'
                    ? ($userRole === 'teacher' ? ($sub['class_name'] ?? $regularEntryForKey['class_name'] ?? '---') : ($sub['new_teacher_shortcut'] ?? '---'))
                    : ($sub['substitution_type'] === 'Entfall' ? 'Entfällt' : ($regularEntryForKey ? ($userRole === 'schueler' ? $regularEntryForKey['teacher_shortcut'] : $regularEntryForKey['class_name']) : '')),
                'room' => $sub['new_room_name'] ?? $regularEntryForKey['room_name'] ?? '',
                'comment' => $sub['comment'] ?? '',
                'original' => $regularEntryForKey
            ];
        }
        return $map;
    }
    private function drawTimetableCell(?array $entry, float $width, float $height, string $fontBody, int $currentPeriod)
    {
        $this->SetFillColor(...$this->colors['cellBg']);
        $this->SetTextColor(...$this->colors['cellText']);
        $this->SetDrawColor(...$this->colors['border']);
        $this->SetLineWidth(0.2);
        $border = 1;
        $startX = $this->GetX();
        $startY = $this->GetY();
        $borderColor = null;
        if ($entry) {
            $subjectText = $entry['subject'] ?? '';
            $mainText = $entry['mainText'] ?? '';
            $roomText = $entry['room'] ?? '';
            $commentText = $entry['comment'] ?? '';
            switch ($entry['type']) {
                case 'Vertretung': $borderColor = $this->colors['substBorderVertretung']; break;
                case 'Raumänderung': $borderColor = $this->colors['substBorderRaum']; break;
                case 'Sonderevent': $borderColor = $this->colors['substBorderEvent']; break;
                case 'Entfall': $borderColor = $this->colors['substBorderEntfall']; break;
                default: $borderColor = $this->colors['border'];
            }
            if ($borderColor && $borderColor !== $this->colors['border']) {
                $this->SetDrawColor(...$borderColor);
                $this->SetLineWidth(0.5);
                $this->Line($startX, $startY, $startX, $startY + $height);
                $this->SetDrawColor(...$this->colors['border']);
                $this->SetLineWidth(0.2);
            }
            $this->SetXY($startX, $startY);
            $this->Cell($width, $height, '', $border, 0, 'C', true);
            $padding = 1.5;
            $availableWidth = $width - (2 * $padding);
            $lineHeight = 3.5;
            $textBlockHeight = 0;
            if ($entry['type'] === 'Entfall') {
                $textBlockHeight += $lineHeight;
            } else {
                $textBlockHeight += $lineHeight;
                $detailsText = trim(($mainText ? $mainText : '') . ($roomText ? ' (' . $roomText . ')' : ''));
                if ($detailsText) $textBlockHeight += $lineHeight;
            }
            if ($commentText && $entry['type'] !== 'Sonderevent') {
                $textBlockHeight += $lineHeight;
            }
            if ($entry['type'] === 'Sonderevent') {
                $textBlockHeight = $lineHeight * 2;
            }
            $contentStartY = $startY + ($height - $textBlockHeight) / 2;
            if ($contentStartY < $startY + $padding) $contentStartY = $startY + $padding;
            $this->SetXY($startX + $padding, $contentStartY);
            $this->SetFont($fontBody, 'B', 9);
            if ($entry['type'] === 'Entfall') {
                $this->SetTextColor(...$this->colors['substTextEntfall']);
                $this->Cell($availableWidth, $lineHeight, 'Entfällt: ' . $subjectText, 0, 1, 'C');
            } else {
                $this->SetTextColor(...$this->colors['cellText']);
                $this->Cell($availableWidth, $lineHeight, $subjectText, 0, 1, 'C');
            }
            if ($entry['type'] !== 'Entfall') {
                $this->SetFont($fontBody, '', 8);
                $this->SetTextColor(...$this->colors['cellText']);
                $detailsText = trim(($mainText ? $mainText : '') . ($roomText ? ' (' . $roomText . ')' : ''));
                if ($detailsText) {
                    $this->SetX($startX + $padding);
                    $this->Cell($availableWidth, $lineHeight, $detailsText, 0, 1, 'C');
                }
            }
            if ($commentText && $entry['type'] !== 'Sonderevent') {
                $this->SetFont($fontBody, '', 7);
                $this->SetTextColor(...$this->colors['commentText']);
                $this->SetX($startX + $padding);
                $this->Cell($availableWidth, $lineHeight, $commentText, 0, 1, 'C');
            }
        } else {
            $isFU = ($currentPeriod == ($this->settings['default_start_hour'] ?? 1) || $currentPeriod == ($this->settings['default_end_hour'] ?? 10));
            if ($isFU) {
                $this->SetFillColor(...$this->colors['headerBg']);
                $this->SetTextColor(...$this->colors['headerText']);
                $this->SetFont($fontBody, 'B', 8);
                $this->Cell($width, $height, 'FU', $border, 0, 'C', true);
            } else {
                $this->Cell($width, $height, '', $border, 0, 'C', true);
            }
        }
        $this->SetXY($startX + $width, $startY);
    }
    private function getDateOfISOWeek(int $week, int $year): DateTime
    {
        $dto = new DateTime();
        $dto->setISODate($year, $week, 1);
        $dto->setTime(0,0,0);
        return $dto;
    }
    public function Header()
    {
    }
    public function Footer()
    {
        $this->SetY(-10);
        $this->SetFont($this->fontBody,'',8);
        $this->SetTextColor(128);
        $footerText = $this->settings['pdf_footer_text'] ?? 'PAUSE Portal';
        $footerText .= ' | Generiert am: ' . date('d.m.Y H:i');
        $this->Cell(0, 10, $footerText, 0, 0, 'L');
        $this->Cell(0, 10, 'Seite '.$this->PageNo().'/{nb}', 0, 0, 'R');
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Services\PdfService.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Services\SingleIcalService.php ---
<?php
namespace App\Services;
use App\Repositories\AcademicEventRepository;
use App\Repositories\PlanRepository;
use DateTimeImmutable;
use DateTimeZone;
use Exception;
class SingleIcalService
{
    private AcademicEventRepository $eventRepo;
    private PlanRepository $planRepo;
    private DateTimeZone $timezone;
    private const PERIOD_TIMES = [
        1 => ['start' => '0800', 'end' => '0845'],
        2 => ['start' => '0855', 'end' => '0940'],
        3 => ['start' => '0940', 'end' => '1025'],
        4 => ['start' => '1035', 'end' => '1120'],
        5 => ['start' => '1120', 'end' => '1205'],
        6 => ['start' => '1305', 'end' => '1350'],
        7 => ['start' => '1350', 'end' => '1435'],
        8 => ['start' => '1445', 'end' => '1530'],
        9 => ['start' => '1530', 'end' => '1615'],
        10 => ['start' => '1625', 'end' => '1710'],
    ];
    public function __construct(
        AcademicEventRepository $eventRepo,
        PlanRepository $planRepo
    ) {
        $this->eventRepo = $eventRepo;
        $this->planRepo = $planRepo;
        $this->timezone = new DateTimeZone('Europe/Berlin');
    }
    public function generateSingleIcs(string $type, int $id): array
    {
        $eventData = null;
        if ($type === 'acad') {
            $eventData = $this->getAcademicEventData($id);
        } elseif ($type === 'sub') {
            $eventData = $this->getSubstitutionEventData($id);
        } else {
            throw new Exception("Ungültiger Event-Typ.", 400);
        }
        if (!$eventData) {
            throw new Exception("Termin nicht gefunden oder ungültig.", 404);
        }
        $icsContent = $this->formatAsIcs($eventData);
        $safeSummary = $eventData['summary'] ?? 'termin';
        $safeSummary = preg_replace('/[^a-zA-Z0-9_-]/', '_', $safeSummary);
        $safeSummary = substr($safeSummary, 0, 50); 
        $filename = $safeSummary . '.ics';
        return [
            'content' => $icsContent,
            'filename' => $filename
        ];
    }
    private function getAcademicEventData(int $id): ?array
    {
        $event = $this->eventRepo->getEventById($id);
        if (!$event) return null;
        $dateObj = new DateTimeImmutable($event['due_date'] . ' 00:00:00', $this->timezone);
        $dtStart = $dateObj;
        $dtEnd = $dateObj->modify('+1 day');
        $dtStartFormat = 'Ymd';
        $dtEndFormat = 'Ymd';
        $timeInfo = "";
        $location = "";
        $icon = 'ℹ️'; $prefix = 'Info';
        if ($event['event_type'] === 'klausur') { $icon = '🎓'; $prefix = 'Klausur'; }
        if ($event['event_type'] === 'aufgabe') { $icon = '📚'; $prefix = 'Aufgabe'; }
        $summary = "{$icon} {$prefix}: " . ($event['title'] ?? 'Eintrag');
        if ($event['subject_shortcut']) {
            $summary .= " (" . $event['subject_shortcut'] . ")";
        }
        $description = "Typ: " . ucfirst($event['event_type']) . "\n";
        $description .= "Fach: " . ($event['subject_shortcut'] ?? '-') . "\n";
        $description .= "Klasse: " . ($event['class_name'] ?? '?') . "\n";
        $description .= "Datum: " . $dateObj->format('d.m.Y') . $timeInfo . "\n";
        if ($event['description']) {
            $description .= "\nBeschreibung:\n" . $event['description'];
        }
        return [
            'uid' => 'acad-' . $event['event_id'],
            'dtStart' => $dtStart,
            'dtEnd' => $dtEnd,
            'dtStartFormat' => $dtStartFormat,
            'dtEndFormat' => $dtEndFormat,
            'summary' => $summary,
            'location' => $location,
            'description' => trim($description),
            'status' => 'CONFIRMED',
        ];
    }
    private function getSubstitutionEventData(int $id): ?array
    {
        $sub = $this->planRepo->getSubstitutionById($id);
        if (!$sub || $sub['substitution_type'] !== 'Sonderevent') {
            return null; 
        }
        $dateObj = new DateTimeImmutable($sub['date'] . ' 00:00:00', $this->timezone);
        $period = (int)$sub['period_number'];
        $times = self::PERIOD_TIMES[$period] ?? null;
        if (!$times) {
            throw new Exception("Ungültige Zeit für Sonderevent.");
        }
        $dtStart = $dateObj->setTime((int)substr($times['start'], 0, 2), (int)substr($times['start'], 2, 2));
        $dtEnd = $dateObj->setTime((int)substr($times['end'], 0, 2), (int)substr($times['end'], 2, 2));
        $dtStartFormat = 'Ymd\THis';
        $dtEndFormat = 'Ymd\THis';
        $summary = "Sonderevent: " . ($sub['comment'] ?: $sub['new_subject_shortcut'] ?: 'Termin');
        $location = $sub['new_room_name'] ?? '';
        $description = "Sonderevent\n";
        $description .= "Klasse: " . ($sub['class_name'] ?? '?') . "\n";
        $description .= "Raum: " . ($location ?: '?') . "\n";
        if ($sub['comment']) {
            $description .= "Details: " . $sub['comment'];
        }
        return [
            'uid' => 'sub-' . $sub['substitution_id'],
            'dtStart' => $dtStart,
            'dtEnd' => $dtEnd,
            'dtStartFormat' => $dtStartFormat,
            'dtEndFormat' => $dtEndFormat,
            'summary' => $summary,
            'location' => $location,
            'description' => trim($description),
            'status' => 'CONFIRMED',
        ];
    }
    private function formatAsIcs(array $event): string
    {
        $ics = "BEGIN:VCALENDAR\r\n";
        $ics .= "VERSION:2.0\r\n";
        $ics .= "PRODID:-//PMI//PAUSE Einzeltermin v1.0//DE\r\n";
        $ics .= "CALSCALE:GREGORIAN\r\n";
        $ics .= "METHOD:PUBLISH\r\n";
        $ics .= "BEGIN:VTIMEZONE\r\n";
        $ics .= "TZID:Europe/Berlin\r\n";
        $ics .= "X-LIC-LOCATION:Europe/Berlin\r\n";
        $ics .= "BEGIN:DAYLIGHT\r\n";
        $ics .= "TZOFFSETFROM:+0100\r\n";
        $ics .= "TZOFFSETTO:+0200\r\n";
        $ics .= "TZNAME:CEST\r\n";
        $ics .= "DTSTART:19700329T020000\r\n";
        $ics .= "RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\n";
        $ics .= "END:DAYLIGHT\r\n";
        $ics .= "BEGIN:STANDARD\r\n";
        $ics .= "TZOFFSETFROM:+0200\r\n";
        $ics .= "TZOFFSETTO:+0100\r\n";
        $ics .= "TZNAME:CET\r\n";
        $ics .= "DTSTART:19701025T030000\r\n";
        $ics .= "RRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\n";
        $ics .= "END:STANDARD\r\n";
        $ics .= "END:VTIMEZONE\r\n";
        $nowUtc = gmdate('Ymd\THis\Z');
        $dtStart = $event['dtStart'];
        $dtEnd = $event['dtEnd'];
        $dtStartFormat = $event['dtStartFormat'] ?? 'Ymd\THis';
        $dtEndFormat = $event['dtEndFormat'] ?? 'Ymd\THis';
        $dtStartString = $dtStart->format($dtStartFormat);
        $dtEndString = $dtEnd->format($dtEndFormat);
        $datePrefix = ($dtStartFormat === 'Ymd') ? ';VALUE=DATE' : ';TZID=Europe/Berlin';
        if ($dtStartFormat === 'Ymd\THis' && $dtEndFormat === 'Ymd') {
             $dtEndString = $dtEnd->format('Ymd\THis');
        }
        $ics .= "BEGIN:VEVENT\r\n";
        $ics .= "UID:" . $event['uid'] . '-' . $dtStart->format('YmdHis') . "@pause.pmi\r\n";
        $ics .= "DTSTAMP:" . $nowUtc . "\r\n";
        $ics .= "DTSTART{$datePrefix}:" . $dtStartString . "\r\n";
        $ics .= "DTEND{$datePrefix}:" . $dtEndString . "\r\n";
        $ics .= "SUMMARY:" . $this->escapeIcsString($event['summary']) . "\r\n";
        if (!empty($event['location'])) {
            $ics .= "LOCATION:" . $this->escapeIcsString($event['location']) . "\r\n";
        }
        if (!empty($event['description'])) {
            $ics .= "DESCRIPTION:" . $this->escapeIcsString($event['description']) . "\r\n";
        }
        $ics .= "STATUS:" . $event['status'] . "\r\n";
        $ics .= ($dtStartFormat === 'Ymd') ? "TRANSP:TRANSPARENT\r\n" : "TRANSP:OPAQUE\r\n";
        $ics .= "END:VEVENT\r\n";
        $ics .= "END:VCALENDAR\r\n";
        return $ics;
    }
    private function escapeIcsString(?string $string): string
    {
        if ($string === null) return '';
        $string = str_replace('\\', '\\\\', $string);
        $string = str_replace(';', '\;', $string);
        $string = str_replace(',', '\,', $string);
        $string = str_replace("\r", '', $string); 
        $string = str_replace("\n", '\n', $string); 
        return $string;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Services\SingleIcalService.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Services\SystemHealthService.php ---
<?php
namespace App\Services;
use App\Core\Database;
use App\Core\Utils;
use PDO;
use Exception;
use PDOException; 
class SystemHealthService
{
    private string $projectRoot;
    private string $publicPath;
    public function __construct()
    {
        $this->projectRoot = dirname(__DIR__, 2);
        $this->publicPath = $this->projectRoot . '/public/';
    }
    public function performSystemChecks(): array
    {
        $checks = [];
        $dbStatus = $this->checkDbStatus();
        $checks['database'] = [
            'label' => 'Datenbank-Verbindung',
            'status' => $dbStatus['status'] === 'ok',
            'message' => $dbStatus['message'],
            'tooltip' => 'Die Verbindung zur MySQL-Datenbank.'
        ];
        $checks['config_file'] = [
            'label' => 'Konfigurationsdatei',
            'status' => true,
            'message' => 'Geladen', 
            'tooltip' => 'Datei: database_access.php'
        ];
        $extensions = $this->checkExtensions();
        foreach ($extensions as $ext => $status) {
             $checks['ext_' . $ext] = [
                'label' => 'PHP Extension: ' . $ext,
                'status' => $status,
                'message' => $status ? 'OK' : 'Fehlt!',
                'tooltip' => $status ? 'Erweiterung ist geladen.' : 'Erforderlich für Kernfunktionen.'
            ];
        }
        $directories = $this->checkDirectories();
        foreach ($directories as $name => $dir) {
             $checks[$name] = [
                'label' => 'Verzeichnis: ' . $name,
                'status' => $dir['status'] === 'ok',
                'message' => $dir['message'],
                'tooltip' => 'Pfad: ' . $dir['path_relative']
             ];
        }
        return $checks;
    }
    public function checkDbStatus(): array
    {
        try {
            $pdo = Database::getInstance();
            $pdo->query("SELECT 1");
            return ['status' => 'ok', 'message' => 'Verbunden (v' . $pdo->getAttribute(PDO::ATTR_SERVER_VERSION) . ')'];
        } catch (PDOException $e) {
            return ['status' => 'error', 'message' => 'Nicht verbunden'];
        }
    }
    public function checkExtensions(): array
    {
        $required = ['pdo_mysql', 'openssl', 'gd', 'mbstring', 'json', 'intl'];
        $status = [];
        foreach ($required as $ext) {
            $status[$ext] = extension_loaded($ext);
        }
        return $status;
    }
    public function checkDirectories(): array
    {
        $dirs = [
            'cache' => $this->projectRoot . '/cache',
            'uploads/announcements' => $this->publicPath . 'uploads/announcements',
            'uploads/branding' => $this->publicPath . 'uploads/branding'
        ];
        $status = [];
        foreach ($dirs as $name => $path) {
            $pathRelative = str_replace($this->projectRoot, '', $path); 
            $pathRelative = str_replace($this->publicPath, 'public/', $pathRelative);
            $pathRelative = str_replace('//', '/', $pathRelative);
            if (!is_dir($path)) {
                if (!@mkdir($path, 0775, true)) {
                     $status[$name] = [
                        'status' => 'error', 
                        'message' => 'Fehlt & Erstellen fehlgeschlagen',
                        'path_relative' => $pathRelative
                     ];
                } else {
                     $status[$name] = [
                        'status' => 'ok', 
                        'message' => 'OK (Erstellt)',
                        'path_relative' => $pathRelative
                     ];
                }
            } else {
                $testFile = rtrim($path, '/') . '/write_test.tmp';
                if (@file_put_contents($testFile, 'test') !== false) {
                    @unlink($testFile);
                    $status[$name] = [
                        'status' => 'ok', 
                        'message' => 'Beschreibbar',
                        'path_relative' => $pathRelative
                    ];
                } else {
                    $status[$name] = [
                        'status' => 'error', 
                        'message' => 'Nicht beschreibbar!',
                        'path_relative' => $pathRelative
                    ];
                }
            }
        }
        return $status;
    }
    public function getSystemInfo(): array
    {
         try {
            $pdo = Database::getInstance();
            $dbVersion = $pdo->getAttribute(PDO::ATTR_SERVER_VERSION);
         } catch (Exception $e) {
            $dbVersion = 'N/A';
         }
         return [
            'php' => phpversion(),
            'db' => $dbVersion,
            'webserver' => $_SERVER['SERVER_SOFTWARE'] ?? 'N/A'
         ];
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Services\SystemHealthService.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\config\database_access.php ---
<?php
return [
    'db_host'    => '127.0.0.1', 
    'db_port'    => 3306,
    'db_name'    => 'pause_db',
    'db_user'    => 'root',
    'db_pass'    => '', 
    'db_charset' => 'utf8mb4',
    'base_url'  => '/files/PAUSE/public',
];
--- END FILE: C:\xampp\htdocs\files\PAUSE\config\database_access.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\config\routes.php ---
<?php
use App\Http\Controllers\Auth\AuthController;
use App\Http\Controllers\DashboardController;
use App\Http\Controllers\Admin\DashboardController as AdminDashboardController;
use App\Http\Controllers\Admin\StammdatenController;
use App\Http\Controllers\Admin\UserController;
use App\Http\Controllers\Admin\AnnouncementController as AdminAnnouncementController;
use App\Http\Controllers\Admin\CsvTemplateController;
use App\Http\Controllers\Admin\AuditLogController;
use App\Http\Controllers\Admin\SettingsController;
use App\Http\Controllers\Admin\CommunityController as AdminCommunityController;
use App\Http\Controllers\Admin\SystemHealthController;
use App\Http\Controllers\Planer\PlanController;
use App\Http\Controllers\Planer\AbsenceController;
use App\Http\Controllers\AnnouncementController;
use App\Http\Controllers\CommunityController;
use App\Http\Controllers\IcalController;
use App\Http\Controllers\PdfController;
use App\Http\Controllers\TeacherController;
use App\Http\Controllers\AcademicEventController;
use App\Http\Controllers\SingleEventController;

return [
    // --- Auth & General ---
    '#^login$#' => [AuthController::class, 'showLogin'],
    '#^login/process$#' => [AuthController::class, 'handleLogin'],
    '#^logout$#' => [AuthController::class, 'logout'],
    '#^logout/revert$#' => [AuthController::class, 'revertImpersonation'],
    '#^$#' => [DashboardController::class, 'index'],
    '#^dashboard$#' => [DashboardController::class, 'index'],

    // --- Admin ---
    '#^admin/dashboard$#' => [AdminDashboardController::class, 'index'],
    '#^admin/users$#' => [UserController::class, 'index'],
    '#^admin/csv-template$#' => [CsvTemplateController::class, 'index'],
    '#^admin/stammdaten$#' => [StammdatenController::class, 'index'],
    '#^admin/announcements$#' => [AdminAnnouncementController::class, 'index'],
    '#^admin/audit-logs$#' => [AuditLogController::class, 'index'],
    '#^admin/system-health$#' => [SystemHealthController::class, 'index'],
    '#^admin/settings$#' => [SettingsController::class, 'index'],
    '#^admin/community-moderation$#' => [AdminCommunityController::class, 'index'],

    // --- Planer ---
    '#^planer/dashboard$#' => [PlanController::class, 'index'],
    '#^planer/absences$#' => [AbsenceController::class, 'index'],

    // --- Services (iCal, PDF, ICS) ---
    '#^ical/([a-f0-9]{64})$#' => [IcalController::class, 'generateFeed'],
    '#^ics/event/(\w+)/(\d+)$#' => [SingleEventController::class, 'generateIcs'],
    '#^pdf/timetable/(\d{4})/(\d{1,2})$#' => [PdfController::class, 'generateTimetablePdf'],

    // --- API: Admin ---
    '#^api/admin/subjects$#' => [StammdatenController::class, 'getSubjects'],
    '#^api/admin/subjects/create$#' => [StammdatenController::class, 'createSubject'],
    '#^api/admin/subjects/update$#' => [StammdatenController::class, 'updateSubject'],
    '#^api/admin/subjects/delete$#' => [StammdatenController::class, 'deleteSubject'],
    '#^api/admin/rooms$#' => [StammdatenController::class, 'getRooms'],
    '#^api/admin/rooms/create$#' => [StammdatenController::class, 'createRoom'],
    '#^api/admin/rooms/update$#' => [StammdatenController::class, 'updateRoom'],
    '#^api/admin/rooms/delete$#' => [StammdatenController::class, 'deleteRoom'],
    '#^api/admin/teachers$#' => [StammdatenController::class, 'getTeachers'],
    '#^api/admin/teachers/create$#' => [StammdatenController::class, 'createTeacher'],
    '#^api/admin/teachers/update$#' => [StammdatenController::class, 'updateTeacher'],
    '#^api/admin/teachers/delete$#' => [StammdatenController::class, 'deleteTeacher'],
    '#^api/admin/classes$#' => [StammdatenController::class, 'getClasses'],
    '#^api/admin/classes/create$#' => [StammdatenController::class, 'createClass'],
    '#^api/admin/classes/update$#' => [StammdatenController::class, 'updateClass'],
    '#^api/admin/classes/delete$#' => [StammdatenController::class, 'deleteClass'],
    '#^api/admin/users$#' => [UserController::class, 'getUsers'],
    '#^api/admin/users/create$#' => [UserController::class, 'createUser'],
    '#^api/admin/users/update$#' => [UserController::class, 'updateUser'],
    '#^api/admin/users/delete$#' => [UserController::class, 'deleteUser'],
    '#^api/admin/users/import$#' => [UserController::class, 'importUsers'],
    '#^api/admin/users/impersonate$#' => [UserController::class, 'impersonateUserApi'],
    '#^api/admin/audit-logs$#' => [AuditLogController::class, 'getLogsApi'],
    '#^api/admin/settings/save$#' => [SettingsController::class, 'save'],
    '#^api/admin/cache/clear$#' => [SettingsController::class, 'clearCacheApi'],
    '#^api/admin/community/approve$#' => [CommunityController::class, 'approvePostApi'],
    '#^api/admin/community/reject$#' => [CommunityController::class, 'rejectPostApi'],
    '#^api/admin/community/delete$#' => [CommunityController::class, 'deletePostApi'],

    // --- API: Planer ---
    '#^api/planer/data$#' => [PlanController::class, 'getTimetableData'],
    '#^api/planer/entry/save$#' => [PlanController::class, 'saveEntry'],
    '#^api/planer/entry/delete$#' => [PlanController::class, 'deleteEntry'],
    '#^api/planer/substitution/save$#' => [PlanController::class, 'saveSubstitution'],
    '#^api/planer/substitution/delete$#' => [PlanController::class, 'deleteSubstitution'],
    '#^api/planer/publish$#' => [PlanController::class, 'publish'],
    '#^api/planer/unpublish$#' => [PlanController::class, 'unpublish'],
    '#^api/planer/status$#' => [PlanController::class, 'getStatus'],
    '#^api/planer/check-conflicts$#' => [PlanController::class, 'checkConflictsApi'],
    '#^api/planer/copy-week$#' => [PlanController::class, 'copyWeek'],
    '#^api/planer/templates$#' => [PlanController::class, 'getTemplates'],
    '#^api/planer/templates/create$#' => [PlanController::class, 'createTemplate'],
    '#^api/planer/templates/apply$#' => [PlanController::class, 'applyTemplate'],
    '#^api/planer/templates/delete$#' => [PlanController::class, 'deleteTemplate'],
    '#^api/planer/templates/(\d+)$#' => [PlanController::class, 'getTemplateDetails'],
    '#^api/planer/templates/save$#' => [PlanController::class, 'saveTemplateDetails'],
    '#^api/planer/absences$#' => [AbsenceController::class, 'getAbsencesApi'],
    '#^api/planer/absences/save$#' => [AbsenceController::class, 'saveAbsenceApi'],
    '#^api/planer/absences/delete$#' => [AbsenceController::class, 'deleteAbsenceApi'],

    // --- API: Allgemein (Announcements, Community) ---
    '#^api/announcements$#' => [AnnouncementController::class, 'getAnnouncements'],
    '#^api/announcements/create$#' => [AnnouncementController::class, 'createAnnouncement'],
    '#^api/announcements/delete$#' => [AnnouncementController::class, 'deleteAnnouncement'],
    '#^api/community/posts$#' => [CommunityController::class, 'getPostsApi'],
    '#^api/community/posts/create$#' => [CommunityController::class, 'createPostApi'],
    '#^api/community/my-posts$#' => [CommunityController::class, 'getMyPostsApi'],
    '#^api/community/post/update$#' => [CommunityController::class, 'updatePostApi'],
    '#^api/community/post/delete$#' => [CommunityController::class, 'deletePostApi'],
    
    // --- API: Dashboard (Schüler/Lehrer) ---
    '#^api/dashboard/weekly-data$#' => [DashboardController::class, 'getWeeklyData'],
    '#^api/student/note/save$#' => [DashboardController::class, 'saveNoteApi'],
    '#^api/student/events$#' => [AcademicEventController::class, 'getForStudent'],
    '#^api/teacher/search-colleagues$#' => [TeacherController::class, 'searchColleaguesApi'],
    '#^api/teacher/find-colleague$#' => [TeacherController::class, 'findColleagueApi'],
    '#^api/teacher/current-lesson$#' => [TeacherController::class, 'getCurrentLessonWithStudentsApi'],
    '#^api/teacher/attendance/save$#' => [TeacherController::class, 'saveAttendanceApi'],
    '#^api/teacher/prerequisites$#' => [TeacherController::class, 'getPrerequisitesApi'],
    '#^api/teacher/events$#' => [AcademicEventController::class, 'getForTeacher'],
    '#^api/teacher/events/create$#' => [AcademicEventController::class, 'createOrUpdate'],
    '#^api/teacher/events/delete$#' => [AcademicEventController::class, 'delete'],
    
    // --- API: Sprechstunden (Lehrer & Schüler) ---
    '#^api/teacher/office-hours$#' => [TeacherController::class, 'getOfficeHoursApi'],
    '#^api/teacher/office-hours/save$#' => [TeacherController::class, 'saveOfficeHoursApi'],
    '#^api/teacher/office-hours/delete$#' => [TeacherController::class, 'deleteOfficeHoursApi'],
    '#^api/teacher/all-appointments$#' => [TeacherController::class, 'getAllAppointmentsApi'],
    '#^api/student/upcoming-slots$#' => [DashboardController::class, 'getUpcomingSlotsApi'], // NEU
    '#^api/student/book-appointment$#' => [DashboardController::class, 'bookAppointmentApi'],
    '#^api/appointment/cancel$#' => [DashboardController::class, 'cancelAppointmentApi'],
];
--- END FILE: C:\xampp\htdocs\files\PAUSE\config\routes.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\libs\Parsedown.php ---
<?php

#
#
# Parsedown
# http://parsedown.org
#
# (c) Emanuil Rusev
# http://erusev.com
#
# For the full license information, view the LICENSE file that was distributed
# with this source code.
#
#

class Parsedown
{
    # ~

    const version = '1.8.0';

    # ~

    function text($text)
    {
        $Elements = $this->textElements($text);

        # convert to markup
        $markup = $this->elements($Elements);

        # trim line breaks
        $markup = trim($markup, "\n");

        return $markup;
    }

    protected function textElements($text)
    {
        # make sure no definitions are set
        $this->DefinitionData = array();

        # standardize line breaks
        $text = str_replace(array("\r\n", "\r"), "\n", $text);

        # remove surrounding line breaks
        $text = trim($text, "\n");

        # split text into lines
        $lines = explode("\n", $text);

        # iterate through lines to identify blocks
        return $this->linesElements($lines);
    }

    #
    # Setters
    #

    function setBreaksEnabled($breaksEnabled)
    {
        $this->breaksEnabled = $breaksEnabled;

        return $this;
    }

    protected $breaksEnabled;

    function setMarkupEscaped($markupEscaped)
    {
        $this->markupEscaped = $markupEscaped;

        return $this;
    }

    protected $markupEscaped;

    function setUrlsLinked($urlsLinked)
    {
        $this->urlsLinked = $urlsLinked;

        return $this;
    }

    protected $urlsLinked = true;

    function setSafeMode($safeMode)
    {
        $this->safeMode = (bool) $safeMode;

        return $this;
    }

    protected $safeMode;

    function setStrictMode($strictMode)
    {
        $this->strictMode = (bool) $strictMode;

        return $this;
    }

    protected $strictMode;

    protected $safeLinksWhitelist = array(
        'http://',
        'https://',
        'ftp://',
        'ftps://',
        'mailto:',
        'tel:',
        'data:image/png;base64,',
        'data:image/gif;base64,',
        'data:image/jpeg;base64,',
        'irc:',
        'ircs:',
        'git:',
        'ssh:',
        'news:',
        'steam:',
    );

    #
    # Lines
    #

    protected $BlockTypes = array(
        '#' => array('Header'),
        '*' => array('Rule', 'List'),
        '+' => array('List'),
        '-' => array('SetextHeader', 'Table', 'Rule', 'List'),
        '0' => array('List'),
        '1' => array('List'),
        '2' => array('List'),
        '3' => array('List'),
        '4' => array('List'),
        '5' => array('List'),
        '6' => array('List'),
        '7' => array('List'),
        '8' => array('List'),
        '9' => array('List'),
        ':' => array('Table'),
        '<' => array('Comment', 'Markup'),
        '=' => array('SetextHeader'),
        '>' => array('Quote'),
        '[' => array('Reference'),
        '_' => array('Rule'),
        '`' => array('FencedCode'),
        '|' => array('Table'),
        '~' => array('FencedCode'),
    );

    # ~

    protected $unmarkedBlockTypes = array(
        'Code',
    );

    #
    # Blocks
    #

    protected function lines(array $lines)
    {
        return $this->elements($this->linesElements($lines));
    }

    protected function linesElements(array $lines)
    {
        $Elements = array();
        $CurrentBlock = null;

        foreach ($lines as $line)
        {
            if (chop($line) === '')
            {
                if (isset($CurrentBlock))
                {
                    $CurrentBlock['interrupted'] = (isset($CurrentBlock['interrupted'])
                        ? $CurrentBlock['interrupted'] + 1 : 1
                    );
                }

                continue;
            }

            while (($beforeTab = strstr($line, "\t", true)) !== false)
            {
                $shortage = 4 - mb_strlen($beforeTab, 'utf-8') % 4;

                $line = $beforeTab
                    . str_repeat(' ', $shortage)
                    . substr($line, strlen($beforeTab) + 1)
                ;
            }

            $indent = strspn($line, ' ');

            $text = $indent > 0 ? substr($line, $indent) : $line;

            # ~

            $Line = array('body' => $line, 'indent' => $indent, 'text' => $text);

            # ~

            if (isset($CurrentBlock['continuable']))
            {
                $methodName = 'block' . $CurrentBlock['type'] . 'Continue';
                $Block = $this->$methodName($Line, $CurrentBlock);

                if (isset($Block))
                {
                    $CurrentBlock = $Block;

                    continue;
                }
                else
                {
                    if ($this->isBlockCompletable($CurrentBlock['type']))
                    {
                        $methodName = 'block' . $CurrentBlock['type'] . 'Complete';
                        $CurrentBlock = $this->$methodName($CurrentBlock);
                    }
                }
            }

            # ~

            $marker = $text[0];

            # ~

            $blockTypes = $this->unmarkedBlockTypes;

            if (isset($this->BlockTypes[$marker]))
            {
                foreach ($this->BlockTypes[$marker] as $blockType)
                {
                    $blockTypes []= $blockType;
                }
            }

            #
            # ~

            foreach ($blockTypes as $blockType)
            {
                $Block = $this->{"block$blockType"}($Line, $CurrentBlock);

                if (isset($Block))
                {
                    $Block['type'] = $blockType;

                    if ( ! isset($Block['identified']))
                    {
                        if (isset($CurrentBlock))
                        {
                            $Elements[] = $this->extractElement($CurrentBlock);
                        }

                        $Block['identified'] = true;
                    }

                    if ($this->isBlockContinuable($blockType))
                    {
                        $Block['continuable'] = true;
                    }

                    $CurrentBlock = $Block;

                    continue 2;
                }
            }

            # ~

            if (isset($CurrentBlock) and $CurrentBlock['type'] === 'Paragraph')
            {
                $Block = $this->paragraphContinue($Line, $CurrentBlock);
            }

            if (isset($Block))
            {
                $CurrentBlock = $Block;
            }
            else
            {
                if (isset($CurrentBlock))
                {
                    $Elements[] = $this->extractElement($CurrentBlock);
                }

                $CurrentBlock = $this->paragraph($Line);

                $CurrentBlock['identified'] = true;
            }
        }

        # ~

        if (isset($CurrentBlock['continuable']) and $this->isBlockCompletable($CurrentBlock['type']))
        {
            $methodName = 'block' . $CurrentBlock['type'] . 'Complete';
            $CurrentBlock = $this->$methodName($CurrentBlock);
        }

        # ~

        if (isset($CurrentBlock))
        {
            $Elements[] = $this->extractElement($CurrentBlock);
        }

        # ~

        return $Elements;
    }

    protected function extractElement(array $Component)
    {
        if ( ! isset($Component['element']))
        {
            if (isset($Component['markup']))
            {
                $Component['element'] = array('rawHtml' => $Component['markup']);
            }
            elseif (isset($Component['hidden']))
            {
                $Component['element'] = array();
            }
        }

        return $Component['element'];
    }

    protected function isBlockContinuable($Type)
    {
        return method_exists($this, 'block' . $Type . 'Continue');
    }

    protected function isBlockCompletable($Type)
    {
        return method_exists($this, 'block' . $Type . 'Complete');
    }

    #
    # Code

    protected function blockCode($Line, $Block = null)
    {
        if (isset($Block) and $Block['type'] === 'Paragraph' and ! isset($Block['interrupted']))
        {
            return;
        }

        if ($Line['indent'] >= 4)
        {
            $text = substr($Line['body'], 4);

            $Block = array(
                'element' => array(
                    'name' => 'pre',
                    'element' => array(
                        'name' => 'code',
                        'text' => $text,
                    ),
                ),
            );

            return $Block;
        }
    }

    protected function blockCodeContinue($Line, $Block)
    {
        if ($Line['indent'] >= 4)
        {
            if (isset($Block['interrupted']))
            {
                $Block['element']['element']['text'] .= str_repeat("\n", $Block['interrupted']);

                unset($Block['interrupted']);
            }

            $Block['element']['element']['text'] .= "\n";

            $text = substr($Line['body'], 4);

            $Block['element']['element']['text'] .= $text;

            return $Block;
        }
    }

    protected function blockCodeComplete($Block)
    {
        return $Block;
    }

    #
    # Comment

    protected function blockComment($Line)
    {
        if ($this->markupEscaped or $this->safeMode)
        {
            return;
        }

        if (strpos($Line['text'], '<!--') === 0)
        {
            $Block = array(
                'element' => array(
                    'rawHtml' => $Line['body'],
                    'autobreak' => true,
                ),
            );

            if (strpos($Line['text'], '-->') !== false)
            {
                $Block['closed'] = true;
            }

            return $Block;
        }
    }

    protected function blockCommentContinue($Line, array $Block)
    {
        if (isset($Block['closed']))
        {
            return;
        }

        $Block['element']['rawHtml'] .= "\n" . $Line['body'];

        if (strpos($Line['text'], '-->') !== false)
        {
            $Block['closed'] = true;
        }

        return $Block;
    }

    #
    # Fenced Code

    protected function blockFencedCode($Line)
    {
        $marker = $Line['text'][0];

        $openerLength = strspn($Line['text'], $marker);

        if ($openerLength < 3)
        {
            return;
        }

        $infostring = trim(substr($Line['text'], $openerLength), "\t ");

        if (strpos($infostring, '`') !== false)
        {
            return;
        }

        $Element = array(
            'name' => 'code',
            'text' => '',
        );

        if ($infostring !== '')
        {
            /**
             * https://www.w3.org/TR/2011/WD-html5-20110525/elements.html#classes
             * Every HTML element may have a class attribute specified.
             * The attribute, if specified, must have a value that is a set
             * of space-separated tokens representing the various classes
             * that the element belongs to.
             * [...]
             * The space characters, for the purposes of this specification,
             * are U+0020 SPACE, U+0009 CHARACTER TABULATION (tab),
             * U+000A LINE FEED (LF), U+000C FORM FEED (FF), and
             * U+000D CARRIAGE RETURN (CR).
             */
            $language = substr($infostring, 0, strcspn($infostring, " \t\n\f\r"));

            $Element['attributes'] = array('class' => "language-$language");
        }

        $Block = array(
            'char' => $marker,
            'openerLength' => $openerLength,
            'element' => array(
                'name' => 'pre',
                'element' => $Element,
            ),
        );

        return $Block;
    }

    protected function blockFencedCodeContinue($Line, $Block)
    {
        if (isset($Block['complete']))
        {
            return;
        }

        if (isset($Block['interrupted']))
        {
            $Block['element']['element']['text'] .= str_repeat("\n", $Block['interrupted']);

            unset($Block['interrupted']);
        }

        if (($len = strspn($Line['text'], $Block['char'])) >= $Block['openerLength']
            and chop(substr($Line['text'], $len), ' ') === ''
        ) {
            $Block['element']['element']['text'] = substr($Block['element']['element']['text'], 1);

            $Block['complete'] = true;

            return $Block;
        }

        $Block['element']['element']['text'] .= "\n" . $Line['body'];

        return $Block;
    }

    protected function blockFencedCodeComplete($Block)
    {
        return $Block;
    }

    #
    # Header

    protected function blockHeader($Line)
    {
        $level = strspn($Line['text'], '#');

        if ($level > 6)
        {
            return;
        }

        $text = trim($Line['text'], '#');

        if ($this->strictMode and isset($text[0]) and $text[0] !== ' ')
        {
            return;
        }

        $text = trim($text, ' ');

        $Block = array(
            'element' => array(
                'name' => 'h' . $level,
                'handler' => array(
                    'function' => 'lineElements',
                    'argument' => $text,
                    'destination' => 'elements',
                )
            ),
        );

        return $Block;
    }

    #
    # List

    protected function blockList($Line, ?array $CurrentBlock = null)
    {
        list($name, $pattern) = $Line['text'][0] <= '-' ? array('ul', '[*+-]') : array('ol', '[0-9]{1,9}+[.\)]');

        if (preg_match('/^('.$pattern.'([ ]++|$))(.*+)/', $Line['text'], $matches))
        {
            $contentIndent = strlen($matches[2]);

            if ($contentIndent >= 5)
            {
                $contentIndent -= 1;
                $matches[1] = substr($matches[1], 0, -$contentIndent);
                $matches[3] = str_repeat(' ', $contentIndent) . $matches[3];
            }
            elseif ($contentIndent === 0)
            {
                $matches[1] .= ' ';
            }

            $markerWithoutWhitespace = strstr($matches[1], ' ', true);

            $Block = array(
                'indent' => $Line['indent'],
                'pattern' => $pattern,
                'data' => array(
                    'type' => $name,
                    'marker' => $matches[1],
                    'markerType' => ($name === 'ul' ? $markerWithoutWhitespace : substr($markerWithoutWhitespace, -1)),
                ),
                'element' => array(
                    'name' => $name,
                    'elements' => array(),
                ),
            );
            $Block['data']['markerTypeRegex'] = preg_quote($Block['data']['markerType'], '/');

            if ($name === 'ol')
            {
                $listStart = ltrim(strstr($matches[1], $Block['data']['markerType'], true), '0') ?: '0';

                if ($listStart !== '1')
                {
                    if (
                        isset($CurrentBlock)
                        and $CurrentBlock['type'] === 'Paragraph'
                        and ! isset($CurrentBlock['interrupted'])
                    ) {
                        return;
                    }

                    $Block['element']['attributes'] = array('start' => $listStart);
                }
            }

            $Block['li'] = array(
                'name' => 'li',
                'handler' => array(
                    'function' => 'li',
                    'argument' => !empty($matches[3]) ? array($matches[3]) : array(),
                    'destination' => 'elements'
                )
            );

            $Block['element']['elements'] []= & $Block['li'];

            return $Block;
        }
    }

    protected function blockListContinue($Line, array $Block)
    {
        if (isset($Block['interrupted']) and empty($Block['li']['handler']['argument']))
        {
            return null;
        }

        $requiredIndent = ($Block['indent'] + strlen($Block['data']['marker']));

        if ($Line['indent'] < $requiredIndent
            and (
                (
                    $Block['data']['type'] === 'ol'
                    and preg_match('/^[0-9]++'.$Block['data']['markerTypeRegex'].'(?:[ ]++(.*)|$)/', $Line['text'], $matches)
                ) or (
                    $Block['data']['type'] === 'ul'
                    and preg_match('/^'.$Block['data']['markerTypeRegex'].'(?:[ ]++(.*)|$)/', $Line['text'], $matches)
                )
            )
        ) {
            if (isset($Block['interrupted']))
            {
                $Block['li']['handler']['argument'] []= '';

                $Block['loose'] = true;

                unset($Block['interrupted']);
            }

            unset($Block['li']);

            $text = isset($matches[1]) ? $matches[1] : '';

            $Block['indent'] = $Line['indent'];

            $Block['li'] = array(
                'name' => 'li',
                'handler' => array(
                    'function' => 'li',
                    'argument' => array($text),
                    'destination' => 'elements'
                )
            );

            $Block['element']['elements'] []= & $Block['li'];

            return $Block;
        }
        elseif ($Line['indent'] < $requiredIndent and $this->blockList($Line))
        {
            return null;
        }

        if ($Line['text'][0] === '[' and $this->blockReference($Line))
        {
            return $Block;
        }

        if ($Line['indent'] >= $requiredIndent)
        {
            if (isset($Block['interrupted']))
            {
                $Block['li']['handler']['argument'] []= '';

                $Block['loose'] = true;

                unset($Block['interrupted']);
            }

            $text = substr($Line['body'], $requiredIndent);

            $Block['li']['handler']['argument'] []= $text;

            return $Block;
        }

        if ( ! isset($Block['interrupted']))
        {
            $text = preg_replace('/^[ ]{0,'.$requiredIndent.'}+/', '', $Line['body']);

            $Block['li']['handler']['argument'] []= $text;

            return $Block;
        }
    }

    protected function blockListComplete(array $Block)
    {
        if (isset($Block['loose']))
        {
            foreach ($Block['element']['elements'] as &$li)
            {
                if (end($li['handler']['argument']) !== '')
                {
                    $li['handler']['argument'] []= '';
                }
            }
        }

        return $Block;
    }

    #
    # Quote

    protected function blockQuote($Line)
    {
        if (preg_match('/^>[ ]?+(.*+)/', $Line['text'], $matches))
        {
            $Block = array(
                'element' => array(
                    'name' => 'blockquote',
                    'handler' => array(
                        'function' => 'linesElements',
                        'argument' => (array) $matches[1],
                        'destination' => 'elements',
                    )
                ),
            );

            return $Block;
        }
    }

    protected function blockQuoteContinue($Line, array $Block)
    {
        if (isset($Block['interrupted']))
        {
            return;
        }

        if ($Line['text'][0] === '>' and preg_match('/^>[ ]?+(.*+)/', $Line['text'], $matches))
        {
            $Block['element']['handler']['argument'] []= $matches[1];

            return $Block;
        }

        if ( ! isset($Block['interrupted']))
        {
            $Block['element']['handler']['argument'] []= $Line['text'];

            return $Block;
        }
    }

    #
    # Rule

    protected function blockRule($Line)
    {
        $marker = $Line['text'][0];

        if (substr_count($Line['text'], $marker) >= 3 and chop($Line['text'], " $marker") === '')
        {
            $Block = array(
                'element' => array(
                    'name' => 'hr',
                ),
            );

            return $Block;
        }
    }

    #
    # Setext

    protected function blockSetextHeader($Line, ?array $Block = null)
    {
        if ( ! isset($Block) or $Block['type'] !== 'Paragraph' or isset($Block['interrupted']))
        {
            return;
        }

        if ($Line['indent'] < 4 and chop(chop($Line['text'], ' '), $Line['text'][0]) === '')
        {
            $Block['element']['name'] = $Line['text'][0] === '=' ? 'h1' : 'h2';

            return $Block;
        }
    }

    #
    # Markup

    protected function blockMarkup($Line)
    {
        if ($this->markupEscaped or $this->safeMode)
        {
            return;
        }

        if (preg_match('/^<[\/]?+(\w*)(?:[ ]*+'.$this->regexHtmlAttribute.')*+[ ]*+(\/)?>/', $Line['text'], $matches))
        {
            $element = strtolower($matches[1]);

            if (in_array($element, $this->textLevelElements))
            {
                return;
            }

            $Block = array(
                'name' => $matches[1],
                'element' => array(
                    'rawHtml' => $Line['text'],
                    'autobreak' => true,
                ),
            );

            return $Block;
        }
    }

    protected function blockMarkupContinue($Line, array $Block)
    {
        if (isset($Block['closed']) or isset($Block['interrupted']))
        {
            return;
        }

        $Block['element']['rawHtml'] .= "\n" . $Line['body'];

        return $Block;
    }

    #
    # Reference

    protected function blockReference($Line)
    {
        if (strpos($Line['text'], ']') !== false
            and preg_match('/^\[(.+?)\]:[ ]*+<?(\S+?)>?(?:[ ]+["\'(](.+)["\')])?[ ]*+$/', $Line['text'], $matches)
        ) {
            $id = strtolower($matches[1]);

            $Data = array(
                'url' => $matches[2],
                'title' => isset($matches[3]) ? $matches[3] : null,
            );

            $this->DefinitionData['Reference'][$id] = $Data;

            $Block = array(
                'element' => array(),
            );

            return $Block;
        }
    }

    #
    # Table

    protected function blockTable($Line, ?array $Block = null)
    {
        if ( ! isset($Block) or $Block['type'] !== 'Paragraph' or isset($Block['interrupted']))
        {
            return;
        }

        if (
            strpos($Block['element']['handler']['argument'], '|') === false
            and strpos($Line['text'], '|') === false
            and strpos($Line['text'], ':') === false
            or strpos($Block['element']['handler']['argument'], "\n") !== false
        ) {
            return;
        }

        if (chop($Line['text'], ' -:|') !== '')
        {
            return;
        }

        $alignments = array();

        $divider = $Line['text'];

        $divider = trim($divider);
        $divider = trim($divider, '|');

        $dividerCells = explode('|', $divider);

        foreach ($dividerCells as $dividerCell)
        {
            $dividerCell = trim($dividerCell);

            if ($dividerCell === '')
            {
                return;
            }

            $alignment = null;

            if ($dividerCell[0] === ':')
            {
                $alignment = 'left';
            }

            if (substr($dividerCell, - 1) === ':')
            {
                $alignment = $alignment === 'left' ? 'center' : 'right';
            }

            $alignments []= $alignment;
        }

        # ~

        $HeaderElements = array();

        $header = $Block['element']['handler']['argument'];

        $header = trim($header);
        $header = trim($header, '|');

        $headerCells = explode('|', $header);

        if (count($headerCells) !== count($alignments))
        {
            return;
        }

        foreach ($headerCells as $index => $headerCell)
        {
            $headerCell = trim($headerCell);

            $HeaderElement = array(
                'name' => 'th',
                'handler' => array(
                    'function' => 'lineElements',
                    'argument' => $headerCell,
                    'destination' => 'elements',
                )
            );

            if (isset($alignments[$index]))
            {
                $alignment = $alignments[$index];

                $HeaderElement['attributes'] = array(
                    'style' => "text-align: $alignment;",
                );
            }

            $HeaderElements []= $HeaderElement;
        }

        # ~

        $Block = array(
            'alignments' => $alignments,
            'identified' => true,
            'element' => array(
                'name' => 'table',
                'elements' => array(),
            ),
        );

        $Block['element']['elements'] []= array(
            'name' => 'thead',
        );

        $Block['element']['elements'] []= array(
            'name' => 'tbody',
            'elements' => array(),
        );

        $Block['element']['elements'][0]['elements'] []= array(
            'name' => 'tr',
            'elements' => $HeaderElements,
        );

        return $Block;
    }

    protected function blockTableContinue($Line, array $Block)
    {
        if (isset($Block['interrupted']))
        {
            return;
        }

        if (count($Block['alignments']) === 1 or $Line['text'][0] === '|' or strpos($Line['text'], '|'))
        {
            $Elements = array();

            $row = $Line['text'];

            $row = trim($row);
            $row = trim($row, '|');

            preg_match_all('/(