--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Cache.php ---
<?php
// app/Core/Cache.php
// MODIFIZIERT: Logik zum Löschen des Caches hinzugefügt.

namespace App\Core; // KORRIGIERT: Namespace muss App\Core sein, nicht App

class Cache
{
    /**
     * Definiert das Cache-Verzeichnis.
     * Liegt im Root-Verzeichnis des Projekts.
     */
    private static function getCacheDir(): string
    {
        // __DIR__ ist app/Core
        // Wir wollen <projekt_root>/cache/
        return dirname(__DIR__, 2) . '/cache/';
    }

    /**
     * Löscht alle .cache-Dateien aus dem Cache-Verzeichnis.
     *
     * @return array [success (bool), message (string)]
     */
    public static function clearAll(): array
    {
        $cacheDir = self::getCacheDir();

        if (!is_dir($cacheDir)) {
            // Wenn das Verzeichnis nicht existiert, ist das kein Fehler,
            // es gibt einfach nichts zu tun.
            return ['success' => true, 'message' => 'Cache-Verzeichnis existiert nicht, nichts zu tun.'];
        }

        // Finde alle .cache Dateien
        $files = glob($cacheDir . '*.cache');
        $successCount = 0;
        $failCount = 0;

        if ($files === false) {
            // Fehler beim Lesen des Verzeichnisses
            error_log("Fehler beim Lesen des Cache-Verzeichnisses: " . $cacheDir);
            return ['success' => false, 'message' => 'Fehler beim Lesen des Cache-Verzeichnisses.'];
        }

        foreach ($files as $file) {
            if (is_file($file)) {
                if (@unlink($file)) { // @ unterdrückt Warnungen, falls Datei inzwischen weg ist
                    $successCount++;
                } else {
                    $failCount++;
                    error_log("Konnte Cache-Datei nicht löschen: " . $file);
                }
            }
        }

        if ($failCount > 0) {
            return [
                'success' => false,
                'message' => "Konnte $failCount von " . ($successCount + $failCount) . " Cache-Dateien nicht löschen. Details im Server-Log."
            ];
        }

        if ($successCount === 0) {
            return ['success' => true, 'message' => 'App-Cache war bereits leer.'];
        }

        return ['success' => true, 'message' => "Erfolgreich $successCount App-Cache-Datei(en) gelöscht."];
    }
    
    // Zukünftige Cache-Methoden (get, set, etc.) würden hier hinkommen
    // public static function get($key) { ... }
    // public static function set($key, $data, $ttl) { ... }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Cache.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Database.php ---
<?php
// app/Core/Database.php

namespace App\Core;

use PDO;
use PDOException;
use RuntimeException;

/**
 * Singleton-Klasse für die Datenbankverbindung.
 * Stellt sicher, dass nur eine PDO-Instanz pro Anfrage erstellt wird.
 */
class Database
{
    private static ?PDO $instance = null;
    private static array $config = [];

    // Private constructor and clone method to prevent multiple instances.
    private function __construct() {}
    private function __clone() {}

    /**
     * Loads the database configuration from the config file.
     * @return array The configuration array.
     */
    public static function getConfig(): array
    {
        if (empty(self::$config)) {
            self::$config = require __DIR__ . '/../../config/database_access.php';
        }
        return self::$config;
    }

    /**
     * Establishes and returns the single PDO database connection instance.
     * @return PDO The PDO instance.
     * @throws RuntimeException If the database connection fails.
     */
    public static function getInstance(): PDO
    {
        if (self::$instance === null) {
            $config = self::getConfig();
            
            $dsn = "mysql:host={$config['db_host']};port={$config['db_port']};dbname={$config['db_name']};charset={$config['db_charset']}";

            // PDO connection options.
            $options = [
                PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
                PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                // WICHTIGE ÄNDERUNG:
                // Das Setzen von EMULATE_PREPARES auf 'true' umgeht einen bekannten Bug in einigen
                // PDO-MySQL-Treibern, der den Fehler 'SQLSTATE[HY093]: Invalid parameter number'
                // verursacht, obwohl der PHP-Code und die SQL-Syntax korrekt sind.
                PDO::ATTR_EMULATE_PREPARES   => true,
            ];

            try {
                self::$instance = new PDO($dsn, $config['db_user'], $config['db_pass'], $options);
            } catch (PDOException $e) {
                // Prevents leaking sensitive connection details in a production environment.
                error_log("Database connection error: " . $e->getMessage());
                throw new RuntimeException("Database connection could not be established.");
            }
        }

        return self::$instance;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Database.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Router.php ---
<?php
// app/Core/Router.php

namespace App\Core;

class Router
{
    private array $routes = [];

    public function add(string $pattern, $handler): void
    {
        $this->routes[$pattern] = $handler;
    }

    public function resolve(string $uri): ?array
    {
        foreach ($this->routes as $pattern => $handler) {
            if (preg_match($pattern, $uri, $matches)) {
                array_shift($matches); // Entfernt den kompletten Match
                return [
                    'handler' => $handler,
                    'matches' => $matches
                ];
            }
        }
        return null;
    }
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Router.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Security.php ---
<?php
// app/Core/Security.php
namespace App\Core;

use Exception; // Added

class Security
{
    /**
     * Stellt sicher, dass ein Benutzer angemeldet ist.
     * Leitet andernfalls zur Login-Seite weiter.
     */
    public static function requireLogin(): void
    {
        if (!isset($_SESSION['user_id'])) {
            header("Location: " . Utils::url('login'));
            exit();
        }
    }

    /**
     * Stellt sicher, dass ein Benutzer eine bestimmte Rolle hat.
     *
     * @param string|array $requiredRoles Die erforderliche Rolle oder ein Array von Rollen.
     */
    public static function requireRole($requiredRoles): void
    {
        self::requireLogin();

        if (!is_array($requiredRoles)) {
            $requiredRoles = [$requiredRoles];
        }

        $userRole = $_SESSION['user_role'] ?? '';

        if (!in_array($userRole, $requiredRoles)) {
            // Optional: Weiterleitung zu einer "Zugriff verweigert"-Seite
            http_response_code(403);
            // Include a more user-friendly error page/message in production
            die("Zugriff verweigert. Sie haben nicht die erforderliche Rolle (" . htmlspecialchars($userRole) . "). Benötigt: " . implode(', ', $requiredRoles));
        }
    }

    /**
     * Generiert ein CSRF-Token, speichert es in der Session und gibt es zurück.
     * Wenn bereits ein Token in der Session existiert, wird dieses zurückgegeben.
     * @return string Das CSRF-Token.
     */
    public static function getCsrfToken(): string
    {
        // Renamed from generateCsrfToken for consistency, kept the logic
        if (empty($_SESSION['csrf_token'])) {
            $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
        }
        return $_SESSION['csrf_token'];
    }

    /**
     * Verifiziert das übermittelte CSRF-Token gegen das in der Session gespeicherte.
     * Wird für POST-Requests und AJAX-Anfragen mit Header verwendet.
     * @throws Exception Wenn das Token ungültig oder nicht vorhanden ist.
     */
    public static function verifyCsrfToken(): void
    {
        // Renamed from validateCsrfToken
        // Check both POST data and potential AJAX header
        $submittedToken = $_POST['_csrf_token'] ?? $_SERVER['HTTP_X_CSRF_TOKEN'] ?? null;
        $sessionToken = $_SESSION['csrf_token'] ?? null;

        if (!$submittedToken || !$sessionToken || !hash_equals($sessionToken, $submittedToken)) {
             http_response_code(403); // Forbidden
             // Log this attempt for security monitoring
             error_log("CSRF token validation failed. Submitted: " . ($submittedToken ?? 'NULL') . ", Session: " . ($sessionToken ?? 'NULL') . ", IP: " . ($_SERVER['REMOTE_ADDR'] ?? 'UNKNOWN'));

            // Provide appropriate response based on request type
             if (!empty($_SERVER['HTTP_X_REQUESTED_WITH']) && strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) == 'xmlhttprequest') {
                 // AJAX request
                 header('Content-Type: application/json');
                 // Throwing exception might be better handled by a global error handler
                 // echo json_encode(['success' => false, 'message' => 'Ungültiges CSRF-Token. Bitte laden Sie die Seite neu.']);
                 // exit();
                 throw new Exception("Sicherheitsüberprüfung fehlgeschlagen (CSRF-Token ungültig oder fehlt).");

             } else {
                 // Standard form submission
                 // In production, show a user-friendly error page instead of die()
                 // die('Fehler: Ungültiges Sicherheitstoken. Bitte versuchen Sie es erneut.');
                 throw new Exception("Sicherheitsüberprüfung fehlgeschlagen (CSRF). Bitte gehen Sie zurück und versuchen Sie es erneut.");
             }
        }
         // Optional: Consider regenerating the token after successful validation for one-time use tokens,
         // but this can cause issues with multiple tabs or back button usage.
         // unset($_SESSION['csrf_token']); // Remove if implementing one-time tokens
    }


    /**
     * Gibt das HTML für das versteckte CSRF-Input-Feld aus.
     * Ruft intern getCsrfToken auf, um sicherzustellen, dass ein Token existiert.
     */
    public static function csrfInput(): void
    {
        echo '<input type="hidden" name="_csrf_token" value="' . htmlspecialchars(self::getCsrfToken()) . '">';
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Security.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Utils.php ---
<?php

namespace App\Core;

use App\Repositories\SettingsRepository; // NEU: Importiere SettingsRepository
use Exception; // NEU: Importiere Exception

class Utils
{
    private static ?array $settingsCache = null; // NEU: Cache für Einstellungen

    /**
     * Generiert eine saubere, SEO-freundliche URL, die vom .htaccess-Router verarbeitet wird.
     * @param string $path Der interne Pfad (z.B. 'profil' oder 'admin/users').
     * @return string Die vollständige, funktionierende URL.
     */
    public static function url(string $path): string
    {
        // Holt die Basis-URL aus der Konfiguration.
        // Diese sollte auf den öffentlichen Ordner zeigen, z.B. '/files/PAUSE/public'.
        $base_url = rtrim(Database::getConfig()['base_url'], '/');

        // Wenn der Pfad leer ist oder nur aus einem / besteht, verlinke zur Startseite.
        if (empty($path) || $path === '/') {
            return $base_url . '/';
        }

        // Hängt den internen Pfad an die Basis-URL an.
        // z.B. wird aus 'login/process' -> '/files/PAUSE/public/login/process'
        return $base_url . '/' . ltrim($path, '/');
    }

    /**
     * Holt die Einstellungen.
     * Versucht zuerst, aus der DB zu laden, und verwendet Standardwerte als Fallback.
     * Ergebnisse werden für die Dauer des Requests zwischengespeichert.
     * @return array
     */
    public static function getSettings(): array
    {
        // Prüfe, ob Einstellungen bereits im Cache liegen
        if (self::$settingsCache !== null) {
            return self::$settingsCache;
        }

        // 1. Definiere Standardwerte
        $defaultSettings = [
            'site_title' => 'PAUSE Portal',
            'maintenance_mode' => '0', // Standardwert für Wartungsmodus
            'maintenance_message' => 'Die Anwendung wird gerade gewartet. Bitte versuchen Sie es später erneut.',
            'maintenance_whitelist_ips' => "127.0.0.1, ::1", // IP Whitelist als String
            'default_start_hour' => 1,
            'default_end_hour' => 10,
            'max_login_attempts' => 5,
            'lockout_minutes' => 15,
            'site_logo_path' => null,
            'site_favicon_path' => null,
            'default_theme' => 'light',
            'ical_enabled' => '1',
            'ical_weeks_future' => 8,
            'pdf_footer_text' => 'PAUSE Portal - PMI - Ein Produkt des PMI.',
            'community_board_enabled' => '1', // NEU: Standardmäßig aktiviert
        ];

        // 2. Lade Einstellungen aus der Datenbank
        try {
            $settingsRepo = new SettingsRepository();
            $dbSettings = $settingsRepo->loadSettings();
        } catch (Exception $e) {
            // Fährt fort, wenn DB-Tabelle (z.B. bei Erstinstallation) noch nicht existiert
            error_log("Hinweis: Konnte Einstellungen nicht aus der DB laden, verwende Standardwerte. Fehler: " . $e->getMessage());
            $dbSettings = [];
        }

        // 3. Überschreibe Standardwerte mit den Werten aus der Datenbank
        // (DB hat Vorrang)
        $finalSettings = array_merge($defaultSettings, $dbSettings);

        // 4. Typkonvertierung (DB speichert alles als String)
        $finalSettings['maintenance_mode'] = (($finalSettings['maintenance_mode'] ?? '0') === '1' || ($finalSettings['maintenance_mode'] ?? false) === true);
        $finalSettings['default_start_hour'] = (int)($finalSettings['default_start_hour'] ?? 1);
        $finalSettings['default_end_hour'] = (int)($finalSettings['default_end_hour'] ?? 10);
        $finalSettings['max_login_attempts'] = (int)($finalSettings['max_login_attempts'] ?? 5);
        $finalSettings['lockout_minutes'] = (int)($finalSettings['lockout_minutes'] ?? 15);
        $finalSettings['ical_enabled'] = (($finalSettings['ical_enabled'] ?? '1') === '1' || ($finalSettings['ical_enabled'] ?? false) === true);
        $finalSettings['ical_weeks_future'] = (int)($finalSettings['ical_weeks_future'] ?? 8);
        // NEU: Konvertierung für Community Board
        $finalSettings['community_board_enabled'] = (($finalSettings['community_board_enabled'] ?? '1') === '1' || ($finalSettings['community_board_enabled'] ?? false) === true);
        // maintenance_whitelist_ips bleibt ein String

        // 5. Im Cache speichern und zurückgeben
        self::$settingsCache = $finalSettings;
        return $finalSettings;
    }

    /**
     * NEU: Löscht den Einstellungs-Cache.
     * Wird nach dem Speichern von Einstellungen aufgerufen.
     */
    public static function clearSettingsCache(): void
    {
        self::$settingsCache = null;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Core\Utils.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\AnnouncementController.php ---
<?php
// app/Http/Controllers/Admin/AnnouncementController.php

namespace App\Http\Controllers\Admin;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\AnnouncementRepository;
use App\Repositories\StammdatenRepository;
use App\Repositories\UserRepository;
use Exception;
use PDO;
use \Parsedown; // KORREKTUR: Parsedown aus dem globalen Namespace importieren

class AnnouncementController
{
    private PDO $pdo;
    private AnnouncementRepository $announcementRepo;
    private StammdatenRepository $stammdatenRepo;
    private UserRepository $userRepo;
    private Parsedown $parsedown; // KORREKTUR: Typehint kann jetzt ohne Backslash sein

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->announcementRepo = new AnnouncementRepository($this->pdo);
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
        $this->parsedown = new Parsedown(); // KORREKTUR: Kann jetzt direkt verwendet werden
        $this->parsedown->setSafeMode(true); 
    }

    /**
     * Zeigt die Hauptseite für die Ankündigungsverwaltung an.
     * Stellt Daten für das Formular bereit (Klassenliste).
     */
    public function index()
    {
        Security::requireRole(['admin', 'planer', 'lehrer']);
        global $config;
        $config = Database::getConfig();

        $page_title = 'Ankündigungsverwaltung';
        $body_class = 'admin-dashboard-body';

        try {
             $userRole = $_SESSION['user_role'] ?? 'Unbekannt';
             $userId = $_SESSION['user_id'] ?? null;
             $user = $userId ? $this->userRepo->findById($userId) : null;
             $allAnnouncements = $this->announcementRepo->getAllAnnouncementsWithDetails();
             $availableClasses = [];
             if (in_array($userRole, ['admin', 'planer'])) {
                 $availableClasses = $this->stammdatenRepo->getClasses();
             } elseif ($userRole === 'lehrer' && $user && isset($user['teacher_id'])) {
                 $availableClasses = $this->stammdatenRepo->getClasses(); // TODO: Ggf. auf Lehrer-Klassen einschränken
             }

             // Convert content to HTML and add file URL
             foreach ($allAnnouncements as &$announcement) {
                 // Convert Markdown content to safe HTML
                 $announcement['content_html'] = $this->parsedown->text($announcement['content'] ?? '');

                 // Add file URL
                if (!empty($announcement['file_path'])) {
                    $announcement['file_url'] = rtrim($config['base_url'], '/') . '/' . ltrim($announcement['file_path'], '/');
                } else {
                    $announcement['file_url'] = null;
                }
             }
             unset($announcement); // Break reference


            Security::getCsrfToken();
            include_once dirname(__DIR__, 4) .'/pages/admin/announcements.php';

        } catch (Exception $e) {
             error_log("Error loading announcement admin page: " . $e->getMessage());
             http_response_code(500);
             die("Ein Fehler ist beim Laden der Seite aufgetreten: " . $e->getMessage());
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\AnnouncementController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\AuditLogController.php ---
<?php
// app/Http/Controllers/Admin/AuditLogController.php

namespace App\Http\Controllers\Admin;

use App\Core\Security;
use App\Core\Database;
use App\Repositories\AuditLogRepository;
use App\Repositories\UserRepository; // Wichtig
use PDO;
use Exception;

class AuditLogController
{
    private PDO $pdo;
    private AuditLogRepository $logRepo;
    private UserRepository $userRepo; // Wichtig

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->logRepo = new AuditLogRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo); // Wichtig
    }

    /**
     * Zeigt die Hauptseite des Audit-Logs an.
     * Lädt Filter-Optionen.
     */
    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();

        $page_title = 'Audit Log (Protokoll)';
        $body_class = 'admin-dashboard-body';

        try {
            // Lade Filter-Daten
            // KORREKTUR: Variablennamen auf camelCase geändert, um den View-Fehler (Warning) zu beheben
            $availableUsers = $this->userRepo->getAll(); // Holt alle Benutzer
            $availableActions = $this->logRepo->getDistinctActions();
            $availableTargetTypes = $this->logRepo->getDistinctTargetTypes();

            include_once dirname(__DIR__, 4) .'/pages/admin/audit_logs.php';
        } catch (Exception $e) {
            error_log("Fehler beim Laden der Audit-Log-Seite: " . $e->getMessage());
            // This is likely where the 500 error page is generated
            http_response_code(500);
            die("Ein kritischer Fehler ist aufgetreten: " . $e->getMessage());
        }
    }

    /**
     * API-Endpunkt zum Abrufen von Log-Daten.
     */
    public function getLogsApi()
    {
        Security::requireRole('admin');
        header('Content-Type: application/json');

        try {
            $page = filter_input(INPUT_GET, 'page', FILTER_VALIDATE_INT, ['options' => ['default' => 1, 'min_range' => 1]]);
            $limit = 20; // Festgelegt

            // KORREKTUR: Verwende FILTER_UNSAFE_RAW (oder lasse Filter für Strings weg, da sie in WHERE-Klauseln verwendet werden)
            // Statt FILTER_SANITIZE_STRING (veraltet/entfernt)
            $filters = [
                'user_id' => filter_input(INPUT_GET, 'user_id', FILTER_VALIDATE_INT) ?: null,
                'action' => filter_input(INPUT_GET, 'action', FILTER_UNSAFE_RAW) ?: null,
                'target_type' => filter_input(INPUT_GET, 'target_type', FILTER_UNSAFE_RAW) ?: null,
                'start_date' => filter_input(INPUT_GET, 'start_date', FILTER_UNSAFE_RAW) ?: null,
                'end_date' => filter_input(INPUT_GET, 'end_date', FILTER_UNSAFE_RAW) ?: null,
            ];
            
            // Entferne leere Filter-Werte
            $filters = array_filter($filters, function($value) {
                return $value !== null && $value !== '';
            }); 

            $logs = $this->logRepo->getLogs($page, $limit, $filters);
            $totalCount = $this->logRepo->getLogsCount($filters);
            $totalPages = ceil($totalCount / $limit);

            echo json_encode([
                'success' => true,
                'logs' => $logs,
                'pagination' => [
                    'currentPage' => $page,
                    'totalPages' => $totalPages,
                    'totalCount' => $totalCount,
                    'limit' => $limit
                ]
            ], JSON_THROW_ON_ERROR); // JSON_THROW_ON_ERROR hilft bei Debugging

        } catch (Exception $e) {
            http_response_code(500);
            // Dies ist der Fehler, den JS empfängt
            error_log("AuditLog API Error: " . $e->getMessage() . "\n" . $e->getTraceAsString()); // Logge den echten PHP-Fehler
            echo json_encode(['success' => false, 'message' => 'Serverfehler beim Abrufen der Logs: ' . $e->getMessage()]);
        }
        exit;
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\AuditLogController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\CommunityController.php ---
<?php
// app/Http/Controllers/Admin/CommunityController.php

namespace App\Http\Controllers\Admin;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\CommunityPostRepository;
use Exception;
use PDO;
use \Parsedown; // KORREKTUR: Parsedown aus dem globalen Namespace importieren

class CommunityController
{
    private PDO $pdo;
    private CommunityPostRepository $postRepo;
    private Parsedown $parsedown; // KORREKTUR: Typehint kann jetzt ohne Backslash sein

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->postRepo = new CommunityPostRepository($this->pdo);
        $this->parsedown = new Parsedown(); // KORREKTUR: Kann jetzt direkt verwendet werden
        $this->parsedown->setSafeMode(true);
    }

    /**
     * Zeigt die Hauptseite für die Moderation des Schwarzen Bretts an.
     * NEU: Lädt jetzt ausstehende UND freigegebene Beiträge.
     */
    public function index()
    {
        Security::requireRole(['admin', 'planer']); // Nur Admins/Planer dürfen moderieren
        global $config;
        $config = Database::getConfig();

        $page_title = 'Moderation Schwarzes Brett';
        $body_class = 'admin-dashboard-body';

        try {
            // Lade alle ausstehenden Beiträge
            $pendingPosts = $this->postRepo->getPostsByStatus('pending');
            
            // Konvertiere Markdown zu HTML für die Vorschau
            foreach ($pendingPosts as &$post) {
                $post['content_html'] = $this->parsedown->text($post['content'] ?? '');
            }
            unset($post); // Referenz aufheben

            // NEU: Lade alle freigegebenen Beiträge
            $approvedPosts = $this->postRepo->getPostsByStatus('approved');
            
            // Konvertiere Markdown zu HTML für die Vorschau
            foreach ($approvedPosts as &$post) {
                $post['content_html'] = $this->parsedown->text($post['content'] ?? '');
            }
            unset($post); // Referenz aufheben


            Security::getCsrfToken();
            include_once dirname(__DIR__, 4) .'/pages/admin/community_moderation.php';

        } catch (Exception $e) {
            error_log("Fehler beim Laden der Moderationsseite: " . $e->getMessage());
            http_response_code(500);
            die("Ein Fehler ist beim Laden der Seite aufgetreten: " . $e->getMessage());
        }
    }
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\CommunityController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\CsvTemplateController.php ---
<?php
// app/Http/Controllers/Admin/CsvTemplateController.php

namespace App\Http\Controllers\Admin;

use App\Core\Security;
use App\Core\Database;
use Exception;

class CsvTemplateController
{
    /**
     * Zeigt die Seite mit der CSV-Importvorlage an.
     */
    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();

        $page_title = 'CSV Importvorlage';
        $body_class = 'admin-dashboard-body';
        
        $templateData = $this->loadCsvTemplate();

        // Übergibt $templateData (Header und Zeilen) an die View
        include_once dirname(__DIR__, 4) . '/pages/admin/csv_template.php';
    }

    /**
     * Lädt die CSV-Vorlagendatei und parst sie.
     * @return array Ein Array mit 'headers' (array) und 'rows' (array of arrays).
     */
    private function loadCsvTemplate(): array
    {
        $templatePath = dirname(__DIR__, 4) . '/public/assets/templates/user_import_template.csv';
        $csvData = [
            'headers' => [],
            'rows' => []
        ];

        if (!file_exists($templatePath)) {
            // Zeigt einen Fehler an, wenn die Vorlagendatei fehlt
            $csvData['error'] = "Vorlagendatei nicht gefunden unter: " . htmlspecialchars($templatePath);
            return $csvData;
        }

        if (($handle = fopen($templatePath, "r")) !== FALSE) {
            // Lese Header
            if (($headers = fgetcsv($handle, 1000, ",")) !== FALSE) {
                $csvData['headers'] = $headers;
            }
            // Lese Beispielzeilen
            while (($data = fgetcsv($handle, 1000, ",")) !== FALSE) {
                $csvData['rows'][] = $data;
            }
            fclose($handle);
        } else {
             $csvData['error'] = "Vorlagendatei konnte nicht gelesen werden.";
        }

        return $csvData;
    }
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\CsvTemplateController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\DashboardController.php ---
<?php
// app/Http/Controllers/Admin/DashboardController.php
namespace App\Http\Controllers\Admin;

use App\Core\Security;
use App\Core\Database;
use App\Core\Utils;
use App\Repositories\UserRepository;
use App\Repositories\StammdatenRepository;
use App\Repositories\AuditLogRepository;
use App\Repositories\PlanRepository;
use PDO;
use Exception;
use DateTime;

class DashboardController
{
    private PDO $pdo;
    private UserRepository $userRepo;
    private StammdatenRepository $stammdatenRepo;
    private AuditLogRepository $auditRepo;
    private PlanRepository $planRepo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->userRepo = new UserRepository($this->pdo);
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
        $this->auditRepo = new AuditLogRepository($this->pdo);
        $this->planRepo = new PlanRepository($this->pdo);
    }

    /**
     * NEU: Private Hilfsfunktion für System-Checks
     * KORRIGIERT: Labels gekürzt und Tooltips hinzugefügt.
     */
    private function performSystemChecks(): array
    {
        $checks = [];
        $basePublicDir = dirname(__DIR__, 4) . '/public/';

        // 1. Datenbankverbindung
        $checks['database'] = [
            'label' => 'Datenbank-Verbindung',
            'status' => true,
            'message' => 'OK',
            'tooltip' => 'Die Verbindung zur MySQL-Datenbank ist aktiv.'
        ];

        // 2. Konfigurationsdatei-Check
        $checks['config_file'] = [
            'label' => 'Konfigurationsdatei',
            'status' => true,
            'message' => 'OK',
            'tooltip' => 'Datei: database_access.php (Geladen)'
        ];
        
        // 3. PHP Extension: PDO MySQL
        $checks['ext_pdo_mysql'] = [
            'label' => 'PHP Extension: pdo_mysql',
            'status' => extension_loaded('pdo_mysql'),
            'message' => extension_loaded('pdo_mysql') ? 'OK' : 'Fehlt!', // Gekürzt
            'tooltip' => extension_loaded('pdo_mysql') ? 'Erweiterung ist geladen.' : 'Erforderlich für die Datenbankverbindung.'
        ];
        
        // 4. PHP Extension: GD
        $checks['ext_gd'] = [
            'label' => 'PHP Extension: GD',
            'status' => extension_loaded('gd'),
            'message' => extension_loaded('gd') ? 'OK' : 'Optional', // Gekürzt
            'tooltip' => extension_loaded('gd') ? 'Erweiterung ist geladen.' : 'Optional (wird für zukünftige Bildverarbeitung genutzt).'
        ];

        // 5. Upload-Verzeichnisse prüfen
        $uploadDirs = [
            'upload_dir_announcements' => 'uploads/announcements/',
            'upload_dir_branding' => 'uploads/branding/'
        ];

        foreach ($uploadDirs as $key => $dir) {
            $fullPath = $basePublicDir . $dir;
            $label = 'Verzeichnis: ' . basename($dir); // Gekürztes Label
            $tooltip = 'Pfad: ' . $dir; // Voller Pfad im Tooltip

            if (!is_dir($fullPath)) {
                // Versuche, das Verzeichnis zu erstellen
                if (!@mkdir($fullPath, 0775, true)) {
                     $checks[$key] = [
                        'label' => $label,
                        'status' => false,
                        'message' => 'Fehler (Erstellen)',
                        'tooltip' => $tooltip . ' - Nicht gefunden & konnte nicht erstellt werden.'
                     ];
                } else {
                     $checks[$key] = [
                        'label' => $label,
                        'status' => true,
                        'message' => 'OK',
                        'tooltip' => $tooltip . ' (OK, wurde gerade erstellt)'
                     ];
                }
            } else {
                // Verzeichnis existiert, teste Schreibzugriff
                $testFile = $fullPath . 'write_test_' . uniqid() . '.tmp';
                if (@file_put_contents($testFile, 'test') !== false) {
                    @unlink($testFile);
                    $checks[$key] = [
                        'label' => $label,
                        'status' => true,
                        'message' => 'OK',
                        'tooltip' => $tooltip . ' (Beschreibbar)'
                    ];
                } else {
                    $checks[$key] = [
                        'label' => $label,
                        'status' => false,
                        'message' => 'Fehler (Schreibrechte)',
                        'tooltip' => $tooltip . ' - Nicht beschreibbar! (Berechtigungen prüfen)'
                    ];
                }
            }
        }
        
        return $checks;
    }


    public function index()
    {
        // Stellt sicher, dass nur Admins auf diese Seite zugreifen können.
        Security::requireRole('admin');

        global $config; // Wird für die Basis-URL in den Views benötigt.
        $config = Database::getConfig();

        $page_title = 'Admin Dashboard';
        $body_class = 'admin-dashboard-body'; // Spezifische Klasse für Admin-Styling

        // --- NEU: Daten für das Dashboard laden ---
        $dashboardData = [];
        try {
            // Statistiken
            $dashboardData['userCounts'] = $this->userRepo->countUsersByRole();
            $dashboardData['totalUsers'] = array_sum($dashboardData['userCounts']);
            $dashboardData['classCount'] = $this->stammdatenRepo->countClasses();
            $dashboardData['teacherCount'] = $this->stammdatenRepo->countTeachers();
            $dashboardData['subjectCount'] = $this->stammdatenRepo->countSubjects();
            $dashboardData['roomCount'] = $this->stammdatenRepo->countRooms();

            // Letzte Audit-Logs (z.B. die letzten 5)
            $dashboardData['latestLogs'] = $this->auditRepo->getLogs(1, 5); // Seite 1, Limit 5

            // Aktuelle Einstellungen (für Wartungsmodus-Schalter)
            $dashboardData['settings'] = Utils::getSettings();

            // NEU: System-Infos
            $dashboardData['systemInfo']['php'] = phpversion();
            $dashboardData['systemInfo']['db'] = $this->pdo->getAttribute(PDO::ATTR_SERVER_VERSION);
            $dashboardData['systemInfo']['webserver'] = $_SERVER['SERVER_SOFTWARE'] ?? 'N/A';
            
            // NEU: System-Checks
            $dashboardData['systemChecks'] = $this->performSystemChecks();

            // NEU: Veröffentlichungsstatus
            $currentYear = (int)date('o');
            $currentWeek = (int)date('W');
            $nextWeekDate = new DateTime('+1 week');
            $nextYear = (int)$nextWeekDate->format('o');
            $nextWeek = (int)$nextWeekDate->format('W');
            
            $dashboardData['publishStatus']['currentWeekNum'] = $currentWeek;
            $dashboardData['publishStatus']['nextWeekNum'] = $nextWeek;
            $dashboardData['publishStatus']['current'] = $this->planRepo->getPublishStatus($currentYear, $currentWeek);
            $dashboardData['publishStatus']['next'] = $this->planRepo->getPublishStatus($nextYear, $nextWeek);


        } catch (Exception $e) {
            error_log("Fehler beim Laden der Admin-Dashboard-Daten: " . $e->getMessage());
            // Setze leere Werte, um Fehler in der View zu vermeiden
            $dashboardData['userCounts'] = [];
            $dashboardData['totalUsers'] = 0;
            $dashboardData['classCount'] = 0;
            $dashboardData['teacherCount'] = 0;
            $dashboardData['subjectCount'] = 0;
            $dashboardData['roomCount'] = 0;
            $dashboardData['latestLogs'] = [];
            $dashboardData['settings'] = Utils::getSettings(); // Lade zumindest Standardeinstellungen
            $dashboardData['systemInfo'] = ['php' => 'N/A', 'db' => 'N/A', 'webserver' => 'N/A'];
            $dashboardData['systemChecks'] = []; // Leere Checks bei Fehler
            $dashboardData['publishStatus'] = ['current' => [], 'next' => [], 'currentWeekNum' => (int)date('W'), 'nextWeekNum' => (int)(new DateTime('+1 week'))->format('W')];
            // Optional: Zeige eine Fehlermeldung auf dem Dashboard an
            $dashboardData['error'] = "Einige Dashboard-Daten konnten nicht geladen werden.";
        }
        // --- ENDE: Daten laden ---

        // CSRF Token für Aktionen wie Wartungsmodus-Schalter generieren
        Security::getCsrfToken();

        require_once dirname(__DIR__, 4) . '/pages/admin/dashboard.php';
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\DashboardController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\SettingsController.php ---
<?php
// app/Http/Controllers/Admin/SettingsController.php
// MODIFIZIERT: clearCacheApi() leert jetzt App\Core\Cache UND Utils::clearSettingsCache()

namespace App\Http\Controllers\Admin;

use App\Core\Security;
use App\Core\Database;
use App\Core\Utils;
use App\Core\Cache; // NEU: Importiert die App-Cache-Klasse
use App\Repositories\SettingsRepository;
use App\Services\AuditLogger;
use Exception;
use PDO;

class SettingsController
{
    private SettingsRepository $settingsRepo;
    private string $uploadDir; // NEU: Upload-Verzeichnis

    public function __construct()
    {
        $this->settingsRepo = new SettingsRepository();
        // NEU: Definiere das Upload-Verzeichnis für Branding
        $this->uploadDir = dirname(__DIR__, 4) . '/public/uploads/branding/';
    }

    /**
     * Zeigt die Hauptseite für die Anwendungseinstellungen an.
     */
    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();

        $page_title = 'Anwendungs-Einstellungen';
        $body_class = 'admin-dashboard-body';

        // Aktuelle Einstellungen laden, um sie im Formular anzuzeigen
        $currentSettings = Utils::getSettings();

        // NEU: Sicherstellen, dass das Upload-Verzeichnis existiert
        if (!is_dir($this->uploadDir)) {
            @mkdir($this->uploadDir, 0775, true);
        }

        Security::getCsrfToken(); // Stellt sicher, dass ein Token für das Formular existiert

        include_once dirname(__DIR__, 4) . '/pages/admin/settings.php';
    }

    /**
     * NEU: Verarbeitet Datei-Uploads für Logos/Favicons.
     * @param string $fileKey Der Schlüssel in der $_FILES-Variable (z.B. 'site_logo')
     * @param array $allowedMimes Erlaubte MIME-Typen (Format: ['mime/type' => 'extension'])
     * @param string|null $currentPath Der Pfad zur aktuell gespeicherten Datei (zum Löschen)
     * @return string|null Der relative Pfad zur neuen Datei oder $currentPath, wenn nichts hochgeladen wurde
     * @throws Exception
     */
    private function handleFileUpload(string $fileKey, array $allowedMimes, ?string $currentPath): ?string
    {
        // Prüfen, ob eine neue Datei hochgeladen wurde
        if (isset($_FILES[$fileKey]) && $_FILES[$fileKey]['error'] === UPLOAD_ERR_OK) {
            $file = $_FILES[$fileKey];
            $fileType = mime_content_type($file['tmp_name']);

            // KORREKTUR: Prüfe, ob der fileType ein SCHLÜSSEL im $allowedMimes Array ist
            if (!array_key_exists($fileType, $allowedMimes)) {
                throw new Exception("Ungültiger Dateityp für '{$fileKey}'. Erlaubt: " . implode(', ', array_keys($allowedMimes)), 400);
            }

            // Sicherstellen, dass das Verzeichnis existiert
            if (!is_dir($this->uploadDir) && !@mkdir($this->uploadDir, 0775, true)) {
                throw new Exception("Upload-Verzeichnis konnte nicht erstellt werden.", 500);
            }
            if (!is_writable($this->uploadDir)) {
                throw new Exception("Upload-Verzeichnis ist nicht beschreibbar.", 500);
            }

            // Sicherer Dateiname
            // KORREKTUR: Verwende die Extension aus dem $allowedMimes Array, nicht aus dem Originalnamen
            $extension = $allowedMimes[$fileType]; 
            $fileName = $fileKey . '_' . uniqid() . '.' . $extension;
            $targetPath = $this->uploadDir . $fileName;

            if (move_uploaded_file($file['tmp_name'], $targetPath)) {
                // Erfolgreich hochgeladen, lösche die alte Datei (falls vorhanden)
                if ($currentPath && file_exists(dirname(__DIR__, 4) . '/public/' . $currentPath)) {
                    @unlink(dirname(__DIR__, 4) . '/public/' . $currentPath);
                }
                // Gebe den *relativen* Pfad für die DB zurück
                return 'uploads/branding/' . $fileName;
            } else {
                throw new Exception("Fehler beim Verschieben der hochgeladenen Datei.", 500);
            }
        }

        // Prüfen, ob die aktuelle Datei entfernt werden soll
        if (isset($_POST['remove_' . $fileKey]) && $_POST['remove_' . $fileKey] === '1') {
            if ($currentPath && file_exists(dirname(__DIR__, 4) . '/public/' . $currentPath)) {
                @unlink(dirname(__DIR__, 4) . '/public/' . $currentPath);
            }
            return null; // Pfad aus der DB entfernen
        }

        // Keine Änderung, behalte den alten Pfad
        return $currentPath;
    }


    /**
     * API: Speichert die Anwendungseinstellungen.
     */
    public function save()
    {
        Security::requireRole('admin');
        header('Content-Type: application/json');

        try {
            Security::verifyCsrfToken();

            // Daten kommen jetzt als Form-Daten (multipart/form-data)
            $data = $_POST;
            
            // Hole aktuelle Einstellungen (wichtig für Datei-Pfade)
            $oldSettings = Utils::getSettings();

            // --- Validierungen ---
            $startHour = filter_var($data['default_start_hour'] ?? 1, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 12]]);
            $endHour = filter_var($data['default_end_hour'] ?? 10, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 12]]);
            if ($startHour === false || $endHour === false || $startHour >= $endHour) {
                throw new Exception("Ungültiger Stundenbereich (1-12, Start < Ende).", 400);
            }
            $maxAttempts = filter_var($data['max_login_attempts'] ?? 5, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 100]]);
            $lockoutMinutes = filter_var($data['lockout_minutes'] ?? 15, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 1440]]);
            if ($maxAttempts === false || $lockoutMinutes === false) {
                throw new Exception("Ungültige Werte für Login-Sperre.", 400);
            }
            $defaultTheme = $data['default_theme'] ?? 'light';
            if (!in_array($defaultTheme, ['light', 'dark'])) {
                $defaultTheme = 'light';
            }
            $icalWeeksFuture = filter_var($data['ical_weeks_future'] ?? 8, FILTER_VALIDATE_INT, ['options' => ['min_range' => 1, 'max_range' => 52]]);
            if ($icalWeeksFuture === false) {
                throw new Exception("Ungültige Anzahl an iCal-Wochen (1-52).", 400);
            }
            // NEU: Bereinige IP-Whitelist-String
            $whitelistIPs = $data['maintenance_whitelist_ips'] ?? '';
            // Entferne alles außer IPs, Kommas, Doppelpunkte (IPv6) und Punkte
            $whitelistIPs = preg_replace('/[^0-9a-fA-F:.,\s]/', '', $whitelistIPs);
            // Ersetze Leerzeichen und Zeilenumbrüche durch Kommas und entferne doppelte Kommas
            $whitelistIPs = preg_replace('/[\s,]+/', ',', $whitelistIPs);
            $whitelistIPs = trim($whitelistIPs, ',');


            // --- Datei-Uploads verarbeiten ---
            $logoPath = $this->handleFileUpload(
                'site_logo',
                ['image/png' => 'png', 'image/jpeg' => 'jpg', 'image/svg+xml' => 'svg', 'image/gif' => 'gif'],
                $oldSettings['site_logo_path'] ?? null
            );

            $faviconPath = $this->handleFileUpload(
                'site_favicon',
                ['image/x-icon' => 'ico', 'image/png' => 'png', 'image/svg+xml' => 'svg'],
                $oldSettings['site_favicon_path'] ?? null
            );


            // Aufbereitete Einstellungen für das Repository
            $settingsToSave = [
                'site_title' => trim($data['site_title'] ?? 'PAUSE Portal'),
                'maintenance_mode' => (isset($data['maintenance_mode']) && ($data['maintenance_mode'] === 'on' || $data['maintenance_mode'] === '1')) ? '1' : '0',
                'maintenance_message' => trim($data['maintenance_message'] ?? ''),
                'maintenance_whitelist_ips' => $whitelistIPs, // NEU
                'default_start_hour' => $startHour,
                'default_end_hour' => $endHour,
                'max_login_attempts' => $maxAttempts,
                'lockout_minutes' => $lockoutMinutes,
                'site_logo_path' => $logoPath,
                'site_favicon_path' => $faviconPath,
                'default_theme' => $defaultTheme,
                'ical_enabled' => (isset($data['ical_enabled']) && ($data['ical_enabled'] === 'on' || $data['ical_enabled'] === '1')) ? '1' : '0',
                'ical_weeks_future' => $icalWeeksFuture,
                'pdf_footer_text' => trim($data['pdf_footer_text'] ?? ''),
                // NEU: Community Board
                'community_board_enabled' => (isset($data['community_board_enabled']) && ($data['community_board_enabled'] === 'on' || $data['community_board_enabled'] === '1')) ? '1' : '0',
            ];


            $this->settingsRepo->saveSettings($settingsToSave);

            // Protokollierung - logge nur geänderte Werte
            $changedDetails = [];
            foreach ($settingsToSave as $key => $newValue) {
                $oldValue = $oldSettings[$key];
                
                // Konvertiere boolesche Werte für den Vergleich
                if ($key === 'maintenance_mode' || $key === 'ical_enabled' || $key === 'community_board_enabled') { // NEU: community_board_enabled
                    $newValueForCompare = $newValue === '1'; // bool
                } else if (is_numeric($newValue)) {
                    $newValueForCompare = (int)$newValue;
                } else {
                    $newValueForCompare = $newValue;
                }

                if ($newValueForCompare != $oldValue) {
                    // Spezielle Behandlung für Logo/Favicon, um nur "geändert" statt Pfad zu loggen
                    if ($key === 'site_logo_path' || $key === 'site_favicon_path') {
                        if ($newValue === null && $oldValue !== null) $changedDetails[$key] = 'entfernt';
                        elseif ($newValue !== null && $oldValue === null) $changedDetails[$key] = 'hinzugefügt';
                        elseif ($newValue !== $oldValue) $changedDetails[$key] = 'geändert';
                    } else {
                        $changedDetails[$key] = ['old' => $oldValue, 'new' => $newValueForCompare];
                    }
                }
            }
            $changedDetails = array_filter($changedDetails);


            if (!empty($changedDetails)) {
                AuditLogger::log(
                    'update_settings',
                    'system',
                    null,
                    $changedDetails
                );
            }

            // Cache in Utils löschen
            Utils::clearSettingsCache();

            echo json_encode([
                'success' => true,
                'message' => 'Einstellungen erfolgreich gespeichert.',
                'data' => [
                    'site_logo_path' => $logoPath,
                    'site_favicon_path' => $faviconPath,
                    'default_theme' => $defaultTheme
                ]
            ]);

        } catch (Exception $e) {
            $statusCode = $e->getCode();
            if (!is_int($statusCode) || $statusCode < 400 || $statusCode > 599) {
                $statusCode = 400;
            }
            http_response_code($statusCode);
            error_log("Settings save error: " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }

    /**
     * NEU: API-Endpunkt zum Leeren des Caches.
     * MODIFIZIERT: Leert jetzt BEIDE Caches (Settings + App).
     */
    public function clearCacheApi()
    {
        Security::requireRole('admin');
        header('Content-Type: application/json');

        try {
            // CSRF-Token aus dem Header holen (von apiFetch gesendet) oder aus POST
            Security::verifyCsrfToken(); 

            // 1. Führe die Cache-Löschung für Einstellungen durch (aus Utils)
            Utils::clearSettingsCache();
            $settingsMessage = 'Einstellungen-Cache geleert.';

            // 2. Führe die App-Cache-Löschung durch (aus Core\Cache)
            $appCacheResult = Cache::clearAll(); // Ruft die neue Methode auf
            $appMessage = $appCacheResult['message'];

            if (!$appCacheResult['success']) {
                // Wenn der App-Cache fehlschlägt, werfe einen Fehler
                throw new Exception("Fehler beim Leeren des App-Caches: " . $appMessage);
            }
            
            // Protokolliere die Aktion (jetzt für alle Caches)
            AuditLogger::log(
                'clear_cache',
                'system',
                null,
                ['cache_type' => 'all_application_caches'] // Aktualisierter Log-Text
            );

            echo json_encode([
                'success' => true,
                'message' => "Erfolgreich! $settingsMessage. $appMessage" // Kombinierte Nachricht
            ]);

        } catch (Exception $e) {
            http_response_code(str_contains($e->getMessage(), 'CSRF') ? 403 : 500);
            error_log("Cache clear error: " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\SettingsController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\StammdatenController.php ---
<?php
// app/Http/Controllers/Admin/StammdatenController.php
namespace App\Http\Controllers\Admin;

use App\Core\Security;
use App\Core\Database;
use App\Repositories\StammdatenRepository;
use Exception;
use PDO;
use App\Services\AuditLogger; // NEU: AuditLogger importieren

class StammdatenController
{
    private PDO $pdo;
    private StammdatenRepository $repository;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->repository = new StammdatenRepository($this->pdo);
    }

    /**
     * Zeigt die Hauptseite für die Stammdatenverwaltung an.
     */
    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();

        $page_title = 'Stammdatenverwaltung';
        $body_class = 'admin-dashboard-body';
         // Ensure CSRF token is generated for forms on this page
        Security::getCsrfToken();

        include_once dirname(__DIR__, 4) . '/pages/admin/stammdaten.php';
    }

    // --- API Helper ---
    /**
     * Helper to wrap common API request logic (auth, CSRF, response type, error handling)
     * @param callable $callback The actual logic to execute
     * @param string $actionName Der Name der Aktion für das Audit-Log (z.B. 'create_subject')
     * @param string $targetType Der Typ des Ziels (z.B. 'subject')
     */
    private function handleApiRequest(callable $callback, string $actionName = '', string $targetType = ''): void
    {
        // Security checks are done within each method that calls this for clarity
        header('Content-Type: application/json'); // Set header early
        try {
            Security::verifyCsrfToken(); // Verify CSRF token here for all modifying actions
            
            // Führe die eigentliche Aktion aus
            $result = $callback(); // Callback gibt jetzt ggf. Daten zurück

            // Protokollierung bei Erfolg (nur wenn actionName gesetzt ist)
            if ($actionName) {
                AuditLogger::log(
                    $actionName,
                    $targetType,
                    $result['target_id'] ?? null, // ID des erstellten/bearbeiteten Objekts
                    $result['details'] ?? null   // Details (z.B. Name)
                );
            }

        } catch (Exception $e) {
            // Determine appropriate status code
            http_response_code(str_contains($e->getMessage(), 'CSRF') ? 403 : (str_contains($e->getMessage(), 'existiert bereits') ? 409 : 400));
            echo json_encode(['success' => false, 'message' => $e->getMessage()], JSON_THROW_ON_ERROR);
        }
        exit();
    }

    // --- API METHODS FOR SUBJECTS ---

    /**
     * API: Holt alle Fächer und gibt sie als JSON zurück. (GET request - no CSRF needed)
     */
    public function getSubjects()
    {
        Security::requireRole('admin');
        header('Content-Type: application/json');
        try {
            $subjects = $this->repository->getSubjects();
            echo json_encode(['success' => true, 'data' => $subjects], JSON_THROW_ON_ERROR);
        } catch (Exception $e) {
            http_response_code(500);
            echo json_encode(['success' => false, 'message' => 'Fehler beim Laden der Fächer: ' . $e->getMessage()], JSON_THROW_ON_ERROR);
        }
        exit();
    }

    /**
     * API: Erstellt ein neues Fach. (POST request)
     */
    public function createSubject()
    {
        Security::requireRole('admin'); // Auth check first
        $this->handleApiRequest(function() { // CSRF check inside handleApiRequest
            $name = trim($_POST['subject_name'] ?? '');
            $shortcut = trim($_POST['subject_shortcut'] ?? '');
            if (empty($name) || empty($shortcut)) {
                throw new Exception("Fachname und Kürzel dürfen nicht leer sein.");
            }
            $newId = $this->repository->createSubject($name, $shortcut);
            $newSubject = ['subject_id' => $newId, 'subject_name' => $name, 'subject_shortcut' => $shortcut];

            echo json_encode(['success' => true, 'message' => 'Fach erfolgreich erstellt.', 'data' => $newSubject], JSON_THROW_ON_ERROR);
            
            // Rückgabe für Audit-Log
            return [
                'target_id' => $newId,
                'details' => ['name' => $name, 'shortcut' => $shortcut]
            ];
        }, 'create_subject', 'subject'); // NEU: Audit-Log Parameter
    }

    /**
     * API: Aktualisiert ein bestehendes Fach. (POST request)
     */
    public function updateSubject()
    {
         Security::requireRole('admin'); // Auth check first
           $this->handleApiRequest(function() { // CSRF check inside handleApiRequest
            $id = filter_input(INPUT_POST, 'subject_id', FILTER_VALIDATE_INT);
            $name = trim($_POST['subject_name'] ?? '');
            $shortcut = trim($_POST['subject_shortcut'] ?? '');

            if (!$id || empty($name) || empty($shortcut)) {
                throw new Exception("Ungültige Daten für das Update.");
            }
            $this->repository->updateSubject($id, $name, $shortcut);
            $updatedSubject = ['subject_id' => $id, 'subject_name' => $name, 'subject_shortcut' => $shortcut];
            echo json_encode(['success' => true, 'message' => 'Fach erfolgreich aktualisiert.', 'data' => $updatedSubject], JSON_THROW_ON_ERROR);

            // Rückgabe für Audit-Log
            return [
                'target_id' => $id,
                'details' => ['name' => $name, 'shortcut' => $shortcut]
            ];
        }, 'update_subject', 'subject'); // NEU: Audit-Log Parameter
    }

    /**
     * API: Löscht ein Fach. (POST request)
     */
    public function deleteSubject()
    {
        Security::requireRole('admin'); // Auth check first
        $this->handleApiRequest(function() { // CSRF check inside handleApiRequest
            $id = filter_input(INPUT_POST, 'subject_id', FILTER_VALIDATE_INT);
            if (!$id) {
                throw new Exception("Ungültige ID.");
            }
            $this->repository->deleteSubject($id);
            echo json_encode(['success' => true, 'message' => 'Fach erfolgreich gelöscht.'], JSON_THROW_ON_ERROR);

            // Rückgabe für Audit-Log
            return [
                'target_id' => $id,
                'details' => ['id' => $id]
            ];
        }, 'delete_subject', 'subject'); // NEU: Audit-Log Parameter
    }

    // --- API METHODS FOR ROOMS ---
    // GET - No CSRF
    public function getRooms() {
        Security::requireRole('admin');
        header('Content-Type: application/json');
        try {
            echo json_encode(['success' => true, 'data' => $this->repository->getRooms()], JSON_THROW_ON_ERROR);
        } catch (Exception $e) {
            http_response_code(500);
            echo json_encode(['success' => false, 'message' => 'Fehler beim Laden der Räume.'], JSON_THROW_ON_ERROR);
        }
        exit();
    }
    // POST - CSRF handled
    public function createRoom() {
        Security::requireRole('admin');
        $this->handleApiRequest(function() {
            $name = trim($_POST['room_name'] ?? '');
            if (empty($name)) throw new Exception("Raumname darf nicht leer sein.");
            $newId = $this->repository->createRoom($name); // Assuming createRoom returns ID
            $newRoom = ['room_id' => $newId, 'room_name' => $name];
            echo json_encode(['success' => true, 'message' => 'Raum erfolgreich erstellt.', 'data' => $newRoom], JSON_THROW_ON_ERROR);
            
            return [
                'target_id' => $newId,
                'details' => ['name' => $name]
            ];
        }, 'create_room', 'room'); // NEU
    }
    // POST - CSRF handled
    public function updateRoom() {
        Security::requireRole('admin');
        $this->handleApiRequest(function() {
            $id = filter_input(INPUT_POST, 'room_id', FILTER_VALIDATE_INT);
            $name = trim($_POST['room_name'] ?? '');
            if (!$id || empty($name)) throw new Exception("Ungültige Daten.");
            $this->repository->updateRoom($id, $name);
            $updatedRoom = ['room_id' => $id, 'room_name' => $name];
            echo json_encode(['success' => true, 'message' => 'Raum erfolgreich aktualisiert.', 'data' => $updatedRoom], JSON_THROW_ON_ERROR);
            
            return [
                'target_id' => $id,
                'details' => ['name' => $name]
            ];
        }, 'update_room', 'room'); // NEU
    }
    // POST - CSRF handled
    public function deleteRoom() {
        Security::requireRole('admin');
        $this->handleApiRequest(function() {
            $id = filter_input(INPUT_POST, 'room_id', FILTER_VALIDATE_INT);
            if (!$id) throw new Exception("Ungültige ID.");
            $this->repository->deleteRoom($id);
            echo json_encode(['success' => true, 'message' => 'Raum erfolgreich gelöscht.'], JSON_THROW_ON_ERROR);
            
            return ['target_id' => $id];
        }, 'delete_room', 'room'); // NEU
    }

    // --- API METHODS FOR TEACHERS ---
    // GET - No CSRF
    public function getTeachers() {
        Security::requireRole('admin');
        header('Content-Type: application/json');
        try {
            echo json_encode(['success' => true, 'data' => $this->repository->getTeachers()], JSON_THROW_ON_ERROR);
        } catch (Exception $e) {
            http_response_code(500);
            echo json_encode(['success' => false, 'message' => 'Fehler beim Laden der Lehrer.'], JSON_THROW_ON_ERROR);
        }
        exit();
    }
    // POST - CSRF handled
    public function createTeacher() {
        Security::requireRole('admin');
        $this->handleApiRequest(function() {
            $data = [
                'shortcut' => trim($_POST['teacher_shortcut'] ?? ''), // Renamed key to match repo
                'first_name' => trim($_POST['first_name'] ?? ''),
                'last_name' => trim($_POST['last_name'] ?? ''),
                'email' => empty(trim($_POST['email'] ?? '')) ? null : trim($_POST['email']) // Handle empty email as NULL
            ];
            if (empty($data['shortcut']) || empty($data['first_name']) || empty($data['last_name'])) {
                throw new Exception("Kürzel, Vorname und Nachname sind Pflichtfelder.");
            }
            $newId = $this->repository->createTeacher($data);
            $newTeacher = array_merge(['teacher_id' => $newId], $data);
            echo json_encode(['success' => true, 'message' => 'Lehrer erfolgreich erstellt.', 'data' => $newTeacher], JSON_THROW_ON_ERROR);
            
            return [
                'target_id' => $newId,
                'details' => $data
            ];
        }, 'create_teacher', 'teacher'); // NEU
    }
    // POST - CSRF handled
    public function updateTeacher() {
        Security::requireRole('admin');
        $this->handleApiRequest(function() {
            $id = filter_input(INPUT_POST, 'teacher_id', FILTER_VALIDATE_INT);
            $data = [
                'shortcut' => trim($_POST['teacher_shortcut'] ?? ''), // Renamed key
                'first_name' => trim($_POST['first_name'] ?? ''),
                'last_name' => trim($_POST['last_name'] ?? ''),
                'email' => empty(trim($_POST['email'] ?? '')) ? null : trim($_POST['email']) // Handle empty email as NULL
            ];
            if (!$id || empty($data['shortcut']) || empty($data['first_name']) || empty($data['last_name'])) {
                throw new Exception("Ungültige Daten.");
            }
            $this->repository->updateTeacher($id, $data);
            $updatedTeacher = array_merge(['teacher_id' => $id], $data);
            echo json_encode(['success' => true, 'message' => 'Lehrer erfolgreich aktualisiert.', 'data' => $updatedTeacher], JSON_THROW_ON_ERROR);
            
            return [
                'target_id' => $id,
                'details' => $data
            ];
        }, 'update_teacher', 'teacher'); // NEU
    }
    // POST - CSRF handled
    public function deleteTeacher() {
        Security::requireRole('admin');
        $this->handleApiRequest(function() {
            $id = filter_input(INPUT_POST, 'teacher_id', FILTER_VALIDATE_INT);
            if (!$id) throw new Exception("Ungültige ID.");
            $this->repository->deleteTeacher($id);
            echo json_encode(['success' => true, 'message' => 'Lehrer erfolgreich gelöscht.'], JSON_THROW_ON_ERROR);
            
            return ['target_id' => $id];
        }, 'delete_teacher', 'teacher'); // NEU
    }

    // --- API METHODS FOR CLASSES ---
    // GET - No CSRF
    public function getClasses() {
        Security::requireRole('admin');
        header('Content-Type: application/json');
        try {
            echo json_encode(['success' => true, 'data' => $this->repository->getClasses()], JSON_THROW_ON_ERROR);
        } catch (Exception $e) {
            http_response_code(500);
            echo json_encode(['success' => false, 'message' => 'Fehler beim Laden der Klassen.'], JSON_THROW_ON_ERROR);
        }
        exit();
    }
    // POST - CSRF handled
    public function createClass() {
        Security::requireRole('admin');
        $this->handleApiRequest(function() {
            // Retrieve class_id from POST data, not use it as primary key directly in create if auto-increment
            $id = filter_input(INPUT_POST, 'class_id_input', FILTER_VALIDATE_INT); // This is the user-defined ID
            $name = trim($_POST['class_name'] ?? '');
            $teacherId = filter_input(INPUT_POST, 'class_teacher_id', FILTER_VALIDATE_INT);
            $teacherId = ($teacherId === 0 || $teacherId === false) ? null : $teacherId; // Handle '0' or empty value correctly

            if (empty($name) || !$id || $id <= 0) { // Also check if ID is positive
                 throw new Exception("Klassen-ID (positiv) und Klassenname dürfen nicht leer sein.");
            }

            // The repository method handles the ID check and insertion
            $this->repository->createClass($id, $name, $teacherId);
            $newClass = ['class_id' => $id, 'class_name' => $name, 'class_teacher_id' => $teacherId]; // Return the data
             // Optionally fetch teacher name here if needed in frontend response
            echo json_encode(['success' => true, 'message' => 'Klasse erfolgreich erstellt.', 'data' => $newClass], JSON_THROW_ON_ERROR);
            
            return [
                'target_id' => $id,
                'details' => ['name' => $name, 'teacher_id' => $teacherId]
            ];
        }, 'create_class', 'class'); // NEU
    }
    // POST - CSRF handled
    public function updateClass() {
        Security::requireRole('admin');
        $this->handleApiRequest(function() {
            $id = filter_input(INPUT_POST, 'class_id_hidden', FILTER_VALIDATE_INT); // ID comes from the hidden input/data attribute now
            $name = trim($_POST['class_name'] ?? '');
            $teacherId = filter_input(INPUT_POST, 'class_teacher_id', FILTER_VALIDATE_INT);
            $teacherId = ($teacherId === 0 || $teacherId === false) ? null : $teacherId; // Handle '0' or empty value correctly

            if (!$id || empty($name)) {
                 throw new Exception("Ungültige Daten für Update (ID und Name benötigt).");
            }
            $this->repository->updateClass($id, $name, $teacherId);
            $updatedClass = ['class_id' => $id, 'class_name' => $name, 'class_teacher_id' => $teacherId];
             // Optionally fetch teacher name here
            echo json_encode(['success' => true, 'message' => 'Klasse erfolgreich aktualisiert.', 'data' => $updatedClass], JSON_THROW_ON_ERROR);
            
            return [
                'target_id' => $id,
                'details' => ['name' => $name, 'teacher_id' => $teacherId]
            ];
        }, 'update_class', 'class'); // NEU
    }
    // POST - CSRF handled
    public function deleteClass() {
        Security::requireRole('admin');
        $this->handleApiRequest(function() {
            $id = filter_input(INPUT_POST, 'class_id', FILTER_VALIDATE_INT);
            if (!$id) throw new Exception("Ungültige ID.");
            $this->repository->deleteClass($id);
            echo json_encode(['success' => true, 'message' => 'Klasse erfolgreich gelöscht.'], JSON_THROW_ON_ERROR);
            
            return ['target_id' => $id];
        }, 'delete_class', 'class'); // NEU
    }
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\StammdatenController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\SystemHealthController.php ---
<?php
// app/Http/Controllers/Admin/SystemHealthController.php
// KORRIGIERT: Utils::renderView() entfernt und durch manuelles Laden der View (include_once) ersetzt.

namespace App\Http\Controllers\Admin;

use App\Core\Security;
use App\Core\Utils;
use App\Core\Database;

class SystemHealthController
{
    public function __construct()
    {
        Security::requireRole('admin');
    }

    /**
     * Zeigt die System-Status-Seite an.
     */
    public function index()
    {
        // KORREKTUR: Globale Variablen setzen, die vom Header benötigt werden
        global $config;
        $config = Database::getConfig();
        $page_title = 'System-Status';
        $body_class = 'admin-dashboard-body';

        // $data wird an die View übergeben
        $data = [
            'phpVersion' => phpversion(),
            'serverSoftware' => $_SERVER['SERVER_SOFTWARE'] ?? 'N/A',
            'dbStatus' => $this->checkDbStatus(),
            'extensions' => $this->checkExtensions(),
            'directoryStatus' => $this->checkDirectories(),
            'settings' => Utils::getSettings() // Für den Wartungsmodus-Status
        ];

        // KORREKTUR: View direkt laden (diese lädt dann Header/Footer)
        include_once dirname(__DIR__, 4) . '/pages/admin/system_health.php';
    }

    /**
     * Prüft die Datenbankverbindung.
     */
    private function checkDbStatus(): array
    {
        try {
            $pdo = Database::getInstance();
            $pdo->query("SELECT 1");
            return ['status' => 'ok', 'message' => 'Verbunden'];
        } catch (\PDOException $e) {
            // Zeige nicht die volle Fehlermeldung, um DB-Details zu schützen
            return ['status' => 'error', 'message' => 'Nicht verbunden'];
        }
    }

    /**
     * Prüft wichtige PHP-Extensions.
     */
    private function checkExtensions(): array
    {
        $required = ['pdo_mysql', 'openssl', 'gd', 'mbstring', 'json', 'intl'];
        $status = [];

        foreach ($required as $ext) {
            $status[$ext] = extension_loaded($ext);
        }
        return $status;
    }

    /**
     * Prüft, ob wichtige Verzeichnisse beschreibbar sind.
     */
    private function checkDirectories(): array
    {
        $projectRoot = dirname(__DIR__, 4);
        $dirs = [
            'cache' => $projectRoot . '/cache',
            'uploads/announcements' => $projectRoot . '/public/uploads/announcements',
            'uploads/branding' => $projectRoot . '/public/uploads/branding'
        ];
        
        $status = [];
        foreach ($dirs as $name => $path) {
            $isDir = is_dir($path);
            $isWritable = $isDir && is_writable($path);
            
            if (!$isDir) {
                $status[$name] = ['status' => 'error', 'message' => 'Verzeichnis existiert nicht'];
            } elseif (!$isWritable) {
                $status[$name] = ['status' => 'error', 'message' => 'Nicht beschreibbar'];
            } else {
                $status[$name] = ['status' => 'ok', 'message' => 'OK'];
            }
        }
        return $status;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\SystemHealthController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\UserController.php ---
<?php
// app/Http/Controllers/Admin/UserController.php
namespace App\Http\Controllers\Admin;

use App\Core\Security;
use App\Core\Database;
use App\Repositories\UserRepository;
use App\Repositories\StammdatenRepository;
use Exception;
use PDO;
use App\Services\AuditLogger; // NEU: AuditLogger importieren

class UserController
{
    private PDO $pdo;
    private UserRepository $userRepository;
    private StammdatenRepository $stammdatenRepository;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->userRepository = new UserRepository($this->pdo);
        $this->stammdatenRepository = new StammdatenRepository($this->pdo);
    }

    /**
     * Zeigt die Hauptseite für die Benutzerverwaltung an.
     */
    public function index()
    {
        Security::requireRole('admin');
        global $config;
        $config = Database::getConfig();

        $page_title = 'Benutzerverwaltung';
        $body_class = 'admin-dashboard-body';
        // Ensure CSRF token is generated for forms on this page
        Security::getCsrfToken();

        include_once dirname(__DIR__, 4) . '/pages/admin/users.php';
    }

    // --- API Helper ---
    /**
     * Helper to wrap common API request logic (auth, CSRF, response type, error handling)
     * @param callable $callback The actual logic to execute
     * @param string $actionName Der Name der Aktion für das Audit-Log (z.B. 'create_user')
     * @param string $targetType Der Typ des Ziels (z.B. 'user')
     */
    private function handleApiRequest(callable $callback, string $actionName = '', string $targetType = ''): void
    {
        header('Content-Type: application/json'); // Set header early
        try {
            Security::verifyCsrfToken(); // Verify CSRF token here for all modifying actions
            
            // Führe die eigentliche Aktion aus
            $result = $callback(); // Callback gibt jetzt ggf. Daten zurück

            // Protokollierung bei Erfolg (nur wenn actionName gesetzt ist)
            if ($actionName) {
                AuditLogger::log(
                    $actionName,
                    $targetType,
                    $result['target_id'] ?? null, // ID des erstellten/bearbeiteten Objekts
                    $result['details'] ?? null   // Details (z.B. Name)
                );
            }

        } catch (Exception $e) {
            // Determine appropriate status code
            // Hinzugefügt: 409 Conflict-Status für Duplikate
            http_response_code(str_contains($e->getMessage(), 'CSRF') ? 403 : (str_contains($e->getMessage(), 'vergeben') ? 409 : 400));
            echo json_encode(['success' => false, 'message' => $e->getMessage()], JSON_THROW_ON_ERROR);
        }
        exit();
    }

    // --- API METHODS ---

    /**
     * API: Holt alle Benutzer und gibt sie als JSON zurück. (GET request - no CSRF needed)
     */
    public function getUsers()
    {
        Security::requireRole('admin');
        header('Content-Type: application/json');
        try {
            $users = $this->userRepository->getAll();
            // Additionally, fetch data needed for forms
            $roles = $this->userRepository->getAvailableRoles();
            $classes = $this->stammdatenRepository->getClasses();
            $teachers = $this->stammdatenRepository->getTeachers();

            echo json_encode(['success' => true, 'data' => [
                'users' => $users,
                'roles' => $roles,
                'classes' => $classes,
                'teachers' => $teachers
            ]], JSON_THROW_ON_ERROR); // Added JSON_THROW_ON_ERROR
        } catch (Exception $e) {
            http_response_code(500);
            echo json_encode(['success' => false, 'message' => 'Fehler beim Laden der Benutzer: ' . $e->getMessage()], JSON_THROW_ON_ERROR); // Added JSON_THROW_ON_ERROR
        }
        exit();
    }

    /**
     * API: Erstellt einen neuen Benutzer. (POST request)
     */
    public function createUser()
    {
        Security::requireRole('admin'); // Auth check first
        $this->handleApiRequest(function() { // CSRF check inside handleApiRequest
            $newUserId = $this->userRepository->create($_POST);
            // Optionally fetch the newly created user data to return
            $newUser = $this->userRepository->findById($newUserId); // Assuming findById exists
            echo json_encode(['success' => true, 'message' => 'Benutzer erfolgreich erstellt.', 'data' => $newUser], JSON_THROW_ON_ERROR);

            // Details für Audit-Log vorbereiten (Passwort nicht loggen)
            $details = $_POST;
            unset($details['password']);
            
            return [
                'target_id' => $newUserId,
                'details' => $details
            ];
        }, 'create_user', 'user'); // NEU
    }

    /**
     * API: Aktualisiert einen bestehenden Benutzer. (POST request)
     */
    public function updateUser()
    {
        Security::requireRole('admin'); // Auth check first
        $this->handleApiRequest(function() { // CSRF check inside handleApiRequest
            $id = filter_input(INPUT_POST, 'user_id', FILTER_VALIDATE_INT);
            if (!$id) {
                throw new Exception("Ungültige Benutzer-ID.");
            }
            $this->userRepository->update($id, $_POST);
             // Optionally fetch the updated user data to return
            $updatedUser = $this->userRepository->findById($id);
            echo json_encode(['success' => true, 'message' => 'Benutzer erfolgreich aktualisiert.', 'data' => $updatedUser], JSON_THROW_ON_ERROR);
            
            // Details für Audit-Log vorbereiten (Passwort nicht loggen)
            $details = $_POST;
            unset($details['password']); // Niemals das Passwort loggen

            return [
                'target_id' => $id,
                'details' => $details
            ];
        }, 'update_user', 'user'); // NEU
    }

    /**
     * API: Löscht einen Benutzer. (POST request)
     */
    public function deleteUser()
    {
        Security::requireRole('admin'); // Auth check first
        $this->handleApiRequest(function() { // CSRF check inside handleApiRequest
            $id = filter_input(INPUT_POST, 'user_id', FILTER_VALIDATE_INT);
            if (!$id) {
                throw new Exception("Ungültige ID.");
            }
            $this->userRepository->delete($id);
            echo json_encode(['success' => true, 'message' => 'Benutzer erfolgreich gelöscht.'], JSON_THROW_ON_ERROR);

            return ['target_id' => $id];
        }, 'delete_user', 'user'); // NEU
    }

    /**
     * NEU: API: Importiert Benutzer aus einer CSV-Datei.
     * (POST request, multipart/form-data)
     */
    public function importUsers()
    {
        // Dieser Endpunkt verwendet multipart/form-data, daher kein handleApiRequest (oder ein angepasster)
        header('Content-Type: application/json');
        try {
            Security::requireRole('admin');
            Security::verifyCsrfToken(); // Manuelle CSRF-Prüfung (prüft POST-Body)

            if (!isset($_FILES['csv_file']) || $_FILES['csv_file']['error'] !== UPLOAD_ERR_OK) {
                throw new Exception('Keine CSV-Datei hochgeladen oder Fehler beim Upload.');
            }

            $tmpFilePath = $_FILES['csv_file']['tmp_name'];
            $fileType = mime_content_type($tmpFilePath);
            $fileExtension = strtolower(pathinfo($_FILES['csv_file']['name'], PATHINFO_EXTENSION));

            // Striktere Prüfung auf CSV-Typen
            if (!in_array($fileType, ['text/plain', 'text/csv', 'application/csv']) && $fileExtension !== 'csv') {
                 throw new Exception('Ungültiger Dateityp. Bitte laden Sie eine CSV-Datei hoch.');
            }

            // Hole Stammdaten für die Validierung
            $validClasses = $this->stammdatenRepository->getClasses();
            $validTeachers = $this->stammdatenRepository->getTeachers();
            $validRoles = $this->userRepository->getAvailableRoles();
            
            $validationData = [
                'class_ids' => array_column($validClasses, 'class_id'),
                'teacher_ids' => array_column($validTeachers, 'teacher_id'),
                'roles' => $validRoles
            ];

            // Führe den Import im Repository durch
            $result = $this->userRepository->importFromCSV($tmpFilePath, $validationData);

            // Protokolliere den Import-Vorgang
            AuditLogger::log(
                'import_users_csv',
                'system',
                null, // Kein spezifisches Zielobjekt
                [
                    'filename' => $_FILES['csv_file']['name'],
                    'success_count' => $result['success_count'],
                    'failure_count' => $result['failure_count'],
                    'errors' => $result['errors'] // Logge die ersten paar Fehler
                ]
            );

            echo json_encode(['success' => true, 'message' => 'Import abgeschlossen.', 'data' => $result]);

        } catch (Exception $e) {
            http_response_code(str_contains($e->getMessage(), 'CSRF') ? 403 : 400);
            error_log("User Import Error: " . $e->getMessage()); // Log des Fehlers
            echo json_encode(['success' => false, 'message' => $e->getMessage()], JSON_THROW_ON_ERROR);
        }
        exit();
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Admin\UserController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Auth\AuthController.php ---
<?php
// app/Http/Controllers/Auth/AuthController.php
namespace App\Http\Controllers\Auth;

use App\Core\Database;
use App\Core\Utils;
use App\Core\Security; // Use statement
use App\Repositories\UserRepository;
use App\Services\AuthenticationService;
use Exception;
use PDO;

class AuthController
{
    private PDO $pdo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
    }

    /**
     * Verarbeitet die POST-Anfrage vom Login-Formular.
     */
    public function handleLogin()
    {
        // CSRF Token Validation
        try {
            Security::verifyCsrfToken(); // Use the updated method name
        } catch (Exception $e) {
             // Handle CSRF validation failure - show login page with error
            $message = $e->getMessage();
            $page_title = 'Login';
             // Regenerate token on failure? Optional, but can help if token expired.
             Security::getCsrfToken(); // Ensure a new one is available for the form
            include_once dirname(__DIR__, 4) . '/pages/auth/login.php';
            return; // Stop execution
        }


        $identifier = $_POST['identifier'] ?? '';
        $password = $_POST['password'] ?? '';

        try {
            // Erstelle die notwendigen Objekte.
            $userRepository = new UserRepository($this->pdo);
            // Assuming LoginAttemptRepository is needed by AuthenticationService
            $loginAttemptRepository = new \App\Repositories\LoginAttemptRepository($this->pdo);
            $authService = new AuthenticationService($userRepository, $loginAttemptRepository);

            // Führe den Login-Versuch durch.
            $userData = $authService->login($identifier, $password);

            // Wenn der Login erfolgreich war (kein Fehler geworfen wurde):
            session_regenerate_id(true); // Wichtig für die Sicherheit
            $_SESSION['user_id'] = $userData['user_id'];
            $_SESSION['username'] = $userData['username'];
            $_SESSION['user_role'] = $userData['role'];
            // Store/Ensure CSRF token after successful login and session regeneration
            Security::getCsrfToken();


            // Leite zum Dashboard weiter.
            header("Location: " . Utils::url('dashboard'));
            exit();

        } catch (Exception $e) {
            // Wenn der Login fehlschlägt, fängt der Catch-Block den Fehler ab.
            // Wir speichern die Fehlermeldung und laden die Login-Seite erneut.
            $message = $e->getMessage();
            $page_title = 'Login';
             // Ensure a CSRF token is available for the re-rendered form
             Security::getCsrfToken();
            include_once dirname(__DIR__, 4) . '/pages/auth/login.php';
        }
    }


    public function showLogin()
    {
        global $config; // Wird für die Basis-URL in den Views benötigt.
        $config = Database::getConfig();
        $page_title = 'Login';
        $message = $_SESSION['flash_message'] ?? '';
        unset($_SESSION['flash_message']);
        // Ensure a CSRF token is available for the form
        Security::getCsrfToken();
        include_once dirname(__DIR__, 4) . '/pages/auth/login.php';
    }

    public function logout()
    {
        $_SESSION = [];
        session_destroy();
        session_start(); // Start a new session for the flash message
        $_SESSION['flash_message'] = "Sie wurden erfolgreich abgemeldet.";
        header("Location: " . Utils::url('login'));
        exit();
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Auth\AuthController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Planer\AbsenceController.php ---
<?php
// app/Http/Controllers/Planer/AbsenceController.php

namespace App\Http\Controllers\Planer;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\TeacherAbsenceRepository;
use App\Repositories\StammdatenRepository;
use App\Services\AuditLogger;
use Exception;
use PDO;
use DateTime;
use DateTimeZone;

/**
 * NEU: Controller für die Verwaltung von Lehrer-Abwesenheiten (nur für Planer/Admins).
 */
class AbsenceController
{
    private PDO $pdo;
    private TeacherAbsenceRepository $absenceRepo;
    private StammdatenRepository $stammdatenRepo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->absenceRepo = new TeacherAbsenceRepository($this->pdo);
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
    }

    /**
     * Zeigt die Hauptseite für die Abwesenheitsverwaltung an.
     * Stellt Daten für das Formular bereit (Lehrerliste).
     */
    public function index()
    {
        Security::requireRole(['admin', 'planer']);
        global $config;
        $config = Database::getConfig();

        $page_title = 'Lehrer-Abwesenheiten';
        $body_class = 'planer-dashboard-body'; // Verwendet dasselbe Layout wie der Planer

        try {
            // Lade alle Lehrer für das Dropdown-Menü
            $availableTeachers = $this->stammdatenRepo->getTeachers();
            
            // Lade die erlaubten Abwesenheitstypen (aus dem Repository, falls sie in der DB wären, sonst hartcodiert)
            $absenceTypes = $this->absenceRepo->getAbsenceTypes();

            Security::getCsrfToken();
            include_once dirname(__DIR__, 4) .'/pages/planer/absences.php';

        } catch (Exception $e) {
            error_log("Fehler beim Laden der Abwesenheits-Seite: " . $e->getMessage());
            http_response_code(500);
            die("Ein Fehler ist beim Laden der Seite aufgetreten: " . $e->getMessage());
        }
    }

    /**
     * API: Holt Abwesenheiten für einen bestimmten Zeitraum (z.B. einen Monat).
     */
    public function getAbsencesApi()
    {
        Security::requireRole(['admin', 'planer']);
        header('Content-Type: application/json');

        try {
            $startDate = filter_input(INPUT_GET, 'start', FILTER_UNSAFE_RAW); // YYYY-MM-DD
            $endDate = filter_input(INPUT_GET, 'end', FILTER_UNSAFE_RAW); // YYYY-MM-DD

            if (!$startDate || !$endDate) {
                // Standard: Aktueller Monat
                $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                $startDate = $today->format('Y-m-01');
                $endDate = $today->format('Y-m-t');
            }

            // Validierung
            if (DateTime::createFromFormat('Y-m-d', $startDate) === false || DateTime::createFromFormat('Y-m-d', $endDate) === false) {
                throw new Exception("Ungültiges Datumsformat.", 400);
            }

            // KORREKTUR: Diese Methode verwendet jetzt die Parameter
            $absences = $this->absenceRepo->getAbsencesForPeriod($startDate, $endDate);

            echo json_encode(['success' => true, 'data' => $absences]);

        } catch (Exception $e) {
            $code = $e->getCode() === 400 ? 400 : 500;
            http_response_code($code);
            error_log("API Error (getAbsencesApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }

    /**
     * API: Erstellt oder aktualisiert eine Abwesenheit.
     */
    public function saveAbsenceApi()
    {
        Security::requireRole(['admin', 'planer']);
        Security::verifyCsrfToken();
        header('Content-Type: application/json');

        try {
            $data = json_decode(file_get_contents('php://input'), true);

            // KORREKTUR: absence_id für Updates/Erstellung
            $absenceId = filter_var($data['absence_id'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $teacherId = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $startDate = $data['start_date'] ?? null;
            $endDate = $data['end_date'] ?? null;
            $reason = trim($data['reason'] ?? '');
            $comment = isset($data['comment']) ? trim($data['comment']) : null;

            if (!$teacherId || !$startDate || !$endDate || empty($reason)) {
                throw new Exception("Fehlende Daten: Lehrer, Start, Ende und Grund sind erforderlich.", 400);
            }
            if (DateTime::createFromFormat('Y-m-d', $startDate) === false || DateTime::createFromFormat('Y-m-d', $endDate) === false) {
                throw new Exception("Ungültiges Datumsformat.", 400);
            }
            if ($endDate < $startDate) {
                throw new Exception("Enddatum muss nach dem Startdatum liegen.", 400);
            }

            // Hole die gültigen Typen
            $validTypes = $this->absenceRepo->getAbsenceTypes();
            if (!in_array($reason, $validTypes)) {
                throw new Exception("Ungültiger Abwesenheitsgrund.", 400);
            }

            // KORREKTUR: Übergibt die absenceId (kann null sein) an die Repository-Methode
            // Die Methode gibt den vollständigen, gespeicherten Datensatz zurück.
            $savedAbsence = $this->absenceRepo->createAbsence($absenceId, $teacherId, $startDate, $endDate, $reason, $comment);
            $newId = $savedAbsence['absence_id'];

            AuditLogger::log(
                $absenceId ? 'update_absence' : 'create_absence',
                'teacher_absence',
                $newId,
                [
                    'teacher_id' => $teacherId,
                    'start_date' => $startDate,
                    'end_date' => $endDate,
                    'reason' => $reason
                ]
            );

            // KORREKTUR: $newAbsence ist bereits $savedAbsence
            echo json_encode(['success' => true, 'message' => 'Abwesenheit gespeichert.', 'data' => $savedAbsence]);

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (saveAbsenceApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }

    /**
     * API: Löscht eine Abwesenheit.
     */
    public function deleteAbsenceApi()
    {
        Security::requireRole(['admin', 'planer']);
        Security::verifyCsrfToken();
        header('Content-Type: application/json');

        try {
            $data = json_decode(file_get_contents('php://input'), true);
            $absenceId = filter_var($data['absence_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$absenceId) {
                throw new Exception("Fehlende Abwesenheits-ID.", 400);
            }

            // Hole Daten für das Log, bevor gelöscht wird
            $absence = $this->absenceRepo->getAbsenceById($absenceId);
            if (!$absence) {
                throw new Exception("Abwesenheit nicht gefunden.", 404);
            }

            $success = $this->absenceRepo->deleteAbsence($absenceId);

            if ($success) {
                AuditLogger::log(
                    'delete_absence',
                    'teacher_absence',
                    $absenceId,
                    [
                        'teacher_id' => $absence['teacher_id'],
                        'reason' => $absence['reason'],
                        'start_date' => $absence['start_date']
                    ]
                );
                echo json_encode(['success' => true, 'message' => 'Abwesenheit gelöscht.']);
            } else {
                throw new Exception("Abwesenheit konnte nicht gelöscht werden.", 500);
            }

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (deleteAbsenceApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Planer\AbsenceController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Planer\PlanController.php ---
<?php
// app/Http/Controllers/Planer/PlanController.php
namespace App\Http\Controllers\Planer;

use App\Core\Security;
use App\Core\Database;
use App\Repositories\PlanRepository;
use App\Repositories\StammdatenRepository;
use App\Repositories\TeacherAbsenceRepository; // NEU: Import
use Exception;
use PDO;
use DateTime;
use DateTimeZone; // Added explicit use
use App\Services\AuditLogger; // NEU: AuditLogger importieren

class PlanController
{
    private PDO $pdo;
    private PlanRepository $planRepository;
    private StammdatenRepository $stammdatenRepository; // <-- Deklaration
    private TeacherAbsenceRepository $absenceRepo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->planRepository = new PlanRepository($this->pdo);
        $this->stammdatenRepository = new StammdatenRepository($this->pdo); // <-- Initialisierung
        $this->absenceRepo = new TeacherAbsenceRepository($this->pdo);
    }

    public function index()
    {
        Security::requireRole(['planer', 'admin']);
        global $config;
        $config = Database::getConfig();
        $page_title = 'Stundenplan-Verwaltung';
        $body_class = 'planer-dashboard-body';
        // Ensure CSRF token is generated for forms/API calls on this page
        Security::getCsrfToken();
        include_once dirname(__DIR__, 4) . '/pages/planer/dashboard.php';
    }

     // --- API Helper ---
     /**
     * Helper to wrap common API request logic (auth, CSRF, response type, error handling)
     * @param callable $callback The actual logic to execute (sollte ein Array zurückgeben)
     * @param string $actionName Der Name der Aktion für das Audit-Log (z.B. 'create_entry')
     * @param string $targetType Der Typ des Ziels (z.B. 'timetable_entry')
     * @param bool $isGetRequest Ob es sich um eine GET-Anfrage handelt (Callback macht eigenen Echo)
     */
    private function handleApiRequest(callable $callback, string $actionName = '', string $targetType = '', bool $isGetRequest = false): void
    {
        header('Content-Type: application/json'); // Set header early
        try {
            if (!$isGetRequest) {
                Security::verifyCsrfToken(); // Verify CSRF token for non-GET requests
            }
            
            // Callback ausführen
            $result = $callback(); 

            if ($isGetRequest) {
                // GET request: Callback kümmert sich selbst um den Echo (wie bei getTimetableData)
                // $result ist in diesem Fall void
            } else {
                // POST/Modifying request: Callback hat Daten zurückgegeben
                // Aktion protokollieren
                if ($actionName) {
                    AuditLogger::log(
                        $actionName,
                        $targetType,
                        $result['log_target_id'] ?? null, // Spezifischer Schlüssel für die ID
                        $result['log_details'] ?? null    // Spezifischer Schlüssel für Details
                    );
                }

                // JSON-Antwort aus dem Ergebnis senden
                echo json_encode($result['json_response'], JSON_THROW_ON_ERROR);
            }

        } catch (Exception $e) {
            // Determine appropriate status code
            // *** UPDATED: Handle conflict exception (409) specifically ***
            $statusCode = 400; // Default Bad Request
            if (str_contains($e->getMessage(), 'CSRF')) {
                $statusCode = 403; // Forbidden
            } elseif (str_contains($e->getMessage(), 'KONFLIKT') || str_contains($e->getMessage(), 'Konflikt')) {
                $statusCode = 409; // Conflict
            } elseif (str_contains($e->getMessage(), 'existiert bereits')) { // Spezifischer Fehler für Vorlagenname
                $statusCode = 409; // Conflict
            }
            
            http_response_code($statusCode);
            
            echo json_encode(['success' => false, 'message' => $e->getMessage()], JSON_THROW_ON_ERROR);
        }
        exit();
    }


    /**
     * API: Holt Stundenplan-Daten für den Planer (Klassen ODER Lehrer).
     * Inklusive Stammdaten und Veröffentlichungsstatus. (GET request - no CSRF needed)
     */
    public function getTimetableData()
    {
        Security::requireRole(['planer', 'admin']);
        // Definiere Callback innerhalb der Methode, um auf $this zuzugreifen
        $callback = function() {
             $classId = filter_input(INPUT_GET, 'class_id', FILTER_VALIDATE_INT);
             $teacherId = filter_input(INPUT_GET, 'teacher_id', FILTER_VALIDATE_INT);
             $year = filter_input(INPUT_GET, 'year', FILTER_VALIDATE_INT);
             $calendarWeek = filter_input(INPUT_GET, 'week', FILTER_VALIDATE_INT);
             $date = $_GET['date'] ?? null; // For daily substitution display in planner

             if ($date && (DateTime::createFromFormat('Y-m-d', $date) === false)) {
                 throw new Exception("Ungültiges Datumsformat. Bitte YYYY-MM-DD verwenden.");
             }

             // Fetch base data (classes, teachers, etc.) only if needed or if no specific plan is requested
             $baseData = [];
             $absencesData = []; // NEU: Abwesenheiten initialisieren
             
             // KORREKTUR: Lade Stammdaten + Abwesenheiten (für Initial-Load)
             if (!$classId && !$teacherId && !$year && !$calendarWeek) { 
                 // KORREKTUR: Verwende $this->stammdatenRepository statt $this->stammdatenRepo
                 $baseData = [
                     'classes' => $this->stammdatenRepository->getClasses(),
                     'teachers' => $this->stammdatenRepository->getTeachers(),
                     'subjects' => $this->stammdatenRepository->getSubjects(),
                     'rooms' => $this->stammdatenRepository->getRooms(),
                     'templates' => $this->planRepository->getTemplates(), 
                 ];
                 // Lade Abwesenheiten für die nächsten Monate (z.B.)
                 $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                 $startDate = $today->format('Y-m-01');
                 $endDate = $today->modify('+3 months')->format('Y-m-t');
                 $absencesData = $this->absenceRepo->getAbsencesForDateRange($startDate, $endDate);
                 $baseData['absences'] = $absencesData; // Füge Abwesenheiten zu Stammdaten hinzu
             }

             $timetable = [];
             $substitutions = [];
             $publishStatus = ['student' => false, 'teacher' => false]; // Default

             // If a specific entity (class or teacher) is selected and year/week are provided
             if (($classId || $teacherId) && $year && $calendarWeek) {
                 $publishStatus = $this->planRepository->getPublishStatus($year, $calendarWeek);

                 if ($classId) {
                     $timetable = $this->planRepository->getTimetableForClassAsPlaner($classId, $year, $calendarWeek);
                     $substitutions = $this->planRepository->getSubstitutionsForClassWeekAsPlaner($classId, $year, $calendarWeek);
                 } elseif ($teacherId) {
                     $timetable = $this->planRepository->getTimetableForTeacherAsPlaner($teacherId, $year, $calendarWeek);
                     $substitutions = $this->planRepository->getSubstitutionsForTeacherWeekAsPlaner($teacherId, $year, $calendarWeek);
                 }
                 
                 // NEU: Lade Abwesenheiten für die ausgewählte Woche
                 $dto = new DateTime();
                 $dto->setISODate($year, $calendarWeek, 1);
                 $startDate = $dto->format('Y-m-d');
                 $dto->setISODate($year, $calendarWeek, 7); // Bis Sonntag
                 $endDate = $dto->format('Y-m-d');
                 $absencesData = $this->absenceRepo->getAbsencesForDateRange($startDate, $endDate);

             } elseif (($classId || $teacherId) && (!$year || !$calendarWeek)) {
                 // Fallback to current week if year/week are missing but entity is selected
                 $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                 $year = (int)$today->format('o');
                 $calendarWeek = (int)$today->format('W');
                 $publishStatus = $this->planRepository->getPublishStatus($year, $calendarWeek);

                 if ($classId) {
                     $timetable = $this->planRepository->getTimetableForClassAsPlaner($classId, $year, $calendarWeek);
                     $substitutions = $this->planRepository->getSubstitutionsForClassWeekAsPlaner($classId, $year, $calendarWeek);
                 } elseif ($teacherId) {
                     $timetable = $this->planRepository->getTimetableForTeacherAsPlaner($teacherId, $year, $calendarWeek);
                     $substitutions = $this->planRepository->getSubstitutionsForTeacherWeekAsPlaner($teacherId, $year, $calendarWeek);
                 }
                 
                 // NEU: Lade Abwesenheiten auch hier
                 $dto = new DateTime();
                 $dto->setISODate($year, $calendarWeek, 1);
                 $startDate = $dto->format('Y-m-d');
                 $dto->setISODate($year, $calendarWeek, 7);
                 $endDate = $dto->format('Y-m-d');
                 $absencesData = $this->absenceRepo->getAbsencesForDateRange($startDate, $endDate);
             }


             echo json_encode(['success' => true, 'data' => array_merge($baseData, [
                 'timetable' => $timetable,
                 'substitutions' => $substitutions,
                 'publishStatus' => $publishStatus,
                 'absences' => $absencesData // NEU: Abwesenheiten immer mitsenden
             ])], JSON_THROW_ON_ERROR);
        };
        // Führe den Callback mit dem API Request Handler aus (GET Request)
        $this->handleApiRequest($callback, '', '', true); // true = $isGetRequest
    }


    // --- Methoden zum Speichern/Löschen (POST requests) ---
    public function saveEntry()
    {
        Security::requireRole(['planer', 'admin']);
        $this->handleApiRequest(function() {
            $data = json_decode(file_get_contents('php://input'), true, 512, JSON_THROW_ON_ERROR);
            if (!$data) throw new Exception("Ungültige Daten empfangen.");
            // The createOrUpdateEntry now potentially returns data (like generated block_id)
            $resultData = $this->planRepository->createOrUpdateEntry($data);
            
            return [
                'json_response' => ['success' => true, 'message' => 'Eintrag erfolgreich gespeichert.', 'data' => $resultData],
                'log_target_id' => $data['entry_id'] ?? $resultData['entry_ids'][0] ?? null,
                'log_details' => $data // Logge die übermittelten Daten
            ];
        }, 'save_entry', 'timetable_entry');
    }

    public function deleteEntry()
    {
        Security::requireRole(['planer', 'admin']);
        $this->handleApiRequest(function() {
            $data = json_decode(file_get_contents('php://input'), true, 512, JSON_THROW_ON_ERROR);
            $entryId = $data['entry_id'] ?? null;
            $blockId = $data['block_id'] ?? null;
            $logTargetId = null;
            $logDetails = $data;

            if ($blockId) {
                $this->planRepository->deleteEntryBlock($blockId);
                $message = 'Block erfolgreich gelöscht.';
                $logTargetId = $blockId; // Logge die Block-ID
            } elseif ($entryId && filter_var($entryId, FILTER_VALIDATE_INT)) {
                $this->planRepository->deleteEntry((int)$entryId);
                $message = 'Eintrag erfolgreich gelöscht.';
                $logTargetId = $entryId; // Logge die Entry-ID
            } else {
                throw new Exception("Ungültige Eintrags- oder Block-ID.");
            }

            return [
                'json_response' => ['success' => true, 'message' => $message],
                'log_target_id' => $logTargetId,
                'log_details' => $logDetails
            ];
        }, 'delete_entry', 'timetable_entry');
    }

    public function saveSubstitution()
    {
        Security::requireRole(['planer', 'admin']);
        $this->handleApiRequest(function() {
            $data = json_decode(file_get_contents('php://input'), true, 512, JSON_THROW_ON_ERROR);
            if (!$data) throw new Exception("Ungültige Daten empfangen.");
            $resultData = $this->planRepository->createOrUpdateSubstitution($data);
            
            return [
                'json_response' => ['success' => true, 'message' => 'Vertretung erfolgreich gespeichert.', 'data' => $resultData],
                'log_target_id' => $resultData['substitution_id'] ?? $data['substitution_id'] ?? null,
                'log_details' => $data
            ];
        }, 'save_substitution', 'substitution');
    }

    public function deleteSubstitution()
    {
        Security::requireRole(['planer', 'admin']);
        $this->handleApiRequest(function() {
            $data = json_decode(file_get_contents('php://input'), true, 512, JSON_THROW_ON_ERROR);
            $id = $data['substitution_id'] ?? null;
            if (!filter_var($id, FILTER_VALIDATE_INT)) throw new Exception("Ungültige Vertretungs-ID.");
            $this->planRepository->deleteSubstitution((int)$id);
            
            return [
                'json_response' => ['success' => true, 'message' => 'Vertretung erfolgreich gelöscht.'],
                'log_target_id' => $id,
                'log_details' => $data
            ];
        }, 'delete_substitution', 'substitution');
    }

    // --- Methoden für Veröffentlichung (POST requests) ---

    public function publish()
    {
        Security::requireRole(['planer', 'admin']);
        $this->handleApiRequest(function() {
            $data = json_decode(file_get_contents('php://input'), true, 512, JSON_THROW_ON_ERROR);
            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $week = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);
            $target = $data['target'] ?? null; // 'student' or 'teacher'
            $userId = $_SESSION['user_id'];

            if (!$year || !$week || !in_array($target, ['student', 'teacher'])) {
                throw new Exception("Ungültige Parameter für Veröffentlichung.");
            }

            $success = $this->planRepository->publishWeek($year, $week, $target, $userId);

            if ($success) {
                $newStatus = $this->planRepository->getPublishStatus($year, $week); // Get updated status
                return [
                    'json_response' => [
                        'success' => true,
                        'message' => "Stundenplan KW $week/$year für " . ($target === 'student' ? 'Schüler' : 'Lehrer') . " veröffentlicht.",
                        'data' => ['publishStatus' => $newStatus] // Send updated status back
                    ],
                    'log_target_id' => null, // No specific entry ID
                    'log_details' => ['year' => $year, 'week' => $week, 'target' => $target]
                ];
            } else {
                throw new Exception("Veröffentlichung fehlgeschlagen.");
            }
        }, 'publish_week', 'system');
    }


    public function unpublish()
    {
        Security::requireRole(['planer', 'admin']);
        $this->handleApiRequest(function() {
            $data = json_decode(file_get_contents('php://input'), true, 512, JSON_THROW_ON_ERROR);
            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $week = filter_var($data['week'] ?? null, FILTER_VALIDATE_INT);
            $target = $data['target'] ?? null;

            if (!$year || !$week || !in_array($target, ['student', 'teacher'])) {
                throw new Exception("Ungültige Parameter.");
            }

            $success = $this->planRepository->unpublishWeek($year, $week, $target);

            if ($success) {
                 $newStatus = $this->planRepository->getPublishStatus($year, $week); // Get updated status
                return [
                    'json_response' => [
                        'success' => true,
                        'message' => "Veröffentlichung KW $week/$year für " . ($target === 'student' ? 'Schüler' : 'Lehrer') . " zurückgenommen.",
                        'data' => ['publishStatus' => $newStatus] // Send updated status back
                    ],
                    'log_target_id' => null,
                    'log_details' => ['year' => $year, 'week' => $week, 'target' => $target]
                ];
            } else {
                throw new Exception("Zurücknahme fehlgeschlagen.");
            }
        }, 'unpublish_week', 'system');
    }

     /**
     * API: Holt den aktuellen Veröffentlichungsstatus für eine Woche.
     * (GET request - no CSRF needed)
     */
     public function getStatus() {
         Security::requireRole(['planer', 'admin']);
         $callback = function() {
             $year = filter_input(INPUT_GET, 'year', FILTER_VALIDATE_INT);
             $week = filter_input(INPUT_GET, 'week', FILTER_VALIDATE_INT);

             if (!$year || !$week) {
                 throw new Exception("Jahr und Woche erforderlich.");
             }
             $status = $this->planRepository->getPublishStatus($year, $week);
             echo json_encode(['success' => true, 'data' => ['publishStatus' => $status]], JSON_THROW_ON_ERROR); // Wrap status
         };
         $this->handleApiRequest($callback, '', '', true); // Mark as GET request
     }

    /**
     * API-Endpunkt für die Echtzeit-Konfliktprüfung.
     * handleApiRequest fängt die Exception vom Repository (falls Konflikte)
     * und gibt einen 409-Statuscode mit den Konfliktmeldungen zurück.
     */
    public function checkConflictsApi()
    {
        Security::requireRole(['planer', 'admin']);
        
        // Verwende handleApiRequest für CSRF und Fehlerbehandlung, aber protokolliere diese Lese-Aktion nicht.
        $this->handleApiRequest(function() {
            $data = json_decode(file_get_contents('php://input'), true, 512, JSON_THROW_ON_ERROR);
            if (!$data) {
                throw new Exception("Keine Daten für Konfliktprüfung empfangen.");
            }

            // Validierung (einfach)
            if (empty($data['year']) || empty($data['calendar_week']) || empty($data['day_of_week']) || empty($data['start_period_number']) || empty($data['end_period_number'])) {
                throw new Exception("Unvollständige Daten für Konfliktprüfung.");
            }
            // class_id '0' oder null ist im Lehrermodus erlaubt
            if (!isset($data['class_id'])) {
                throw new Exception("Fehlende class_id für Konfliktprüfung.");
            }

            $excludeEntryId = !empty($data['entry_id']) ? (int)$data['entry_id'] : null;
            $excludeBlockId = !empty($data['block_id']) ? (string)$data['block_id'] : null;

            // Ruft die Repository-Methode auf.
            // Diese wirft bei Konflikten eine Exception, die von handleApiRequest gefangen wird.
            $conflicts = $this->planRepository->checkConflicts($data, $excludeEntryId, $excludeBlockId);

            // Wenn checkConflicts *keine* Exception wirft, gab es keine Konflikte.
            return [
                'json_response' => ['success' => true, 'conflicts' => []]
                // Keine Log-Infos, da dies eine Lese-Aktion ist
            ];
        }); // Keine Log-Parameter übergeben
    }

    /**
     * API-Endpunkt zum Kopieren einer Woche.
     */
    public function copyWeek()
    {
        Security::requireRole(['planer', 'admin']);
        // Dies ist KEINE GET-Anfrage, CSRF wird in handleApiRequest geprüft
        $this->handleApiRequest(function() {
            $data = json_decode(file_get_contents('php://input'), true, 512, JSON_THROW_ON_ERROR);

            // Validierung der Eingabedaten
            $sourceYear = filter_var($data['sourceYear'] ?? null, FILTER_VALIDATE_INT);
            $sourceWeek = filter_var($data['sourceWeek'] ?? null, FILTER_VALIDATE_INT);
            $targetYear = filter_var($data['targetYear'] ?? null, FILTER_VALIDATE_INT);
            $targetWeek = filter_var($data['targetWeek'] ?? null, FILTER_VALIDATE_INT);
            $classId = filter_var($data['classId'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $teacherId = filter_var($data['teacherId'] ?? null, FILTER_VALIDATE_INT) ?: null;

            if (!$sourceYear || !$sourceWeek || !$targetYear || !$targetWeek) {
                throw new Exception("Quell- und Zielwoche sind erforderlich.");
            }
            if ($classId === null && $teacherId === null) {
                throw new Exception("Klasse oder Lehrer erforderlich.");
            }

            // Aufruf der Repository-Methode
            $copiedCount = $this->planRepository->copyWeekData(
                $sourceYear,
                $sourceWeek,
                $targetYear,
                $targetWeek,
                $classId,
                $teacherId
            );

            return [
                'json_response' => [
                    'success' => true,
                    'message' => "Woche erfolgreich kopiert. {$copiedCount} Einträge wurden in KW {$targetWeek}/{$targetYear} eingefügt.",
                    'copiedCount' => $copiedCount
                ],
                'log_target_id' => null, // Kein spezifisches Objekt, Systemaktion
                'log_details' => $data // Logge die Quell- und Zieldaten
            ];
        }, 'copy_week', 'system');
    }

    // --- NEUE API METHODEN FÜR VORLAGEN ---

    /**
     * API: Holt alle verfügbaren Vorlagen (GET - no CSRF needed).
     */
    public function getTemplates()
    {
        Security::requireRole(['planer', 'admin']);
        $this->handleApiRequest(function() {
            $templates = $this->planRepository->getTemplates();
            echo json_encode(['success' => true, 'data' => $templates], JSON_THROW_ON_ERROR);
        }, '', '', true); // Mark as GET request
    }

    /**
     * API: Erstellt eine neue Vorlage aus der aktuell angezeigten Woche (POST).
     */
    public function createTemplate()
    {
        Security::requireRole(['planer', 'admin']);
        $this->handleApiRequest(function() {
            $data = json_decode(file_get_contents('php://input'), true, 512, JSON_THROW_ON_ERROR);

            $name = trim($data['name'] ?? '');
            $description = trim($data['description'] ?? '') ?: null;
            $sourceYear = filter_var($data['sourceYear'] ?? null, FILTER_VALIDATE_INT);
            $sourceWeek = filter_var($data['sourceWeek'] ?? null, FILTER_VALIDATE_INT);
            $sourceClassId = filter_var($data['sourceClassId'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $sourceTeacherId = filter_var($data['sourceTeacherId'] ?? null, FILTER_VALIDATE_INT) ?: null;

            if (empty($name) || !$sourceYear || !$sourceWeek || ($sourceClassId === null && $sourceTeacherId === null)) {
                throw new Exception("Ungültige Daten zum Erstellen der Vorlage.");
            }

            // Quelldaten holen
            $sourceEntries = [];
            if ($sourceClassId) {
                $sourceEntries = $this->planRepository->getTimetableForClassAsPlaner($sourceClassId, $sourceYear, $sourceWeek);
            } elseif ($sourceTeacherId) {
                $sourceEntries = $this->planRepository->getTimetableForTeacherAsPlaner($sourceTeacherId, $sourceYear, $sourceWeek);
            }

            if (empty($sourceEntries)) {
                throw new Exception("Keine Stundenplandaten in der Quellwoche gefunden, um die Vorlage zu erstellen.");
            }

            // Vorlage erstellen
            $newTemplateId = $this->planRepository->createTemplate($name, $description, $sourceEntries);

            return [
                'json_response' => [
                    'success' => true,
                    'message' => "Vorlage '{$name}' erfolgreich erstellt.",
                    'data' => ['template_id' => $newTemplateId, 'name' => $name, 'description' => $description] // Neue Vorlage zurückgeben
                ],
                'log_target_id' => $newTemplateId,
                'log_details' => $data
            ];
        }, 'create_template_from_week', 'template');
    }

    /**
     * API: Wendet eine Vorlage auf die aktuell ausgewählte Woche an (POST).
     */
    public function applyTemplate()
    {
        Security::requireRole(['planer', 'admin']);
        $this->handleApiRequest(function() {
            $data = json_decode(file_get_contents('php://input'), true, 512, JSON_THROW_ON_ERROR);

            $templateId = filter_var($data['templateId'] ?? null, FILTER_VALIDATE_INT);
            $targetYear = filter_var($data['targetYear'] ?? null, FILTER_VALIDATE_INT);
            $targetWeek = filter_var($data['targetWeek'] ?? null, FILTER_VALIDATE_INT);
            $targetClassId = filter_var($data['targetClassId'] ?? null, FILTER_VALIDATE_INT) ?: null;
            $targetTeacherId = filter_var($data['targetTeacherId'] ?? null, FILTER_VALIDATE_INT) ?: null;

            if (!$templateId || !$targetYear || !$targetWeek || ($targetClassId === null && $targetTeacherId === null)) {
                throw new Exception("Ungültige Daten zum Anwenden der Vorlage.");
            }

            // Vorlage anwenden
            $appliedCount = $this->planRepository->applyTemplateToWeek(
                $templateId,
                $targetYear,
                $targetWeek,
                $targetClassId,
                $targetTeacherId
            );
            
            return [
                'json_response' => [
                    'success' => true,
                    'message' => "Vorlage erfolgreich angewendet. {$appliedCount} Einträge wurden in KW {$targetWeek}/{$targetYear} eingefügt.",
                    'appliedCount' => $appliedCount
                ],
                'log_target_id' => $templateId,
                'log_details' => $data
            ];
        }, 'apply_template', 'template');
    }

    /**
     * API: Löscht eine Vorlage (POST).
     */
    public function deleteTemplate()
    {
        Security::requireRole(['planer', 'admin']);
        $this->handleApiRequest(function() {
            $data = json_decode(file_get_contents('php://input'), true, 512, JSON_THROW_ON_ERROR);
            $templateId = filter_var($data['templateId'] ?? null, FILTER_VALIDATE_INT);

            if (!$templateId) {
                throw new Exception("Ungültige Vorlagen-ID.");
            }

            $success = $this->planRepository->deleteTemplate($templateId);

            if ($success) {
                return [
                    'json_response' => ['success' => true, 'message' => 'Vorlage erfolgreich gelöscht.'],
                    'log_target_id' => $templateId,
                    'log_details' => $data
                ];
            } else {
                throw new Exception("Fehler beim Löschen der Vorlage.");
            }
        }, 'delete_template', 'template');
    }
    
    /**
     * API: Lädt die Details (Stammdaten + Einträge) einer einzelnen Vorlage.
     * (GET request)
     */
    public function getTemplateDetails(int $templateId)
    {
        Security::requireRole(['planer', 'admin']);
        // Verwende den GET-Modus des Helpers (true)
        $this->handleApiRequest(function() use ($templateId) {
            $details = $this->planRepository->loadTemplateDetails($templateId);
            echo json_encode(['success' => true, 'data' => $details], JSON_THROW_ON_ERROR);
        }, '', '', true);
    }
    
    /**
     * API: Speichert eine Vorlage (neu oder Update) aus dem Editor.
     * (POST request)
     */
    public function saveTemplateDetails()
    {
        Security::requireRole(['planer', 'admin']);
        
        $this->handleApiRequest(function() {
            $data = json_decode(file_get_contents('php://input'), true, 512, JSON_THROW_ON_ERROR);
            
            // Validierung im Controller, bevor es an das Repo geht
            if (empty($data['name'])) {
                throw new Exception("Vorlagenname darf nicht leer sein.");
            }

            $savedTemplate = $this->planRepository->saveTemplateDetails($data);
            
            $action = empty($data['template_id']) ? 'create_template' : 'update_template';

            return [
                'json_response' => [
                    'success' => true,
                    'message' => 'Vorlage erfolgreich gespeichert.',
                    'data' => $savedTemplate // Gibt die gespeicherten Stammdaten (mit ID) zurück
                ],
                'log_target_id' => $savedTemplate['template_id'],
                'log_details' => [
                    'name' => $savedTemplate['name'],
                    'description' => $savedTemplate['description'],
                    'entries_count' => count($data['entries'] ?? [])
                ]
            ];

        }, 'save_template_details', 'template'); // Aktion wird intern bestimmt, Logging hier allgemein
    }


    // --- ENDE NEUE API METHODEN FÜR VORLAGEN ---
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\Planer\PlanController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\AcademicEventController.php ---
<?php
// app/Http/Controllers/AcademicEventController.php

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\AcademicEventRepository;
use App\Repositories\UserRepository;
use App\Repositories\StammdatenRepository; // NEU: Für Fächer etc. im Formular
use App\Services\AuditLogger;
use Exception;
use PDO;
use DateTime;
use DateTimeZone;

class AcademicEventController
{
    private PDO $pdo;
    private AcademicEventRepository $eventRepo;
    private UserRepository $userRepo;
    private StammdatenRepository $stammdatenRepo; // NEU

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->eventRepo = new AcademicEventRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
        $this->stammdatenRepo = new StammdatenRepository($this->pdo); // NEU
    }

    /**
     * API: Holt Events für den eingeloggten Schüler für eine bestimmte Woche.
     */
    public function getForStudent()
    {
        Security::requireRole('schueler');
        header('Content-Type: application/json');

        try {
            $userId = $_SESSION['user_id'];
            $user = $this->userRepo->findById($userId);
            if (!$user || !$user['class_id']) {
                throw new Exception("Schülerdaten unvollständig (Klasse fehlt).", 400);
            }
            $classId = $user['class_id'];

            $year = filter_input(INPUT_GET, 'year', FILTER_VALIDATE_INT);
            $week = filter_input(INPUT_GET, 'week', FILTER_VALIDATE_INT);

            if (!$year || !$week) {
                 $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                 $year = (int)$today->format('o'); // ISO year
                 $week = (int)$today->format('W'); // ISO week
            }

            $events = $this->eventRepo->getEventsForClassByWeek($classId, $year, $week);

            echo json_encode(['success' => true, 'data' => $events]);

        } catch (Exception $e) {
            $code = $e->getCode() === 400 ? 400 : 500;
            http_response_code($code);
            error_log("API Error (getForStudent): " . $e->getMessage()); // Log detailed error
            echo json_encode(['success' => false, 'message' => 'Fehler beim Laden der Termine: ' . $e->getMessage()]);
        }
        exit();
    }

    /**
     * API: Holt Events, die vom eingeloggten Lehrer erstellt wurden (für die nächsten 14 Tage).
     */
    public function getForTeacher()
    {
        Security::requireRole('lehrer');
        header('Content-Type: application/json');

        try {
            $userId = $_SESSION['user_id'];
            // Kein zusätzlicher User-Check nötig, da requireRole prüft
            $daysInFuture = 14; // Standardmäßig die nächsten 14 Tage

            $events = $this->eventRepo->getEventsByTeacher($userId, $daysInFuture);

            echo json_encode(['success' => true, 'data' => $events]);

        } catch (Exception $e) {
            http_response_code(500);
            error_log("API Error (getForTeacher): " . $e->getMessage()); // Log detailed error
            echo json_encode(['success' => false, 'message' => 'Fehler beim Laden Ihrer Einträge: ' . $e->getMessage()]);
        }
        exit();
    }

    /**
     * API: Erstellt oder aktualisiert ein Event (Aufgabe/Klausur/Info).
     * Nur für Lehrer.
     */
    public function createOrUpdate()
    {
        Security::requireRole('lehrer');
        Security::verifyCsrfToken();
        header('Content-Type: application/json');

        try {
            $userId = $_SESSION['user_id'];
            $user = $this->userRepo->findById($userId); // Hole Lehrerdaten für teacher_id
            if (!$user || !$user['teacher_id']) {
                throw new Exception("Lehrerprofil nicht gefunden.", 403);
            }
            $teacherId = $user['teacher_id']; // teacher_id aus teachers Tabelle

            $data = json_decode(file_get_contents('php://input'), true);
            if (json_last_error() !== JSON_ERROR_NONE) {
                throw new Exception("Ungültige Daten (JSON) empfangen.", 400);
            }

            // Validierung der Eingaben
            $eventId = filter_var($data['event_id'] ?? null, FILTER_VALIDATE_INT) ?: null; // Optional für Update
            $classId = filter_var($data['class_id'] ?? null, FILTER_VALIDATE_INT);
            $subjectId = filter_var($data['subject_id'] ?? null, FILTER_VALIDATE_INT) ?: null; // Optional
            $eventType = $data['event_type'] ?? null;
            $title = trim($data['title'] ?? '');
            $dueDate = $data['due_date'] ?? null;
            // KORREKTUR: period_number entfernt
            // $period = filter_var($data['period_number'] ?? null, FILTER_VALIDATE_INT) ?: null; // Optional
            $description = isset($data['description']) ? trim($data['description']) : null;

            if (!$classId || !$eventType || empty($title) || !$dueDate || !in_array($eventType, ['aufgabe', 'klausur', 'info'])) {
                throw new Exception("Fehlende oder ungültige Pflichtfelder (Typ, Klasse, Titel, Datum).", 400);
            }
            if (DateTime::createFromFormat('Y-m-d', $dueDate) === false) {
                 throw new Exception("Ungültiges Datumsformat. Bitte YYYY-MM-DD verwenden.", 400);
            }

            // Berechtigungsprüfung: Darf der Lehrer für diese Klasse/Datum erstellen?
            if (!$this->eventRepo->checkTeacherAuthorization($teacherId, $classId, $dueDate)) {
                 error_log("Hinweis: Lehrer {$userId} erstellt Event für Klasse {$classId} an Datum {$dueDate} ohne expliziten Unterrichtsnachweis.");
            }

            // KORREKTUR: Parameter $period entfernt
            $savedEvent = $this->eventRepo->saveEvent(
                $eventId,
                $userId, // Wichtig: Die user_id des Lehrers, nicht die teacher_id
                $classId,
                $subjectId,
                $eventType,
                $title,
                $dueDate,
                $description
            );

            // Logging
            $action = $eventId ? 'update_event' : 'create_event';
            AuditLogger::log($action, 'academic_event', $savedEvent['event_id'], [
                'type' => $eventType,
                'title' => $title,
                'class_id' => $classId,
                'due_date' => $dueDate
            ]);


            echo json_encode([
                'success' => true,
                'message' => 'Eintrag erfolgreich ' . ($eventId ? 'aktualisiert' : 'erstellt') . '.',
                'data' => $savedEvent // Gibt das gespeicherte Event zurück
            ]);

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (createOrUpdate Event): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }

    /**
     * API: Löscht ein Event.
     * Nur für den erstellenden Lehrer.
     */
    public function delete()
    {
        Security::requireRole('lehrer');
        Security::verifyCsrfToken();
        header('Content-Type: application/json');

        try {
            $userId = $_SESSION['user_id'];

            $data = json_decode(file_get_contents('php://input'), true);
            $eventId = filter_var($data['event_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$eventId) {
                throw new Exception("Keine Event-ID angegeben.", 400);
            }

            // Hole Event-Details vor dem Löschen für das Logging
            $eventToDelete = $this->eventRepo->getEventById($eventId);

            $success = $this->eventRepo->deleteEvent($eventId, $userId);

            if ($success) {
                AuditLogger::log('delete_event', 'academic_event', $eventId, [
                     'title' => $eventToDelete['title'] ?? 'N/A',
                     'type' => $eventToDelete['event_type'] ?? 'N/A',
                     'class_id' => $eventToDelete['class_id'] ?? 'N/A',
                     'due_date' => $eventToDelete['due_date'] ?? 'N/A'
                 ]);
                echo json_encode(['success' => true, 'message' => 'Eintrag erfolgreich gelöscht.']);
            } else {
                throw new Exception("Eintrag konnte nicht gelöscht werden (nicht gefunden oder keine Berechtigung).", 404);
            }

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
             // Spezifische Behandlung für 403 oder 404 aus dem Repository
            if (str_contains($e->getMessage(), 'Berechtigung') || str_contains($e->getMessage(), 'Authorization')) {
                $code = 403;
            } elseif (str_contains($e->getMessage(), 'gefunden') || str_contains($e->getMessage(), 'found')) {
                $code = 404;
            }
            http_response_code($code);
            error_log("API Error (delete Event): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\AcademicEventController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\AnnouncementController.php ---
<?php
// app/Http/Controllers/AnnouncementController.php

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\AnnouncementRepository;
use App\Repositories\UserRepository;
use Exception;
use PDO;
use \Parsedown; // KORREKTUR: Parsedown aus dem globalen Namespace importieren
use App\Services\AuditLogger; 

class AnnouncementController
{
    private PDO $pdo;
    private AnnouncementRepository $announcementRepo;
    private UserRepository $userRepo;
    private Parsedown $parsedown; // KORREKTUR: Typehint kann jetzt ohne Backslash sein

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->announcementRepo = new AnnouncementRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
        $this->parsedown = new Parsedown(); // KORREKTUR: Kann jetzt direkt verwendet werden
        $this->parsedown->setSafeMode(true); 
    }

     // --- API Helper ---
     /**
     * Helper to wrap common API request logic (auth, CSRF, response type, error handling)
     * @param callable $callback The actual logic to execute
     * @param string $actionName Der Name der Aktion für das Audit-Log (z.B. 'create_announcement')
     * @param string $targetType Der Typ des Ziels (z.B. 'announcement')
     * @param bool $isGetRequest Ob es sich um eine GET-Anfrage handelt (kein CSRF-Check)
     */
    private function handleApiRequest(callable $callback, string $actionName = '', string $targetType = '', bool $isGetRequest = false): void
    {
        header('Content-Type: application/json');
        try {
            if (!$isGetRequest) {
                 Security::verifyCsrfToken();
            }
            
            // Führe die eigentliche Aktion aus
            $result = $callback(); // Callback gibt jetzt ggf. Daten zurück

            // Protokollierung bei Erfolg (nur wenn actionName gesetzt ist)
            if ($actionName) {
                AuditLogger::log(
                    $actionName,
                    $targetType,
                    $result['target_id'] ?? null, // ID des erstellten/bearbeiteten Objekts
                    $result['details'] ?? null    // Details (z.B. Name)
                );
            }

        } catch (Exception $e) {
            $statusCode = 400; // Default Bad Request
            if (str_contains($e->getMessage(), 'CSRF')) {
                $statusCode = 403; // Forbidden
            } elseif (str_contains($e->getMessage(), 'berechtigt')) {
                $statusCode = 403; // Forbidden
            }
            
            http_response_code($statusCode);
            error_log("API Error: " . $e->getMessage() . "\n" . $e->getTraceAsString()); // Log detailed error
            echo json_encode(['success' => false, 'message' => $e->getMessage()], JSON_THROW_ON_ERROR);
        }
        exit();
    }


    /**
     * API: Holt Ankündigungen basierend auf der Rolle des Benutzers.
     * (GET request - no CSRF needed)
     */
    public function getAnnouncements()
    {
        Security::requireLogin();
        header('Content-Type: application/json'); // Ensure JSON header
        try {
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $user = $this->userRepo->findById($userId);

            if (!$user) {
                throw new Exception("Benutzer nicht gefunden.");
            }

            $classId = ($userRole === 'schueler' && isset($user['class_id'])) ? $user['class_id'] : null;
            $announcements = $this->announcementRepo->getVisibleAnnouncements($userRole, $classId);

             // Add author info, file URL, and convert content to HTML
             foreach ($announcements as &$announcement) {
                 $author = $this->userRepo->findById($announcement['user_id']);
                 $announcement['author_name'] = $author ? ($author['first_name'] . ' ' . $author['last_name']) : 'Unbekannt';

                 // Convert Markdown content to safe HTML
                 $announcement['content_html'] = $this->parsedown->text($announcement['content'] ?? '');

                 if (!empty($announcement['file_path'])) {
                     $announcement['file_url'] = rtrim(Database::getConfig()['base_url'], '/') . '/' . ltrim($announcement['file_path'], '/');
                 } else {
                    $announcement['file_url'] = null;
                 }
                 $announcement['visibility'] = $announcement['is_global'] ? 'global' : 'class';
             }
             unset($announcement);


            echo json_encode(['success' => true, 'data' => $announcements], JSON_THROW_ON_ERROR);

        } catch (Exception $e) {
            error_log("Error in getAnnouncements API: " . $e->getMessage()); // Log error
            http_response_code(500);
            echo json_encode(['success' => false, 'message' => 'Fehler beim Laden der Ankündigungen.'], JSON_THROW_ON_ERROR); // Generic message
        }
        exit(); // Make sure script exits
    }

    /**
     * API: Erstellt eine neue Ankündigung.
     * (POST request)
     */
    public function createAnnouncement()
    {
        Security::requireRole(['admin', 'planer', 'lehrer']);
        
        $this->handleApiRequest(function() {
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];
            $title = trim($_POST['title'] ?? '');
            $content = trim($_POST['content'] ?? ''); // Raw Markdown content

            if (empty($title) || empty($content)) {
                throw new Exception("Titel und Inhalt dürfen nicht leer sein.");
            }

            // --- Determine Target Role and Class ID ---
            $targetRole = 'all'; // Default
            $targetClassId = null;
             if ($userRole === 'lehrer') {
                 $targetClassId = filter_input(INPUT_POST, 'target_class_id', FILTER_VALIDATE_INT);
                 if (!$targetClassId) { throw new Exception("Lehrer müssen eine Klasse auswählen."); }
                 $targetRole = 'schueler';
             }
             elseif (in_array($userRole, ['admin', 'planer'])) {
                 $isGlobal = isset($_POST['target_global']) && $_POST['target_global'] === '1';
                 $isTeacher = isset($_POST['target_teacher']) && $_POST['target_teacher'] === '1';
                 $isPlaner = isset($_POST['target_planer']) && $_POST['target_planer'] === '1';
                 $selectedClassId = filter_input(INPUT_POST, 'target_class_id', FILTER_VALIDATE_INT);
                 $selectedClassId = ($selectedClassId === false || $selectedClassId === 0) ? null : $selectedClassId;
                 $checkedCount = ($isGlobal ? 1 : 0) + ($isTeacher ? 1 : 0) + ($isPlaner ? 1 : 0);

                 if ($checkedCount > 1) { throw new Exception("Bitte nur eine Zielgruppen-Checkbox auswählen."); }
                 elseif ($checkedCount === 1) {
                     if ($isGlobal) $targetRole = 'all'; elseif ($isTeacher) $targetRole = 'lehrer'; elseif ($isPlaner) $targetRole = 'planer';
                     $targetClassId = null;
                 } elseif ($selectedClassId !== null) {
                     $targetRole = 'schueler'; $targetClassId = $selectedClassId;
                 } else { $targetRole = 'all'; $targetClassId = null; } // Default to 'all' if nothing selected
             } else { throw new Exception("Unbekannte Benutzerrolle."); }


            // Handle File Upload if present
            $attachmentPath = null;
            if (isset($_FILES['attachment']) && $_FILES['attachment']['error'] === UPLOAD_ERR_OK) {
                 if (!in_array($userRole, ['admin', 'planer'])) { throw new Exception("Nur Admins und Planer dürfen Dateien anhängen."); }
                 $uploadDir = dirname(__DIR__, 3) . '/public/uploads/announcements/';
                 if (!is_dir($uploadDir)) { if (!mkdir($uploadDir, 0775, true)) { throw new Exception("Upload-Verzeichnis konnte nicht erstellt werden."); } }
                 $fileName = uniqid('', true) . '_' . basename($_FILES['attachment']['name']); $targetFile = $uploadDir . $fileName;
                 $allowedTypes = ['image/jpeg', 'image/png', 'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
                 $fileType = mime_content_type($_FILES['attachment']['tmp_name']);
                 if (!in_array($fileType, $allowedTypes)) { throw new Exception("Ungültiger Dateityp."); }
                 if ($_FILES['attachment']['size'] > 5 * 1024 * 1024) { throw new Exception("Datei ist zu groß (max. 5MB)."); }
                 if (move_uploaded_file($_FILES['attachment']['tmp_name'], $targetFile)) { $attachmentPath = 'uploads/announcements/' . $fileName; }
                 else { throw new Exception("Fehler beim Hochladen der Datei."); }
            }


            // Pass raw Markdown content to repository
            $newId = $this->announcementRepo->createAnnouncement(
                $userId,
                $title,
                $content, // Pass raw Markdown
                $targetRole,
                $targetClassId,
                $attachmentPath
            );

            // Fetch the newly created announcement
            $newAnnouncement = $this->announcementRepo->getAnnouncementById($newId);
            if ($newAnnouncement) {
                 // Convert content to HTML for the response
                 $newAnnouncement['content_html'] = $this->parsedown->text($newAnnouncement['content'] ?? '');

                 $author = $this->userRepo->findById($newAnnouncement['user_id']);
                 $newAnnouncement['author_name'] = $author ? ($author['first_name'] . ' ' . $author['last_name']) : 'Unbekannt';
                 if (!empty($newAnnouncement['file_path'])) {
                      $newAnnouncement['file_url'] = rtrim(Database::getConfig()['base_url'], '/') . '/' . ltrim($newAnnouncement['file_path'], '/');
                 } else {
                    $newAnnouncement['file_url'] = null;
                 }
                 $newAnnouncement['visibility'] = $newAnnouncement['is_global'] ? 'global' : 'class';
            }

            echo json_encode(['success' => true, 'message' => 'Ankündigung erfolgreich erstellt.', 'data' => $newAnnouncement], JSON_THROW_ON_ERROR);
            
            // Rückgabe für Audit-Log
            return [
                'target_id' => $newId,
                'details' => [
                    'title' => $title, 
                    'target_role' => $targetRole, 
                    'target_class_id' => $targetClassId,
                    'has_attachment' => !empty($attachmentPath)
                ]
            ];

        }, 'create_announcement', 'announcement');
    }

     /**
      * API: Löscht eine Ankündigung.
      * (POST request)
      */
     public function deleteAnnouncement()
     {
         Security::requireRole(['admin', 'planer', 'lehrer']);
         
         $this->handleApiRequest(function() {
              $userId = $_SESSION['user_id'];
              $userRole = $_SESSION['user_role'];
              $announcementId = filter_input(INPUT_POST, 'announcement_id', FILTER_VALIDATE_INT);

              if (!$announcementId) { throw new Exception("Ungültige Ankündigungs-ID."); }
              $announcement = $this->announcementRepo->getAnnouncementById($announcementId);
              if (!$announcement) { throw new Exception("Ankündigung nicht gefunden."); }
              
              // Berechtigungsprüfung
              if ($userRole === 'lehrer' && $announcement['user_id'] !== $userId) { 
                   throw new Exception("Sie sind nicht berechtigt, diese Ankündigung zu löschen."); 
              }

              $success = $this->announcementRepo->deleteAnnouncement($announcementId);

              if ($success) { 
                   echo json_encode(['success' => true, 'message' => 'Ankündigung erfolgreich gelöscht.'], JSON_THROW_ON_ERROR); 
              }
              else { 
                   throw new Exception("Fehler beim Löschen der Ankündigung."); 
              }
              
              // Rückgabe für Audit-Log
              return [
                   'target_id' => $announcementId,
                   'details' => ['title' => $announcement['title'] ?? 'N/A']
              ];

         }, 'delete_announcement', 'announcement');
     }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\AnnouncementController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\CommunityController.php ---
<?php
// app/Http/Controllers/CommunityController.php

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\CommunityPostRepository;
use App\Services\AuditLogger;
use Exception;
use PDO;
use \Parsedown; // KORREKTUR: Parsedown aus dem globalen Namespace importieren

class CommunityController
{
    private PDO $pdo;
    private CommunityPostRepository $postRepo;
    private Parsedown $parsedown; // KORREKTUR: Typehint kann jetzt ohne Backslash sein

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->postRepo = new CommunityPostRepository($this->pdo);
        $this->parsedown = new Parsedown(); // KORREKTUR: Kann jetzt direkt verwendet werden
        $this->parsedown->setSafeMode(true);
    }

    /**
     * API: Holt die letzten 50 freigegebenen Beiträge für das Dashboard.
     */
    public function getPostsApi()
    {
        Security::requireLogin();
        header('Content-Type: application/json');

        try {
            // KORREKTUR: Rufe die Methode im Repository auf, die E-Mails mitlädt
            $posts = $this->postRepo->getApprovedPostsWithAuthorEmail(50);

            // Konvertiere Markdown zu HTML
            foreach ($posts as &$post) {
                $post['content_html'] = $this->parsedown->text($post['content'] ?? '');
            }
            unset($post);

            echo json_encode(['success' => true, 'data' => $posts]);

        } catch (Exception $e) {
            http_response_code(500);
            error_log("API Error (getPostsApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => 'Fehler beim Laden der Beiträge.']);
        }
        exit();
    }

    /**
     * NEU: API: Holt alle Beiträge, die vom aktuell eingeloggten Benutzer erstellt wurden.
     */
    public function getMyPostsApi()
    {
        Security::requireLogin();
        header('Content-Type: application/json');

        try {
            $userId = $_SESSION['user_id'];
            $posts = $this->postRepo->getPostsByUserId($userId);

            // Konvertiere Markdown zu HTML
            foreach ($posts as &$post) {
                $post['content_html'] = $this->parsedown->text($post['content'] ?? '');
            }
            unset($post);

            echo json_encode(['success' => true, 'data' => $posts]);

        } catch (Exception $e) {
            http_response_code(500);
            error_log("API Error (getMyPostsApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => 'Fehler beim Laden Ihrer Beiträge.']);
        }
        exit();
    }


    /**
     * API: Erstellt einen neuen Beitrag.
     * Admins/Planer/Lehrer werden sofort freigeschaltet, Schüler müssen moderiert werden.
     */
    public function createPostApi()
    {
        Security::requireLogin();
        Security::verifyCsrfToken();
        header('Content-Type: application/json');

        try {
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];

            $data = json_decode(file_get_contents('php://input'), true);
            $title = trim($data['title'] ?? '');
            $content = trim($data['content'] ?? '');

            if (empty($title) || empty($content)) {
                throw new Exception("Titel und Inhalt dürfen nicht leer sein.", 400);
            }

            // Admins, Planer und Lehrer dürfen ohne Moderation posten
            $allowedToAutoApprove = ['admin', 'planer', 'lehrer'];
            $initialStatus = in_array($userRole, $allowedToAutoApprove) ? 'approved' : 'pending';

            $newPostId = $this->postRepo->createPost($userId, $title, $content, $initialStatus);
            
            AuditLogger::log('create_community_post', 'community_post', $newPostId, [
                'title' => $title,
                'status' => $initialStatus
            ]);

            $message = ($initialStatus === 'approved')
                ? 'Beitrag erfolgreich veröffentlicht.'
                : 'Beitrag wurde zur Moderation eingereicht.';

            echo json_encode(['success' => true, 'message' => $message, 'status' => $initialStatus]);

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (createPostApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => 'Fehler beim Erstellen des Beitrags: ' . $e->getMessage()]);
        }
        exit();
    }

    /**
     * NEU: API: Aktualisiert einen bestehenden Beitrag.
     * Nur der Ersteller (Schüler) oder Admins/Planer dürfen dies.
     * Setzt den Status bei Schüler-Bearbeitung auf 'pending' zurück.
     */
    public function updatePostApi()
    {
        Security::requireLogin();
        Security::verifyCsrfToken();
        header('Content-Type: application/json');

        try {
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];

            $data = json_decode(file_get_contents('php://input'), true);
            $postId = filter_var($data['post_id'] ?? null, FILTER_VALIDATE_INT);
            $title = trim($data['title'] ?? '');
            $content = trim($data['content'] ?? '');

            if (!$postId || empty($title) || empty($content)) {
                throw new Exception("ID, Titel und Inhalt dürfen nicht leer sein.", 400);
            }

            // Prüfe Berechtigung
            $post = $this->postRepo->getPostById($postId);
            if (!$post) {
                throw new Exception("Beitrag nicht gefunden.", 404);
            }

            $isOwner = ($post['user_id'] == $userId);
            $isModerator = in_array($userRole, ['admin', 'planer']);

            if (!$isOwner && !$isModerator) {
                throw new Exception("Sie sind nicht berechtigt, diesen Beitrag zu bearbeiten.", 403);
            }

            // Wenn ein Schüler (der Besitzer ist) bearbeitet, auf 'pending' zurücksetzen.
            // Admins/Planer dürfen bearbeiten, ohne den Status zu ändern.
            $newStatus = $post['status'];
            if ($isOwner && !$isModerator) {
                $newStatus = 'pending';
            }
            
            // Moderator-ID setzen, wenn ein Moderator bearbeitet, sonst NULL
            $moderatorId = $isModerator ? $userId : null;

            $success = $this->postRepo->updatePost($postId, $title, $content, $newStatus, $moderatorId);

            if ($success) {
                AuditLogger::log('update_community_post', 'community_post', $postId, [
                    'title' => $title,
                    'new_status' => $newStatus
                ]);
                $message = ($newStatus === 'pending')
                    ? 'Beitrag aktualisiert und zur erneuten Moderation eingereicht.'
                    : 'Beitrag erfolgreich aktualisiert.';
                echo json_encode(['success' => true, 'message' => $message, 'new_status' => $newStatus]);
            } else {
                throw new Exception("Beitrag konnte nicht aktualisiert werden.", 500);
            }

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (updatePostApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => 'Fehler beim Aktualisieren: ' . $e->getMessage()]);
        }
        exit();
    }


    /**
     * API: Genehmigt einen Beitrag (Admin/Planer).
     */
    public function approvePostApi()
    {
        Security::requireRole(['admin', 'planer']);
        Security::verifyCsrfToken();
        header('Content-Type: application/json');

        try {
            $moderatorId = $_SESSION['user_id'];
            $data = json_decode(file_get_contents('php://input'), true);
            $postId = filter_var($data['post_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$postId) {
                throw new Exception("Ungültige Beitrags-ID.", 400);
            }

            $success = $this->postRepo->updatePostStatus($postId, 'approved', $moderatorId);

            if ($success) {
                AuditLogger::log('approve_community_post', 'community_post', $postId);
                echo json_encode(['success' => true, 'message' => 'Beitrag freigegeben.']);
            } else {
                throw new Exception("Beitrag konnte nicht freigegeben werden (vielleicht schon moderiert?).", 404);
            }

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }
    
    /**
     * API: Lehnt einen Beitrag ab (Admin/Planer).
     * KORRIGIERT: Setzt Status auf 'rejected' statt zu löschen.
     */
    public function rejectPostApi()
    {
        Security::requireRole(['admin', 'planer']);
        Security::verifyCsrfToken();
        header('Content-Type: application/json');

        try {
            $moderatorId = $_SESSION['user_id']; // Für Logging
            $data = json_decode(file_get_contents('php://input'), true);
            $postId = filter_var($data['post_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$postId) {
                throw new Exception("Ungültige Beitrags-ID.", 400);
            }
            
            // Optional: Daten für Log holen
            $post = $this->postRepo->getPostById($postId);

            // Status auf 'rejected' setzen
            $success = $this->postRepo->updatePostStatus($postId, 'rejected', $moderatorId);

            if ($success) {
                AuditLogger::log('reject_community_post', 'community_post', $postId, ['title' => $post['title'] ?? 'N/A']);
                echo json_encode(['success' => true, 'message' => 'Beitrag abgelehnt.']);
            } else {
                throw new Exception("Beitrag konnte nicht abgelehnt werden (vielleicht schon moderiert?).", 404);
            }

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }

    /**
     * NEU: API: Löscht einen Beitrag (Admin, Planer oder Ersteller).
     */
    public function deletePostApi()
    {
        Security::requireLogin();
        Security::verifyCsrfToken();
        header('Content-Type: application/json');

        try {
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];

            $data = json_decode(file_get_contents('php://input'), true);
            $postId = filter_var($data['post_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$postId) {
                throw new Exception("Ungültige Beitrags-ID.", 400);
            }

            $post = $this->postRepo->getPostById($postId);
            if (!$post) {
                throw new Exception("Beitrag nicht gefunden.", 404);
            }

            $isOwner = ($post['user_id'] == $userId);
            $isModerator = in_array($userRole, ['admin', 'planer']);

            if (!$isOwner && !$isModerator) {
                throw new Exception("Sie sind nicht berechtigt, diesen Beitrag zu löschen.", 403);
            }

            // Admins/Planer dürfen immer löschen, Besitzer nur, wenn er nicht 'rejected' ist?
            // Aktuelle Logik: Besitzer darf immer löschen.
            
            $success = $this->postRepo->deletePost($postId);

            if ($success) {
                AuditLogger::log('delete_community_post', 'community_post', $postId, [
                    'title' => $post['title'] ?? 'N/A',
                    'deleted_by' => $userRole
                ]);
                echo json_encode(['success' => true, 'message' => 'Beitrag erfolgreich gelöscht.']);
            } else {
                throw new Exception("Beitrag konnte nicht gelöscht werden.", 500);
            }

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (deletePostApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => 'Fehler beim Löschen: ' . $e->getMessage()]);
        }
        exit();
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\CommunityController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\DashboardController.php ---
<?php
// app/Http/Controllers/DashboardController.php
namespace App\Http\Controllers;

use App\Core\Security;
use App\Core\Utils;
use App\Core\Database;
use App\Repositories\PlanRepository;
use App\Repositories\UserRepository;
use App\Repositories\AppointmentRepository;
use App\Repositories\StudentNoteRepository; // NEU
use App\Services\AuditLogger;
use Exception;
use PDO;
use DateTime;
use DateTimeZone;

class DashboardController
{
    private PDO $pdo;
    private UserRepository $userRepository;
    private PlanRepository $planRepository;
    private AppointmentRepository $appointmentRepo;
    private StudentNoteRepository $noteRepo; // NEU

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->userRepository = new UserRepository($this->pdo);
        $this->planRepository = new PlanRepository($this->pdo);
        $this->appointmentRepo = new AppointmentRepository($this->pdo);
        $this->noteRepo = new StudentNoteRepository($this->pdo); // NEU
    }

    public function index()
    {
        Security::requireLogin();
        $userId = $_SESSION['user_id']; // Get user ID from session
        $role = $_SESSION['user_role'] ?? 'Unbekannt';
        global $config;
        $config = Database::getConfig();

        // Redirect Admins and Planers to their specific dashboards
        if ($role === 'admin') {
            header("Location: " . Utils::url('admin/dashboard'));
            exit();
        }
        if ($role === 'planer') {
            header("Location: " . Utils::url('planer/dashboard'));
            exit();
        }

        // --- Fetch iCal Token and URL for Students/Teachers ---
        $icalSubscriptionUrl = null;
        $user = null; // Initialize user variable
        if (in_array($role, ['schueler', 'lehrer'])) {
             try {
                 $user = $this->userRepository->findById($userId); // Fetch user data once
                 if ($user) {
                     $token = $this->userRepository->generateOrGetIcalToken($userId);
                     if ($token) {
                         // Construct the full URL - ensure base_url ends correctly
                         $baseUrl = rtrim($config['base_url'], '/');
                         // Use Utils::url to handle potential base URL structure correctly
                         $icalPath = 'ical/' . $token;
                         // Build absolute URL
                         $protocol = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off' || $_SERVER['SERVER_PORT'] == 443) ? "https://" : "http://";
                         $host = $_SERVER['HTTP_HOST']; // e.g., localhost, yourdomain.com
                         // Combine protocol, host, and the relative path generated by Utils::url
                         $icalSubscriptionUrl = $protocol . $host . Utils::url($icalPath);

                     } else {
                          error_log("Could not generate or get iCal token for user ID: " . $userId);
                     }
                 } else {
                      error_log("User not found for ID: " . $userId . " in DashboardController");
                 }

             } catch (Exception $e) {
                   error_log("Error fetching iCal token: " . $e->getMessage());
                   // Don't crash the page, just don't show the URL
             }
        }
        // --- End iCal Token Fetch ---


        // Default for schueler, lehrer
        $page_title = 'Mein Stundenplan';
        $body_class = 'dashboard-body'; // Consistent class name

        // Today's date info for "Mein Tag" (Moved from view to controller)
        $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
        $dayOfWeekName = [
            1 => 'Montag', 2 => 'Dienstag', 3 => 'Mittwoch', 4 => 'Donnerstag', 5 => 'Freitag', 6 => 'Samstag', 7 => 'Sonntag'
        ][$today->format('N')] ?? 'Unbekannt';
        $dateFormatted = $today->format('d.m.Y');


        require_once dirname(__DIR__, 3) . '/pages/dashboard.php';
    }


    /**
     * API-Endpunkt zum Laden des kompletten Wochenplans, aller Wochen-Vertretungen,
     * UND NEU: anstehender Termine (Aufgaben, Sprechstunden) SOWIE NOTIZEN.
     * NUR VERÖFFENTLICHTE DATEN.
     */
    public function getWeeklyData()
    {
        Security::requireLogin();
        header('Content-Type: application/json');

        try {
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];

            $year = filter_input(INPUT_GET, 'year', FILTER_VALIDATE_INT);
            $calendarWeek = filter_input(INPUT_GET, 'week', FILTER_VALIDATE_INT);

            if (!$year || !$calendarWeek) {
                $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                $year = (int)$today->format('o'); // ISO year
                $calendarWeek = (int)$today->format('W'); // ISO week
            }
            
            // NEU: Datumsbereich für die Abfrage von Terminen
            $monday = new DateTime();
            $monday->setISODate($year, $calendarWeek, 1);
            $startDate = $monday->format('Y-m-d');
            
            $sunday = new DateTime();
            $sunday->setISODate($year, $calendarWeek, 7);
            $endDate = $sunday->format('Y-m-d');
            

            $user = $this->userRepository->findById($userId);
            if (!$user) {
                throw new Exception("Benutzer nicht gefunden.");
            }

            $regularTimetable = [];
            $substitutions = [];
            $appointments = [];
            $notes = []; // NEU
            $targetGroup = null; // Determine target group for publish check

            if ($userRole === 'schueler' && !empty($user['class_id'])) {
                $targetGroup = 'student';
                if ($this->planRepository->isWeekPublishedFor($targetGroup, $year, $calendarWeek)) {
                    $regularTimetable = $this->planRepository->getPublishedTimetableForClass($user['class_id'], $year, $calendarWeek);
                    $substitutions = $this->planRepository->getPublishedSubstitutionsForClassWeek($user['class_id'], $year, $calendarWeek);
                    // Lade Sprechstunden für Schüler
                    $appointments = $this->appointmentRepo->getAppointmentsForStudent($userId, $startDate, $endDate);
                    // NEU: Lade Notizen für Schüler
                    $notes = $this->noteRepo->getNotesForWeek($userId, $year, $calendarWeek);
                }
            } elseif ($userRole === 'lehrer' && !empty($user['teacher_id'])) {
                 $targetGroup = 'teacher';
                 if ($this->planRepository->isWeekPublishedFor($targetGroup, $year, $calendarWeek)) {
                      $regularTimetable = $this->planRepository->getPublishedTimetableForTeacher($user['teacher_id'], $year, $calendarWeek);
                      $substitutions = $this->planRepository->getPublishedSubstitutionsForTeacherWeek($user['teacher_id'], $year, $calendarWeek);
                      // Lade Sprechstunden für Lehrer (user_id verwenden)
                      $appointments = $this->appointmentRepo->getAppointmentsForTeacher($userId, $startDate, $endDate);
                      // Lehrer haben keine Notizen
                 }
            }

            // Wenn $targetGroup null ist (z.B. Admin/Planer, obwohl sie hier nicht sein sollten) oder
            // die Woche nicht veröffentlicht wurde, bleiben die Arrays leer, was korrekt ist.

            echo json_encode(['success' => true, 'data' => [
                'timetable' => $regularTimetable,
                'substitutions' => $substitutions,
                'appointments' => $appointments,
                'notes' => $notes // NEU
            ]]);

        } catch (Exception $e) {
            http_response_code(500);
            error_log("API Error in getWeeklyData API: " . $e->getMessage()); // Log error
            echo json_encode(['success' => false, 'message' => 'Fehler beim Laden der Plandaten.']); // Generic message
        }
        exit();
    }

    // --- NEUE API-ENDPUNKTE FÜR SCHÜLER (SPRECHSTUNDEN & NOTIZEN) ---

    /**
     * NEU: API: Speichert eine private Notiz für einen Schüler.
     */
    public function saveNoteApi()
    {
        Security::requireRole('schueler');
        Security::verifyCsrfToken();
        header('Content-Type: application/json');
        
        try {
            $userId = $_SESSION['user_id'];
            $data = json_decode(file_get_contents('php://input'), true);

            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $calendarWeek = filter_var($data['calendar_week'] ?? null, FILTER_VALIDATE_INT);
            $dayOfWeek = filter_var($data['day_of_week'] ?? null, FILTER_VALIDATE_INT);
            $periodNumber = filter_var($data['period_number'] ?? null, FILTER_VALIDATE_INT);
            $content = $data['note_content'] ?? ''; // Erlaube leeren String (zum Löschen)

            if (!$year || !$calendarWeek || !$dayOfWeek || !$periodNumber) {
                throw new Exception("Fehlende Kontextdaten (Woche, Tag oder Stunde).", 400);
            }

            $success = $this->noteRepo->saveNote(
                $userId,
                $year,
                $calendarWeek,
                $dayOfWeek,
                $periodNumber,
                $content
            );

            if ($success) {
                // Logge das Speichern (aber nicht den Inhalt)
                AuditLogger::log('save_student_note', 'student_note', null, [
                    'year' => $year,
                    'week' => $calendarWeek,
                    'day' => $dayOfWeek,
                    'period' => $periodNumber,
                    'action' => empty(trim($content)) ? 'deleted' : 'saved'
                ]);
                echo json_encode(['success' => true, 'message' => 'Notiz gespeichert.']);
            } else {
                throw new Exception("Notiz konnte nicht gespeichert werden.");
            }

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (saveNoteApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }


    /**
     * API: Holt die verfügbaren Slots für einen Lehrer an einem Datum.
     * (Für Schüler)
     */
    public function getAvailableSlotsApi()
    {
        Security::requireRole('schueler'); // Nur Schüler können Slots buchen
        header('Content-Type: application/json');

        try {
            // KORREKTUR: Muss teacher_id (aus Stammdaten) in teacher_user_id (aus users) umwandeln
            $teacherId = filter_input(INPUT_GET, 'teacher_id', FILTER_VALIDATE_INT);
            $date = filter_input(INPUT_GET, 'date', FILTER_UNSAFE_RAW); // Y-m-d

            if (!$teacherId || !$date || DateTime::createFromFormat('Y-m-d', $date) === false) {
                throw new Exception("Ungültige Lehrer-ID oder Datum.", 400);
            }
            
            // KORREKTUR: Finde die user_id des Lehrers
            $teacherUser = $this->userRepository->findUserByTeacherId($teacherId);
            if (!$teacherUser) {
                throw new Exception("Lehrerprofil (Benutzer) nicht gefunden.", 404);
            }
            $teacherUserId = $teacherUser['user_id'];
            
            // Verhindere Buchungen in der Vergangenheit
            $today = (new DateTime('now', new DateTimeZone('Europe/Berlin')))->format('Y-m-d');
            $slots = []; // Initialisiere Slots
            if ($date < $today) {
                 // Erlaube die Anzeige heutiger Slots
                 $slots = $this->appointmentRepo->getAvailableSlots($teacherUserId, $date);
                 if (empty($slots) && $date < $today) { // Nur wenn keine Slots UND Vergangenheit
                      throw new Exception("Termine können nicht in der Vergangenheit gebucht werden.", 400);
                 }
            } else {
                 $slots = $this->appointmentRepo->getAvailableSlots($teacherUserId, $date);
            }
            
            echo json_encode(['success' => true, 'data' => $slots]);

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (getAvailableSlotsApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }

    /**
     * API: Bucht einen Termin.
     * (Für Schüler)
     */
    public function bookAppointmentApi()
    {
        Security::requireRole('schueler');
        Security::verifyCsrfToken();
        header('Content-Type: application/json');
        
        try {
            $studentUserId = $_SESSION['user_id'];
            $data = json_decode(file_get_contents('php://input'), true);

            // KORREKTUR: Empfängt teacher_id (Stammdaten), muss teacher_user_id finden
            $teacherId = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $date = $data['date'] ?? null;
            $time = $data['time'] ?? null; // HH:MM:SS
            $duration = filter_var($data['duration'] ?? null, FILTER_VALIDATE_INT);
            $notes = isset($data['notes']) ? trim($data['notes']) : null;

            if (!$teacherId || !$date || !$time || !$duration) {
                throw new Exception("Fehlende Daten für die Buchung.", 400);
            }
            
            // KORREKTUR: Finde die user_id des Lehrers
            $teacherUser = $this->userRepository->findUserByTeacherId($teacherId);
            if (!$teacherUser) {
                throw new Exception("Lehrerprofil (Benutzer) nicht gefunden.", 404);
            }
            $teacherUserId = $teacherUser['user_id'];
            
            // Verhindere Buchungen in der Vergangenheit
            $today = (new DateTime('now', new DateTimeZone('Europe/Berlin')))->format('Y-m-d');
            if ($date < $today) {
                 throw new Exception("Termine können nicht in der Vergangenheit gebucht werden.", 400);
            }

            $newId = $this->appointmentRepo->bookAppointment(
                $studentUserId,
                $teacherUserId, // KORREKTUR: Verwende die gefundene user_id
                $date,
                $time,
                $duration,
                $notes
            );
            
            AuditLogger::log('book_appointment', 'appointment', $newId, [
                'teacher_user_id' => $teacherUserId,
                'date' => $date,
                'time' => $time
            ]);

            echo json_encode(['success' => true, 'message' => 'Sprechstunde erfolgreich gebucht!']);

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (bookAppointmentApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }

    /**
     * API: Storniert einen Termin.
     * (Für Schüler ODER Lehrer)
     */
    public function cancelAppointmentApi()
    {
        Security::requireLogin(); // Lehrer oder Schüler
        Security::verifyCsrfToken();
        header('Content-Type: application/json');
        
        try {
            $userId = $_SESSION['user_id'];
            $role = $_SESSION['user_role'];

            $data = json_decode(file_get_contents('php://input'), true);
            $appointmentId = filter_var($data['appointment_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$appointmentId) {
                throw new Exception("Keine Termin-ID angegeben.", 400);
            }

            $success = $this->appointmentRepo->cancelAppointment($appointmentId, $userId, $role);
            
            if ($success) {
                 AuditLogger::log('cancel_appointment', 'appointment', $appointmentId, ['cancelled_by_role' => $role]);
                 echo json_encode(['success' => true, 'message' => 'Termin erfolgreich storniert.']);
            }
            // Fehler (403, 404) werden vom Repository geworfen

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (cancelAppointmentApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\DashboardController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\IcalController.php ---
<?php
// app/Http\Controllers\IcalController.php

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Utils;
use App\Repositories\UserRepository;
use App\Repositories\PlanRepository;
use App\Repositories\AcademicEventRepository; // NEU: Importiere Event Repository
use DateTime;
use DateTimeImmutable; // Use immutable for calculations
use DateTimeZone;
use Exception;

class IcalController
{
    private UserRepository $userRepository;
    private PlanRepository $planRepository;
    private AcademicEventRepository $eventRepository; // NEU: Property für Event Repository
    private \PDO $pdo;
    private array $settings;

    // Define exact start and end times for each period (HHMM format for calculations)
    // Adjust these times according to your actual school schedule!
    private const PERIOD_TIMES = [
        1 => ['start' => '0800', 'end' => '0845'],
        2 => ['start' => '0855', 'end' => '0940'],
        3 => ['start' => '0940', 'end' => '1025'], // Example: Double period
        4 => ['start' => '1035', 'end' => '1120'],
        5 => ['start' => '1120', 'end' => '1205'],
        // Mittagspause
        6 => ['start' => '1305', 'end' => '1350'],
        7 => ['start' => '1350', 'end' => '1435'],
        8 => ['start' => '1445', 'end' => '1530'],
        9 => ['start' => '1530', 'end' => '1615'],
        10 => ['start' => '1625', 'end' => '1710'],
    ];

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->userRepository = new UserRepository($this->pdo);
        $this->planRepository = new PlanRepository($this->pdo);
        $this->eventRepository = new AcademicEventRepository($this->pdo); // NEU: Instanziiere Event Repository
        $this->settings = Utils::getSettings();
    }

    public function generateFeed(string $token)
    {
        // Schritt 0: Prüfen, ob iCal global aktiviert ist
        if (!$this->settings['ical_enabled']) {
            http_response_code(503); // Service Unavailable
            header('Content-Type: text/plain');
            echo "Kalender-Feeds sind derzeit systemweit deaktiviert.";
            exit;
        }

        // 1. Validate Token & Find User
        $user = $this->userRepository->findByIcalToken($token);
        if (!$user) {
            http_response_code(404);
            header('Content-Type: text/plain');
            echo "Ungültiger oder unbekannter Kalender-Feed-Token.";
            exit;
        }

        // 2. Determine User Type
        $userRole = $user['role'];
        $classId = ($userRole === 'schueler' && !empty($user['class_id'])) ? (int)$user['class_id'] : null;
        $teacherId = ($userRole === 'lehrer' && !empty($user['teacher_id'])) ? (int)$user['teacher_id'] : null;
        $teacherUserId = ($userRole === 'lehrer') ? (int)$user['user_id'] : null; // NEU: Lehrer User ID für Events

        if (($userRole !== 'schueler' && $userRole !== 'lehrer') || ($userRole === 'schueler' && !$classId) || ($userRole === 'lehrer' && !$teacherId)) {
            http_response_code(403);
            header('Content-Type: text/plain');
            echo "Kalender-Feed nur für gültige Schüler- oder Lehrerprofile verfügbar.";
            exit;
        }

        // 3. Fetch Data
        $timezone = new DateTimeZone('Europe/Berlin');
        $now = new DateTimeImmutable('now', $timezone); // Use Immutable
        $currentWeekInfo = $this->getWeekYear($now);
        $currentYear = $currentWeekInfo['year'];
        $currentWeek = $currentWeekInfo['week'];

        $allEventsData = [];
        $rangeWeeksBefore = 1;
        $rangeWeeksAfter = $this->settings['ical_weeks_future'];

        try {
            for ($weekOffset = -$rangeWeeksBefore; $weekOffset <= $rangeWeeksAfter; $weekOffset++) {
                $dt = $now->modify('+' . ($weekOffset * 7) . ' days');
                $weekInfo = $this->getWeekYear($dt);
                $targetYear = $weekInfo['year'];
                $targetWeek = $weekInfo['week'];

                $targetGroup = ($userRole === 'schueler') ? 'student' : 'teacher';

                $academicEventsForWeek = []; // NEU: Initialisiere Events-Array für die Woche

                if ($this->planRepository->isWeekPublishedFor($targetGroup, $targetYear, $targetWeek)) {
                    $timetable = [];
                    $substitutions = [];
                    if ($classId) {
                        $timetable = $this->planRepository->getPublishedTimetableForClass($classId, $targetYear, $targetWeek);
                        $substitutions = $this->planRepository->getPublishedSubstitutionsForClassWeek($classId, $targetYear, $targetWeek);
                        // NEU: Lade Events für Schüler
                        $academicEventsForWeek = $this->eventRepository->getEventsForClassByWeek($classId, $targetYear, $targetWeek);
                    } elseif ($teacherId && $teacherUserId) { // Stelle sicher, dass teacherUserId vorhanden ist
                        $timetable = $this->planRepository->getPublishedTimetableForTeacher($teacherId, $targetYear, $targetWeek);
                        $substitutions = $this->planRepository->getPublishedSubstitutionsForTeacherWeek($teacherId, $targetYear, $targetWeek);
                        // NEU: Lade Events für Lehrer (die er erstellt hat) - braucht Start/End Datum
                        [$startDate, $endDate] = $this->getWeekDateRange($targetYear, $targetWeek);
                        // Hole Events für den Lehrer im gesamten Wochenbereich
                        $academicEventsForWeek = $this->eventRepository->getEventsByTeacherForDateRange($teacherUserId, $startDate, $endDate);
                    }

                    $this->processWeekData($allEventsData, $timetable, $substitutions, $targetYear, $targetWeek, $timezone, $userRole);

                    // NEU: Verarbeite Academic Events für diese Woche
                    $this->processAcademicEvents($allEventsData, $academicEventsForWeek, $timezone);
                }
            } // End week loop

        } catch (Exception $e) {
            error_log("iCal feed generation error for token {$token}: " . $e->getMessage());
            http_response_code(500);
            header('Content-Type: text/plain');
            echo "Fehler beim Abrufen der Kalenderdaten.";
            exit;
        }


        // 4. Format as iCalendar
        $icsContent = $this->formatAsIcs($allEventsData, $user);

        // 5. Output Headers and Content
        header('Content-Type: text/calendar; charset=utf-8');
        header('Content-Disposition: inline; filename="pause_stundenplan.ics"');
        header('Cache-Control: no-cache, no-store, must-revalidate');
        header('Pragma: no-cache');
        header('Expires: 0');

        echo $icsContent;
        exit;
    }

    private function getWeekYear(DateTimeImmutable $date): array {
        $year = (int)$date->format('o'); // ISO-8601 year
        $week = (int)$date->format('W'); // ISO-8601 week number
        return ['week' => $week, 'year' => $year];
    }

    /**
    * Hilfsfunktion, um Start- und Enddatum einer Kalenderwoche zu ermitteln (Mo - So).
    * @param int $year ISO Year
    * @param int $week ISO Week
    * @return array ['Y-m-d', 'Y-m-d']
    */
    private function getWeekDateRange(int $year, int $week): array
    {
        $dto = new DateTime();
        $dto->setISODate($year, $week, 1); // Montag
        $startDate = $dto->format('Y-m-d');
        $dto->setISODate($year, $week, 7); // Sonntag
        $endDate = $dto->format('Y-m-d');
        return [$startDate, $endDate];
    }


    /**
     * Gets the DateTimeImmutable object for the start of a given day (00:00:00) within a specific week/year.
     * @param int $year ISO Year
     * @param int $week ISO Week
     * @param int $dayNum Day number (1=Monday, ..., 7=Sunday)
     * @param DateTimeZone $timezone
     * @return DateTimeImmutable
     */
    private function getDateForDayOfWeek(int $year, int $week, int $dayNum, DateTimeZone $timezone): DateTimeImmutable {
        $dt = new DateTimeImmutable("{$year}-W" . sprintf('%02d', $week) . "-{$dayNum}", $timezone);
        return $dt->setTime(0, 0, 0); // Ensure start of the day
    }


    private function processWeekData(array &$events, array $timetable, array $substitutions, int $year, int $week, DateTimeZone $timezone, string $userRole): void
    {
        $processedRegularSlots = []; // Keep track of processed regular slots 'day-period' or block_id
        $substitutionMap = []; // Map substitutions to 'YYYY-MM-DD-period'
        foreach ($substitutions as $sub) {
            $key = $sub['date'] . '-' . $sub['period_number'];
            $substitutionMap[$key] = $sub;
        }

        // --- Process Substitutions First ---
        foreach ($substitutions as $sub) {
            $subKey = $sub['date'] . '-' . $sub['period_number'];
            if (isset($processedRegularSlots[$subKey])) continue; // Already processed as part of a block

            $period = (int)$sub['period_number'];
            $times = self::PERIOD_TIMES[$period] ?? null;
            if (!$times) continue; // Skip if period time is undefined

            // Use DateTimeImmutable for safety
            try {
                $dateObj = new DateTimeImmutable($sub['date'] . ' 00:00:00', $timezone);
            } catch (Exception $e) {
                error_log("Invalid date format in substitution: " . $sub['date']);
                continue;
            }

            $dtStart = $dateObj->setTime((int)substr($times['start'], 0, 2), (int)substr($times['start'], 2, 2));
            $dtEnd = $dateObj->setTime((int)substr($times['end'], 0, 2), (int)substr($times['end'], 2, 2));

            // Check for multi-period substitutions (simple consecutive check)
            $span = 1;
            while (true) {
                $nextPeriod = $period + $span;
                $nextSubKey = $sub['date'] . '-' . $nextPeriod;
                 // Check if next period exists, has a substitution, and if it's essentially the same event
                 // (same type, comment, new teacher/subject/room)
                if (isset(self::PERIOD_TIMES[$nextPeriod]) && isset($substitutionMap[$nextSubKey])) {
                    $nextSub = $substitutionMap[$nextSubKey];
                    if ($nextSub['substitution_type'] === $sub['substitution_type'] &&
                        $nextSub['comment'] === $sub['comment'] &&
                        $nextSub['new_teacher_id'] === $sub['new_teacher_id'] &&
                        $nextSub['new_subject_id'] === $sub['new_subject_id'] &&
                        $nextSub['new_room_id'] === $sub['new_room_id'])
                    {
                         $nextTimes = self::PERIOD_TIMES[$nextPeriod];
                         $dtEnd = $dateObj->setTime((int)substr($nextTimes['end'], 0, 2), (int)substr($nextTimes['end'], 2, 2));
                         $processedRegularSlots[$nextSubKey] = true; // Mark as processed
                         $span++;
                    } else {
                         break; // Different substitution, stop block
                    }
                } else {
                     break; // No more consecutive substitutions
                }
            }

            // Find original entry for context if substitution isn't 'Sonderevent'
            $originalEntry = null;
            if ($sub['substitution_type'] !== 'Sonderevent') {
                 // Try finding matching regular entry for the same day/period
                 $dbDayNum = $dateObj->format('N'); // 1 (Mon) - 7 (Sun)
                 $originalEntry = array_values(array_filter($timetable,
                    fn($e) => $e['day_of_week'] == $dbDayNum && $e['period_number'] == $period
                 ))[0] ?? null;
            }

            $summary = '';
            $description = "Typ: " . $sub['substitution_type'] . "\n";
            $location = $sub['new_room_name'] ?? $originalEntry['room_name'] ?? '';
            $status = 'CONFIRMED';

            switch ($sub['substitution_type']) {
                case 'Entfall':
                    $summary = "ENTFALL: " . ($originalEntry['subject_shortcut'] ?? 'Unterricht');
                    $description .= "Ursprünglich: " . ($originalEntry['subject_shortcut'] ?? '?') . " bei " . ($originalEntry['teacher_shortcut'] ?? '?') . "\n";
                    $location = ''; // No location for cancellation
                    $status = 'CANCELLED';
                    break;
                case 'Raumänderung':
                    $summary = ($originalEntry['subject_shortcut'] ?? 'Unterricht') . " in Raum " . ($sub['new_room_name'] ?? '???');
                    $description .= "Neuer Raum: " . ($sub['new_room_name'] ?? '???') . "\n";
                    $description .= "Fach: " . ($originalEntry['subject_shortcut'] ?? '?') . "\n";
                    $description .= "Lehrer/Klasse: " . ($userRole === 'schueler' ? ($originalEntry['teacher_shortcut'] ?? '?') : ($originalEntry['class_name'] ?? '?')) . "\n";
                    break;
                case 'Sonderevent':
                    $summary = $sub['comment'] ?: 'Sonderevent';
                    $location = $sub['new_room_name'] ?? '';
                    break;
                case 'Vertretung':
                default:
                    $subject = $sub['new_subject_shortcut'] ?? $originalEntry['subject_shortcut'] ?? '???';
                    $teacher = $sub['new_teacher_shortcut'] ?? '???';
                    $class = $sub['class_name'] ?? $originalEntry['class_name'] ?? '???';
                    $summary = "VERTR.: {$subject} - " . ($userRole === 'schueler' ? $teacher : $class);
                    $description .= "Fach: {$subject}\n";
                    $description .= "Lehrer: {$teacher}\n";
                    $description .= "Raum: " . ($sub['new_room_name'] ?? $originalEntry['room_name'] ?? '???') . "\n";
                    if ($originalEntry) {
                         $description .= "Ursprünglich: " . $originalEntry['subject_shortcut'] . " bei " . $originalEntry['teacher_shortcut'] . "\n";
                    }
                    break;
            }
            if ($sub['comment'] && $sub['substitution_type'] !== 'Sonderevent') {
                $description .= "Kommentar: " . $sub['comment'] . "\n";
            }

            $events[] = [
                'uid' => 'sub-' . $sub['substitution_id'], // Unique ID based on substitution
                'dtStart' => $dtStart,
                'dtEnd' => $dtEnd,
                'summary' => $summary,
                'location' => $location,
                'description' => trim($description),
                'status' => $status,
            ];

             $processedRegularSlots[$subKey] = true; // Mark the starting slot
        } // End substitution processing


        // --- Process Regular Timetable Entries (excluding overridden slots) ---
        foreach ($timetable as $entry) {
            $dayNum = (int)$entry['day_of_week'];
            $period = (int)$entry['period_number'];
            $regKey = $this->getDateForDayOfWeek($year, $week, $dayNum, $timezone)->format('Y-m-d') . '-' . $period;
            $blockId = $entry['block_id'];

            // Skip if already handled by substitution OR already processed as part of a block
            if (isset($substitutionMap[$regKey]) || isset($processedRegularSlots[$regKey]) || ($blockId && isset($processedRegularSlots[$blockId]))) {
                continue;
            }

            $times = self::PERIOD_TIMES[$period] ?? null;
            if (!$times) continue;

            $dateObj = $this->getDateForDayOfWeek($year, $week, $dayNum, $timezone);
            $dtStart = $dateObj->setTime((int)substr($times['start'], 0, 2), (int)substr($times['start'], 2, 2));
            $dtEnd = $dateObj->setTime((int)substr($times['end'], 0, 2), (int)substr($times['end'], 2, 2));
            $uidBase = 'entry-' . $entry['entry_id'];

            // Handle Blocks
            if ($blockId) {
                // Find all entries for this block
                $blockEntries = array_filter($timetable, fn($e) => $e['block_id'] === $blockId);
                if (!empty($blockEntries)) {
                    $minPeriod = min(array_column($blockEntries, 'period_number'));
                    $maxPeriod = max(array_column($blockEntries, 'period_number'));

                    // Only process the block once using the first period entry
                    if ($period === $minPeriod) {
                         $startTime = self::PERIOD_TIMES[$minPeriod]['start'] ?? null;
                         $endTime = self::PERIOD_TIMES[$maxPeriod]['end'] ?? null;
                         if ($startTime && $endTime) {
                             $dtStart = $dateObj->setTime((int)substr($startTime, 0, 2), (int)substr($startTime, 2, 2));
                             $dtEnd = $dateObj->setTime((int)substr($endTime, 0, 2), (int)substr($endTime, 2, 2));
                         }
                         $uidBase = 'block-' . $blockId;
                         // Mark all periods of this block as processed
                         for ($p = $minPeriod; $p <= $maxPeriod; $p++) {
                             $blockKey = $dateObj->format('Y-m-d') . '-' . $p;
                             $processedRegularSlots[$blockKey] = true;
                         }
                         $processedRegularSlots[$blockId] = true; // Mark block itself
                    } else {
                         continue; // Skip other entries of an already processed block
                    }
                }
            } else {
                 $processedRegularSlots[$regKey] = true; // Mark single entry
            }


            $summary = ($entry['subject_shortcut'] ?? '???') . " - " . ($userRole === 'schueler' ? ($entry['teacher_shortcut'] ?? '???') : ($entry['class_name'] ?? '???'));
            $description = "Fach: " . ($entry['subject_name'] ?? $entry['subject_shortcut'] ?? '???') . "\n";
            $description .= "Lehrer: " . ($entry['teacher_shortcut'] ?? '???') . "\n";
            $description .= "Klasse: " . ($entry['class_name'] ?? '???') . "\n";
            $description .= "Raum: " . ($entry['room_name'] ?? '???') . "\n";
            if (!empty($entry['comment'])) {
                $description .= "Kommentar: " . $entry['comment'] . "\n";
            }

            $events[] = [
                'uid' => $uidBase,
                'dtStart' => $dtStart,
                'dtEnd' => $dtEnd,
                'summary' => $summary,
                'location' => $entry['room_name'] ?? '',
                'description' => trim($description),
                'status' => 'CONFIRMED',
            ];

        } // End regular entry processing
    }

    /**
     * NEU: Verarbeitet Aufgaben/Klausuren und fügt sie zur Event-Liste hinzu.
     * @param array &$events Das Haupt-Event-Array (wird modifiziert).
     * @param array $academicEvents Die zu verarbeitenden Aufgaben/Klausuren.
     * @param DateTimeZone $timezone Die Zeitzone.
     */
    private function processAcademicEvents(array &$events, array $academicEvents, DateTimeZone $timezone): void
    {
        foreach ($academicEvents as $event) {
            try {
                $dateObj = new DateTimeImmutable($event['due_date'] . ' 00:00:00', $timezone);
            } catch (Exception $e) {
                error_log("Invalid date format in academic event: " . $event['due_date']);
                continue;
            }

            $period = $event['period_number'] ? (int)$event['period_number'] : null;
            $times = $period ? (self::PERIOD_TIMES[$period] ?? null) : null;

            if ($times) {
                // Event findet zu einer bestimmten Stunde statt
                $dtStart = $dateObj->setTime((int)substr($times['start'], 0, 2), (int)substr($times['start'], 2, 2));
                $dtEnd = $dateObj->setTime((int)substr($times['end'], 0, 2), (int)substr($times['end'], 2, 2));
                // iCal Format für spezifische Zeit (kein DATE)
                $dtStartFormat = 'Ymd\THis';
                $dtEndFormat = 'Ymd\THis';
                $timeInfo = " ({$period}. Std.)";
            } else {
                // Ganztägiges Event (oder ohne spezifische Zeit)
                $dtStart = $dateObj; // Start of the day
                $dtEnd = $dateObj->modify('+1 day'); // End of the day (exclusive in iCal)
                // iCal Format für ganztägige Events (DATE)
                $dtStartFormat = 'Ymd';
                $dtEndFormat = 'Ymd';
                $timeInfo = "";
            }

            $icon = 'ℹ️'; // Info
            $prefix = 'Info';
            if ($event['event_type'] === 'klausur') {
                $icon = '🎓';
                $prefix = 'Klausur';
            }
            if ($event['event_type'] === 'aufgabe') {
                $icon = '📚';
                $prefix = 'Aufgabe';
            }

            $summary = "{$icon} {$prefix}: " . ($event['title'] ?? 'Eintrag');
            if ($event['subject_shortcut']) {
                $summary .= " (" . $event['subject_shortcut'] . ")";
            }

            $description = "Typ: " . ucfirst($event['event_type']) . "\n";
            $description .= "Fach: " . ($event['subject_shortcut'] ?? '-') . "\n";
            // Lehrername hinzufügen (falls verfügbar, z.B. für Schüleransicht)
            if (isset($event['teacher_first_name'])) {
                 $description .= "Lehrer: " . $event['teacher_first_name'] . ' ' . $event['teacher_last_name'] . "\n";
            }
            // Klassenname hinzufügen (falls verfügbar, z.B. für Lehreransicht)
            if (isset($event['class_name'])) {
                 $description .= "Klasse: " . $event['class_name'] . "\n";
            }

            $description .= "Datum: " . $dateObj->format('d.m.Y') . $timeInfo . "\n";
            if ($event['description']) {
                $description .= "\nBeschreibung:\n" . $event['description'];
            }

            $events[] = [
                'uid' => 'acad-' . $event['event_id'], // Eindeutige ID
                'dtStart' => $dtStart,
                'dtEnd' => $dtEnd,
                'dtStartFormat' => $dtStartFormat, // NEU: Format für Start
                'dtEndFormat' => $dtEndFormat,     // NEU: Format für Ende
                'summary' => $summary,
                'location' => '', // Kein spezifischer Ort für Aufgaben/Klausuren im iCal
                'description' => trim($description),
                'status' => 'CONFIRMED',
            ];
        }
    }


    private function formatAsIcs(array $events, array $user): string
    {
        $ics = "BEGIN:VCALENDAR\r\n";
        $ics .= "VERSION:2.0\r\n";
        $ics .= "PRODID:-//PMI//PAUSE Stundenplan v1.0//DE\r\n";
        $ics .= "CALSCALE:GREGORIAN\r\n";
        $ics .= "METHOD:PUBLISH\r\n";
        $ics .= "X-WR-CALNAME:PAUSE Stundenplan (" . $this->escapeIcsString($user['username']) . ")\r\n";
        $ics .= "X-WR-TIMEZONE:Europe/Berlin\r\n";
        $ics .= "X-PUBLISHED-TTL:PT1H\r\n";

        // Add Timezone Definition
        $ics .= "BEGIN:VTIMEZONE\r\n";
        $ics .= "TZID:Europe/Berlin\r\n";
        $ics .= "X-LIC-LOCATION:Europe/Berlin\r\n";
        $ics .= "BEGIN:DAYLIGHT\r\n";
        $ics .= "TZOFFSETFROM:+0100\r\n";
        $ics .= "TZOFFSETTO:+0200\r\n";
        $ics .= "TZNAME:CEST\r\n";
        $ics .= "DTSTART:19700329T020000\r\n";
        $ics .= "RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\n";
        $ics .= "END:DAYLIGHT\r\n";
        $ics .= "BEGIN:STANDARD\r\n";
        $ics .= "TZOFFSETFROM:+0200\r\n";
        $ics .= "TZOFFSETTO:+0100\r\n";
        $ics .= "TZNAME:CET\r\n";
        $ics .= "DTSTART:19701025T030000\r\n";
        $ics .= "RRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\n";
        $ics .= "END:STANDARD\r\n";
        $ics .= "END:VTIMEZONE\r\n";

        $nowUtc = gmdate('Ymd\THis\Z');

        // Loop through processed events and create VEVENT blocks
        foreach ($events as $event) {
            /** @var DateTimeImmutable $dtStart */
            /** @var DateTimeImmutable $dtEnd */
            $dtStart = $event['dtStart'];
            $dtEnd = $event['dtEnd'];

            // NEU: Verwende spezifische Formate für ganztägige vs. zeitgebundene Events
            $dtStartFormat = $event['dtStartFormat'] ?? 'Ymd\THis';
            $dtEndFormat = $event['dtEndFormat'] ?? 'Ymd\THis';
            $dtStartString = $dtStart->format($dtStartFormat);
            $dtEndString = $dtEnd->format($dtEndFormat);
            $datePrefix = ($dtStartFormat === 'Ymd') ? ';VALUE=DATE' : ';TZID=Europe/Berlin';


            $ics .= "BEGIN:VEVENT\r\n";
            // UID: Use base + start time to ensure uniqueness even if details change slightly
            $ics .= "UID:" . $event['uid'] . '-' . $dtStart->format('YmdHis') . "@pause.pmi\r\n";
            $ics .= "DTSTAMP:" . $nowUtc . "\r\n";
            // Use TZID or VALUE=DATE based on format
            $ics .= "DTSTART{$datePrefix}:" . $dtStartString . "\r\n";
            $ics .= "DTEND{$datePrefix}:" . $dtEndString . "\r\n";


            $ics .= "SUMMARY:" . $this->escapeIcsString($event['summary']) . "\r\n";
            if (!empty($event['location'])) {
                $ics .= "LOCATION:" . $this->escapeIcsString($event['location']) . "\r\n";
            }
            if (!empty($event['description'])) {
                $ics .= "DESCRIPTION:" . $this->escapeIcsString($event['description']) . "\r\n";
            }
            $ics .= "STATUS:" . $event['status'] . "\r\n";
            // NEU: Setze TRANSPARENT für ganztägige Events (blockiert keine Zeit), OPAQUE für zeitgebundene
            $ics .= ($dtStartFormat === 'Ymd') ? "TRANSP:TRANSPARENT\r\n" : "TRANSP:OPAQUE\r\n";
            $ics .= "END:VEVENT\r\n";
        }


        $ics .= "END:VCALENDAR\r\n";
        return $ics;
    }

    private function escapeIcsString(?string $string): string {
        if ($string === null) return '';
        $string = str_replace('\\', '\\\\', $string);
        $string = str_replace(';', '\;', $string);
        $string = str_replace(',', '\,', $string);
        $string = str_replace("\r", '', $string); // Remove CR
        $string = str_replace("\n", '\n', $string); // Escape LF
        return $string;
    }

} // End class
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\IcalController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\PdfController.php ---
<?php
// app/Http/Controllers/PdfController.php

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Security;
use App\Core\Utils;
use App\Repositories\PlanRepository;
use App\Repositories\UserRepository;
use Exception;
use DateTime;
use DateTimeZone;

// Define the font path constant BEFORE including tFPDF
// ** KORRIGIERT: Pfad zeigt jetzt auf das 'font' Hauptverzeichnis **
// tFPDF fügt 'unifont/' für TTF-Dateien selbst hinzu.
if (!defined('FPDF_FONTPATH')) {
    define('FPDF_FONTPATH', dirname(__DIR__, 3) . DIRECTORY_SEPARATOR . 'libs' . DIRECTORY_SEPARATOR . 'tfpdf' . DIRECTORY_SEPARATOR . 'font' . DIRECTORY_SEPARATOR);
}

// Include tFPDF library
require_once dirname(__DIR__, 3) . '/libs/tfpdf/tfpdf.php';


class PdfController extends \tFPDF
{
    private PlanRepository $planRepository;
    private UserRepository $userRepository;
    private array $config;
    private array $settings; // NEU: Einstellungen
    private array $userData;
    private int $targetYear;
    private int $targetWeek;
    private array $timetableData = [];
    private array $substitutionData = [];
    private array $cellWidths = [];
    // private float $rowHeight = 8; // VERALTET: Wird jetzt berechnet
    private float $headerHeight = 7; // Header row height in mm
    private float $totalWidth = 277; // A4 Landscape (297) - 10mm margins = 277

    // --- Font properties ---
    private string $fontBody = 'Arial';
    private string $fontDisplay = 'Arial';

    // --- Color definitions (RGB) ---
    private array $colors = [
        'border' => [200, 200, 200],
        'headerBg' => [240, 240, 240],
        'headerText' => [50, 50, 50],
        'cellBg' => [255, 255, 255],
        'cellText' => [0, 0, 0],
        'substBorderVertretung' => [220, 53, 69], // danger
        'substBorderRaum' => [255, 193, 7], // warning
        'substBorderEvent' => [13, 110, 253], // primary-ish
        'substBorderEntfall' => [108, 117, 125], // secondary-ish
        'substTextEntfall' => [108, 117, 125],
        'commentText' => [108, 117, 125], // secondary-ish
    ];


    public function __construct()
    {
        // Call tFPDF constructor (implicitly done via parent::__construct inside generateTimetablePdf)
        $pdo = Database::getInstance();
        $this->planRepository = new PlanRepository($pdo);
        $this->userRepository = new UserRepository($pdo);
        $this->config = Database::getConfig();
        $this->settings = Utils::getSettings(); // NEU: Einstellungen laden
    }

    /**
     * Entry point for generating the PDF.
     * Fetches data based on session and URL params, then builds the PDF.
     */
    public function generateTimetablePdf(int $year, int $week)
    {
        try {
            Security::requireLogin(); // Ensure user is logged in
            $userId = $_SESSION['user_id'] ?? null;
            $userRole = $_SESSION['user_role'] ?? null;
            $this->userData = $userId ? $this->userRepository->findById($userId) : null;

            if (!$this->userData || !in_array($userRole, ['schueler', 'lehrer'])) {
                throw new Exception("PDF Export nur für Schüler und Lehrer verfügbar.", 403);
            }

            $this->targetYear = $year;
            $this->targetWeek = $week;

            // Fetch data (only if published)
            $targetGroup = ($userRole === 'schueler') ? 'student' : 'teacher';
            if (!$this->planRepository->isWeekPublishedFor($targetGroup, $year, $week)) {
                 throw new Exception("Der Stundenplan für diese Woche ist noch nicht veröffentlicht.", 403);
            }

            if ($userRole === 'schueler' && !empty($this->userData['class_id'])) {
                $classId = $this->userData['class_id'];
                $this->timetableData = $this->planRepository->getPublishedTimetableForClass($classId, $year, $week);
                $this->substitutionData = $this->planRepository->getPublishedSubstitutionsForClassWeek($classId, $year, $week);
            } elseif ($userRole === 'lehrer' && !empty($this->userData['teacher_id'])) {
                $teacherId = $this->userData['teacher_id'];
                $this->timetableData = $this->planRepository->getPublishedTimetableForTeacher($teacherId, $year, $week);
                $this->substitutionData = $this->planRepository->getPublishedSubstitutionsForTeacherWeek($teacherId, $year, $week);
            } else {
                 throw new Exception("Benutzerdaten unvollständig (Klasse/Lehrer fehlt).", 400);
            }

            // --- Start PDF Generation ---
            parent::__construct('L', 'mm', 'A4'); // Call tFPDF constructor

            // --- FONT LOADING ---
            try {
                // ** KORRIGIERT: Verwende .ttf Dateinamen und 'true' für Unicode **
                // tFPDF sucht diese (mit $uni=true) automatisch im FPDF_FONTPATH . "unifont/" Verzeichnis
                 if (!file_exists(FPDF_FONTPATH . 'unifont' . DIRECTORY_SEPARATOR . 'Oswald-Regular.ttf')) throw new Exception("Font file not found: Oswald-Regular.ttf in " . FPDF_FONTPATH . 'unifont' . DIRECTORY_SEPARATOR);
                 if (!file_exists(FPDF_FONTPATH . 'unifont' . DIRECTORY_SEPARATOR . 'Oswald-Bold.ttf')) throw new Exception("Font file not found: Oswald-Bold.ttf in " . FPDF_FONTPATH . 'unifont' . DIRECTORY_SEPARATOR);
                 
                $this->AddFont('Oswald', '', 'Oswald-Regular.ttf', true);
                $this->AddFont('Oswald', 'B', 'Oswald-Bold.ttf', true);
                
                $this->fontBody = 'Arial'; // Set class property (Arial ist Core-Font)
                $this->fontDisplay = 'Oswald'; // Set class property

            } catch (Exception $fontEx) {
                 // Fallback auf Arial, falls Oswald auch fehlschlägt
                 error_log("Fehler beim Laden der PDF-Schriftarten: " . $fontEx->getMessage() . " - Fallback auf Arial.");
                 $this->fontBody = 'Arial'; // Set class property
                 $this->fontDisplay = 'Arial'; // Set class property
            }
            $this->AliasNbPages();
            $this->AddPage();
            // --- END FONT LOADING ---


            // Set Margins
            $this->SetMargins(10, 10, 10);
            // ** KORREKTUR: AutoPageBreak deaktivieren, da wir die Höhe manuell berechnen **
            $this->SetAutoPageBreak(false); 

            // Draw Header (Title)
            $this->drawPdfHeader();

            // Draw Timetable Grid
            $this->drawTimetableGrid();

            // Output PDF
            $filename = sprintf(
                'Stundenplan_%s_KW%02d_%d.pdf',
                str_replace([' ', '.'], '_', $this->userData['username'] ?? 'User'), // Replace spaces and dots in username
                $week,
                $year
            );
            // 'I' for inline display in browser
            $this->Output('I', $filename);
            exit; // Stop script after PDF output

        } catch (Exception $e) {
            http_response_code($e->getCode() ?: 500);
            // Simple error page (replace with a proper error view if needed)
            // CORRECTED PATHS: Go up 3 levels to project root, use DIRECTORY_SEPARATOR
            $projectRoot = dirname(__DIR__, 3);
            $headerPath = $projectRoot . DIRECTORY_SEPARATOR . 'pages' . DIRECTORY_SEPARATOR . 'partials' . DIRECTORY_SEPARATOR . 'header.php';
            $footerPath = $projectRoot . DIRECTORY_SEPARATOR . 'pages' . DIRECTORY_SEPARATOR . 'partials' . DIRECTORY_SEPARATOR . 'footer.php';

             // Prepare config for header/footer partials if they exist
             global $config; // Make $config available
             $config = $this->config; // Use the loaded config
             $page_title = "PDF Fehler"; // Basic title for error page

            // Check if header/footer exist before including to prevent further errors
            if (file_exists($headerPath)) {
                 include_once $headerPath;
            } else {
                 echo "<!DOCTYPE html><html><head><title>Fehler</title></head><body>"; // Basic fallback HTML
                 error_log("Error page header not found: " . $headerPath);
            }

            echo '<div class="container message error" style="margin-top: 50px;">';
            echo '<h1>PDF Generierungsfehler</h1>';
            // Avoid showing potentially sensitive details from font loading errors directly
             $errorMessage = htmlspecialchars($e->getMessage());
             if (str_contains($e->getMessage(), 'Could not include font definition file') || str_contains($e->getMessage(), 'Font file not found')) {
                 $errorMessage = 'Ein Fehler ist beim Laden der Schriftarten für das PDF aufgetreten (' . $errorMessage . '). Stellen Sie sicher, dass die .ttf-Dateien (und ggf. generierte .php/.z-Dateien) im korrekten Verzeichnis (`libs/tfpdf/font/unifont/`) liegen und lesbar sind. Kontaktieren Sie ggf. den Administrator.';
                 error_log("PDF Generation Font Error: " . $e->getMessage() . " | Trace: " . $e->getTraceAsString()); // Log original error
             }
             echo '<p>' . $errorMessage . '</p>';

            echo '<p><a href="' . Utils::url('dashboard') . '" class="btn btn-primary">Zurück zum Dashboard</a></p>';
            echo '</div>';

            if (file_exists($footerPath)) {
                 include_once $footerPath;
            } else {
                 echo "</body></html>";
                 error_log("Error page footer not found: " . $footerPath);
            }
            exit;
        }
    }

    /**
     * Draws the main title and subtitle of the PDF.
     * @return float The calculated height of the header area.
     */
    private function drawPdfHeader(): float
    {
        $monday = $this->getDateOfISOWeek($this->targetWeek, $this->targetYear);
        $friday = new DateTime();
        $friday->setTimestamp($monday->getTimestamp() + 4 * 24 * 60 * 60);

        $className = '';
        if($_SESSION['user_role'] === 'schueler') {
             $classData = $this->userRepository->findClassByUserId($this->userData['user_id']);
             if ($classData) {
                 $className = 'Klasse ' . ($classData['class_name'] ?? $classData['class_id']);
             }
        }

        $title = sprintf(
            'Stundenplan %s %s', // Removed () if className is empty
            $this->userData['username'] ?? 'Benutzer',
            $className ? '(' . $className . ')' : ''
        );
        $subTitle = sprintf(
            'Kalenderwoche %d / %d (%s - %s)',
            $this->targetWeek,
            $this->targetYear,
            $monday->format('d.m.Y'),
            $friday->format('d.m.Y')
        );

        $this->SetFont($this->fontDisplay, 'B', 16); // Use class property
        $this->SetTextColor(0, 0, 0);
        $this->Cell(0, 8, $this->utf8($title), 0, 1, 'C'); // Centered title
        $this->SetFont($this->fontBody, '', 10); // Use class property
        $this->Cell(0, 6, $this->utf8($subTitle), 0, 1, 'C'); // Centered subtitle
        $this->Ln(5); // Space after header

        return 8 + 6 + 5; // Return calculated height (8 + 6 + 5 = 19)
    }

    /**
     * Draws the complete timetable grid with headers and data.
     */
    private function drawTimetableGrid()
    {
        // --- Calculate Column Widths ---
        $timeColWidth = 18; // Width for the time column
        $dayColWidth = ($this->totalWidth - $timeColWidth) / 5; // Width for each day column
        $this->cellWidths = [$timeColWidth, $dayColWidth, $dayColWidth, $dayColWidth, $dayColWidth, $dayColWidth];

        // --- Draw Headers ---
        $this->SetFont($this->fontBody, 'B', 8); // Use class property
        $this->SetFillColor(...$this->colors['headerBg']);
        $this->SetTextColor(...$this->colors['headerText']);
        $this->SetDrawColor(...$this->colors['border']);
        $this->SetLineWidth(0.2);

        // Header Row 1: Time + Days
        $this->Cell($this->cellWidths[0], $this->headerHeight, $this->utf8('Zeit'), 1, 0, 'C', true);
        $daysOfWeek = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag'];
        foreach ($daysOfWeek as $i => $day) {
            $this->Cell($this->cellWidths[$i + 1], $this->headerHeight, $this->utf8($day), 1, 0, 'C', true);
        }
        $this->Ln($this->headerHeight);

        // --- Calculate Dynamic Row Height ---
        $headerAreaHeight = 19; // Höhe von drawPdfHeader (8 + 6 + 5)
        // ** KORREKTUR: $this->bMargin (unterer Rand für PageBreak) wird durch 10 (den expliziten unteren Rand) ersetzt
        $drawableHeight = $this->h - $this->tMargin - 10; // 210 - 10 - 10 = 190 (bei A4 landscape)
        $gridBodyHeight = $drawableHeight - $headerAreaHeight - $this->headerHeight; // 190 - 19 - 7 = 164
        
         $timeSlotsDisplay = [
             "08:00\n08:45", "08:55\n09:40", "09:40\n10:25", "10:35\n11:20",
             "11:20\n12:05", "13:05\n13:50", "13:50\n14:35", "14:45\n15:30",
             "15:30\n16:15", "16:25\n17:10"
         ];
         $numRows = count($timeSlotsDisplay);
         $calculatedRowHeight = $gridBodyHeight / $numRows; // z.B. 164 / 10 = 16.4mm
         $timeCellLineHeight = 3.5; // Feste Zeilenhöhe für 3 Zeilen Text (Stunde, Start, Ende)

        $timetableByCell = $this->prepareTimetableData();

        foreach ($timeSlotsDisplay as $period => $timeLabel) {
            $currentPeriod = $period + 1; // 1., 2., 3. Stunde...

            // Store Y position before drawing time cell
            $rowStartY = $this->GetY();

            // Draw Time Cell
            $this->SetFillColor(...$this->colors['headerBg']);
            $this->SetTextColor(...$this->colors['headerText']);
            
            // *** Stundennummer (z.B. 1.) ***
            $this->SetFont($this->fontBody, 'B', 8); // Größere Schrift für Stundennummer
            $periodLabel = $currentPeriod . ".";
            
            // *** Zeit (z.B. 08:00 - 08:45) ***
            $timeLabelParts = explode("\n", $timeLabel); // "08:00", "08:45"
            $timeLabelFormatted = $timeLabelParts[0] . ' - ' . $timeLabelParts[1];
            
            // Berechne Y-Start für Zentrierung von 2 Zeilen (Stunde + Zeit)
            $totalTextHeight = $timeCellLineHeight * 2;
            $cellCenterY = $rowStartY + ($calculatedRowHeight / 2);
            $textStartY = $cellCenterY - ($totalTextHeight / 2);

            // *** KORREKTUR: Erst Hintergrundzelle, dann Text ***

            // 1. Rahmen und BG für die Zelle zeichnen
            $this->SetXY(10, $rowStartY); 
            $this->Cell($this->cellWidths[0], $calculatedRowHeight, '', 1, 0, 'C', true); // Rahmen und BG zeichnen

            // 2. Stundennummer (darüber schreiben)
            $this->SetXY(10, $textStartY); // 10 = left margin
            $this->SetFont($this->fontBody, 'B', 8);
            $this->Cell($this->cellWidths[0], $timeCellLineHeight, $this->utf8($periodLabel), 0, 1, 'C', false); // 0 border, false fill
            
            // 3. Zeit (darüber schreiben)
            $this->SetFont($this->fontBody, '', 7); // Kleinere Schrift für Zeit
            $this->SetX(10);
            $this->Cell($this->cellWidths[0], $timeCellLineHeight, $this->utf8($timeLabelFormatted), 0, 1, 'C', false);


            // Reset Y position for drawing day cells in the same row
            $this->SetY($rowStartY);

            // Draw Day Cells for this period
            for ($dayNum = 1; $dayNum <= 5; $dayNum++) {
                 // Move X position for each day cell
                 $currentX = 10 + $this->cellWidths[0] + (($dayNum - 1) * $this->cellWidths[$dayNum]); // Margin + Time Col + Prev Day Cols
                 $this->SetX($currentX);

                 $cellKey = $dayNum . '-' . $currentPeriod;
                 $entry = $timetableByCell[$cellKey] ?? null;

                 // Draw the cell using calculated max height
                 $this->drawTimetableCell($entry, $this->cellWidths[$dayNum], $calculatedRowHeight, $this->fontBody, $currentPeriod); // Pass currentPeriod
            }
             // Move to the next line using the calculated max height
             $this->Ln($calculatedRowHeight);
        }
    }

    /**
     * Prepares timetable and substitution data into a lookup map by 'day-period'.
     * @return array Map where key is 'day-period' and value is the entry/substitution data.
     */
     private function prepareTimetableData(): array
     {
         $map = [];
         $userRole = $_SESSION['user_role'];

         // 1. Add regular entries
         foreach ($this->timetableData as $entry) {
             $key = $entry['day_of_week'] . '-' . $entry['period_number'];
             $map[$key] = [
                 'type' => 'regular',
                 'subject' => $entry['subject_shortcut'] ?? '---',
                 'mainText' => $userRole === 'schueler' ? ($entry['teacher_shortcut'] ?? '---') : ($entry['class_name'] ?? '---'),
                 'room' => $entry['room_name'] ?? '',
                 'comment' => $entry['comment'] ?? '',
                 'original' => $entry // Store original for context
             ];
         }

         // 2. Add substitutions, potentially overwriting regular entries
         foreach ($this->substitutionData as $sub) {
             // Calculate day_of_week (1=Mon, 5=Fri) using PHP DateTime
             try {
                 $subDate = new DateTime($sub['date']);
                 $dayNum = $subDate->format('N'); // ISO-8601 day of week (1 = Monday, 7 = Sunday)
             } catch (Exception $e) { continue; } // Skip if date is invalid

             if ($dayNum < 1 || $dayNum > 5) continue; // Skip weekends

             $key = $dayNum . '-' . $sub['period_number'];
             $regularEntryForKey = $map[$key]['original'] ?? null; // Get original entry if it exists

             $map[$key] = [
                 'type' => $sub['substitution_type'],
                 'subject' => $sub['new_subject_shortcut'] ?? $regularEntryForKey['subject_shortcut'] ?? ($sub['substitution_type'] === 'Sonderevent' ? 'EVENT' : ($sub['substitution_type'] === 'Entfall' ? ($regularEntryForKey['subject_shortcut'] ?? '---') : '---')),
                 'mainText' => $sub['substitution_type'] === 'Vertretung'
                     ? ($userRole === 'teacher' ? ($sub['class_name'] ?? $regularEntryForKey['class_name'] ?? '---') : ($sub['new_teacher_shortcut'] ?? '---'))
                     : ($sub['substitution_type'] === 'Entfall' ? 'Entfällt' : ($regularEntryForKey ? ($userRole === 'schueler' ? $regularEntryForKey['teacher_shortcut'] : $regularEntryForKey['class_name']) : '')),
                 'room' => $sub['new_room_name'] ?? $regularEntryForKey['room_name'] ?? '',
                 'comment' => $sub['comment'] ?? '',
                 'original' => $regularEntryForKey // Keep original entry context if available
             ];
         }
         return $map;
     }

    /**
     * Draws a single cell in the timetable grid.
     * @param array|null $entry Data for the cell, or null if empty.
     * @param float $width Cell width.
     * @param float $height Cell height.
     * @param string $fontBody Font name for cell content.
     * @param int $currentPeriod The current period number (1-10)
     */
    private function drawTimetableCell(?array $entry, float $width, float $height, string $fontBody, int $currentPeriod)
    {
        $this->SetFillColor(...$this->colors['cellBg']);
        $this->SetTextColor(...$this->colors['cellText']);
        $this->SetDrawColor(...$this->colors['border']);
        $this->SetLineWidth(0.2);
        $border = 1; // LRTB borders

        // Initial position
        $startX = $this->GetX();
        $startY = $this->GetY();

        $borderColor = null;

        if ($entry) {
            $subjectText = $this->utf8($entry['subject'] ?? '');
            $mainText = $this->utf8($entry['mainText'] ?? '');
            $roomText = $this->utf8($entry['room'] ?? '');
            $commentText = $this->utf8($entry['comment'] ?? '');

            // Determine border color for substitutions
            switch ($entry['type']) {
                case 'Vertretung': $borderColor = $this->colors['substBorderVertretung']; break;
                case 'Raumänderung': $borderColor = $this->colors['substBorderRaum']; break;
                case 'Sonderevent': $borderColor = $this->colors['substBorderEvent']; break;
                case 'Entfall': $borderColor = $this->colors['substBorderEntfall']; break;
                default: $borderColor = $this->colors['border']; // Regular border color
            }

            // Draw border first (if substitution)
            if ($borderColor && $borderColor !== $this->colors['border']) {
                $this->SetDrawColor(...$borderColor);
                $this->SetLineWidth(0.5); // Thicker border
                $this->Line($startX, $startY, $startX, $startY + $height); // Left border only
                $this->SetDrawColor(...$this->colors['border']); // Reset draw color
                $this->SetLineWidth(0.2); // Reset line width
            }

            // Draw the cell background and standard border
            $this->SetXY($startX, $startY);
            $this->Cell($width, $height, '', $border, 0, 'C', true);

            // --- Cell Content (Vertically Centered) ---
            $padding = 1.5; // Padding from top/sides
            $availableWidth = $width - (2 * $padding);
            $lineHeight = 3.5; // Angepasste Zeilenhöhe

            // Berechne die benötigte Gesamthöhe des Textblocks
            $textBlockHeight = 0;
            if ($entry['type'] === 'Entfall') {
                $textBlockHeight += $lineHeight; // Für "Entfällt: FACH"
            } else {
                $textBlockHeight += $lineHeight; // Für Fach
                $detailsText = trim(($mainText ? $mainText : '') . ($roomText ? ' (' . $roomText . ')' : ''));
                if ($detailsText) $textBlockHeight += $lineHeight;
            }
            if ($commentText && $entry['type'] !== 'Sonderevent') {
                $textBlockHeight += $lineHeight; // Annahme: Kommentar passt auf eine Zeile (oder MultiCell Höhe)
            }
             // Für Sonderevent (Fach + Kommentar als MainText)
            if ($entry['type'] === 'Sonderevent') {
                 $textBlockHeight = $lineHeight * 2; // Annahme: 2 Zeilen
            }


            // Berechne Y-Startposition für vertikale Zentrierung
            $contentStartY = $startY + ($height - $textBlockHeight) / 2;
            if ($contentStartY < $startY + $padding) $contentStartY = $startY + $padding; // Verhindere Überlappung oben

            $this->SetXY($startX + $padding, $contentStartY);

            // Subject
            $this->SetFont($fontBody, 'B', 9); // Größere Schrift
             if ($entry['type'] === 'Entfall') {
                 $this->SetTextColor(...$this->colors['substTextEntfall']);
                 $this->Cell($availableWidth, $lineHeight, $this->utf8('Entfällt: ') . $subjectText, 0, 1, 'C');
             } else {
                  $this->SetTextColor(...$this->colors['cellText']);
                  $this->Cell($availableWidth, $lineHeight, $subjectText, 0, 1, 'C');
             }

            // Main Text & Room (if not Entfall)
            if ($entry['type'] !== 'Entfall') {
                $this->SetFont($fontBody, '', 8); // Größere Schrift
                $this->SetTextColor(...$this->colors['cellText']);
                $detailsText = trim(($mainText ? $mainText : '') . ($roomText ? ' (' . $roomText . ')' : ''));
                 if ($detailsText) {
                     $this->SetX($startX + $padding); // Reset X
                     $this->Cell($availableWidth, $lineHeight, $detailsText, 0, 1, 'C');
                 }
            }

             // Comment
             if ($commentText && $entry['type'] !== 'Sonderevent') {
                 $this->SetFont($fontBody, '', 7); // Größere Schrift
                 $this->SetTextColor(...$this->colors['commentText']);
                 $this->SetX($startX + $padding); // Reset X
                 // Verwende Cell statt MultiCell, um Zeilenumbruch zu verhindern (besseres Layout bei fester Höhe)
                 $this->Cell($availableWidth, $lineHeight, $commentText, 0, 1, 'C');
             }

        } else {
            // Empty cell or FU
             // ** KORRIGIERT: Verwende die übergebene $currentPeriod **
             $isFU = ($currentPeriod == $this->settings['default_start_hour'] || $currentPeriod == $this->settings['default_end_hour']); // Verwende Einstellungen

            if ($isFU && ($currentPeriod == 1 || $currentPeriod == 10)) { // Fallback, falls Einstellungen nicht geladen (sollte nicht passieren)
                 $isFU = true;
            } else if ($isFU) {
                 // Verwende die Werte aus den Einstellungen
                 $isFU = ($currentPeriod == $this->settings['default_start_hour'] || $currentPeriod == $this->settings['default_end_hour']);
            }


            if ($isFU) {
                 $this->SetFillColor(...$this->colors['headerBg']); // Lighter background for FU
                 $this->SetTextColor(...$this->colors['headerText']);
                 $this->SetFont($fontBody, 'B', 8); // Größer
                 $this->Cell($width, $height, $this->utf8('FU'), $border, 0, 'C', true);
            } else {
                 // Completely empty cell
                 $this->Cell($width, $height, '', $border, 0, 'C', true);
            }

        }
        // Ensure we are positioned correctly for the next cell in the row
        $this->SetXY($startX + $width, $startY);
    }

    /**
     * Converts a UTF-8 string. Prefers mb_convert_encoding, falls back to iconv, then utf8_decode.
     */
    private function utf8($str) {
        if (!is_string($str)) {
             return $str; // Return non-strings as is
        }
        // If the string is already ISO-8859-1 or ASCII, no conversion needed
        if (mb_check_encoding($str, 'ISO-8859-1') || mb_check_encoding($str, 'ASCII')) {
             return $str;
        }

        if (function_exists('mb_convert_encoding')) {
            // Try ISO-8859-1 first, then CP1252 as a common Windows fallback
            $converted = @mb_convert_encoding($str, 'ISO-8859-1', 'UTF-8');
            // Check if conversion resulted in loss of characters (heuristic)
             if ($converted !== false && mb_strlen($str, 'UTF-8') === mb_strlen($converted, 'ISO-8859-1')) {
                 return $converted;
             }
             // Try CP1252 if ISO failed for some characters
             $converted_cp = @mb_convert_encoding($str, 'CP1252', 'UTF-8');
              if ($converted_cp !== false && mb_strlen($str, 'UTF-8') === mb_strlen($converted_cp, 'CP1252')) {
                  return $converted_cp;
              }

        }
        if (function_exists('iconv')) {
            // Use //TRANSLIT or //IGNORE - TRANSLIT might be better for accents
            $converted = @iconv('UTF-8', 'ISO-8859-1//TRANSLIT', $str);
            if ($converted !== false) {
                 return $converted;
            }
             $converted_cp = @iconv('UTF-8', 'CP1252//TRANSLIT', $str);
              if ($converted_cp !== false) {
                  return $converted_cp;
              }

        }
        // Final fallback
        return utf8_decode($str);
    }


     /**
      * Gets the date of the Monday of a given calendar week and year.
      * @param int $week - The calendar week.
      * @param int $year - The year.
      * @return DateTime The Date object for Monday (local time).
      */
     private function getDateOfISOWeek(int $week, int $year): DateTime {
          $dto = new DateTime();
          $dto->setISODate($year, $week, 1); // Set to Monday of the week
          $dto->setTime(0,0,0); // Set time to midnight
          return $dto;
     }

    // --- Override Header/Footer if needed ---
     // public function Header() { /* ... */ }
     public function Footer()
     {
         // Position at 1 cm from bottom
         $this->SetY(-10);
         // KORRIGIERT: Verwende die Klassen-Eigenschaft $this->fontBody
         $this->SetFont($this->fontBody,'',8);
         $this->SetTextColor(128); // Graue Schrift

         // NEU: Benutzerdefinierter Footer-Text aus Einstellungen
         $footerText = $this->settings['pdf_footer_text'] ?? 'PAUSE Portal';
         // Füge Generierungsdatum hinzu
         $footerText .= ' | Generiert am: ' . date('d.m.Y H:i');
         
         $this->Cell(0, 10, $this->utf8($footerText), 0, 0, 'L'); // Linksbündig

         // Page number
         // $this->Cell(0,10,$this->utf8('Seite ').$this->PageNo().'/{nb}',0,0,'C'); // Zentriert
         $this->Cell(0, 10, $this->utf8('Seite ').$this->PageNo().'/{nb}', 0, 0, 'R'); // Rechtsbündig
     }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\PdfController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\SingleEventController.php ---
<?php
// app/Http/Controllers/SingleEventController.php

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Security;
use App\Repositories\AcademicEventRepository;
use App\Repositories\PlanRepository;
use DateTimeImmutable;
use DateTimeZone;
use Exception;
use PDO;

/**
 * Erstellt einzelne .ics-Dateien für spezifische Events.
 */
class SingleEventController
{
    private PDO $pdo;
    private AcademicEventRepository $eventRepo;
    private PlanRepository $planRepo;
    private DateTimeZone $timezone;

    // Zeitdefinitionen (konsistent mit IcalController)
    private const PERIOD_TIMES = [
        1 => ['start' => '0800', 'end' => '0845'],
        2 => ['start' => '0855', 'end' => '0940'],
        3 => ['start' => '0940', 'end' => '1025'],
        4 => ['start' => '1035', 'end' => '1120'],
        5 => ['start' => '1120', 'end' => '1205'],
        6 => ['start' => '1305', 'end' => '1350'],
        7 => ['start' => '1350', 'end' => '1435'],
        8 => ['start' => '1445', 'end' => '1530'],
        9 => ['start' => '1530', 'end' => '1615'],
        10 => ['start' => '1625', 'end' => '1710'],
    ];

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->eventRepo = new AcademicEventRepository($this->pdo);
        $this->planRepo = new PlanRepository($this->pdo);
        $this->timezone = new DateTimeZone('Europe/Berlin');
    }

    /**
     * Generiert eine .ics-Datei für ein einzelnes Event (Aufgabe, Klausur oder Sonderevent).
     *
     * @param string $type Typ des Events ('acad' für academic_events, 'sub' für substitutions)
     * @param int $id Die ID des Events
     */
    public function generateIcs(string $type, int $id)
    {
        try {
            Security::requireLogin(); // Benutzer muss angemeldet sein

            $eventData = null;
            if ($type === 'acad') {
                $eventData = $this->getAcademicEventData($id);
            } elseif ($type === 'sub') {
                $eventData = $this->getSubstitutionEventData($id);
            } else {
                throw new Exception("Ungültiger Event-Typ.", 400);
            }

            if (!$eventData) {
                throw new Exception("Termin nicht gefunden.", 404);
            }
            
            // Berechtigungsprüfung (vereinfacht):
            // TODO: Prüfen, ob der User (Schüler/Lehrer) dieses Event überhaupt sehen darf.
            // Für MVP lassen wir diese komplexe Prüfung weg, da Security::requireLogin() gilt.

            $icsContent = $this->formatAsIcs($eventData);
            $filename = str_replace(' ', '_', $eventData['summary'] ?? 'termin') . '.ics';

            // HTTP-Header für .ics-Download senden
            header('Content-Type: text/calendar; charset=utf-8');
            header('Content-Disposition: attachment; filename="' . $filename . '"');
            header('Cache-Control: no-cache, no-store, must-revalidate');
            header('Pragma: no-cache');
            header('Expires: 0');
            
            echo $icsContent;
            exit;

        } catch (Exception $e) {
            http_response_code($e->getCode() ?: 500);
            // Zeige eine einfache Fehlermeldung statt die App abzustürzen
            die("Fehler beim Erstellen der Kalenderdatei: " . htmlspecialchars($e->getMessage()));
        }
    }

    /** Holt und formatiert Daten für Aufgaben/Klausuren */
    private function getAcademicEventData(int $id): ?array
    {
        $event = $this->eventRepo->getEventById($id); // Diese Methode ist jetzt public
        if (!$event) return null;

        $dateObj = new DateTimeImmutable($event['due_date'] . ' 00:00:00', $this->timezone);
        $dtStart = $dateObj;
        $dtEnd = $dateObj->modify('+1 day');
        $dtStartFormat = 'Ymd';
        $dtEndFormat = 'Ymd';
        $timeInfo = "";
        $location = ""; // Aufgaben/Klausuren haben keinen Ort im Schema

        $icon = 'ℹ️'; $prefix = 'Info';
        if ($event['event_type'] === 'klausur') { $icon = '🎓'; $prefix = 'Klausur'; }
        if ($event['event_type'] === 'aufgabe') { $icon = '📚'; $prefix = 'Aufgabe'; }

        $summary = "{$icon} {$prefix}: " . ($event['title'] ?? 'Eintrag');
        if ($event['subject_shortcut']) {
            $summary .= " (" . $event['subject_shortcut'] . ")";
        }

        $description = "Typ: " . ucfirst($event['event_type']) . "\n";
        $description .= "Fach: " . ($event['subject_shortcut'] ?? '-') . "\n";
        $description .= "Klasse: " . ($event['class_name'] ?? '?') . "\n";
        $description .= "Datum: " . $dateObj->format('d.m.Y') . $timeInfo . "\n";
        if ($event['description']) {
            $description .= "\nBeschreibung:\n" . $event['description'];
        }

        return [
            'uid' => 'acad-' . $event['event_id'],
            'dtStart' => $dtStart,
            'dtEnd' => $dtEnd,
            'dtStartFormat' => $dtStartFormat,
            'dtEndFormat' => $dtEndFormat,
            'summary' => $summary,
            'location' => $location,
            'description' => trim($description),
            'status' => 'CONFIRMED',
        ];
    }

    /** Holt und formatiert Daten für Sonderevents (aus Vertretungen) */
    private function getSubstitutionEventData(int $id): ?array
    {
        $sub = $this->planRepo->getSubstitutionById($id); // Diese Methode ist public
        if (!$sub || $sub['substitution_type'] !== 'Sonderevent') {
            // Nur Sonderevents zulassen
            return null; 
        }

        $dateObj = new DateTimeImmutable($sub['date'] . ' 00:00:00', $this->timezone);
        $period = (int)$sub['period_number'];
        $times = self::PERIOD_TIMES[$period] ?? null;

        if (!$times) {
            throw new Exception("Ungültige Zeit für Sonderevent.");
        }

        $dtStart = $dateObj->setTime((int)substr($times['start'], 0, 2), (int)substr($times['start'], 2, 2));
        $dtEnd = $dateObj->setTime((int)substr($times['end'], 0, 2), (int)substr($times['end'], 2, 2));
        $dtStartFormat = 'Ymd\THis';
        $dtEndFormat = 'Ymd\THis';
        
        $summary = "Sonderevent: " . ($sub['comment'] ?: $sub['new_subject_shortcut'] ?: 'Termin');
        $location = $sub['new_room_name'] ?? '';
        
        $description = "Sonderevent\n";
        $description .= "Klasse: " . ($sub['class_name'] ?? '?') . "\n";
        $description .= "Raum: " . ($location ?: '?') . "\n";
        if ($sub['comment']) {
            $description .= "Details: " . $sub['comment'];
        }

        return [
            'uid' => 'sub-' . $sub['substitution_id'],
            'dtStart' => $dtStart,
            'dtEnd' => $dtEnd,
            'dtStartFormat' => $dtStartFormat,
            'dtEndFormat' => $dtEndFormat,
            'summary' => $summary,
            'location' => $location,
            'description' => trim($description),
            'status' => 'CONFIRMED',
        ];
    }

    /** Formatiert ein einzelnes Event als vollständigen iCal-String */
    private function formatAsIcs(array $event): string
    {
        $ics = "BEGIN:VCALENDAR\r\n";
        $ics .= "VERSION:2.0\r\n";
        $ics .= "PRODID:-//PMI//PAUSE Einzeltermin v1.0//DE\r\n";
        $ics .= "CALSCALE:GREGORIAN\r\n";
        $ics .= "METHOD:PUBLISH\r\n";

        // Zeitzonen-Definition (wichtig für zeitbasierte Termine)
        $ics .= "BEGIN:VTIMEZONE\r\n";
        $ics .= "TZID:Europe/Berlin\r\n";
        $ics .= "X-LIC-LOCATION:Europe/Berlin\r\n";
        $ics .= "BEGIN:DAYLIGHT\r\n";
        $ics .= "TZOFFSETFROM:+0100\r\n";
        $ics .= "TZOFFSETTO:+0200\r\n";
        $ics .= "TZNAME:CEST\r\n";
        $ics .= "DTSTART:19700329T020000\r\n";
        $ics .= "RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\n";
        $ics .= "END:DAYLIGHT\r\n";
        $ics .= "BEGIN:STANDARD\r\n";
        $ics .= "TZOFFSETFROM:+0200\r\n";
        $ics .= "TZOFFSETTO:+0100\r\n";
        $ics .= "TZNAME:CET\r\n";
        $ics .= "DTSTART:19701025T030000\r\n";
        $ics .= "RRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\n";
        $ics .= "END:STANDARD\r\n";
        $ics .= "END:VTIMEZONE\r\n";

        $nowUtc = gmdate('Ymd\THis\Z');

        // Event-Daten
        $dtStart = $event['dtStart'];
        $dtEnd = $event['dtEnd'];
        $dtStartFormat = $event['dtStartFormat'] ?? 'Ymd\THis';
        $dtEndFormat = $event['dtEndFormat'] ?? 'Ymd\THis';
        $dtStartString = $dtStart->format($dtStartFormat);
        $dtEndString = $dtEnd->format($dtEndFormat);
        $datePrefix = ($dtStartFormat === 'Ymd') ? ';VALUE=DATE' : ';TZID=Europe/Berlin';
        
        if ($dtStartFormat === 'Ymd\THis' && $dtEndFormat === 'Ymd') {
             $dtEndString = $dtEnd->format('Ymd\THis'); // Korrigiere Endformat bei Zeit-Events
        }

        $ics .= "BEGIN:VEVENT\r\n";
        $ics .= "UID:" . $event['uid'] . '-' . $dtStart->format('YmdHis') . "@pause.pmi\r\n";
        $ics .= "DTSTAMP:" . $nowUtc . "\r\n";
        $ics .= "DTSTART{$datePrefix}:" . $dtStartString . "\r\n";
        $ics .= "DTEND{$datePrefix}:" . $dtEndString . "\r\n";
        $ics .= "SUMMARY:" . $this->escapeIcsString($event['summary']) . "\r\n";
        if (!empty($event['location'])) {
            $ics .= "LOCATION:" . $this->escapeIcsString($event['location']) . "\r\n";
        }
        if (!empty($event['description'])) {
            $ics .= "DESCRIPTION:" . $this->escapeIcsString($event['description']) . "\r\n";
        }
        $ics .= "STATUS:" . $event['status'] . "\r\n";
        $ics .= ($dtStartFormat === 'Ymd') ? "TRANSP:TRANSPARENT\r\n" : "TRANSP:OPAQUE\r\n";
        $ics .= "END:VEVENT\r\n";

        $ics .= "END:VCALENDAR\r\n";
        return $ics;
    }

    private function escapeIcsString(?string $string): string {
        if ($string === null) return '';
        $string = str_replace('\\', '\\\\', $string);
        $string = str_replace(';', '\;', $string);
        $string = str_replace(',', '\,', $string);
        $string = str_replace("\r", '', $string);
        $string = str_replace("\n", '\n', $string);
        return $string;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\SingleEventController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\TeacherController.php ---
<?php
// app/Http/Controllers/TeacherController.php

namespace App\Http\Controllers;

use App\Core\Database;
use App\Core\Security;
use App\Core\Utils;
use App\Repositories\StammdatenRepository;
use App\Repositories\PlanRepository;
use App\Repositories\UserRepository;
use App\Repositories\AttendanceRepository;
use App\Repositories\AppointmentRepository; // NEU
use App\Services\AuditLogger;
use Exception;
use PDO;
use DateTime;
use DateTimeZone;

class TeacherController
{
    private PDO $pdo;
    private StammdatenRepository $stammdatenRepo;
    private PlanRepository $planRepo;
    private UserRepository $userRepo;
    private AttendanceRepository $attendanceRepo;
    private AppointmentRepository $appointmentRepo; // NEU

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->stammdatenRepo = new StammdatenRepository($this->pdo);
        $this->planRepo = new PlanRepository($this->pdo);
        $this->userRepo = new UserRepository($this->pdo);
        $this->attendanceRepo = new AttendanceRepository($this->pdo);
        $this->appointmentRepo = new AppointmentRepository($this->pdo); // NEU
    }

    /**
     * API: Sucht nach Lehrern basierend auf einer Suchanfrage.
     * KORREKTUR: Jetzt für 'lehrer' UND 'schueler' verfügbar.
     */
    public function searchColleaguesApi()
    {
        Security::requireRole(['lehrer', 'schueler']); // ERWEITERT
        header('Content-Type: application/json');

        try {
            $query = filter_input(INPUT_GET, 'query', FILTER_UNSAFE_RAW) ?? '';
            
            $allTeachers = $this->stammdatenRepo->getTeachers();
            
            $filteredTeachers = [];
            if (!empty($query)) {
                $filteredTeachers = array_filter($allTeachers, function($teacher) use ($query) {
                    $fullName = $teacher['first_name'] . ' ' . $teacher['last_name'];
                    return stripos($fullName, $query) !== false || 
                           stripos($teacher['teacher_shortcut'], $query) !== false;
                });
            } else {
                $filteredTeachers = array_slice($allTeachers, 0, 10);
            }

            echo json_encode(['success' => true, 'data' => array_values($filteredTeachers)]);

        } catch (Exception $e) {
            http_response_code(500);
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }

    /**
     * API: Findet den aktuellen Aufenthaltsort (Stunde/Raum) eines Lehrers.
     * Nur für eingeloggte Lehrer.
     */
    public function findColleagueApi()
    {
        Security::requireRole('lehrer');
        header('Content-Type: application/json');

        try {
            $teacherId = filter_input(INPUT_GET, 'teacher_id', FILTER_VALIDATE_INT);
            if (!$teacherId) {
                throw new Exception("Keine Lehrer-ID angegeben.", 400);
            }

            // 1. Aktuelle Zeit, Woche, Tag und Stunde ermitteln
            $now = new DateTime('now', new DateTimeZone('Europe/Berlin'));
            $currentDate = $now->format('Y-m-d');
            $currentYear = (int)$now->format('o');
            $currentWeek = (int)$now->format('W');
            $currentDayOfWeek = (int)$now->format('N'); // 1 (Mo) - 7 (So)
            
            $currentHourMinute = (int)$now->format('Hi');
            $currentPeriod = $this->getCurrentPeriod($currentHourMinute);

            if ($currentDayOfWeek > 5 || $currentPeriod === null) {
                echo json_encode(['success' => true, 'data' => [
                    'status' => 'Außerhalb der Zeit',
                    'message' => 'Der Kollege befindet sich wahrscheinlich nicht im Unterricht (Wochenende oder außerhalb der Unterrichtszeit).'
                ]]);
                exit();
            }

            // 2. Repository abfragen
            $lessonInfo = $this->planRepo->findTeacherLocation(
                $teacherId,
                $currentDate,
                $currentYear,
                $currentWeek,
                $currentDayOfWeek,
                $currentPeriod
            );
            
            // 3. Antwort basierend auf dem Ergebnis formatieren
            $message = $this->formatLessonInfo($lessonInfo);

            echo json_encode(['success' => true, 'data' => [
                'status' => $lessonInfo['status'],
                'message' => $message,
                'details' => $lessonInfo['data'] ?? null
            ]]);

        } catch (Exception $e) {
            http_response_code($e->getCode() === 400 ? 400 : 500);
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }
    
    /**
     * API: Holt die aktuelle Stunde des Lehrers UND die Schülerliste dafür.
     */
    public function getCurrentLessonWithStudentsApi()
    {
        Security::requireRole('lehrer');
        header('Content-Type: application/json');

        try {
            // 1. Aktuellen Lehrer-Benutzer holen
            $user = $this->userRepo->findById($_SESSION['user_id']);
            if (!$user || !$user['teacher_id']) {
                throw new Exception("Kein gültiges Lehrerprofil gefunden.", 403);
            }
            $teacherId = $user['teacher_id'];

            // 2. Aktuelle Zeit/Periode ermitteln
            $now = new DateTime('now', new DateTimeZone('Europe/Berlin'));
            $currentDate = $now->format('Y-m-d');
            $currentYear = (int)$now->format('o');
            $currentWeek = (int)$now->format('W');
            $currentDayOfWeek = (int)$now->format('N');
            $currentHourMinute = (int)$now->format('Hi');
            $currentPeriod = $this->getCurrentPeriod($currentHourMinute);
            
            if ($currentDayOfWeek > 5 || $currentPeriod === null) {
                echo json_encode(['success' => true, 'data' => ['status' => 'Außerhalb der Zeit', 'lesson' => null, 'students' => []]]);
                exit();
            }
            
            // 3. Aktuellen Standort/Unterricht finden
            $lessonInfo = $this->planRepo->findTeacherLocation(
                $teacherId,
                $currentDate,
                $currentYear,
                $currentWeek,
                $currentDayOfWeek,
                $currentPeriod
            );
            
            // 4. Prüfen, ob der Lehrer unterrichtet
            if ($lessonInfo['status'] === 'Unterricht' || $lessonInfo['status'] === 'Vertretung') {
                $lessonData = $lessonInfo['data'];
                $classId = $lessonData['class_id'];
                
                // 5. Schülerliste holen
                $students = $this->userRepo->getStudentsByClassId($classId);
                
                // 6. Bereits erfasste Anwesenheit holen
                $attendance = $this->attendanceRepo->getAttendance($classId, $currentDate, $currentPeriod);
                
                echo json_encode(['success' => true, 'data' => [
                    'status' => $lessonInfo['status'],
                    'lesson' => $lessonData,
                    'students' => $students,
                    'attendance' => $attendance,
                    'context' => ['date' => $currentDate, 'period' => $currentPeriod] // Kontext für Speichern
                ]]);

            } else {
                // Freistunde, Entfall etc.
                echo json_encode(['success' => true, 'data' => ['status' => $lessonInfo['status'], 'lesson' => null, 'students' => []]]);
            }

        } catch (Exception $e) {
            http_response_code(500);
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }
    
    /**
     * API: Speichert die Anwesenheitsliste.
     */
    public function saveAttendanceApi()
    {
        Security::requireRole('lehrer');
        Security::verifyCsrfToken();
        header('Content-Type: application/json');
        
        try {
            $data = json_decode(file_get_contents('php://input'), true);
            if (json_last_error() !== JSON_ERROR_NONE) {
                throw new Exception("Ungültige Daten (JSON) empfangen.", 400);
            }
            
            // 1. Aktuellen Lehrer-Benutzer holen
            $user = $this->userRepo->findById($_SESSION['user_id']);
            if (!$user || !$user['teacher_id']) {
                throw new Exception("Kein gültiges Lehrerprofil gefunden.", 403);
            }
            $teacherUserId = $user['user_id']; // ID aus der users-Tabelle, nicht teachers
            
            // 2. Daten validieren
            $classId = filter_var($data['class_id'] ?? null, FILTER_VALIDATE_INT);
            $date = $data['date'] ?? null;
            $period = filter_var($data['period_number'] ?? null, FILTER_VALIDATE_INT);
            $students = $data['students'] ?? [];

            if (!$classId || !$date || !$period || empty($students) || !is_array($students)) {
                throw new Exception("Fehlende oder ungültige Daten (Klasse, Datum, Stunde oder Schülerliste).", 400);
            }
            
            // 3. Speichern
            $success = $this->attendanceRepo->saveAttendance(
                $teacherUserId,
                $classId,
                $date,
                $period,
                $students
            );

            if ($success) {
                AuditLogger::log('save_attendance', 'class', $classId, [
                    'date' => $date, 
                    'period' => $period, 
                    'student_count' => count($students)
                ]);
                echo json_encode(['success' => true, 'message' => 'Anwesenheit gespeichert!']);
            } else {
                throw new Exception("Anwesenheit konnte nicht gespeichert werden.");
            }

        } catch (Exception $e) {
            $code = $e->getCode() === 400 ? 400 : 500;
            http_response_code($code);
            error_log("Save Attendance Error: " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }

    
    /**
     * API: Holt die Voraussetzungen (Fächer und unterrichtete Klassen) für das Event-Formular.
     */
    public function getPrerequisitesApi()
    {
        Security::requireRole('lehrer');
        header('Content-Type: application/json');

        try {
            // 1. Aktuellen Lehrer-Benutzer holen
            $user = $this->userRepo->findById($_SESSION['user_id']);
            if (!$user || !$user['teacher_id']) {
                throw new Exception("Kein gültiges Lehrerprofil gefunden.", 403);
            }
            $teacherId = $user['teacher_id'];

            // 2. Alle Fächer holen
            $subjects = $this->stammdatenRepo->getSubjects();
            
            // 3. Nur die Klassen holen, die dieser Lehrer unterrichtet
            $classes = $this->planRepo->getClassesForTeacher($teacherId);

            echo json_encode([
                'success' => true,
                'data' => [
                    'subjects' => $subjects,
                    'classes' => $classes
                ]
            ]);

        } catch (Exception $e) {
            $code = $e->getCode() === 403 ? 403 : 500;
            http_response_code($code);
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }


    // --- NEUE METHODEN FÜR SPRECHSTUNDEN ---

    /**
     * API: Holt die definierten Sprechstundenfenster des eingeloggten Lehrers.
     */
    public function getOfficeHoursApi()
    {
        Security::requireRole('lehrer');
        header('Content-Type: application/json');
        try {
            $teacherUserId = $_SESSION['user_id'];
            $availabilities = $this->appointmentRepo->getAvailabilities($teacherUserId);
            echo json_encode(['success' => true, 'data' => $availabilities]);
        } catch (Exception $e) {
            http_response_code(500);
            echo json_encode(['success' => false, 'message' => 'Fehler beim Laden der Sprechzeiten: ' . $e->getMessage()]);
        }
        exit();
    }

    /**
     * API: Speichert ein neues Sprechstundenfenster für den eingeloggten Lehrer.
     */
    public function saveOfficeHoursApi()
    {
        Security::requireRole('lehrer');
        Security::verifyCsrfToken();
        header('Content-Type: application/json');

        try {
            $teacherUserId = $_SESSION['user_id'];
            $data = json_decode(file_get_contents('php://input'), true);

            // Validierung
            $dayOfWeek = filter_var($data['day_of_week'] ?? null, FILTER_VALIDATE_INT);
            $startTime = $data['start_time'] ?? null; // z.B. 14:00
            $endTime = $data['end_time'] ?? null;
            $slotDuration = filter_var($data['slot_duration'] ?? 15, FILTER_VALIDATE_INT);

            if (!$dayOfWeek || !$startTime || !$endTime || !$slotDuration || $dayOfWeek < 1 || $dayOfWeek > 5 || $slotDuration < 5) {
                throw new Exception("Ungültige Eingabedaten.", 400);
            }

            $newId = $this->appointmentRepo->createAvailability($teacherUserId, $dayOfWeek, $startTime, $endTime, $slotDuration);
            
            AuditLogger::log('create_office_hours', 'teacher_availability', $newId, $data);
            
            echo json_encode(['success' => true, 'message' => 'Sprechzeit erfolgreich gespeichert.', 'data' => ['availability_id' => $newId]]);

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            echo json_encode(['success' => false, 'message' => 'Fehler beim Speichern: ' . $e->getMessage()]);
        }
        exit();
    }

    /**
     * API: Löscht ein Sprechstundenfenster des eingeloggten Lehrers.
     */
    public function deleteOfficeHoursApi()
    {
        Security::requireRole('lehrer');
        Security::verifyCsrfToken();
        header('Content-Type: application/json');

        try {
            $teacherUserId = $_SESSION['user_id'];
            $data = json_decode(file_get_contents('php://input'), true);
            $availabilityId = filter_var($data['availability_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$availabilityId) {
                throw new Exception("Keine ID angegeben.", 400);
            }

            $success = $this->appointmentRepo->deleteAvailability($availabilityId, $teacherUserId);
            
            if ($success) {
                AuditLogger::log('delete_office_hours', 'teacher_availability', $availabilityId);
                echo json_encode(['success' => true, 'message' => 'Sprechzeit erfolgreich gelöscht.']);
            } else {
                throw new Exception("Sprechzeit nicht gefunden oder keine Berechtigung.", 404);
            }

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            echo json_encode(['success' => false, 'message' => 'Fehler beim Löschen: ' . $e->getMessage()]);
        }
        exit();
    }

    
    /**
     * Hilfsfunktion: Wandelt einen 'Hi'-Zeitstempel in eine Periodennummer um.
     */
    private function getCurrentPeriod(int $hourMinute): ?int
    {
        if ($hourMinute >= 800 && $hourMinute <= 845) return 1;
        if ($hourMinute >= 855 && $hourMinute <= 940) return 2;
        if ($hourMinute >= 940 && $hourMinute <= 1025) return 3;
        if ($hourMinute >= 1035 && $hourMinute <= 1120) return 4;
        if ($hourMinute >= 1120 && $hourMinute <= 1205) return 5;
        // Mittagspause
        if ($hourMinute >= 1305 && $hourMinute <= 1350) return 6;
        if ($hourMinute >= 1350 && $hourMinute <= 1435) return 7;
        if ($hourMinute >= 1445 && $hourMinute <= 1530) return 8;
        if ($hourMinute >= 1530 && $hourMinute <= 1615) return 9;
        if ($hourMinute >= 1625 && $hourMinute <= 1710) return 10;
        
        return null; // Außerhalb der Zeit
    }
    
    /**
     * Hilfsfunktion: Formatiert die Rohdaten aus dem Repository in eine lesbare Nachricht.
     */
    private function formatLessonInfo(array $info): string
    {
        $data = $info['data'] ?? null;
        
        switch ($info['status']) {
            case 'Unterricht':
                return sprintf(
                    "Hält regulären Unterricht (%s) in Klasse %s in Raum %s.",
                    htmlspecialchars($data['subject_shortcut'] ?? '?'),
                    htmlspecialchars($data['class_name'] ?? '?'),
                    htmlspecialchars($data['room_name'] ?? '?')
                );
            case 'Vertretung':
                return sprintf(
                    "Ist als Vertretung (%s) in Klasse %s in Raum %s.",
                    htmlspecialchars($data['new_subject_shortcut'] ?? '?'),
                    htmlspecialchars($data['class_name'] ?? '?'),
                    htmlspecialchars($data['new_room_name'] ?? '?')
                );
            case 'Entfall':
                return sprintf(
                    "Die Stunde (%s, Klasse %s) entfällt. Der Kollege ist voraussichtlich frei.",
                    htmlspecialchars($data['original_subject_shortcut'] ?? '?'),
                    htmlspecialchars($data['class_name'] ?? '?')
                );
            case 'Raumänderung':
                return sprintf(
                    "Die Stunde (%s, Klasse %s) wurde nach Raum %s verlegt.",
                    htmlspecialchars($data['original_subject_shortcut'] ?? '?'),
                    htmlspecialchars($data['class_name'] ?? '?'),
                    htmlspecialchars($data['new_room_name'] ?? '?')
                );
            case 'Sonderevent':
                 return sprintf(
                    "Nimmt am Sonderevent '%s' (Klasse %s) in Raum %s teil.",
                    htmlspecialchars($data['comment'] ?? 'Event'),
                    htmlspecialchars($data['class_name'] ?? '?'),
                    htmlspecialchars($data['new_room_name'] ?? '?')
                );
            case 'Freistunde':
                return "Hat laut Plan jetzt eine Freistunde (FU).";
            default:
                return "Status unbekannt.";
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Http\Controllers\TeacherController.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AcademicEventRepository.php ---
<?php
// app/Repositories/AcademicEventRepository.php

namespace App\Repositories;

use PDO;
use Exception;
use DateTime; // Wichtig für Datumsberechnungen

class AcademicEventRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Holt alle Events (Aufgaben, Klausuren) für eine bestimmte Klasse in einem Zeitraum.
     * @param int $classId
     * @param int $year
     * @param int $week
     * @return array
     */
    public function getEventsForClassByWeek(int $classId, int $year, int $week): array
    {
        // Berechne Start- und Enddatum der Woche (Mo-So)
        $monday = new DateTime();
        $monday->setISODate($year, $week, 1); // 1 = Montag
        $startDate = $monday->format('Y-m-d');

        $sunday = new DateTime();
        $sunday->setISODate($year, $week, 7); // 7 = Sonntag
        $endDate = $sunday->format('Y-m-d');

        // Nutze die neue, allgemeinere Funktion
        return $this->getEventsForClassByDateRange($classId, $startDate, $endDate);
    }

    /**
     * Holt Events für eine Klasse in einem Datumsbereich.
     * @param int $classId
     * @param string $startDate (Y-m-d)
     * @param string $endDate (Y-m-d)
     * @return array
     */
    public function getEventsForClassByDateRange(int $classId, string $startDate, string $endDate): array
    {
        // KORREKTUR: ae.period_number aus ORDER BY entfernt
        $sql = "SELECT
                    ae.*,
                    s.subject_shortcut,
                    u.first_name AS teacher_first_name,
                    u.last_name AS teacher_last_name
                FROM academic_events ae
                LEFT JOIN subjects s ON ae.subject_id = s.subject_id
                JOIN users u ON ae.user_id = u.user_id
                WHERE ae.class_id = :class_id
                  AND ae.due_date BETWEEN :start_date AND :end_date
                ORDER BY ae.due_date ASC, ae.event_type ASC";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':class_id' => $classId,
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }


    /**
     * Holt alle Events, die ein Lehrer für die nahe Zukunft erstellt hat.
     * @param int $teacherUserId Die user_id des Lehrers
     * @param int $daysInFuture
     * @return array
     */
    public function getEventsByTeacher(int $teacherUserId, int $daysInFuture = 14): array
    {
        $startDate = (new DateTime('now', new \DateTimeZone('Europe/Berlin')))->format('Y-m-d');
        $endDate = (new DateTime('now', new \DateTimeZone('Europe/Berlin')))->modify("+{$daysInFuture} days")->format('Y-m-d');

        // Nutze die neue, allgemeinere Funktion
        return $this->getEventsByTeacherForDateRange($teacherUserId, $startDate, $endDate);
    }

    /**
     * Holt Events, die ein Lehrer erstellt hat, in einem Datumsbereich.
     * @param int $teacherUserId
     * @param string $startDate (Y-m-d)
     * @param string $endDate (Y-m-d)
     * @return array
     */
    public function getEventsByTeacherForDateRange(int $teacherUserId, string $startDate, string $endDate): array
    {
        // KORREKTUR: ae.period_number aus ORDER BY entfernt
         $sql = "SELECT
                    ae.*,
                    s.subject_shortcut,
                    c.class_name
                FROM academic_events ae
                LEFT JOIN subjects s ON ae.subject_id = s.subject_id
                JOIN classes c ON ae.class_id = c.class_id
                WHERE ae.user_id = :teacher_user_id
                  AND ae.due_date BETWEEN :start_date AND :end_date
                ORDER BY ae.due_date ASC, c.class_name ASC";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':teacher_user_id' => $teacherUserId,
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Prüft, ob ein Lehrer berechtigt ist, für eine Klasse an einem Datum einen Eintrag zu erstellen.
     * (Prüft, ob der Lehrer an dem Tag Unterricht in der Klasse hat)
     * @param int $teacherId Die teacher_id (aus der teachers Tabelle)
     * @param int $classId
     * @param string $date YYYY-MM-DD
     * @return bool
     */
    public function checkTeacherAuthorization(int $teacherId, int $classId, string $date): bool
    {
        try {
            $dateObj = new DateTime($date);
            $year = (int)$dateObj->format('o');
            $week = (int)$dateObj->format('W');
            $dayOfWeek = (int)$dateObj->format('N'); // 1=Mo, 7=So

            // 1. Prüfen auf regulären Unterricht
            $sqlRegular = "SELECT 1 FROM timetable_entries
                           WHERE teacher_id = :teacher_id
                             AND class_id = :class_id
                             AND year = :year
                             AND calendar_week = :week
                             AND day_of_week = :day_of_week
                           LIMIT 1";

            $stmtRegular = $this->pdo->prepare($sqlRegular);
            $stmtRegular->execute([
                ':teacher_id' => $teacherId,
                ':class_id' => $classId,
                ':year' => $year,
                ':week' => $week,
                ':day_of_week' => $dayOfWeek
            ]);

            if ($stmtRegular->fetchColumn()) {
                return true; // Ja, hat regulären Unterricht
            }

            // 2. Prüfen auf Vertretung (als neuer Lehrer)
            $sqlSub = "SELECT 1 FROM substitutions
                       WHERE new_teacher_id = :teacher_id
                         AND class_id = :class_id
                         AND date = :date
                       LIMIT 1";

            $stmtSub = $this->pdo->prepare($sqlSub);
            $stmtSub->execute([
                ':teacher_id' => $teacherId,
                ':class_id' => $classId,
                ':date' => $date
            ]);

            if ($stmtSub->fetchColumn()) {
                return true; // Ja, hält eine Vertretung
            }

            return false; // Kein Unterricht an diesem Tag in dieser Klasse gefunden

        } catch (Exception $e) {
            error_log("Fehler bei checkTeacherAuthorization: " . $e->getMessage());
            return false; // Im Zweifel ablehnen
        }
    }

    /**
     * Speichert (Insert/Update) ein Event.
     * KORREKTUR: Parameter $period entfernt.
     * @param int|null $eventId
     * @param int $teacherUserId (Dies ist die user_id aus der users Tabelle)
     * @param int $classId
     * @param int|null $subjectId
     * @param string $eventType
     * @param string $title
     * @param string $dueDate
     * @param string|null $description
     * @return array Das gespeicherte Event
     * @throws Exception
     */
    public function saveEvent(?int $eventId, int $teacherUserId, int $classId, ?int $subjectId, string $eventType, string $title, string $dueDate, ?string $description): array
    {
        if ($eventId) {
            // Update
            // KORREKTUR: period_number entfernt
            $sql = "UPDATE academic_events SET
                        class_id = :class_id,
                        subject_id = :subject_id,
                        event_type = :event_type,
                        title = :title,
                        due_date = :due_date,
                        description = :description
                    WHERE event_id = :event_id AND user_id = :teacher_user_id";

            $params = [
                ':event_id' => $eventId,
                ':teacher_user_id' => $teacherUserId,
                ':class_id' => $classId,
                ':subject_id' => $subjectId,
                ':event_type' => $eventType,
                ':title' => $title,
                ':due_date' => $dueDate,
                ':description' => $description
            ];
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute($params);

        } else {
            // Insert
            // KORREKTUR: period_number entfernt
            $sql = "INSERT INTO academic_events
                        (user_id, class_id, subject_id, event_type, title, due_date, description)
                    VALUES
                        (:teacher_user_id, :class_id, :subject_id, :event_type, :title, :due_date, :description)";

            $params = [
                ':teacher_user_id' => $teacherUserId,
                ':class_id' => $classId,
                ':subject_id' => $subjectId,
                ':event_type' => $eventType,
                ':title' => $title,
                ':due_date' => $dueDate,
                ':description' => $description
            ];
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute($params);
            $eventId = (int)$this->pdo->lastInsertId();
        }

        // Hole den gespeicherten Datensatz (inkl. Joins) für die Rückgabe an das Frontend
        $savedEvent = $this->getEventById($eventId);
        if (!$savedEvent) {
            throw new Exception("Fehler beim Abrufen des gespeicherten Events.");
        }
        return $savedEvent;
    }

    /**
     * Löscht ein Event, wenn es dem Lehrer gehört.
     * @param int $eventId
     * @param int $teacherUserId (Dies ist die user_id)
     * @return bool
     */
    public function deleteEvent(int $eventId, int $teacherUserId): bool
    {
        $sql = "DELETE FROM academic_events
                WHERE event_id = :event_id AND user_id = :teacher_user_id";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':event_id' => $eventId,
            ':teacher_user_id' => $teacherUserId
        ]);

        return $stmt->rowCount() > 0;
    }

    /**
     * Hilfsfunktion: Holt ein einzelnes Event anhand seiner ID (mit Joins).
     * @param int $eventId
     * @return array|false
     */
    public function getEventById(int $eventId)
    {
         $sql = "SELECT
                    ae.*,
                    s.subject_shortcut,
                    c.class_name,
                    u.first_name AS teacher_first_name,
                    u.last_name AS teacher_last_name
                FROM academic_events ae
                LEFT JOIN subjects s ON ae.subject_id = s.subject_id
                JOIN classes c ON ae.class_id = c.class_id
                JOIN users u ON ae.user_id = u.user_id
                WHERE ae.event_id = :event_id";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':event_id' => $eventId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AcademicEventRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AnnouncementRepository.php ---
<?php
// app/Repositories/AnnouncementRepository.php
namespace App\Repositories;

use PDO;
use Exception; // Added for potential errors

class AnnouncementRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Erstellt eine neue Ankündigung in der Datenbank.
     * Nutzt is_global und class_id basierend auf der Logik im Controller.
     *
     * @param int $userId ID des Autors
     * @param string $title Titel
     * @param string $content Inhalt
     * @param string $targetRole Zielgruppe ('all', 'schueler', 'lehrer', 'planer') - Wird jetzt in is_global/class_id übersetzt
     * @param ?int $targetClassId Klassen-ID (nur wenn targetRole 'schueler')
     * @param ?string $attachmentPath Pfad zur angehängten Datei (relativ zum public-Ordner)
     * @return int Die ID der neu erstellten Ankündigung.
     * @throws Exception
     */
    public function createAnnouncement(int $userId, string $title, string $content, string $targetRole, ?int $targetClassId, ?string $attachmentPath): int
    {
        // *** Convert targetRole/targetClassId to is_global/class_id ***
        // 'schueler' with a class ID means it's class-specific (is_global = 0)
        // 'all', 'lehrer', 'planer', or 'schueler' without a class ID means it's global (is_global = 1)
        $isGlobal = !($targetRole === 'schueler' && $targetClassId !== null);
        $dbClassId = ($targetRole === 'schueler' && $targetClassId !== null) ? $targetClassId : null;

        // *** Use is_global and class_id in SQL ***
        $sql = "INSERT INTO announcements (user_id, title, content, is_global, class_id, file_path, created_at) /* Corrected column name file_path */
                VALUES (:user_id, :title, :content, :is_global, :class_id, :file_path, NOW())";
        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([
            ':user_id' => $userId,
            ':title' => $title,
            ':content' => $content,
            ':is_global' => $isGlobal ? 1 : 0,
            ':class_id' => $dbClassId,
            ':file_path' => $attachmentPath // Corrected parameter name
        ]);

        if (!$success) {
            // Log detailed error
            error_log("Announcement creation failed: " . print_r($stmt->errorInfo(), true));
            throw new Exception("Fehler beim Erstellen der Ankündigung.");
        }
        return (int)$this->pdo->lastInsertId();
    }

    /**
     * Holt Ankündigungen, die für einen bestimmten Benutzer sichtbar sind.
     * Berücksichtigt Rolle und ggf. Klassenzugehörigkeit.
     *
     * @param string $userRole Rolle des aktuellen Benutzers
     * @param ?int $classId Klassen-ID des Schülers (falls zutreffend)
     * @return array Array von Ankündigungen.
     */
    public function getVisibleAnnouncements(string $userRole, ?int $classId): array
    {
        // *** Uses is_global and class_id ***
        $sql = "SELECT a.*, CONCAT(u.first_name, ' ', u.last_name) as author_name, c.class_name as target_class_name
                FROM announcements a
                JOIN users u ON a.user_id = u.user_id
                LEFT JOIN classes c ON a.class_id = c.class_id
                WHERE (
                    a.is_global = 1"; // Global announcements are always visible (covers all, lehrer, planer types)

        $params = [];

        // Add condition for students to see their class-specific announcements
        if ($userRole === 'schueler' && $classId !== null) {
            $sql .= " OR (a.is_global = 0 AND a.class_id = :class_id)";
            $params[':class_id'] = $classId;
        }

        // Close the main WHERE parenthesis
        $sql .= " ) ORDER BY a.created_at DESC LIMIT 20";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($params);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }


    /**
     * Holt alle Ankündigungen mit zusätzlichen Details (Autor, Klasse).
     * Wird für die Admin-Ansicht verwendet.
     * @return array Array aller Ankündigungen.
     */
    public function getAllAnnouncementsWithDetails(): array
    {
        $sql = "SELECT a.*, CONCAT(u.first_name, ' ', u.last_name) as author_name, c.class_name as target_class_name
                FROM announcements a
                JOIN users u ON a.user_id = u.user_id
                LEFT JOIN classes c ON a.class_id = c.class_id
                ORDER BY a.created_at DESC";
        $stmt = $this->pdo->query($sql);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }


    /**
     * Holt eine einzelne Ankündigung anhand ihrer ID.
     * @param int $announcementId
     * @return array|false Die Ankündigungsdaten oder false, wenn nicht gefunden.
     */
    public function getAnnouncementById(int $announcementId): array|false
    {
        $sql = "SELECT a.*, CONCAT(u.first_name, ' ', u.last_name) as author_name, c.class_name as target_class_name
                FROM announcements a
                JOIN users u ON a.user_id = u.user_id
                LEFT JOIN classes c ON a.class_id = c.class_id
                WHERE a.announcement_id = :id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':id' => $announcementId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    /**
     * Löscht eine Ankündigung anhand ihrer ID.
     * @param int $announcementId
     * @return bool True bei Erfolg, False bei Misserfolg.
     */
    public function deleteAnnouncement(int $announcementId): bool
    {
        $announcement = $this->getAnnouncementById($announcementId);

        $sql = "DELETE FROM announcements WHERE announcement_id = :id";
        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([':id' => $announcementId]);

        // If deletion was successful and there was an attachment, try to delete the file
        if ($success && $announcement && !empty($announcement['file_path'])) {
             $filePath = dirname(__DIR__, 2) . '/public/' . $announcement['file_path'];
            if (file_exists($filePath)) {
                @unlink($filePath);
            }
        }

        return $success;
    }

     // Update method (Placeholder - needs implementation)
     /*
     public function updateAnnouncement(int $announcementId, int $userId, string $title, string $content, string $targetRole, ?int $targetClassId, ?string $attachmentPath, bool $removeAttachment): bool {
         // Determine is_global and dbClassId based on targetRole/targetClassId
         $isGlobal = !($targetRole === 'schueler' && $targetClassId !== null);
         $dbClassId = ($targetRole === 'schueler' && $targetClassId !== null) ? $targetClassId : null;

         // Fetch current announcement to handle file deletion if requested or replaced
         $current = $this->getAnnouncementById($announcementId);
         $currentFilePath = $current['file_path'] ?? null;
         $newFilePath = $attachmentPath; // If a new file was uploaded
         $finalFilePath = $newFilePath; // Assume new file replaces old by default

         if ($removeAttachment && !$newFilePath && $currentFilePath) {
             // Delete existing file, set path to NULL
             $filePathToDelete = dirname(__DIR__, 2) . '/public/' . $currentFilePath;
              if (file_exists($filePathToDelete)) {
                  @unlink($filePathToDelete);
              }
             $finalFilePath = null;
         } elseif ($newFilePath && $currentFilePath && $newFilePath !== $currentFilePath) {
             // New file replaces old one, delete the old one
              $filePathToDelete = dirname(__DIR__, 2) . '/public/' . $currentFilePath;
              if (file_exists($filePathToDelete)) {
                  @unlink($filePathToDelete);
              }
             $finalFilePath = $newFilePath;
         } elseif (!$newFilePath && !$removeAttachment) {
              // No new file, don't remove existing -> keep current path
              $finalFilePath = $currentFilePath;
         }
         // If !$newFilePath and $removeAttachment, finalFilePath is already correctly set to null above.


         $sql = "UPDATE announcements SET
                     title = :title,
                     content = :content,
                     is_global = :is_global,
                     class_id = :class_id,
                     file_path = :file_path
                     -- Optionally update user_id or created_at? Probably not.
                 WHERE announcement_id = :id";

         $stmt = $this->pdo->prepare($sql);
         return $stmt->execute([
             ':title' => $title,
             ':content' => $content,
             ':is_global' => $isGlobal ? 1 : 0,
             ':class_id' => $dbClassId,
             ':file_path' => $finalFilePath,
             ':id' => $announcementId
         ]);
     }
     */
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AnnouncementRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AppointmentRepository.php ---
<?php
// app/Repositories/AppointmentRepository.php

namespace App\Repositories;

use PDO;
use Exception;
use DateTime;
use DateTimeZone;
use DateInterval;
use DatePeriod;

class AppointmentRepository
{
    private PDO $pdo;
    private DateTimeZone $timezone;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
        $this->timezone = new DateTimeZone('Europe/Berlin');
    }

    // --- Lehrer: Verfügbarkeit verwalten ---

    /**
     * Fügt ein neues Verfügbarkeitsfenster für einen Lehrer hinzu.
     * @param int $teacherUserId
     * @param int $dayOfWeek (1-5)
     * @param string $startTime (HH:MM)
     * @param string $endTime (HH:MM)
     * @param int $slotDuration (in Minuten)
     * @return int ID der neuen Verfügbarkeit
     * @throws Exception
     */
    public function createAvailability(int $teacherUserId, int $dayOfWeek, string $startTime, string $endTime, int $slotDuration): int
    {
        // TODO: Auf Überlappung mit bestehenden Fenstern prüfen
        $sql = "INSERT INTO teacher_availability (teacher_user_id, day_of_week, start_time, end_time, slot_duration)
                VALUES (:teacher_user_id, :day_of_week, :start_time, :end_time, :slot_duration)";
        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([
            ':teacher_user_id' => $teacherUserId,
            ':day_of_week' => $dayOfWeek,
            ':start_time' => $startTime,
            ':end_time' => $endTime,
            ':slot_duration' => $slotDuration
        ]);

        if (!$success) {
            throw new Exception("Sprechzeit konnte nicht gespeichert werden (eventuell überlappend?).");
        }
        return (int)$this->pdo->lastInsertId();
    }

    /**
     * Löscht ein Verfügbarkeitsfenster.
     * @param int $availabilityId
     * @param int $teacherUserId (Zur Sicherheit)
     * @return bool
     */
    public function deleteAvailability(int $availabilityId, int $teacherUserId): bool
    {
        // Löscht auch alle zukünftigen, noch nicht stattgefundenen Termine, die auf diesem Fenster basieren
        $this->pdo->beginTransaction();
        try {
            // 1. Zukünftige Termine löschen
            $sqlDeleteAppointments = "DELETE FROM appointments 
                                      WHERE teacher_user_id = :teacher_user_id 
                                        AND appointment_date >= CURDATE()
                                        AND status = 'booked'
                                        AND appointment_time >= (SELECT start_time FROM teacher_availability WHERE availability_id = :availability_id)
                                        AND appointment_time < (SELECT end_time FROM teacher_availability WHERE availability_id = :availability_id)";
            // HINWEIS: Diese Logik ist vereinfacht. Sie löscht alle Termine des Lehrers an dem Tag im Fenster.
            // Eine bessere Logik würde die availability_id in appointments speichern.
            // Für dieses MVP löschen wir einfach das Fenster.
            
            // TODO: Wenn appointments.availability_id hinzugefügt wird, stattdessen das verwenden:
            // $sqlDeleteAppointments = "DELETE FROM appointments WHERE availability_id = :availability_id AND appointment_date >= CURDATE()";
            // $this->pdo->prepare($sqlDeleteAppointments)->execute([':availability_id' => $availabilityId]);


            // 2. Verfügbarkeitsfenster löschen
            $sqlDeleteAvailability = "DELETE FROM teacher_availability 
                                      WHERE availability_id = :availability_id AND teacher_user_id = :teacher_user_id";
            $stmt = $this->pdo->prepare($sqlDeleteAvailability);
            $stmt->execute([
                ':availability_id' => $availabilityId,
                ':teacher_user_id' => $teacherUserId
            ]);
            
            $this->pdo->commit();
            return $stmt->rowCount() > 0;

        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("Fehler beim Löschen der Sprechzeit: " . $e->getMessage());
            return false;
        }
    }

    /**
     * Holt alle Verfügbarkeitsfenster für einen Lehrer.
     * @param int $teacherUserId
     * @return array
     */
    public function getAvailabilities(int $teacherUserId): array
    {
        $sql = "SELECT * FROM teacher_availability WHERE teacher_user_id = :teacher_user_id ORDER BY day_of_week, start_time";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':teacher_user_id' => $teacherUserId]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }


    // --- Schüler: Slots abrufen und buchen ---

    /**
     * Holt alle verfügbaren (noch nicht gebuchten) Slots für einen Lehrer an einem bestimmten Datum.
     * @param int $teacherUserId
     * @param string $date (Y-m-d)
     * @return array
     * @throws Exception
     */
    public function getAvailableSlots(int $teacherUserId, string $date): array
    {
        $dateObj = new DateTime($date, $this->timezone);
        $dayOfWeek = (int)$dateObj->format('N'); // 1=Mo, 7=So

        // 1. Hole alle Fenster für diesen Wochentag
        $sqlAvail = "SELECT * FROM teacher_availability 
                     WHERE teacher_user_id = :teacher_user_id AND day_of_week = :day_of_week";
        $stmtAvail = $this->pdo->prepare($sqlAvail);
        $stmtAvail->execute([':teacher_user_id' => $teacherUserId, ':day_of_week' => $dayOfWeek]);
        $availabilities = $stmtAvail->fetchAll(PDO::FETCH_ASSOC);

        if (empty($availabilities)) {
            return []; // Lehrer bietet an diesem Wochentag keine Sprechzeiten an
        }

        // 2. Hole alle bereits gebuchten Termine für diesen Tag
        $sqlBooked = "SELECT appointment_time FROM appointments 
                      WHERE teacher_user_id = :teacher_user_id AND appointment_date = :date AND status = 'booked'";
        $stmtBooked = $this->pdo->prepare($sqlBooked);
        $stmtBooked->execute([':teacher_user_id' => $teacherUserId, ':date' => $date]);
        $bookedTimes = $stmtBooked->fetchAll(PDO::FETCH_COLUMN, 0);
        $bookedSlots = array_flip($bookedTimes); // Macht Zeiten zu Schlüsseln für schnelle Suche

        $availableSlots = [];

        // 3. Generiere Slots aus den Fenstern und filtere gebuchte heraus
        foreach ($availabilities as $window) {
            $start = new DateTime($date . ' ' . $window['start_time'], $this->timezone);
            $end = new DateTime($date . ' ' . $window['end_time'], $this->timezone);
            $duration = $window['slot_duration'];
            $interval = new DateInterval("PT{$duration}M");
            $period = new DatePeriod($start, $interval, $end);

            foreach ($period as $slotStart) {
                $timeString = $slotStart->format('H:i:s'); // z.B. 14:00:00
                $timeStringShort = $slotStart->format('H:i'); // z.B. 14:00

                // Prüfe, ob der Slot bereits gebucht ist
                if (!isset($bookedSlots[$timeString])) {
                    $availableSlots[] = [
                        'time' => $timeString, // Volle Zeit für die Buchung
                        'display' => $timeStringShort, // Angezeigte Zeit
                        'duration' => $duration
                    ];
                }
            }
        }

        return $availableSlots;
    }

    /**
     * Bucht einen Termin für einen Schüler.
     * @param int $studentUserId
     * @param int $teacherUserId
     * @param string $date (Y-m-d)
     * @param string $time (HH:MM:SS)
     * @param int $duration
     * @param string|null $notes
     * @return int ID des neuen Termins
     * @throws Exception
     */
    public function bookAppointment(int $studentUserId, int $teacherUserId, string $date, string $time, int $duration, ?string $notes): int
    {
        // Atomare Operation: INSERT versuchen. Wenn der unique_appointment_slot fehlschlägt,
        // (weil jemand anderes schneller war), wird eine PDOException ausgelöst.
        $sql = "INSERT INTO appointments (student_user_id, teacher_user_id, appointment_date, appointment_time, duration, notes, status)
                VALUES (:student_user_id, :teacher_user_id, :date, :time, :duration, :notes, 'booked')";
        
        try {
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute([
                ':student_user_id' => $studentUserId,
                ':teacher_user_id' => $teacherUserId,
                ':date' => $date,
                ':time' => $time,
                ':duration' => $duration,
                ':notes' => $notes
            ]);
            return (int)$this->pdo->lastInsertId();

        } catch (\PDOException $e) {
            if ($e->errorInfo[1] == 1062) { // 1062 = Duplicate entry
                throw new Exception("Dieser Termin wurde gerade von jemand anderem gebucht. Bitte wählen Sie einen anderen Slot.", 409);
            } else {
                error_log("Fehler bei Terminbuchung: " . $e->getMessage());
                throw new Exception("Ein Fehler ist bei der Buchung aufgetreten.", 500);
            }
        }
    }
    
    // --- Termine abrufen (für "Mein Tag") ---

    /**
     * Holt alle gebuchten Termine eines Schülers in einem Datumsbereich.
     * @param int $studentUserId
     * @param string $startDate (Y-m-d)
     * @param string $endDate (Y-m-d)
     * @return array
     */
    public function getAppointmentsForStudent(int $studentUserId, string $startDate, string $endDate): array
    {
        $sql = "SELECT a.*, CONCAT(t.first_name, ' ', t.last_name) as teacher_name, t.teacher_shortcut
                FROM appointments a
                JOIN users u ON a.teacher_user_id = u.user_id
                JOIN teachers t ON u.teacher_id = t.teacher_id
                WHERE a.student_user_id = :student_user_id
                  AND a.status = 'booked'
                  AND a.appointment_date BETWEEN :start_date AND :end_date
                ORDER BY a.appointment_date, a.appointment_time";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':student_user_id' => $studentUserId,
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Holt alle gebuchten Termine eines Lehrers in einem Datumsbereich.
     * @param int $teacherUserId
     * @param string $startDate (Y-m-d)
     * @param string $endDate (Y-m-d)
     * @return array
     */
    public function getAppointmentsForTeacher(int $teacherUserId, string $startDate, string $endDate): array
    {
        $sql = "SELECT a.*, CONCAT(u.first_name, ' ', u.last_name) as student_name, c.class_name
                FROM appointments a
                JOIN users u ON a.student_user_id = u.user_id
                LEFT JOIN classes c ON u.class_id = c.class_id
                WHERE a.teacher_user_id = :teacher_user_id
                  AND a.status = 'booked'
                  AND a.appointment_date BETWEEN :start_date AND :end_date
                ORDER BY a.appointment_date, a.appointment_time";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':teacher_user_id' => $teacherUserId,
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    /**
     * Storniert einen Termin (durch Schüler oder Lehrer).
     * @param int $appointmentId
     * @param int $userId (Der stornierende Benutzer)
     * @param string $role (Die Rolle des stornierenden Benutzers)
     * @return bool
     * @throws Exception
     */
    public function cancelAppointment(int $appointmentId, int $userId, string $role): bool
    {
        $sql = "UPDATE appointments SET status = :status 
                WHERE appointment_id = :appointment_id AND ";

        if ($role === 'schueler') {
            $sql .= "student_user_id = :user_id";
            $newStatus = 'cancelled_by_student';
        } elseif ($role === 'lehrer') {
            $sql .= "teacher_user_id = :user_id";
            $newStatus = 'cancelled_by_teacher';
        } else {
            throw new Exception("Nur Schüler oder Lehrer können Termine stornieren.", 403);
        }

        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([
            ':status' => $newStatus,
            ':appointment_id' => $appointmentId,
            ':user_id' => $userId
        ]);
        
        if ($stmt->rowCount() === 0) {
            throw new Exception("Termin nicht gefunden oder keine Berechtigung zum Stornieren.", 404);
        }
        
        return $success;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AppointmentRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AttendanceRepository.php ---
<?php
// app/Repositories/AttendanceRepository.php

namespace App\Repositories;

use PDO;
use Exception;
use PDOException;

class AttendanceRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Speichert oder aktualisiert einen Batch von Anwesenheitsdaten.
     *
     * @param int $teacherUserId Der Lehrer, der die Daten speichert
     * @param int $classId
     * @param string $date (Y-m-d)
     * @param int $periodNumber
     * @param array $studentsStatus Array von ['student_id' => X, 'status' => '...']
     * @return bool
     * @throws Exception
     */
    public function saveAttendance(int $teacherUserId, int $classId, string $date, int $periodNumber, array $studentsStatus): bool
    {
        // SQL mit ON DUPLICATE KEY UPDATE, um Atomarität zu gewährleisten
        $sql = "INSERT INTO attendance_logs (date, period_number, class_id, student_user_id, teacher_user_id, status)
                VALUES (:date, :period_number, :class_id, :student_user_id, :teacher_user_id, :status)
                ON DUPLICATE KEY UPDATE 
                    teacher_user_id = VALUES(teacher_user_id), 
                    status = VALUES(status)";
        
        try {
            $this->pdo->beginTransaction();
            $stmt = $this->pdo->prepare($sql);

            foreach ($studentsStatus as $student) {
                if (!isset($student['student_id']) || !isset($student['status'])) {
                    throw new Exception("Ungültige Studentendaten im Batch.");
                }
                
                $stmt->execute([
                    ':date' => $date,
                    ':period_number' => $periodNumber,
                    ':class_id' => $classId,
                    ':student_user_id' => $student['student_id'],
                    ':teacher_user_id' => $teacherUserId,
                    ':status' => $student['status']
                ]);
            }
            
            return $this->pdo->commit();

        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("Fehler beim Speichern der Anwesenheit: " . $e->getMessage());
            throw new Exception("Fehler beim Speichern der Anwesenheit: " . $e->getMessage());
        }
    }

    /**
     * Ruft die bereits erfasste Anwesenheit für eine bestimmte Stunde ab.
     *
     * @param int $classId
     * @param string $date
     * @param int $periodNumber
     * @return array Assoziatives Array [student_user_id => status]
     */
    public function getAttendance(int $classId, string $date, int $periodNumber): array
    {
        $sql = "SELECT student_user_id, status 
                FROM attendance_logs
                WHERE class_id = :class_id 
                  AND date = :date 
                  AND period_number = :period_number";
                  
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':class_id' => $classId,
            ':date' => $date,
            ':period_number' => $periodNumber
        ]);
        
        // Gibt ein Array zurück, z.B. [15 => 'anwesend', 16 => 'abwesend']
        return $stmt->fetchAll(PDO::FETCH_KEY_PAIR) ?: [];
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AttendanceRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AuditLogRepository.php ---
<?php
// app/Repositories/AuditLogRepository.php
namespace App\Repositories;
use PDO;

class AuditLogRepository
{
    private PDO $pdo;
    public function __construct(PDO $pdo) { $this->pdo = $pdo; }

    /**
     * Holt eine paginierte Liste von Logs, optional gefiltert.
     * NEU: Limit kann übergeben werden, Standard 20
     * @param int $page
     * @param int $limit
     * @param array $filters
     * @return array
     */
    public function getLogs(int $page = 1, int $limit = 20, array $filters = []): array
    {
        $offset = ($page - 1) * $limit;

        // Basis-SQL mit JOIN, um Benutzerinformationen abzurufen
        $sql = "SELECT l.*, u.username, u.first_name, u.last_name
                FROM audit_logs l
                LEFT JOIN users u ON l.user_id = u.user_id";

        list($whereClause, $params) = $this->buildWhereClause($filters);
        $sql .= $whereClause;

        // Verwende den korrekten Spaltennamen 'timestamp'
        $sql .= " ORDER BY l.timestamp DESC";
        $sql .= " LIMIT :limit OFFSET :offset";

        $stmt = $this->pdo->prepare($sql);

        // Füge Paginierungs-Parameter hinzu
        $params[':limit'] = $limit;
        $params[':offset'] = $offset;

        // Binde alle Parameter (Filter + Paginierung)
        $this->bindValues($stmt, $params);

        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Zählt die Gesamtanzahl der Logs für die Filter.
     *
     * @param array $filters
     * @return int
     */
    public function getLogsCount(array $filters = []): int
    {
        $sql = "SELECT COUNT(*) FROM audit_logs l"; // Alias 'l' ist wichtig
        list($whereClause, $params) = $this->buildWhereClause($filters);
        $sql .= $whereClause;

        $stmt = $this->pdo->prepare($sql);

        // Binde nur die Filter-Parameter
        $this->bindValues($stmt, $params);

        $stmt->execute();
        return (int)$stmt->fetchColumn();
    }

    /**
     * Baut die WHERE-Klausel und Parameter für die Log-Abfragen.
     *
     * @param array $filters
     * @return array [string $whereClause, array $params]
     */
    private function buildWhereClause(array $filters): array
    {
        $where = [];
        $params = [];

        if (!empty($filters['user_id'])) {
            $where[] = "l.user_id = :user_id"; // 'l.' alias ist wichtig
            $params[':user_id'] = $filters['user_id'];
        }
        if (!empty($filters['action'])) {
            $where[] = "l.action LIKE :action";
            $params[':action'] = '%' . $filters['action'] . '%';
        }
        if (!empty($filters['target_type'])) {
            $where[] = "l.target_type = :target_type";
            $params[':target_type'] = $filters['target_type'];
        }
        if (!empty($filters['start_date'])) {
            // Verwende den korrekten Spaltennamen 'timestamp'
            $where[] = "l.timestamp >= :start_date";
            $params[':start_date'] = $filters['start_date'];
        }
        if (!empty($filters['end_date'])) {
            // Um das gesamte Enddatum einzuschließen (bis 23:59:59)
            // Verwende den korrekten Spaltennamen 'timestamp'
            $where[] = "l.timestamp <= :end_date";
            $params[':end_date'] = $filters['end_date'] . ' 23:59:59';
        }

        $whereClause = !empty($where) ? ' WHERE ' . implode(' AND ', $where) : '';

        return [$whereClause, $params];
    }

    /**
     * Hilfsfunktion zum korrekten Binden von Werten an ein PDO-Statement.
     * Behandelt INT- und STR-Typen.
     *
     * @param \PDOStatement $stmt
     * @param array $params
     */
    private function bindValues(\PDOStatement $stmt, array $params): void
    {
        foreach ($params as $key => $val) {
            // Bestimme den Typ für bindValue
            if ($key === ':limit' || $key === ':offset' || $key === ':user_id') {
                $stmt->bindValue($key, $val, PDO::PARAM_INT);
            } else {
                $stmt->bindValue($key, $val, PDO::PARAM_STR);
            }
        }
    }

    /**
     * Holt alle eindeutigen Aktions-Typen aus dem Log.
     *
     * @return array
     */
    public function getDistinctActions(): array
    {
        $sql = "SELECT DISTINCT action FROM audit_logs WHERE action IS NOT NULL AND action != '' ORDER BY action ASC";
        $stmt = $this->pdo->query($sql);
        return $stmt->fetchAll(PDO::FETCH_COLUMN);
    }

    /**
     * Holt alle eindeutigen Ziel-Typen aus dem Log.
     *
     * @return array
     */
    public function getDistinctTargetTypes(): array
    {
        $sql = "SELECT DISTINCT target_type FROM audit_logs WHERE target_type IS NOT NULL AND target_type != '' ORDER BY target_type ASC";
        $stmt = $this->pdo->query($sql);
        return $stmt->fetchAll(PDO::FETCH_COLUMN);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\AuditLogRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\CommunityPostRepository.php ---
<?php
// app/Repositories/CommunityPostRepository.php

namespace App\Repositories;

use PDO;
use Exception;

class CommunityPostRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Erstellt einen neuen Beitrag.
     * @param int $userId
     * @param string $title
     * @param string $content
     * @param string $initialStatus (z.B. 'pending' oder 'approved')
     * @return int
     * @throws Exception
     */
    public function createPost(int $userId, string $title, string $content, string $initialStatus = 'pending'): int
    {
        $sql = "INSERT INTO community_posts (user_id, title, content, status, created_at)
                VALUES (:user_id, :title, :content, :status, NOW())";
        $stmt = $this->pdo->prepare($sql);
        $success = $stmt->execute([
            ':user_id' => $userId,
            ':title' => $title,
            ':content' => $content,
            ':status' => $initialStatus
        ]);

        if (!$success) {
            throw new Exception("Beitrag konnte nicht erstellt werden.");
        }
        return (int)$this->pdo->lastInsertId();
    }

    /**
     * NEU: Aktualisiert einen bestehenden Beitrag.
     * @param int $postId
     * @param int $userId (Zur Verifizierung der Inhaberschaft)
     * @param string $title
     * @param string $content
     * @param string $newStatus (z.B. 'pending' nach Bearbeitung)
     * @return bool
     */
    public function updatePost(int $postId, int $userId, string $title, string $content, string $newStatus): bool
    {
        $sql = "UPDATE community_posts SET
                    title = :title,
                    content = :content,
                    status = :status,
                    moderated_at = NULL,
                    moderator_id = NULL
                WHERE post_id = :post_id AND user_id = :user_id";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':title' => $title,
            ':content' => $content,
            ':status' => $newStatus,
            ':post_id' => $postId,
            ':user_id' => $userId
        ]);
        
        return $stmt->rowCount() > 0;
    }


    /**
     * Holt Beiträge basierend auf dem Status, sortiert von neu nach alt.
     * @param string $status ('approved', 'pending', 'rejected')
     * @param int $limit
     * @return array
     */
    public function getPostsByStatus(string $status, int $limit = 50): array
    {
        // Hole Posts inklusive Ersteller-Infos
        $sql = "SELECT p.*, u.username, u.first_name, u.last_name
                FROM community_posts p
                JOIN users u ON p.user_id = u.user_id
                WHERE p.status = :status
                ORDER BY p.created_at DESC
                LIMIT :limit";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindParam(':status', $status, PDO::PARAM_STR);
        $stmt->bindParam(':limit', $limit, PDO::PARAM_INT);
        $stmt->execute();
        
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    /**
     * NEU: Holt alle Beiträge eines bestimmten Benutzers.
     * @param int $userId
     * @return array
     */
    public function getPostsByUserId(int $userId): array
    {
        // Holt Posts ohne Ersteller-Infos (da es der eigene Benutzer ist)
        // Sortiert, sodass 'pending' oben steht, dann nach Datum
        $sql = "SELECT *
                FROM community_posts
                WHERE user_id = :user_id
                ORDER BY
                    CASE status
                        WHEN 'pending' THEN 1
                        WHEN 'approved' THEN 2
                        WHEN 'rejected' THEN 3
                        ELSE 4
                    END,
                    created_at DESC";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':user_id' => $userId]);
        
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    
    /**
     * NEU: Holt freigegebene Beiträge INKLUSIVE E-Mail des Autors.
     * @param int $limit
     * @return array
     */
    public function getApprovedPostsWithAuthorEmail(int $limit = 50): array
    {
        $sql = "SELECT p.*, u.username, u.first_name, u.last_name, u.email
                FROM community_posts p
                JOIN users u ON p.user_id = u.user_id
                WHERE p.status = 'approved'
                ORDER BY p.created_at DESC
                LIMIT :limit";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindParam(':limit', $limit, PDO::PARAM_INT);
        $stmt->execute();
        
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }


    /**
     * Holt einen einzelnen Post anhand der ID.
     * @param int $postId
     * @return array|false
     */
    public function getPostById(int $postId)
    {
        $sql = "SELECT * FROM community_posts WHERE post_id = :post_id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':post_id' => $postId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    /**
     * Aktualisiert den Status eines Beitrags.
     * @param int $postId
     * @param string $newStatus ('approved', 'rejected')
     * @param int $moderatorUserId
     * @return bool
     */
    public function updatePostStatus(int $postId, string $newStatus, int $moderatorUserId): bool
    {
        if (!in_array($newStatus, ['approved', 'rejected'])) {
            return false; // Ungültiger Status
        }

        $sql = "UPDATE community_posts SET
                    status = :status,
                    moderator_id = :moderator_id,
                    moderated_at = NOW()
                WHERE post_id = :post_id";
        
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':status' => $newStatus,
            ':moderator_id' => $moderatorUserId,
            ':post_id' => $postId
        ]);
    }

    /**
     * Löscht einen Beitrag (alternativ zu 'rejected').
     * @param int $postId
     * @return bool
     */
    public function deletePost(int $postId): bool
    {
        $sql = "DELETE FROM community_posts WHERE post_id = :post_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':post_id' => $postId]);
    }
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\CommunityPostRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\LoginAttemptRepository.php ---
<?php
// app/Repositories/LoginAttemptRepository.php
namespace App\Repositories;

use App\Core\Utils; // NEU: Utils importieren
use PDO;

class LoginAttemptRepository
{
    private PDO $pdo;
    // VERALTET: Konstanten werden durch Einstellungen ersetzt
    // private const MAX_ATTEMPTS = 5;
    // private const LOCKOUT_MINUTES = 15;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Prüft, ob ein Login-Versuch für den gegebenen Identifier erlaubt ist.
     * Gibt `false` zurück, wenn die maximale Anzahl an Versuchen im Lockout-Zeitraum überschritten wurde.
     */
    public function isAllowed(string $identifier): bool
    {
        // NEU: Hole Werte aus den Einstellungen
        $settings = Utils::getSettings();
        $maxAttempts = $settings['max_login_attempts'];
        $lockoutMinutes = $settings['lockout_minutes'];

        $sql = "SELECT COUNT(*) FROM login_attempts
                WHERE identifier = :identifier
                AND attempt_time > (NOW() - INTERVAL :lockout MINUTE)";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':identifier' => $identifier,
            ':lockout' => $lockoutMinutes // Verwende den Wert aus den Einstellungen
        ]);

        $attempts = (int)$stmt->fetchColumn();

        return $attempts < $maxAttempts; // Vergleiche mit dem Wert aus den Einstellungen
    }

    /**
     * Speichert einen fehlgeschlagenen Login-Versuch in der Datenbank.
     */
    public function recordFailure(string $identifier): void
    {
        $sql = "INSERT INTO login_attempts (identifier, ip_address, attempt_time)
                VALUES (:identifier, :ip_address, NOW())";

        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':identifier' => $identifier,
            ':ip_address' => $_SERVER['REMOTE_ADDR'] ?? 'UNKNOWN'
        ]);
    }

    /**
     * Löscht alle Login-Versuche für einen Identifier nach einem erfolgreichen Login.
     */
    public function clearAttempts(string $identifier): void
    {
        $sql = "DELETE FROM login_attempts WHERE identifier = :identifier";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':identifier' => $identifier]);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\LoginAttemptRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\PlanRepository.php ---
<?php
// app/Repositories/PlanRepository.php
namespace App\Repositories;

use PDO;
use Exception;
use DateTime;
use DateTimeZone; // Added explicit use
use PDOException; // Added for specific exception handling
use App\Repositories\TeacherAbsenceRepository; // NEU: Import

class PlanRepository
{
    private PDO $pdo;
    private TeacherAbsenceRepository $absenceRepo; // NEU: Property

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
        $this->absenceRepo = new TeacherAbsenceRepository($pdo); // NEU: Instanziieren
    }

    /**
     * Hilfsfunktion, um Start- und Enddatum einer Kalenderwoche zu ermitteln.
     * @param int $year ISO Year
     * @param int $week ISO Week
     * @return array ['Y-m-d', 'Y-m-d']
     */
    private function getWeekDateRange(int $year, int $week): array
    {
        // Use DateTime for ISO week date calculations
        $dto = new DateTime();
        $dto->setISODate($year, $week, 1); // Set to Monday of the week
        $startDate = $dto->format('Y-m-d');
        $dto->setISODate($year, $week, 5); // Set to Friday of the week
        $endDate = $dto->format('Y-m-d');
        return [$startDate, $endDate];
    }

    // --- Methoden für den öffentlichen Dashboard-Zugriff (Schüler/Lehrer) ---

    /**
     * Holt den regulären Stundenplan für eine Klasse, ABER NUR WENN veröffentlicht.
     * @param int $classId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getPublishedTimetableForClass(int $classId, int $year, int $calendarWeek): array
    {
        // Prüfe zuerst, ob die Woche veröffentlicht ist
        if (!$this->isWeekPublishedFor('student', $year, $calendarWeek)) {
            return []; // Leeres Array, wenn nicht veröffentlicht
        }
        // Use the AsPlaner method as the underlying data is the same
        return $this->getTimetableForClassAsPlaner($classId, $year, $calendarWeek);
    }

    /**
     * Holt den regulären Stundenplan für einen Lehrer, ABER NUR WENN veröffentlicht.
     * @param int $teacherId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getPublishedTimetableForTeacher(int $teacherId, int $year, int $calendarWeek): array
    {
        // Prüfe zuerst, ob die Woche veröffentlicht ist
        if (!$this->isWeekPublishedFor('teacher', $year, $calendarWeek)) {
            return []; // Leeres Array, wenn nicht veröffentlicht
        }
        // Use the AsPlaner method as the underlying data is the same
        return $this->getTimetableForTeacherAsPlaner($teacherId, $year, $calendarWeek);
    }

    /**
     * Holt alle Vertretungen für eine Klasse in einer Woche, ABER NUR WENN veröffentlicht.
     * @param int $classId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getPublishedSubstitutionsForClassWeek(int $classId, int $year, int $calendarWeek): array
    {
        if (!$this->isWeekPublishedFor('student', $year, $calendarWeek)) {
            return [];
        }
        // Use the AsPlaner method as the underlying data is the same
        return $this->getSubstitutionsForClassWeekAsPlaner($classId, $year, $calendarWeek);
    }

    /**
     * Holt alle Vertretungen für einen Lehrer in einer Woche, ABER NUR WENN veröffentlicht.
     * @param int $teacherId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getPublishedSubstitutionsForTeacherWeek(int $teacherId, int $year, int $calendarWeek): array
    {
         if (!$this->isWeekPublishedFor('teacher', $year, $calendarWeek)) {
             return [];
         }
        // Use the AsPlaner method as the underlying data is the same
        return $this->getSubstitutionsForTeacherWeekAsPlaner($teacherId, $year, $calendarWeek);
    }

    // --- Methoden für den Planer-Zugriff ---

    /**
     * Holt den regulären Stundenplan für eine Klasse (für Planer/Admin).
     * @param int $classId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getTimetableForClassAsPlaner(int $classId, int $year, int $calendarWeek): array
    {
        $sql = "SELECT te.*, s.subject_shortcut, s.subject_name, t.teacher_shortcut, r.room_name, c.class_name
                FROM timetable_entries te
                LEFT JOIN subjects s ON te.subject_id = s.subject_id
                LEFT JOIN teachers t ON te.teacher_id = t.teacher_id
                LEFT JOIN rooms r ON te.room_id = r.room_id
                JOIN classes c ON te.class_id = c.class_id
                WHERE te.class_id = :class_id
                    AND te.year = :year
                    AND te.calendar_week = :calendar_week
                ORDER BY te.day_of_week ASC, te.period_number ASC";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':class_id' => $classId, ':year' => $year, ':calendar_week' => $calendarWeek]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Holt den regulären Stundenplan für einen Lehrer (für Planer/Admin).
     * @param int $teacherId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getTimetableForTeacherAsPlaner(int $teacherId, int $year, int $calendarWeek): array
    {
        $sql = "SELECT te.*, s.subject_shortcut, s.subject_name, c.class_name, r.room_name, t.teacher_shortcut
                FROM timetable_entries te
                LEFT JOIN subjects s ON te.subject_id = s.subject_id
                JOIN classes c ON te.class_id = c.class_id
                LEFT JOIN rooms r ON te.room_id = r.room_id
                JOIN teachers t ON te.teacher_id = t.teacher_id
                WHERE te.teacher_id = :teacher_id
                    AND te.year = :year
                    AND te.calendar_week = :calendar_week
                ORDER BY te.day_of_week ASC, te.period_number ASC";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':teacher_id' => $teacherId, ':year' => $year, ':calendar_week' => $calendarWeek]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Holt alle Vertretungen für eine Klasse in einer Woche (für Planer/Admin).
     * @param int $classId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getSubstitutionsForClassWeekAsPlaner(int $classId, int $year, int $calendarWeek): array
    {
        return $this->getSubstitutionsForWeekInternal($year, $calendarWeek, $classId, null);
    }

    /**
     * Holt alle Vertretungen für einen Lehrer in einer Woche (für Planer/Admin).
     * @param int $teacherId
     * @param int $year
     * @param int $calendarWeek
     * @return array
     */
    public function getSubstitutionsForTeacherWeekAsPlaner(int $teacherId, int $year, int $calendarWeek): array
    {
        return $this->getSubstitutionsForWeekInternal($year, $calendarWeek, null, $teacherId);
    }

    /**
     * Interne Methode zum Abrufen von Vertretungen für eine Woche, gefiltert nach Klasse oder Lehrer.
     * @param int $year
     * @param int $calendarWeek
     * @param int|null $classId
     * @param int|null $teacherId
     * @return array
     */
    private function getSubstitutionsForWeekInternal(int $year, int $calendarWeek, ?int $classId, ?int $teacherId): array
    {
        [$startDate, $endDate] = $this->getWeekDateRange($year, $calendarWeek);

        // Calculate day_of_week (1=Mon, 5=Fri) using SQL DAYOFWEEK (Sunday=1, Monday=2...). Exclude weekends.
        $sql = "SELECT
                            s.*,
                            DAYOFWEEK(s.date) as day_of_week_iso, /* MySQL Sunday=1, keep for reference */
                            CASE DAYOFWEEK(s.date) WHEN 1 THEN NULL WHEN 7 THEN NULL ELSE DAYOFWEEK(s.date) - 1 END as day_of_week, /* Calculate day_of_week (1=Mon, 5=Fri) */
                            orig_s.subject_shortcut as original_subject_shortcut,
                            new_t.teacher_shortcut as new_teacher_shortcut,
                            new_s.subject_shortcut as new_subject_shortcut,
                            new_r.room_name as new_room_name,
                            c.class_name
                        FROM substitutions s
                        JOIN classes c ON s.class_id = c.class_id
                        LEFT JOIN subjects orig_s ON s.original_subject_id = orig_s.subject_id
                        LEFT JOIN teachers new_t ON s.new_teacher_id = new_t.teacher_id
                        LEFT JOIN subjects new_s ON s.new_subject_id = new_s.subject_id
                        LEFT JOIN rooms new_r ON s.new_room_id = new_r.room_id
                        WHERE s.date BETWEEN :start_date AND :end_date";

        $params = [':start_date' => $startDate, ':end_date' => $endDate];

        if ($classId !== null) {
            $sql .= " AND s.class_id = :class_id";
            $params[':class_id'] = $classId;
        } elseif ($teacherId !== null) {
            // Check if the teacher is the new teacher OR was the original teacher of the replaced lesson
            $sql .= " AND (s.new_teacher_id = :teacher_id OR EXISTS (
                            SELECT 1 FROM timetable_entries te
                            WHERE te.class_id = s.class_id
                                AND te.year = :year
                                AND te.calendar_week = :calendar_week
                                AND te.day_of_week = (CASE DAYOFWEEK(s.date) WHEN 1 THEN NULL WHEN 7 THEN NULL ELSE DAYOFWEEK(s.date) - 1 END)
                                AND te.period_number = s.period_number
                                AND te.teacher_id = :teacher_id
                        ))";
            $params[':teacher_id'] = $teacherId;
            $params[':year'] = $year; // Add year and week for subquery
            $params[':calendar_week'] = $calendarWeek;
        }

        $sql .= " ORDER BY s.date ASC, s.period_number ASC";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($params);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    // --- Methoden zum Verwalten des Veröffentlichungsstatus ---

    /**
     * Veröffentlicht den Plan für eine Woche und Zielgruppe.
     * @param int $year
     * @param int $calendarWeek
     * @param string $targetGroup 'student' or 'teacher'
     * @param int $userId ID des veröffentlichenden Benutzers
     * @return bool Erfolg
     */
    public function publishWeek(int $year, int $calendarWeek, string $targetGroup, int $userId): bool
    {
        $sql = "INSERT INTO timetable_publish_status (year, calendar_week, target_group, published_at, publisher_user_id)
                VALUES (:year, :calendar_week, :target_group, NOW(), :user_id)
                ON DUPLICATE KEY UPDATE published_at = NOW(), publisher_user_id = VALUES(publisher_user_id)"; // Update timestamp and publisher
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':target_group' => $targetGroup,
            ':user_id' => $userId
        ]);
    }

    /**
     * Nimmt die Veröffentlichung für eine Woche und Zielgruppe zurück.
     * @param int $year
     * @param int $calendarWeek
     * @param string $targetGroup 'student' or 'teacher'
     * @return bool Erfolg
     */
    public function unpublishWeek(int $year, int $calendarWeek, string $targetGroup): bool
    {
        $sql = "DELETE FROM timetable_publish_status
                WHERE year = :year AND calendar_week = :calendar_week AND target_group = :target_group";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':target_group' => $targetGroup
        ]);
    }

    /**
     * Holt den Veröffentlichungsstatus für eine Woche.
     * @param int $year
     * @param int $calendarWeek
     * @return array ['student' => bool, 'teacher' => bool]
     */
    public function getPublishStatus(int $year, int $calendarWeek): array
    {
        $sql = "SELECT target_group FROM timetable_publish_status
                WHERE year = :year AND calendar_week = :calendar_week";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':year' => $year, ':calendar_week' => $calendarWeek]);
        $results = $stmt->fetchAll(PDO::FETCH_COLUMN);
        // Ensure both keys always exist
        return ['student' => in_array('student', $results), 'teacher' => in_array('teacher', $results)];
    }


    /**
     * Interne Hilfsfunktion zum Prüfen des Status für eine Zielgruppe.
     * @param string $targetGroup 'student' or 'teacher'
     * @param int $year
     * @param int $calendarWeek
     * @return bool True if published, False otherwise.
     */
    public function isWeekPublishedFor(string $targetGroup, int $year, int $calendarWeek): bool
    {
        $sql = "SELECT 1 FROM timetable_publish_status
                WHERE year = :year AND calendar_week = :calendar_week AND target_group = :target_group LIMIT 1";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':target_group' => $targetGroup
        ]);
        return $stmt->fetchColumn() !== false;
    }


    // --- Methoden zum Bearbeiten von Daten ---

    /**
     * Löscht einen einzelnen Stundenplaneintrag.
     * @param int $entryId
     * @return bool Erfolg
     */
    public function deleteEntry(int $entryId): bool
    {
        $sql = "DELETE FROM timetable_entries WHERE entry_id = :entry_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':entry_id' => $entryId]);
    }

    /**
     * Löscht alle Einträge, die zu einem Block gehören.
     * @param string $blockId
     * @return bool Erfolg
     */
    public function deleteEntryBlock(string $blockId): bool
    {
        $sql = "DELETE FROM timetable_entries WHERE block_id = :block_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':block_id' => $blockId]);
    }

    /**
     * Erstellt oder aktualisiert einen Stundenplaneintrag (oder Block).
     * @param array $data Daten aus dem Formular/API-Call.
     * @return array Informationen über den erstellten/aktualisierten Eintrag (z.B. block_id).
     * @throws Exception
     */
    public function createOrUpdateEntry(array $data): array
    {
        // Validate required fields
        $required = ['year', 'calendar_week', 'day_of_week', 'class_id', 'teacher_id', 'subject_id', 'room_id'];
        foreach ($required as $field) {
            // Check if required fields potentially holding ID '0' are missing or truly empty strings
            // IDs should usually start from 1. If '0' is not valid, add $data[$field] === 0 check.
             // Allow class_id '0' for teacher-mode entries
            if ($field === 'class_id' && ($data[$field] === 0 || $data[$field] === '0')) {
                // Skip check, '0' is allowed for class_id
            }
            elseif (!isset($data[$field]) || $data[$field] === '') {
                throw new Exception("Fehlende Daten: Feld '{$field}' ist erforderlich und darf nicht leer sein.");
            }
        }

        // Sanitize comment
        $comment = isset($data['comment']) ? trim($data['comment']) : null;
        if ($comment === '') {
             $comment = null; // Store NULL instead of empty string
        }

        $startPeriod = (int)($data['start_period_number'] ?? $data['period_number'] ?? 0);
        $endPeriod = (int)($data['end_period_number'] ?? $data['period_number'] ?? 0);
        
        // Add start/end period back to data array for checkConflicts
        $data['start_period_number'] = $startPeriod;
        $data['end_period_number'] = $endPeriod;


        if ($startPeriod <= 0 || $endPeriod <= 0 || $startPeriod > $endPeriod) {
            throw new Exception("Ungültiger Stundenbereich (Start/Ende > 0 und Start <= Ende erforderlich).");
        }
        
        // *** NEW: Check Conflicts BEFORE transaction ***
        $excludeEntryId = !empty($data['entry_id']) ? (int)$data['entry_id'] : null;
        $excludeBlockId = !empty($data['block_id']) ? (string)$data['block_id'] : null;
        
        // Note: checkConflicts will now throw an Exception if conflicts are found
        $this->checkConflicts($data, $excludeEntryId, $excludeBlockId);
        // *** END NEW CONFLICT CHECK ***


        // --- Transaction ---
        $this->pdo->beginTransaction();
        try {
            // Delete existing entries for this exact slot(s) first
            // If updating, delete the specific old entry/block instead of just the timeslot
             if (!empty($data['entry_id']) && filter_var($data['entry_id'], FILTER_VALIDATE_INT)) {
                 $deleteSql = "DELETE FROM timetable_entries WHERE entry_id = :entry_id";
                 $deleteParams = [':entry_id' => $data['entry_id']];
            } elseif (!empty($data['block_id'])) {
                 $deleteSql = "DELETE FROM timetable_entries WHERE block_id = :block_id";
                 $deleteParams = [':block_id' => $data['block_id']];
            } else {
                 // Deleting by timeslot (when creating a new entry over an empty slot - shouldn't delete anything, but safe)
                 $deleteSql = "DELETE FROM timetable_entries
                                 WHERE year = :year
                                   AND calendar_week = :calendar_week
                                   AND day_of_week = :day_of_week
                                   AND class_id = :class_id
                                   AND period_number >= :start_period AND period_number <= :end_period";
                 $deleteParams = [
                     ':year' => $data['year'],
                     ':calendar_week' => $data['calendar_week'],
                     ':day_of_week' => $data['day_of_week'],
                     ':class_id' => $data['class_id'], // Ensure deletion is class-specific
                     ':start_period' => $startPeriod,
                     ':end_period' => $endPeriod
                 ];
            }

             $deleteStmt = $this->pdo->prepare($deleteSql);
             $deleteStmt->execute($deleteParams);


            // Generate block_id only if it's a multi-period entry
            $blockId = ($startPeriod !== $endPeriod) ? uniqid('block_', true) : null;

            $insertSql = "INSERT INTO timetable_entries (year, calendar_week, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_id, comment)
                           VALUES (:year, :calendar_week, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_id, :comment)";

            $insertStmt = $this->pdo->prepare($insertSql);

            $insertedIds = []; // To potentially return IDs if needed
            for ($period = $startPeriod; $period <= $endPeriod; $period++) {
                $params = [
                    ':year' => $data['year'],
                    ':calendar_week' => $data['calendar_week'],
                    ':day_of_week' => $data['day_of_week'],
                    ':period_number' => $period,
                    ':class_id' => $data['class_id'], // Can be '0' for teacher mode
                    ':teacher_id' => $data['teacher_id'],
                    ':subject_id' => $data['subject_id'],
                    ':room_id' => $data['room_id'],
                    ':block_id' => $blockId,
                    ':comment' => $comment
                ];
                if (!$insertStmt->execute($params)) {
                    // Get detailed error info
                    $errorInfo = $insertStmt->errorInfo();
                    throw new PDOException("Fehler beim Einfügen von Stunde {$period}. SQLSTATE[{$errorInfo[0]}]: {$errorInfo[2]}");
                }
                 $insertedIds[] = $this->pdo->lastInsertId(); // Store last insert ID
            }

            $this->pdo->commit();

            // Return relevant info
             return [
                 'block_id' => $blockId,
                 'entry_ids' => $insertedIds, // Return array of created entry IDs
                 'periods' => range($startPeriod, $endPeriod)
             ];

        } catch (Exception $e) {
            $this->pdo->rollBack();
            // Log the detailed error
            error_log("PlanRepository::createOrUpdateEntry failed: " . $e->getMessage());
            // Rethrow a more generic error for the user, potentially including specifics if safe
            throw new Exception("Fehler beim Speichern des Stundenplaneintrags: " . $e->getMessage());
        }
    }


    /**
     * Erstellt oder aktualisiert eine Vertretung.
     * @param array $data Daten aus dem Formular/API-Call.
     * @return array Die Daten der erstellten/aktualisierten Vertretung inkl. ID.
     * @throws Exception
     */
    public function createOrUpdateSubstitution(array $data): array
    {
        // Validate required fields
        if (empty($data['date']) || empty($data['period_number']) || !isset($data['class_id']) || empty($data['substitution_type'])) {
            throw new Exception("Datum, Stunde, Klasse und Vertretungstyp sind Pflichtfelder.");
        }
        // Basic date validation
        if (DateTime::createFromFormat('Y-m-d', $data['date']) === false) {
            throw new Exception("Ungültiges Datumsformat. Bitte YYYY-MM-DD verwenden.");
        }
        
        // NEU: Konfliktprüfung für den NEUEN Lehrer (falls gesetzt)
        if (!empty($data['new_teacher_id'])) {
            // 1. Prüfe auf Doppelbuchung des Lehrers (regulärer Unterricht)
            $dateObj = new DateTime($data['date']);
            $conflictData = [
                'year' => (int)$dateObj->format('o'),
                'calendar_week' => (int)$dateObj->format('W'),
                'day_of_week' => (int)$dateObj->format('N'),
                'start_period_number' => $data['period_number'],
                'end_period_number' => $data['period_number'],
                'teacher_id' => $data['new_teacher_id'],
                'room_id' => null, // Wir prüfen nur den Lehrer
                'class_id' => $data['class_id'] // Die Klasse, in die er soll
            ];
            // Wir müssen die aktuelle Vertretungs-ID (falls vorhanden) von der Prüfung ausschließen
            // $excludeSubId = !empty($data['substitution_id']) ? (int)$data['substitution_id'] : null;
            // HINWEIS: checkConflicts prüft aktuell nur timetable_entries. Wir müssen Vertretungen separat prüfen.
            
            // checkConflicts wirft eine Exception, wenn ein Konflikt in timetable_entries gefunden wird
            try {
                $this->checkConflicts($conflictData, null, null);
            } catch (Exception $e) {
                // Passe die Fehlermeldung an
                if (str_contains($e->getMessage(), 'LEHRER-KONFLIKT')) {
                    throw new Exception("KONFLIKT: Dieser Lehrer hält bereits regulären Unterricht in einer anderen Klasse.", 409, $e);
                }
                throw $e; // Wirf andere Konflikte (z.B. Klasse) erneut
            }

            // 2. Prüfe auf Doppelbuchung (Vertretungen)
            $sqlCheckSub = "SELECT 1 FROM substitutions 
                            WHERE new_teacher_id = :teacher_id 
                              AND date = :date AND period_number = :period
                              AND substitution_id != :exclude_id
                            LIMIT 1";
            $stmtCheckSub = $this->pdo->prepare($sqlCheckSub);
            $stmtCheckSub->execute([
                ':teacher_id' => $data['new_teacher_id'],
                ':date' => $data['date'],
                ':period' => $data['period_number'],
                ':exclude_id' => $data['substitution_id'] ?? 0
            ]);
            if ($stmtCheckSub->fetchColumn()) {
                throw new Exception("KONFLIKT: Dieser Lehrer hält bereits eine andere Vertretung in dieser Stunde.", 409);
            }

            // 3. NEU: Prüfe auf Abwesenheit des NEUEN Lehrers
            $absence = $this->absenceRepo->checkAbsence($data['new_teacher_id'], $data['date']);
            if ($absence) {
                throw new Exception("KONFLIKT: Der Vertretungslehrer (ID {$data['new_teacher_id']}) ist an diesem Tag als '{$absence['reason']}' gemeldet.", 409);
            }
        }
        // --- ENDE NEUE KONFLIKTPRÜFUNG ---


        // Set fields to null if they are empty strings or '0' for foreign keys
        $nullableFields = ['original_subject_id', 'new_teacher_id', 'new_subject_id', 'new_room_id', 'comment'];
        foreach ($nullableFields as $field) {
            if (isset($data[$field])) {
                $value = trim($data[$field]);
                // Treat empty string or '0' as NULL for optional foreign keys, keep comment as empty string if intended
                if ($value === '' || ($value === '0' && $field !== 'comment')) {
                    $data[$field] = null;
                } else {
                    $data[$field] = $value; // Keep trimmed value otherwise
                }
            } else {
                $data[$field] = null; // Ensure key exists and is null if not provided
            }
        }


        if (!empty($data['substitution_id']) && filter_var($data['substitution_id'], FILTER_VALIDATE_INT)) {
            // Update existing substitution
            $sql = "UPDATE substitutions SET
                                date = :date,
                                period_number = :period_number,
                                class_id = :class_id,
                                substitution_type = :substitution_type,
                                original_subject_id = :original_subject_id,
                                new_teacher_id = :new_teacher_id,
                                new_subject_id = :new_subject_id,
                                new_room_id = :new_room_id,
                                comment = :comment
                            WHERE substitution_id = :substitution_id";
            $currentId = (int)$data['substitution_id'];
        } else {
            // Insert new substitution
            $sql = "INSERT INTO substitutions (date, period_number, class_id, substitution_type, original_subject_id, new_teacher_id, new_subject_id, new_room_id, comment)
                    VALUES (:date, :period_number, :class_id, :substitution_type, :original_subject_id, :new_teacher_id, :new_subject_id, :new_room_id, :comment)";
            $currentId = null; // Will get ID after insert
        }

        $stmt = $this->pdo->prepare($sql);

        $params = [
            ':date' => $data['date'],
            ':period_number' => $data['period_number'],
            ':class_id' => $data['class_id'], // Can be '0' if coming from teacher mode
            ':substitution_type' => $data['substitution_type'],
            ':original_subject_id' => $data['original_subject_id'],
            ':new_teacher_id' => $data['new_teacher_id'],
            ':new_subject_id' => $data['new_subject_id'],
            ':new_room_id' => $data['new_room_id'],
            ':comment' => $data['comment'], // Use sanitized value (can be null or trimmed string)
        ];

        if ($currentId !== null) {
            $params[':substitution_id'] = $currentId;
        }

        if (!$stmt->execute($params)) {
            $errorInfo = $stmt->errorInfo();
            error_log("Substitution save failed: SQLSTATE[{$errorInfo[0]}] {$errorInfo[2]}");
            throw new Exception("Fehler beim Speichern der Vertretung.");
        }

         if ($currentId === null) {
             $currentId = (int)$this->pdo->lastInsertId();
         }

         // Fetch the saved data to return it (including potentially looked up names/shortcuts)
         $savedData = $this->getSubstitutionById($currentId);
         if (!$savedData) {
             // Fallback if fetch fails, return input data with ID
             $data['substitution_id'] = $currentId;
             // Add calculated day_of_week for consistency
             try {
                 $dateObj = new DateTime($data['date']);
                 $dayOfWeek = $dateObj->format('N'); // 1 (Mon) - 7 (Sun)
                 $data['day_of_week'] = ($dayOfWeek >= 1 && $dayOfWeek <= 5) ? $dayOfWeek : null;
                 $data['day_of_week_iso'] = $dateObj->format('N'); // Keep ISO day if needed elsewhere
             } catch (Exception $e) {
                 $data['day_of_week'] = null;
                 $data['day_of_week_iso'] = null;
             }
             return $data;
         }
         return $savedData;
    }

     /**
      * Holt eine einzelne Vertretung anhand ihrer ID mit zusätzlichen Details.
      * @param int $substitutionId
      * @return array|false
      */
     public function getSubstitutionById(int $substitutionId): array|false
     {
         $sql = "SELECT
                                    s.*,
                                    DAYOFWEEK(s.date) as day_of_week_iso, /* MySQL Sunday=1 */
                                    CASE DAYOFWEEK(s.date) WHEN 1 THEN NULL WHEN 7 THEN NULL ELSE DAYOFWEEK(s.date) - 1 END as day_of_week, /* Calculate day_of_week (1=Mon, 5=Fri) */
                                    orig_s.subject_shortcut as original_subject_shortcut,
                                    new_t.teacher_shortcut as new_teacher_shortcut,
                                    new_s.subject_shortcut as new_subject_shortcut,
                                    new_r.room_name as new_room_name,
                                    c.class_name
                                FROM substitutions s
                                JOIN classes c ON s.class_id = c.class_id
                                LEFT JOIN subjects orig_s ON s.original_subject_id = orig_s.subject_id
                                LEFT JOIN teachers new_t ON s.new_teacher_id = new_t.teacher_id
                                LEFT JOIN subjects new_s ON s.new_subject_id = new_s.subject_id
                                LEFT JOIN rooms new_r ON s.new_room_id = new_r.room_id
                                WHERE s.substitution_id = :id";
         $stmt = $this->pdo->prepare($sql);
         $stmt->execute([':id' => $substitutionId]);
         return $stmt->fetch(PDO::FETCH_ASSOC);
     }


    /**
     * Löscht eine Vertretung.
     * @param int $substitutionId
     * @return bool Erfolg
     */
    public function deleteSubstitution(int $substitutionId): bool
    {
        $sql = "DELETE FROM substitutions WHERE substitution_id = :substitution_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':substitution_id' => $substitutionId]);
    }

    /**
     * Checks for conflicts (teacher or room double-booking) for a given timeslot.
     * @param array $data Contains year, calendar_week, day_of_week, start_period_number, end_period_number, teacher_id, room_id, class_id
     * @param int|null $excludeEntryId Entry ID to exclude (during updates)
     * @param string|null $excludeBlockId Block ID to exclude (during updates)
     * @return array List of conflict messages.
     * @throws Exception If conflicts are found (to be caught by API handler).
     */
    public function checkConflicts(array $data, ?int $excludeEntryId = null, ?string $excludeBlockId = null): array
    {
        $conflicts = [];
        $baseSql = "SELECT te.*, c.class_name, t.teacher_shortcut, r.room_name
                                FROM timetable_entries te
                                LEFT JOIN classes c ON te.class_id = c.class_id
                                LEFT JOIN teachers t ON te.teacher_id = t.teacher_id
                                LEFT JOIN rooms r ON te.room_id = r.room_id
                                WHERE te.year = :year
                                  AND te.calendar_week = :calendar_week
                                  AND te.day_of_week = :day_of_week
                                  AND te.period_number >= :start_period
                                  AND te.period_number <= :end_period";

        $params = [
            ':year' => $data['year'],
            ':calendar_week' => $data['calendar_week'],
            ':day_of_week' => $data['day_of_week'],
            ':start_period' => $data['start_period_number'],
            ':end_period' => $data['end_period_number'],
        ];

        // Add exclusion conditions if updating
        $exclusionSql = "";
        if ($excludeEntryId !== null) {
            $exclusionSql = " AND te.entry_id != :exclude_entry_id";
            $params[':exclude_entry_id'] = $excludeEntryId;
        } elseif ($excludeBlockId !== null) {
            $exclusionSql = " AND te.block_id != :exclude_block_id";
            $params[':exclude_block_id'] = $excludeBlockId;
        }
        
        // NEU: Hole das Datum für die Abwesenheitsprüfung
        $dateForAbsenceCheck = '';
        try {
            $dto = new DateTime();
            $dto->setISODate($data['year'], $data['calendar_week'], $data['day_of_week']);
            $dateForAbsenceCheck = $dto->format('Y-m-d');
        } catch (Exception $e) {
            throw new Exception("Interner Fehler: Datum für Konfliktprüfung konnte nicht berechnet werden.");
        }


        // 1. Check Teacher Conflict (booked in another class at the same time)
        if (!empty($data['teacher_id'])) {
            // 1a. NEU: Auf Abwesenheit prüfen
            $absence = $this->absenceRepo->checkAbsence($data['teacher_id'], $dateForAbsenceCheck);
            if ($absence) {
                $conflicts[] = "LEHRER-KONFLIKT: Lehrer (ID {$data['teacher_id']}) ist an diesem Tag als '{$absence['reason']}' gemeldet.";
            }

            // 1b. Auf Doppelbuchung (Stundenplan) prüfen
            $teacherSql = $baseSql . " AND te.teacher_id = :teacher_id" . $exclusionSql;
            $teacherParams = $params + [':teacher_id' => $data['teacher_id']];
            
            // Remove exclusion params if they are not in the query
            if ($excludeEntryId === null) unset($teacherParams[':exclude_entry_id']);
            if ($excludeBlockId === null) unset($teacherParams[':exclude_block_id']);

            $stmtTeacher = $this->pdo->prepare($teacherSql);
            $stmtTeacher->execute($teacherParams);
            $existingTeacherEntry = $stmtTeacher->fetch(PDO::FETCH_ASSOC);

            if ($existingTeacherEntry) {
                $shortcut = $existingTeacherEntry['teacher_shortcut'] ?: $data['teacher_id'];
                // Verständlichere Meldung:
                $conflicts[] = "LEHRER-KONFLIKT: '{$shortcut}' ist bereits in Klasse {$existingTeacherEntry['class_name']} ({$existingTeacherEntry['room_name']}) eingeteilt.";
            }
        }

        // 2. Check Room Conflict (booked by another class at the same time)
         if (!empty($data['room_id'])) {
            $roomSql = $baseSql . " AND te.room_id = :room_id" . $exclusionSql;
            $roomParams = $params + [':room_id' => $data['room_id']];
            
            if ($excludeEntryId === null) unset($roomParams[':exclude_entry_id']);
            if ($excludeBlockId === null) unset($roomParams[':exclude_block_id']);

            $stmtRoom = $this->pdo->prepare($roomSql);
            $stmtRoom->execute($roomParams);
            $existingRoomEntry = $stmtRoom->fetch(PDO::FETCH_ASSOC);
            
            if ($existingRoomEntry) {
                $name = $existingRoomEntry['room_name'] ?: $data['room_id'];
                // Verständlichere Meldung:
                $conflicts[] = "RAUM-KONFLIKT: '{$name}' ist bereits von Klasse {$existingRoomEntry['class_name']} (Lehrer: {$existingRoomEntry['teacher_shortcut']}) belegt.";
            }
         }
        
        // 3. Check Class Conflict (class booked for another lesson at the same time)
         // Nur prüfen, wenn es nicht der Lehrermodus ist (dort ist class_id 0 oder null)
         if (!empty($data['class_id']) && $data['class_id'] !== '0' && $data['class_id'] !== 0) {
            $classSql = $baseSql . " AND te.class_id = :class_id" . $exclusionSql;
            $classParams = $params + [':class_id' => $data['class_id']];
            if ($excludeEntryId === null) unset($classParams[':exclude_entry_id']);
            if ($excludeBlockId === null) unset($classParams[':exclude_block_id']);

            $stmtClass = $this->pdo->prepare($classSql);
            $stmtClass->execute($classParams);
            $existingClassEntry = $stmtClass->fetch(PDO::FETCH_ASSOC);

            if ($existingClassEntry) {
                 // *** GEÄNDERTE MELDUNG (Benutzerwunsch) ***
                 $conflicts[] = "KONFLIKT (Slot belegt): Die Klasse {$existingClassEntry['class_name']} hat in diesem Zeitraum bereits Unterricht.";
            }
         }

        // Throw exception if conflicts found (to be caught by handleApiRequest in saveEntry)
        if (!empty($conflicts)) {
            // Wirft die erste (oder kombinierte) Meldung als Fehler
            throw new Exception(implode("\n", $conflicts));
        }

        return $conflicts; // Return empty array if no conflicts
    }

    /**
     * NEU: Kopiert Stundenplandaten von einer Woche in eine andere für eine Klasse oder einen Lehrer.
     * @param int $sourceYear
     * @param int $sourceWeek
     * @param int $targetYear
     * @param int $targetWeek
     * @param int|null $classId
     * @param int|null $teacherId
     * @return int Anzahl der kopierten Einträge.
     * @throws Exception
     */
    public function copyWeekData(int $sourceYear, int $sourceWeek, int $targetYear, int $targetWeek, ?int $classId, ?int $teacherId): int
    {
        if ($classId === null && $teacherId === null) {
            throw new Exception("Es muss entweder eine Klasse oder ein Lehrer zum Kopieren ausgewählt werden.");
        }
        if ($sourceYear === $targetYear && $sourceWeek === $targetWeek) {
            throw new Exception("Quell- und Zielwoche dürfen nicht identisch sein.");
        }

        $this->pdo->beginTransaction();
        try {
            // 1. Zieldaten löschen
            $deleteSql = "DELETE FROM timetable_entries 
                            WHERE year = :target_year AND calendar_week = :target_week";
            $deleteParams = [
                ':target_year' => $targetYear,
                ':target_week' => $targetWeek
            ];
            
            $whereField = "";
            if ($classId !== null) {
                $deleteSql .= " AND class_id = :entity_id";
                $whereField = "class_id";
                $deleteParams[':entity_id'] = $classId;
            } else {
                $deleteSql .= " AND teacher_id = :entity_id";
                $whereField = "teacher_id";
                $deleteParams[':entity_id'] = $teacherId;
            }
            
            $this->pdo->prepare($deleteSql)->execute($deleteParams);

            // 2. Quelldaten holen
            $selectSql = "SELECT * FROM timetable_entries
                            WHERE year = :source_year AND calendar_week = :source_week AND $whereField = :entity_id";
            
            $stmtSelect = $this->pdo->prepare($selectSql);
            $stmtSelect->execute([
                ':source_year' => $sourceYear,
                ':source_week' => $sourceWeek,
                ':entity_id' => $classId ?? $teacherId
            ]);
            $sourceEntries = $stmtSelect->fetchAll(PDO::FETCH_ASSOC);

            if (empty($sourceEntries)) {
                $this->pdo->rollBack(); // Rückgängig machen, da keine Daten zum Kopieren vorhanden waren
                return 0; // 0 Einträge kopiert
            }

            // 3. Neue Einträge vorbereiten und einfügen
            $insertSql = "INSERT INTO timetable_entries 
                            (year, calendar_week, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_id, comment) 
                            VALUES 
                            (:year, :calendar_week, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_id, :comment)";
            
            $stmtInsert = $this->pdo->prepare($insertSql);
            
            $copiedCount = 0;
            $blockIdMap = []; // Mappt alte block_ids auf neue

            foreach ($sourceEntries as $entry) {
                // Generiere neue block_id, falls vorhanden, und behalte sie für die Woche bei
                $newBlockId = null;
                if ($entry['block_id']) {
                    if (!isset($blockIdMap[$entry['block_id']])) {
                        $blockIdMap[$entry['block_id']] = uniqid('block_', true);
                    }
                    $newBlockId = $blockIdMap[$entry['block_id']];
                }

                $success = $stmtInsert->execute([
                    ':year' => $targetYear, // Zieljahr
                    ':calendar_week' => $targetWeek, // Zielwoche
                    ':day_of_week' => $entry['day_of_week'],
                    ':period_number' => $entry['period_number'],
                    ':class_id' => $entry['class_id'],
                    ':teacher_id' => $entry['teacher_id'],
                    ':subject_id' => $entry['subject_id'],
                    ':room_id' => $entry['room_id'],
                    ':block_id' => $newBlockId, // Neue Block-ID
                    ':comment' => $entry['comment']
                ]);
                if ($success) {
                    $copiedCount++;
                }
            }

            $this->pdo->commit();
            return $copiedCount;

        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("PlanRepository::copyWeekData failed: " . $e->getMessage());
            throw new Exception("Fehler beim Kopieren der Wochendaten: " . $e->getMessage());
        }
    }

    // --- NEUE METHODEN FÜR VORLAGEN ---

    /**
     * Erstellt eine neue Stundenplan-Vorlage aus vorhandenen Einträgen.
     * @param string $name Name der Vorlage.
     * @param string|null $description Beschreibung der Vorlage.
     * @param array $sourceEntries Die Stundenplaneinträge (z.B. aus getTimetableFor...AsPlaner).
     * @return int Die ID der neu erstellten Vorlage.
     * @throws Exception
     */
    public function createTemplate(string $name, ?string $description, array $sourceEntries): int
    {
        if (empty($name)) {
            throw new Exception("Vorlagenname darf nicht leer sein.");
        }
        if (empty($sourceEntries)) {
            throw new Exception("Vorlage muss mindestens einen Eintrag enthalten.");
        }

        // Prüfen, ob der Name bereits existiert
        $stmtCheck = $this->pdo->prepare("SELECT COUNT(*) FROM timetable_templates WHERE name = :name");
        $stmtCheck->execute([':name' => $name]);
        if ($stmtCheck->fetchColumn() > 0) {
            throw new Exception("Eine Vorlage mit dem Namen '{$name}' existiert bereits.", 409); // Use 409 for conflict
        }

        $this->pdo->beginTransaction();
        try {
            // 1. Vorlage erstellen
            $sqlTemplate = "INSERT INTO timetable_templates (name, description) VALUES (:name, :description)";
            $stmtTemplate = $this->pdo->prepare($sqlTemplate);
            $stmtTemplate->execute([':name' => $name, ':description' => $description]);
            $templateId = (int)$this->pdo->lastInsertId();

            // 2. Einträge für die Vorlage erstellen
            $sqlEntry = "INSERT INTO timetable_template_entries
                            (template_id, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_ref, comment)
                            VALUES
                            (:template_id, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_ref, :comment)";
            $stmtEntry = $this->pdo->prepare($sqlEntry);

            $blockRefMap = []; // Mappt originale block_ids zu neuen block_refs für diese Vorlage

            foreach ($sourceEntries as $entry) {
                $blockRef = null;
                if ($entry['block_id']) {
                    if (!isset($blockRefMap[$entry['block_id']])) {
                        $blockRefMap[$entry['block_id']] = uniqid('tpl_blk_', true); // Eindeutige Referenz für Blöcke in DIESER Vorlage
                    }
                    $blockRef = $blockRefMap[$entry['block_id']];
                }

                $stmtEntry->execute([
                    ':template_id' => $templateId,
                    ':day_of_week' => $entry['day_of_week'],
                    ':period_number' => $entry['period_number'],
                    ':class_id' => $entry['class_id'], // Speichert die Klasse des ursprünglichen Eintrags
                    ':teacher_id' => $entry['teacher_id'],
                    ':subject_id' => $entry['subject_id'],
                    ':room_id' => $entry['room_id'],
                    ':block_ref' => $blockRef,
                    ':comment' => $entry['comment']
                ]);
            }

            $this->pdo->commit();
            return $templateId;

        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("PlanRepository::createTemplate failed: " . $e->getMessage());
            // Rethrow specific conflict error
             if (str_contains($e->getMessage(), 'Duplicate entry') || $e->getCode() == 409) {
                 throw new Exception("Eine Vorlage mit dem Namen '{$name}' existiert bereits.", 409);
             }
            throw new Exception("Fehler beim Erstellen der Vorlage: " . $e->getMessage());
        }
    }

    /**
     * Ruft alle verfügbaren Vorlagen ab.
     * @return array Array von Vorlagen [['template_id', 'name', 'description'], ...].
     */
    public function getTemplates(): array
    {
        $stmt = $this->pdo->query("SELECT template_id, name, description FROM timetable_templates ORDER BY name ASC");
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Wendet eine Vorlage auf eine spezifische Woche für eine Klasse oder einen Lehrer an.
     * Überschreibt vorhandene Einträge für diese Entität in der Zielwoche.
     * @param int $templateId ID der anzuwendenden Vorlage.
     * @param int $targetYear Zieljahr.
     * @param int $targetWeek Zielwoche.
     * @param int|null $targetClassId ID der Zielklasse (wenn Anwenden auf Klasse).
     * @param int|null $targetTeacherId ID des Ziellehrers (wenn Anwenden auf Lehrer).
     * @return int Anzahl der angewendeten Einträge.
     * @throws Exception
     */
    public function applyTemplateToWeek(int $templateId, int $targetYear, int $targetWeek, ?int $targetClassId, ?int $targetTeacherId): int
    {
        if ($targetClassId === null && $targetTeacherId === null) {
            throw new Exception("Es muss entweder eine Klasse oder ein Lehrer als Ziel angegeben werden.");
        }

        // 1. Vorlageneinträge abrufen
        $stmtFetch = $this->pdo->prepare("SELECT * FROM timetable_template_entries WHERE template_id = :template_id ORDER BY day_of_week, period_number");
        $stmtFetch->execute([':template_id' => $templateId]);
        $templateEntries = $stmtFetch->fetchAll(PDO::FETCH_ASSOC);

        if (empty($templateEntries)) {
            // Vorlage ist leer oder existiert nicht
            return 0;
        }

        $this->pdo->beginTransaction();
        try {
            // 2. Bestehende Einträge für Zielwoche/-entität löschen
            $deleteSql = "DELETE FROM timetable_entries
                            WHERE year = :target_year AND calendar_week = :target_week";
            $deleteParams = [':target_year' => $targetYear, ':target_week' => $targetWeek];

            if ($targetClassId !== null) {
                $deleteSql .= " AND class_id = :entity_id";
                $deleteParams[':entity_id'] = $targetClassId;
                $entityIdField = 'class_id';
                $entityIdValue = $targetClassId;
            } else {
                $deleteSql .= " AND teacher_id = :entity_id";
                $deleteParams[':entity_id'] = $targetTeacherId;
                $entityIdField = 'teacher_id';
                $entityIdValue = $targetTeacherId;
            }
            $this->pdo->prepare($deleteSql)->execute($deleteParams);

            // 3. Neue Einträge basierend auf Vorlage einfügen
            $insertSql = "INSERT INTO timetable_entries
                            (year, calendar_week, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_id, comment)
                            VALUES
                            (:year, :calendar_week, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_id, :comment)";
            $stmtInsert = $this->pdo->prepare($insertSql);

            $appliedCount = 0;
            $blockIdMap = []; // Mappt template block_ref zu neuer, eindeutiger block_id für die Zielwoche

            foreach ($templateEntries as $entry) {
                $newBlockId = null;
                if ($entry['block_ref']) {
                    if (!isset($blockIdMap[$entry['block_ref']])) {
                        $blockIdMap[$entry['block_ref']] = uniqid('block_', true); // Generiert eindeutige ID für die Zielwoche
                    }
                    $newBlockId = $blockIdMap[$entry['block_ref']];
                }

                // Bestimme die korrekte class_id für den neuen Eintrag
                // Wenn wir auf einen Lehrer anwenden, MUSS die class_id aus der Vorlage kommen.
                // Wenn wir auf eine Klasse anwenden, MUSS die class_id die Zielklasse sein.
                $entryClassId = ($entityIdField === 'class_id') ? $entityIdValue : $entry['class_id'];
                // Stelle sicher, dass eine class_id vorhanden ist, wenn auf Lehrer angewendet wird
                if ($entityIdField === 'teacher_id' && (empty($entryClassId) || $entryClassId == 0)) {
                   // Überspringe diesen Eintrag oder wirf einen Fehler, da Lehrer ohne Klasse nicht geplant werden kann
                   error_log("Template apply skipped: Teacher template entry missing class_id. TemplateEntryID: " . $entry['template_entry_id']);
                   continue; // Überspringe diesen Eintrag
                }


                $success = $stmtInsert->execute([
                    ':year' => $targetYear,
                    ':calendar_week' => $targetWeek,
                    ':day_of_week' => $entry['day_of_week'],
                    ':period_number' => $entry['period_number'],
                    ':class_id' => $entryClassId, // Angepasste Klassen-ID
                    ':teacher_id' => $entry['teacher_id'],
                    ':subject_id' => $entry['subject_id'],
                    ':room_id' => $entry['room_id'],
                    ':block_id' => $newBlockId, // Neue Block-ID für die Zielwoche
                    ':comment' => $entry['comment']
                ]);
                if ($success) {
                    $appliedCount++;
                } else {
                    // Optional: Fehler loggen, falls ein Eintrag fehlschlägt
                    error_log("Failed to apply template entry: " . print_r($stmtInsert->errorInfo(), true));
                }
            }

            $this->pdo->commit();
            return $appliedCount;

        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("PlanRepository::applyTemplateToWeek failed: " . $e->getMessage());
            throw new Exception("Fehler beim Anwenden der Vorlage: " . $e->getMessage());
        }
    }

    /**
     * Löscht eine Vorlage und alle zugehörigen Einträge.
     * @param int $templateId ID der zu löschenden Vorlage.
     * @return bool Erfolg.
     */
    public function deleteTemplate(int $templateId): bool
    {
        // Durch ON DELETE CASCADE in der DB werden die Einträge automatisch mitgelöscht
        $sql = "DELETE FROM timetable_templates WHERE template_id = :template_id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':template_id' => $templateId]);
    }

    // --- ENDE NEUE METHODEN FÜR VORLAGEN ---

    /**
     * Lädt die Details einer Vorlage (Stammdaten und Einträge).
     *
     * @param int $templateId
     * @return array
     * @throws Exception
     */
    public function loadTemplateDetails(int $templateId): array
    {
        // 1. Vorlagen-Stammdaten abrufen
        $stmtTemplate = $this->pdo->prepare("SELECT * FROM timetable_templates WHERE template_id = :id");
        $stmtTemplate->execute([':id' => $templateId]);
        $templateInfo = $stmtTemplate->fetch(PDO::FETCH_ASSOC);

        if (!$templateInfo) {
            throw new Exception("Vorlage nicht gefunden.");
        }

        // 2. Zugehörige Einträge abrufen
        // WICHTIG: Wir holen die Roh-IDs, da der Planer-Editor die Stammdaten bereits hat
        $stmtEntries = $this->pdo->prepare("SELECT * FROM timetable_template_entries WHERE template_id = :id ORDER BY day_of_week, period_number");
        $stmtEntries->execute([':id' => $templateId]);
        $entries = $stmtEntries->fetchAll(PDO::FETCH_ASSOC);

        return [
            'template' => $templateInfo,
            'entries' => $entries
        ];
    }

    /**
     * Speichert eine Vorlage (neu oder Update) basierend auf den Editor-Daten.
     *
     * @param array $data Daten mit ['name', 'description', 'template_id' (optional), 'entries' (array)]
     * @return array Die gespeicherten Vorlagen-Stammdaten (inkl. ID)
     * @throws Exception
     */
    public function saveTemplateDetails(array $data): array
    {
        $templateId = $data['template_id'] ?? null;
        $name = trim($data['name']);
        $description = trim($data['description'] ?? '') ?: null;
        $entries = $data['entries'] ?? [];

        if (empty($name)) {
            throw new Exception("Vorlagenname darf nicht leer sein.");
        }

        $this->pdo->beginTransaction();
        try {
            // Prüfen, ob der Name (außerhalb dieser ID) bereits existiert
            $sqlCheckName = "SELECT template_id FROM timetable_templates WHERE name = :name AND (:id IS NULL OR template_id != :id)";
            $stmtCheckName = $this->pdo->prepare($sqlCheckName);
            $stmtCheckName->execute([':name' => $name, ':id' => $templateId]);
            if ($stmtCheckName->fetch()) {
                throw new Exception("Eine andere Vorlage mit diesem Namen existiert bereits.", 409);
            }

            if ($templateId) {
                // Update existing template
                $sqlTemplate = "UPDATE timetable_templates SET name = :name, description = :description WHERE template_id = :id";
                $stmtTemplate = $this->pdo->prepare($sqlTemplate);
                $stmtTemplate->execute([':name' => $name, ':description' => $description, ':id' => $templateId]);
            } else {
                // Create new template
                $sqlTemplate = "INSERT INTO timetable_templates (name, description) VALUES (:name, :description)";
                $stmtTemplate = $this->pdo->prepare($sqlTemplate);
                $stmtTemplate->execute([':name' => $name, ':description' => $description]);
                $templateId = (int)$this->pdo->lastInsertId();
            }

            // Einträge neu schreiben (Delete + Insert)
            $stmtDelete = $this->pdo->prepare("DELETE FROM timetable_template_entries WHERE template_id = :id");
            $stmtDelete->execute([':id' => $templateId]);

            if (!empty($entries)) {
                $sqlEntry = "INSERT INTO timetable_template_entries
                                (template_id, day_of_week, period_number, class_id, teacher_id, subject_id, room_id, block_ref, comment)
                                VALUES
                                (:template_id, :day_of_week, :period_number, :class_id, :teacher_id, :subject_id, :room_id, :block_ref, :comment)";
                $stmtEntry = $this->pdo->prepare($sqlEntry);

                foreach ($entries as $entry) {
                    $stmtEntry->execute([
                        ':template_id' => $templateId,
                        ':day_of_week' => $entry['day_of_week'],
                        ':period_number' => $entry['period_number'],
                        ':class_id' => $entry['class_id'],
                        ':teacher_id' => $entry['teacher_id'],
                        ':subject_id' => $entry['subject_id'],
                        ':room_id' => $entry['room_id'],
                        ':block_ref' => $entry['block_ref'] ?: null,
                        ':comment' => $entry['comment'] ?: null
                    ]);
                }
            }

            $this->pdo->commit();

            return [
                'template_id' => $templateId,
                'name' => $name,
                'description' => $description
            ];

        } catch (Exception $e) {
            $this->pdo->rollBack();
            // Loggen Sie den detaillierten Fehler
            error_log("PlanRepository::saveTemplateDetails failed: " . $e->getMessage());
            // Werfen Sie den Fehler erneut, damit der Controller ihn fangen kann
            // Behalten Sie den Konflikt-Code 409 bei
            $errorCode = $e->getCode() == 409 ? 409 : 500;
            throw new Exception("Fehler beim Speichern der Vorlage: " . $e->getMessage(), $errorCode);
        }
    }


    public function findTeacherLocation(int $teacherId, string $date, int $year, int $calendarWeek, int $dayOfWeek, int $periodNumber): array
    {
        // 1. Prüfen, ob der Lehrer als NEUER Lehrer in einer Vertretung eingeteilt ist
        $sqlSubAsNew = "SELECT s.*, c.class_name, ns.subject_shortcut as new_subject_shortcut, nr.room_name as new_room_name
                        FROM substitutions s
                        JOIN classes c ON s.class_id = c.class_id
                        LEFT JOIN subjects ns ON s.new_subject_id = ns.subject_id
                        LEFT JOIN rooms nr ON s.new_room_id = nr.room_id
                        WHERE s.new_teacher_id = :teacher_id 
                            AND s.date = :date 
                            AND s.period_number = :period_number";
        
        $stmtSubAsNew = $this->pdo->prepare($sqlSubAsNew);
        $stmtSubAsNew->execute([
            ':teacher_id' => $teacherId,
            ':date' => $date,
            ':period_number' => $periodNumber
        ]);
        $subAsNew = $stmtSubAsNew->fetch(PDO::FETCH_ASSOC);

        if ($subAsNew) {
            // Der Lehrer hält aktiv eine Vertretung
            // Wir müssen den Typ der Vertretung zurückgeben (z.B. Vertretung, Sonderevent)
            return [
                'status' => $subAsNew['substitution_type'], // z.B. "Vertretung" oder "Sonderevent"
                'data' => $subAsNew
            ];
        }

        // 2. Prüfen, ob der Lehrer regulären Unterricht HÄTTE
        $sqlRegular = "SELECT te.*, s.subject_shortcut, c.class_name, r.room_name
                        FROM timetable_entries te
                        LEFT JOIN subjects s ON te.subject_id = s.subject_id
                        LEFT JOIN classes c ON te.class_id = c.class_id
                        LEFT JOIN rooms r ON te.room_id = r.room_id
                        WHERE te.teacher_id = :teacher_id
                            AND te.year = :year
                            AND te.calendar_week = :calendar_week
                            AND te.day_of_week = :day_of_week
                            AND te.period_number = :period_number";
        
        $stmtRegular = $this->pdo->prepare($sqlRegular);
        $stmtRegular->execute([
            ':teacher_id' => $teacherId,
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':day_of_week' => $dayOfWeek,
            ':period_number' => $periodNumber
        ]);
        $regularEntry = $stmtRegular->fetch(PDO::FETCH_ASSOC);

        if (!$regularEntry) {
            // 3. Kein regulärer Unterricht und keine Vertretung -> Freistunde
            return [
                'status' => 'Freistunde',
                'data' => null
            ];
        }

        // 4. Regulärer Unterricht ist geplant. PRÜFE, ob DIESE Stunde vertreten wird.
        $sqlCheckSub = "SELECT s.*, c.class_name, 
                               os.subject_shortcut as original_subject_shortcut, 
                               ns.subject_shortcut as new_subject_shortcut, 
                               nr.room_name as new_room_name
                        FROM substitutions s
                        JOIN classes c ON s.class_id = c.class_id
                        LEFT JOIN subjects os ON s.original_subject_id = os.subject_id
                        LEFT JOIN subjects ns ON s.new_subject_id = ns.subject_id
                        LEFT JOIN rooms nr ON s.new_room_id = nr.room_id
                        WHERE s.date = :date 
                            AND s.period_number = :period_number
                            AND s.class_id = :class_id";
        
        $stmtCheckSub = $this->pdo->prepare($sqlCheckSub);
        $stmtCheckSub->execute([
            ':date' => $date,
            ':period_number' => $periodNumber,
            ':class_id' => $regularEntry['class_id']
        ]);
        $substitution = $stmtCheckSub->fetch(PDO::FETCH_ASSOC);

        if ($substitution) {
            // 5. Ja, die Stunde wird vertreten (z.B. Entfall, Raumänderung)
            // Der Lehrer ist also NICHT im regulären Raum.
            // Der Status ist der Typ der Vertretung.
            return [
                'status' => $substitution['substitution_type'],
                'data' => $substitution
            ];
        }

        // 6. Kein Treffer in Schritt 1 und 5 -> Der Lehrer hält regulären Unterricht.
        return [
            'status' => 'Unterricht',
            'data' => $regularEntry
        ];
    }
    
    /**
     * NEU: Holt alle eindeutigen Klassen-IDs, die ein Lehrer unterrichtet.
     * @param int $teacherId
     * @return array
     */
    public function getClassesForTeacher(int $teacherId): array
    {
        // Holt Klassen aus regulären Einträgen
        $sqlEntries = "SELECT DISTINCT c.class_id, c.class_name 
                        FROM timetable_entries te
                        JOIN classes c ON te.class_id = c.class_id
                        WHERE te.teacher_id = :teacher_id";
                        
        // Holt Klassen aus Vertretungen (wo der Lehrer der *neue* Lehrer ist)
        $sqlSubs = "SELECT DISTINCT c.class_id, c.class_name
                    FROM substitutions s
                    JOIN classes c ON s.class_id = c.class_id
                    WHERE s.new_teacher_id = :teacher_id";

        try {
            $stmtEntries = $this->pdo->prepare($sqlEntries);
            $stmtEntries->execute([':teacher_id' => $teacherId]);
            $classesFromEntries = $stmtEntries->fetchAll(PDO::FETCH_ASSOC);
            
            $stmtSubs = $this->pdo->prepare($sqlSubs);
            $stmtSubs->execute([':teacher_id' => $teacherId]);
            $classesFromSubs = $stmtSubs->fetchAll(PDO::FETCH_ASSOC);

            // Kombiniere die Ergebnisse und entferne Duplikate (basierend auf class_id)
            $allClasses = [];
            foreach (array_merge($classesFromEntries, $classesFromSubs) as $class) {
                $allClasses[$class['class_id']] = $class; // Nutzen der ID als Schlüssel entfernt Duplikate
            }
            
            // Sortiere nach Klassen-ID
            ksort($allClasses);

            return array_values($allClasses); // Gebe nur die Werte (die Klassen-Arrays) zurück

        } catch (Exception $e) {
            error_log("Fehler beim Abrufen der Klassen für Lehrer {$teacherId}: " . $e->getMessage());
            return [];
        }
    }
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\PlanRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\SettingsRepository.php ---
<?php
// app/Repositories/SettingsRepository.php

namespace App\Repositories;

use PDO;
use Exception;
use App\Core\Database;

/**
 * Repository zur Verwaltung von Einstellungen in der Datenbank.
 */
class SettingsRepository
{
    private PDO $pdo;

    public function __construct()
    {
        $this->pdo = Database::getInstance();
    }

    /**
     * Lädt alle Einstellungen aus der Datenbank.
     *
     * @return array Assoziatives Array [setting_key => setting_value]
     */
    public function loadSettings(): array
    {
        try {
            $stmt = $this->pdo->query("SELECT setting_key, setting_value FROM settings");
            // Wandelt das Ergebnis [ ['setting_key' => 'k', 'setting_value' => 'v'], ... ]
            // in ein assoziatives Array [ 'k' => 'v' ] um.
            return $stmt->fetchAll(PDO::FETCH_KEY_PAIR) ?: [];
        } catch (Exception $e) {
            // Loggt den Fehler, aber fährt mit leeren DB-Einstellungen fort (Fallback auf JSON)
            error_log("Could not load settings from DB: " . $e->getMessage());
            return [];
        }
    }

    /**
     * Speichert mehrere Einstellungen in der Datenbank.
     *
     * @param array $settings Assoziatives Array [setting_key => setting_value]
     * @return bool True bei Erfolg
     * @throws Exception Bei Datenbankfehlern
     */
    public function saveSettings(array $settings): bool
    {
        // Verwendet INSERT ... ON DUPLICATE KEY UPDATE für Effizienz
        $sql = "INSERT INTO settings (setting_key, setting_value) VALUES (:key, :value)
                ON DUPLICATE KEY UPDATE setting_value = :value";
        
        try {
            $this->pdo->beginTransaction();
            $stmt = $this->pdo->prepare($sql);
            
            foreach ($settings as $key => $value) {
                // Konvertiert boolesche Werte und NULL in speicherbare Formate
                if (is_bool($value)) {
                    $value = $value ? '1' : '0';
                }
                if ($value === null) {
                    $value = ''; // Oder je nach Logik NULL, aber TEXT-Spalte kann '' sein
                }

                $stmt->execute([':key' => $key, ':value' => $value]);
            }
            
            $this->pdo->commit();
            return true;
        } catch (Exception $e) {
            $this->pdo->rollBack();
            error_log("Failed to save settings: " . $e->getMessage());
            throw new Exception("Einstellungen konnten nicht gespeichert werden: " . $e->getMessage());
        }
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\SettingsRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\StammdatenRepository.php ---
<?php
// app/Repositories/StammdatenRepository.php
namespace App\Repositories;

use PDO;
use Exception; // Hinzugefügt für Zähl-Methoden

class StammdatenRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    // --- Subject Methods ---
    public function getSubjects(): array {
        $stmt = $this->pdo->prepare("SELECT * FROM subjects ORDER BY subject_name ASC");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function createSubject(string $name, string $shortcut): int {
        $sql = "INSERT INTO subjects (subject_name, subject_shortcut) VALUES (:name, :shortcut)";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':name' => $name, ':shortcut' => $shortcut]);
        return (int)$this->pdo->lastInsertId();
    }
    public function updateSubject(int $id, string $name, string $shortcut): bool {
        $sql = "UPDATE subjects SET subject_name = :name, subject_shortcut = :shortcut WHERE subject_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id, ':name' => $name, ':shortcut' => $shortcut]);
    }
    public function deleteSubject(int $id): bool {
        $sql = "DELETE FROM subjects WHERE subject_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id]);
    }
    /** NEU: Zählt die Anzahl der Fächer */
    public function countSubjects(): int {
        try {
            $stmt = $this->pdo->query("SELECT COUNT(*) FROM subjects");
            return (int)($stmt->fetchColumn() ?: 0);
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Fächer: " . $e->getMessage());
            return 0;
        }
    }

    // --- Rooms Methods ---
    public function getRooms(): array {
        $stmt = $this->pdo->prepare("SELECT * FROM rooms ORDER BY room_name ASC");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function createRoom(string $name): int {
        $sql = "INSERT INTO rooms (room_name) VALUES (:name)";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':name' => $name]);
        return (int)$this->pdo->lastInsertId();
    }
    public function updateRoom(int $id, string $name): bool {
        $sql = "UPDATE rooms SET room_name = :name WHERE room_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id, ':name' => $name]);
    }
    public function deleteRoom(int $id): bool {
        $sql = "DELETE FROM rooms WHERE room_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id]);
    }
    /** NEU: Zählt die Anzahl der Räume */
    public function countRooms(): int {
        try {
            $stmt = $this->pdo->query("SELECT COUNT(*) FROM rooms");
            return (int)($stmt->fetchColumn() ?: 0);
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Räume: " . $e->getMessage());
            return 0;
        }
    }

    // --- Teachers Methods ---
    public function getTeachers(): array {
        $stmt = $this->pdo->prepare("SELECT * FROM teachers ORDER BY last_name, first_name ASC");
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    public function createTeacher(array $data): int {
        $sql = "INSERT INTO teachers (teacher_shortcut, first_name, last_name, email) VALUES (:shortcut, :first_name, :last_name, :email)";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($data);
        return (int)$this->pdo->lastInsertId();
    }
    public function updateTeacher(int $id, array $data): bool {
        $sql = "UPDATE teachers SET teacher_shortcut = :shortcut, first_name = :first_name, last_name = :last_name, email = :email WHERE teacher_id = :id";
        $data['id'] = $id;
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute($data);
    }
    public function deleteTeacher(int $id): bool {
        $sql = "DELETE FROM teachers WHERE teacher_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id]);
    }
    /** NEU: Zählt die Anzahl der Lehrer */
    public function countTeachers(): int {
        try {
            $stmt = $this->pdo->query("SELECT COUNT(*) FROM teachers");
            return (int)($stmt->fetchColumn() ?: 0);
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Lehrer: " . $e->getMessage());
            return 0;
        }
    }

    // --- Classes Methods (ANGEPASST) ---
    public function getClasses(): array {
        $sql = "SELECT c.class_id, c.class_name, c.class_teacher_id, CONCAT_WS(' ', t.first_name, t.last_name) as teacher_name
                FROM classes c
                LEFT JOIN teachers t ON c.class_teacher_id = t.teacher_id
                ORDER BY c.class_id ASC";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute();
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public function createClass(int $id, string $name, ?int $teacherId): bool {
        // Prüfen, ob die ID bereits existiert
        $stmtCheck = $this->pdo->prepare("SELECT COUNT(*) FROM classes WHERE class_id = :id");
        $stmtCheck->execute([':id' => $id]);
        if ($stmtCheck->fetchColumn() > 0) {
            throw new \Exception("Die Klassen-ID '{$id}' ist bereits vergeben.");
        }

        $sql = "INSERT INTO classes (class_id, class_name, class_teacher_id) VALUES (:id, :name, :teacher_id)";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id, ':name' => $name, ':teacher_id' => $teacherId]);
    }

    public function updateClass(int $id, string $name, ?int $teacherId): bool {
        // Die ID (Primärschlüssel) selbst wird hier nicht geändert.
        $sql = "UPDATE classes SET class_name = :name, class_teacher_id = :teacher_id WHERE class_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id, ':name' => $name, ':teacher_id' => $teacherId]);
    }

    public function deleteClass(int $id): bool {
        $sql = "DELETE FROM classes WHERE class_id = :id";
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([':id' => $id]);
    }
    /** NEU: Zählt die Anzahl der Klassen */
    public function countClasses(): int {
        try {
            $stmt = $this->pdo->query("SELECT COUNT(*) FROM classes");
            return (int)($stmt->fetchColumn() ?: 0);
        } catch (Exception $e) {
            error_log("Fehler beim Zählen der Klassen: " . $e->getMessage());
            return 0;
        }
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\StammdatenRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\StudentNoteRepository.php ---
<?php
// app/Repositories/StudentNoteRepository.php

namespace App\Repositories;

use PDO;
use Exception;

class StudentNoteRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Holt alle Notizen eines Schülers für eine bestimmte Woche.
     *
     * @param int $userId
     * @param int $year
     * @param int $calendarWeek
     * @return array Assoziatives Array (z.B. ["1-2" => "Notiz..."])
     */
    public function getNotesForWeek(int $userId, int $year, int $calendarWeek): array
    {
        $sql = "SELECT day_of_week, period_number, note_content
                FROM student_notes
                WHERE user_id = :user_id
                  AND year = :year
                  AND calendar_week = :calendar_week";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':user_id' => $userId,
            ':year' => $year,
            ':calendar_week' => $calendarWeek
        ]);

        $notes = [];
        // Erstellt ein einfaches Key-Value-Paar "Tag-Stunde" => "Inhalt"
        while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $key = $row['day_of_week'] . '-' . $row['period_number'];
            $notes[$key] = $row['note_content'];
        }
        
        return $notes;
    }

    /**
     * Speichert oder aktualisiert eine Notiz (UPSERT).
     *
     * @param int $userId
     * @param int $year
     * @param int $calendarWeek
     * @param int $dayOfWeek
     * @param int $periodNumber
     * @param string $content
     * @return bool
     */
    public function saveNote(int $userId, int $year, int $calendarWeek, int $dayOfWeek, int $periodNumber, string $content): bool
    {
        // Wenn der Inhalt leer ist, löschen wir den Eintrag, anstatt einen leeren String zu speichern.
        if (empty(trim($content))) {
            return $this->deleteNote($userId, $year, $calendarWeek, $dayOfWeek, $periodNumber);
        }

        $sql = "INSERT INTO student_notes (user_id, `year`, calendar_week, day_of_week, period_number, note_content)
                VALUES (:user_id, :year, :calendar_week, :day_of_week, :period_number, :note_content)
                ON DUPLICATE KEY UPDATE
                    note_content = VALUES(note_content),
                    last_updated = NOW()";
        
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':user_id' => $userId,
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':day_of_week' => $dayOfWeek,
            ':period_number' => $periodNumber,
            ':note_content' => $content
        ]);
    }

    /**
     * Löscht eine Notiz, z.B. wenn der Inhalt geleert wird.
     */
    private function deleteNote(int $userId, int $year, int $calendarWeek, int $dayOfWeek, int $periodNumber): bool
    {
         $sql = "DELETE FROM student_notes
                  WHERE user_id = :user_id
                    AND `year` = :year
                    AND calendar_week = :calendar_week
                    AND day_of_week = :day_of_week
                    AND period_number = :period_number";
        
        $stmt = $this->pdo->prepare($sql);
        return $stmt->execute([
            ':user_id' => $userId,
            ':year' => $year,
            ':calendar_week' => $calendarWeek,
            ':day_of_week' => $dayOfWeek,
            ':period_number' => $periodNumber
        ]);
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\StudentNoteRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\TeacherAbsenceRepository.php ---
<?php
// app/Repositories/TeacherAbsenceRepository.php

namespace App\Repositories;

use PDO;
use Exception;
use DateTime;
use DateTimeZone;

class TeacherAbsenceRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
        $this->pdo = $pdo;
    }

    /**
     * Holt alle Abwesenheiten für den Kalender für einen bestimmten Zeitraum.
     * (KORRIGIERT: Akzeptiert jetzt Parameter)
     *
     * @param string $startDate (Y-m-d)
     * @param string $endDate (Y-m-d)
     * @return array
     */
    public function getAbsencesForPeriod(string $startDate, string $endDate): array
    {
        // KORREKTUR: Verwendet die übergebenen Daten anstelle eines festen Zeitraums
        $sql = "SELECT ta.*, t.teacher_shortcut, t.first_name, t.last_name
                FROM teacher_absences ta
                JOIN teachers t ON ta.teacher_id = t.teacher_id
                WHERE ta.start_date <= :end_date AND ta.end_date >= :start_date
                ORDER BY ta.start_date ASC";
                
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':start_date' => $startDate,
            ':end_date' => $endDate
        ]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    /**
     * Holt eine einzelne Abwesenheit anhand ihrer ID.
     *
     * @param int $absenceId
     * @return array|false
     */
    public function getAbsenceById(int $absenceId): array|false
    {
        $sql = "SELECT ta.*, t.teacher_shortcut, t.first_name, t.last_name
                FROM teacher_absences ta
                JOIN teachers t ON ta.teacher_id = t.teacher_id
                WHERE ta.absence_id = :absence_id";
                
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':absence_id' => $absenceId]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }


    /**
     * Speichert (Insert/Update) eine Abwesenheit.
     *
     * @param int|null $absenceId
     * @param int $teacherId
     * @param string $startDate
     * @param string $endDate
     * @param string $reason
     * @param string|null $comment
     * @return array Der gespeicherte Datensatz
     * @throws Exception
     */
    public function createAbsence(?int $absenceId, int $teacherId, string $startDate, string $endDate, string $reason, ?string $comment): array
    {
        // Validierung der Daten
        if ($startDate > $endDate) {
            throw new Exception("Das Startdatum darf nicht nach dem Enddatum liegen.");
        }
        if (empty($teacherId) || empty($reason)) {
             throw new Exception("Lehrer und Grund sind Pflichtfelder.");
        }

        if ($absenceId) {
            // Update
            $sql = "UPDATE teacher_absences SET
                        teacher_id = :teacher_id,
                        start_date = :start_date,
                        end_date = :end_date,
                        reason = :reason,
                        comment = :comment
                    WHERE absence_id = :absence_id";
            $params = [
                ':teacher_id' => $teacherId,
                ':start_date' => $startDate,
                ':end_date' => $endDate,
                ':reason' => $reason,
                ':comment' => $comment,
                ':absence_id' => $absenceId
            ];
        } else {
            // Insert
            $sql = "INSERT INTO teacher_absences (teacher_id, start_date, end_date, reason, comment)
                    VALUES (:teacher_id, :start_date, :end_date, :reason, :comment)";
            $params = [
                ':teacher_id' => $teacherId,
                ':start_date' => $startDate,
                ':end_date' => $endDate,
                ':reason' => $reason,
                ':comment' => $comment
            ];
        }
        
        $stmt = $this->pdo->prepare($sql);
        if (!$stmt->execute($params)) {
            throw new Exception("Datenbankfehler beim Speichern der Abwesenheit.");
        }

        $newId = $absenceId ?? (int)$this->pdo->lastInsertId();
        
        // Hole den gespeicherten Datensatz zurück
        $savedData = $this->getAbsenceById($newId);
        if (!$savedData) {
            throw new Exception("Fehler beim Abrufen der gespeicherten Abwesenheit.");
        }
        return $savedData;
    }

    /**
     * Löscht eine Abwesenheit.
     *
     * @param int $absenceId
     * @return bool
     * @throws Exception
     */
    public function deleteAbsence(int $absenceId): bool
    {
        $sql = "DELETE FROM teacher_absences WHERE absence_id = :absence_id";
        $stmt = $this->pdo->prepare($sql);
        
        if (!$stmt->execute([':absence_id' => $absenceId])) {
            throw new Exception("Datenbankfehler beim Löschen der Abwesenheit.");
        }
        
        return $stmt->rowCount() > 0;
    }

    /**
     * Holt Abwesenheiten für einen bestimmten Zeitraum (für den PlanController).
     *
     * @param string $startDate (Y-m-d)
     * @param string $endDate (Y-m-d)
     * @return array
     */
    public function getAbsencesForDateRange(string $startDate, string $endDate): array
    {
        $sql = "SELECT teacher_id, start_date, end_date, reason
                FROM teacher_absences
                WHERE start_date <= :end_date AND end_date >= :start_date";
                
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':start_date' => $startDate, ':end_date' => $endDate]);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
    
    /**
     * Prüft, ob ein spezifischer Lehrer an einem spezifischen Tag abwesend ist.
     *
     * @param int $teacherId
     * @param string $date (Y-m-d)
     * @return array|false Die Abwesenheitsdaten oder false
     */
    public function checkAbsence(int $teacherId, string $date)
    {
        $sql = "SELECT * FROM teacher_absences
                WHERE teacher_id = :teacher_id
                  AND :date BETWEEN start_date AND end_date
                LIMIT 1";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':teacher_id' => $teacherId, ':date' => $date]);
        return $stmt->fetch(PDO::FETCH_ASSOC);
    }

    /**
     * Holt die definierten Abwesenheitstypen.
     * Aktuell hardcodiert, könnte später aus einer DB-Tabelle kommen.
     *
     * @return array
     */
    public function getAbsenceTypes(): array
    {
        return [
            'Krank',
            'Fortbildung',
            'Beurlaubt',
            'Sonstiges'
        ];
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\TeacherAbsenceRepository.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\app\Repositories\UserRepository.php ---
<?php
// app/Repositories/UserRepository.php
namespace App\Repositories;

use PDO;
use Exception;

class UserRepository
{
    private PDO $pdo;

    public function __construct(PDO $pdo)
    {
   