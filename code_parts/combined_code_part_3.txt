dataset.id;
    const postTitle = postItem?.querySelector('.post-title')?.textContent || 'dieser Beitrag';

    if (!postId) {
        showToast('Konnte Beitrags-ID nicht finden.', 'error');
        return;
    }

    let actionText, url, confirmTitle, confirmMessage, logAction;

    if (approveBtn) {
        actionText = 'Freigeben';
        url = `${window.APP_CONFIG.baseUrl}/api/admin/community/approve`;
        logAction = 'approve';
        confirmTitle = 'Beitrag freigeben';
        confirmMessage = `Möchten Sie "${postTitle}" wirklich freigeben?`;
    } else if (rejectBtn) {
        actionText = 'Ablehnen & Löschen';
        url = `${window.APP_CONFIG.baseUrl}/api/admin/community/reject`;
        logAction = 'reject';
        confirmTitle = 'Beitrag ablehnen';
        confirmMessage = `Möchten Sie "${postTitle}" wirklich ablehnen und löschen?`;
    } else if (deleteBtn) { // NEU
        actionText = 'Endgültig Löschen';
        url = `${window.APP_CONFIG.baseUrl}/api/admin/community/delete-approved`;
        logAction = 'delete';
        confirmTitle = 'Beitrag löschen';
        confirmMessage = `Möchten Sie den freigegebenen Beitrag "${postTitle}" wirklich endgültig löschen?`;
    }

    // Bestätigung einholen
    if (await showConfirm(confirmTitle, confirmMessage)) {
        button.disabled = true;
        const spinner = document.createElement('span');
        spinner.className = 'loading-spinner small';
        button.insertAdjacentElement('afterend', spinner);

        try {
            const response = await apiFetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ post_id: postId })
            });

            if (response.success) {
                showToast(response.message, 'success');
                // Beitrag aus der Liste entfernen
                postItem.style.transition = 'opacity 0.3s ease, height 0.3s ease, margin 0.3s ease, padding 0.3s ease';
                postItem.style.opacity = '0';
                postItem.style.height = '0px';
                postItem.style.paddingTop = '0';
                postItem.style.paddingBottom = '0';
                postItem.style.margin = '0';
                
                setTimeout(() => {
                    const listContainer = postItem.parentElement;
                    postItem.remove();
                    // Prüfen, ob die Liste jetzt leer ist
                    if (listContainer && listContainer.childElementCount === 0) {
                        const messageType = (logAction === 'approve' || logAction === 'reject') ? 'ausstehende' : 'freigegebene';
                        listContainer.innerHTML = `<p class="message info">Aktuell gibt es keine ${messageType} Beiträge.</p>`;
                    }
                }, 300);
            }
            // Fehler wird von apiFetch als Toast angezeigt
        } catch (error) {
            console.error(`Fehler bei Aktion '${logAction}':`, error);
            // Button wieder aktivieren, falls der Request fehlschlägt
            button.disabled = false;
        } finally {
            spinner.remove();
        }
    }
}



--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-community.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-settings.js ---
import { apiFetch } from './api-client.js';
import { showToast } from './notifications.js';

export function initializeAdminSettings() {
    const settingsForm = document.getElementById('settings-form');
    if (!settingsForm) return;

    const saveButton = document.getElementById('save-settings-btn');
    const statusSpinner = document.getElementById('save-settings-spinner');
    
    // Toggle-Schalter
    const maintenanceToggle = document.getElementById('maintenance_mode');
    const maintenanceStatus = document.getElementById('maintenance-status');
    const icalToggle = document.getElementById('ical_enabled'); // NEU
    const icalStatus = document.getElementById('ical-status'); // NEU
    
    // Datei-Upload-Vorschau-Handler
    const logoInput = document.getElementById('site_logo');
    const logoPreviewContainer = document.getElementById('logo-preview-container');
    const logoRemoveCheckbox = document.querySelector('input[name="remove_site_logo"]');
    const faviconInput = document.getElementById('site_favicon');
    const faviconPreviewContainer = document.getElementById('favicon-preview-container');
    const faviconRemoveCheckbox = document.querySelector('input[name="remove_site_favicon"]');


    // NEU: Hilfsfunktion für Toggles
    const setupToggle = (toggleElement, statusElement, activeText = 'Aktiviert', inactiveText = 'Deaktiviert') => {
        if (!toggleElement || !statusElement) return;
        
        const updateStatus = () => {
             if (toggleElement.checked) {
                statusElement.textContent = activeText;
                statusElement.style.color = 'var(--color-success)';
            } else {
                statusElement.textContent = inactiveText;
                statusElement.style.color = 'var(--color-text-muted)';
            }
        };
        
        toggleElement.addEventListener('change', updateStatus);
        updateStatus(); // Initialen Status beim Laden setzen
    };

    // Live-Aktualisierung der Status-Texte
    setupToggle(maintenanceToggle, maintenanceStatus, 'Aktiviert', 'Deaktiviert');
    setupToggle(icalToggle, icalStatus, 'Aktiviert', 'Deaktiviert'); // NEU


    // Funktion zur Aktualisierung der Datei-Vorschau
    const updatePreview = (input, container, removeCheckbox, isLogo = true) => {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = (e) => {
                container.innerHTML = `
                    <img src="${e.target.result}" alt="Vorschau" class="${isLogo ? 'logo-preview' : 'favicon-preview'}">
                    <label class="remove-file-label" style="display: block;">
                        <input type="checkbox" name="${removeCheckbox.name}" value="1"> Entfernen
                    </label>
                `;
                // Re-binde den "Entfernen"-Checkbox-Listener für das *neue* Element
                const newRemoveCheckbox = container.querySelector(`input[name="${removeCheckbox.name}"]`);
                if (newRemoveCheckbox) {
                     newRemoveCheckbox.addEventListener('change', () => handleRemoveCheck(newRemoveCheckbox, input, container, isLogo ? 'Logo' : 'Favicon'));
                }
            };
            reader.readAsDataURL(input.files[0]);
            if (removeCheckbox) removeCheckbox.checked = false; // Deaktiviere "Entfernen", wenn neue Datei gewählt
        }
    };
    
    // Funktion, die das "Entfernen" behandelt
    const handleRemoveCheck = (checkbox, input, container, altText) => {
         if (checkbox.checked) {
            if (input) input.value = ''; // Clear file input
            container.querySelector('img')?.remove(); // Remove preview image
            container.querySelector('.no-file')?.remove();
            
            const noFileSpan = document.createElement('span');
            noFileSpan.className = 'no-file';
            noFileSpan.textContent = `${altText} wird entfernt.`;
            container.prepend(noFileSpan);
            // Verstecke die Checkbox selbst, da sie ihre Aufgabe erfüllt hat
            if (checkbox.parentElement) checkbox.parentElement.style.display = 'none';
        }
    };

    // Event Listener für Datei-Vorschau
    if (logoInput) logoInput.addEventListener('change', () => updatePreview(logoInput, logoPreviewContainer, logoRemoveCheckbox, true));
    if (faviconInput) faviconInput.addEventListener('change', () => updatePreview(faviconInput, faviconPreviewContainer, faviconRemoveCheckbox, false));
    
    // Logik für "Entfernen"-Checkbox (für bereits geladene Bilder)
    if (logoRemoveCheckbox) {
        logoRemoveCheckbox.addEventListener('change', () => handleRemoveCheck(logoRemoveCheckbox, logoInput, logoPreviewContainer, 'Logo'));
    }
     if (faviconRemoveCheckbox) {
        faviconRemoveCheckbox.addEventListener('change', () => handleRemoveCheck(faviconRemoveCheckbox, faviconInput, faviconPreviewContainer, 'Favicon'));
    }


    settingsForm.addEventListener('submit', async (e) => {
        e.preventDefault();

        if (saveButton) saveButton.disabled = true;
        if (statusSpinner) statusSpinner.style.display = 'inline-block';

        const formData = new FormData(settingsForm);

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/settings/save`, {
                method: 'POST',
                body: formData // Sende als FormData (inkl. Dateien)
            });

            if (response.success) {
                showToast('Einstellungen erfolgreich gespeichert.', 'success');
                
                const cacheBuster = `?v=${new Date().getTime()}`;

                // Update site title in header if changed
                const newTitle = formData.get('site_title');
                const logoContainer = document.querySelector('.site-logo');
                
                if (logoContainer) {
                    if (response.data.site_logo_path) {
                        // Neues Logo wurde gesetzt
                        logoContainer.innerHTML = `<img src="${window.APP_CONFIG.baseUrl}/${response.data.site_logo_path}${cacheBuster}" alt="${escapeHtml(newTitle)} Logo" class="site-logo-image" id="header-logo-img">`;
                    } else {
                        // Logo wurde entfernt oder war nie da, zeige Titel
                        logoContainer.innerHTML = `<span id="header-logo-text">${escapeHtml(newTitle)}</span>`;
                    }
                }
                // Update document title
                document.title = escapeHtml(newTitle);
                
                // Update Favicon
                let faviconElement = document.querySelector('link[rel="icon"]');
                if (response.data.site_favicon_path) {
                    const newFaviconUrl = `${window.APP_CONFIG.baseUrl}/${response.data.site_favicon_path}${cacheBuster}`;
                    if (faviconElement) {
                        faviconElement.href = newFaviconUrl;
                    } else {
                        // Erstelle Favicon-Link, falls er nicht existiert
                        const newLink = document.createElement('link');
                        newLink.rel = 'icon';
                        newLink.href = newFaviconUrl;
                        document.head.appendChild(newLink);
                    }
                } else if (!response.data.site_favicon_path && faviconElement) {
                    // Favicon wurde entfernt
                    faviconElement.remove();
                }

                // Aktualisiere die Vorschau-Container in der Einstellungs-Seite selbst
                updatePreviewContainer(logoPreviewContainer, response.data.site_logo_path, 'remove_site_logo', 'Logo', true);
                updatePreviewContainer(faviconPreviewContainer, response.data.site_favicon_path, 'remove_site_favicon', 'Favicon', false);
                // Setze File-Inputs zurück
                if (logoInput) logoInput.value = '';
                if (faviconInput) faviconInput.value = '';

                 // Aktualisiere globalen Config-Cache
                 window.APP_CONFIG.settings.site_title = newTitle;
                 window.APP_CONFIG.settings.site_logo_path = response.data.site_logo_path;
                 window.APP_CONFIG.settings.site_favicon_path = response.data.site_favicon_path;
                 window.APP_CONFIG.settings.default_theme = response.data.default_theme;
                 window.APP_CONFIG.settings.ical_enabled = formData.get('ical_enabled') === '1';
                 window.APP_CONFIG.settings.ical_weeks_future = parseInt(formData.get('ical_weeks_future'), 10);
                 window.APP_CONFIG.settings.maintenance_whitelist_ips = formData.get('maintenance_whitelist_ips'); // NEU
            }
             // Errors are handled by apiFetch and showToast
        } catch (error) {
            console.error('Fehler beim Speichern der Einstellungen:', error);
            // Error toast is already shown by apiFetch
        } finally {
            if (saveButton) saveButton.disabled = false;
            if (statusSpinner) statusSpinner.style.display = 'none';
        }
    });

    /**
     * NEU: Hilfsfunktion zum Aktualisieren des Vorschau-Containers nach dem Speichern.
     */
    function updatePreviewContainer(container, newPath, checkboxName, altText, isLogo) {
        if (!container) return;
        
        // Cache-Buster für das neue Bild
        const cacheBuster = `?v=${new Date().getTime()}`;
        
        if (newPath) {
             container.innerHTML = `
                <img src="${window.APP_CONFIG.baseUrl}/${newPath}${cacheBuster}" alt="${altText} Vorschau" class="${isLogo ? 'logo-preview' : 'favicon-preview'}">
                <label class="remove-file-label">
                    <input type="checkbox" name="${checkboxName}" value="1"> ${altText} entfernen
                </label>
            `;
            // Re-binde den Event Listener für die neue Checkbox
             const newCheckbox = container.querySelector(`input[name="${checkboxName}"]`);
             if (newCheckbox) {
                 const inputEl = document.getElementById(isLogo ? 'site_logo' : 'site_favicon');
                 newCheckbox.addEventListener('change', () => handleRemoveCheck(newCheckbox, inputEl, container, altText));
             }

        } else {
             container.innerHTML = `<span class="no-file">Kein ${altText} festgelegt.</span>`;
        }
    }
    
    // Hilfsfunktion zum Escapen von HTML
    function escapeHtml(unsafe) {
         if (!unsafe) return '';
         return String(unsafe)
              .replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&#039;");
    }

}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-settings.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-stammdaten.js ---
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js'; // Import notification functions

/**
 * Steuert die Tab-Navigation und das "Lazy Loading" der Inhalte.
 */
function initializeTabbedInterface() {
    const stammdatenManagement = document.getElementById('stammdaten-management');
    if (!stammdatenManagement) return;

    const tabButtons = stammdatenManagement.querySelectorAll('.tab-button');
    const tabContents = stammdatenManagement.querySelectorAll('.dashboard-section');

    const initializers = {
        'subjects-section': initializeSubjectManagement,
        'rooms-section': initializeRoomManagement,
        'teachers-section': initializeTeacherManagement,
        'classes-section': initializeClassManagement,
    };

    const handleTabClick = (button) => {
        tabButtons.forEach(btn => btn.classList.remove('active'));
        tabContents.forEach(content => content.classList.remove('active'));

        button.classList.add('active');
        const targetId = button.dataset.target;
        const targetContent = document.getElementById(targetId);

        if (targetContent) {
            targetContent.classList.add('active');

            // Initialize content only once
            if (!targetContent.dataset.initialized) {
                const initFunc = initializers[targetId];
                if (typeof initFunc === 'function') {
                    initFunc(); // Call the specific initializer for this tab
                    targetContent.dataset.initialized = 'true';
                }
            }

            // Focus first input in the form for better UX
            const firstInput = targetContent.querySelector('form input[type="text"], form input[type="email"], form input[type="number"]');
            if (firstInput) {
                setTimeout(() => firstInput.focus(), 50); // Small delay might be needed
            }
        }
    };

    tabButtons.forEach(button => {
        button.addEventListener('click', () => handleTabClick(button));
    });

    // Initialize the initially active tab (defined by 'active' class in HTML)
    const initiallyActiveButton = stammdatenManagement.querySelector('.tab-button.active');
    if (initiallyActiveButton) {
        handleTabClick(initiallyActiveButton);
    }
}


function initializeSubjectManagement() {
    const section = document.getElementById('subjects-section');
    if (!section) return;

    const tableBody = section.querySelector('#subjects-table tbody');
    const form = section.querySelector('#subject-form');
    const formTitle = section.querySelector('#subject-form-container h4');
    const subjectIdInput = section.querySelector('#subject_id');
    const subjectNameInput = section.querySelector('#subject_name');
    const subjectShortcutInput = section.querySelector('#subject_shortcut');
    const cancelBtn = section.querySelector('#cancel-edit-subject');

    const resetForm = () => {
        form.dataset.mode = 'create';
        form.reset();
        subjectIdInput.value = '';
        formTitle.textContent = 'Neues Fach anlegen';
        cancelBtn.style.display = 'none';
    };

    const renderTable = (subjects) => {
        tableBody.innerHTML = subjects.length > 0 ? subjects.map(subject => `
            <tr data-id="${subject.subject_id}">
                <td>${subject.subject_id}</td>
                <td>${subject.subject_name}</td>
                <td>${subject.subject_shortcut}</td>
                <td class="actions">
                    <button class="btn btn-warning btn-small edit-subject" data-name="${subject.subject_name}" data-shortcut="${subject.subject_shortcut}">Bearbeiten</button>
                    <button class="btn btn-danger btn-small delete-subject">Löschen</button>
                </td>
            </tr>
        `).join('') : '<tr><td colspan="4">Keine Fächer gefunden.</td></tr>';
    };

    const loadSubjects = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/subjects`);
            if (response.success) {
                renderTable(response.data);
            }
            // Error handled by apiFetch
        } catch (error) {
            tableBody.innerHTML = '<tr><td colspan="4" class="message error">Fehler beim Laden der Fächer.</td></tr>';
        }
    };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const mode = form.dataset.mode;
        const formData = new FormData(form);
        const url = mode === 'create'
            ? `${window.APP_CONFIG.baseUrl}/api/admin/subjects/create`
            : `${window.APP_CONFIG.baseUrl}/api/admin/subjects/update`;

        try {
            const response = await apiFetch(url, { method: 'POST', body: formData });
            if(response.success) {
                // Use imported function directly
                showToast(response.message, 'success');
                resetForm();
                loadSubjects(); // Reload table
            }
             // Error handled by apiFetch
        } catch(error) {}
    });

    tableBody.addEventListener('click', async (e) => {
        const target = e.target;
        const row = target.closest('tr');
        if (!row) return;

        const id = row.dataset.id;

        if (target.classList.contains('edit-subject')) {
            form.dataset.mode = 'update';
            subjectIdInput.value = id;
            subjectNameInput.value = target.dataset.name;
            subjectShortcutInput.value = target.dataset.shortcut;
            formTitle.textContent = 'Fach bearbeiten';
            cancelBtn.style.display = 'inline-block';
            subjectNameInput.focus();
        }

        if (target.classList.contains('delete-subject')) {
            // Use imported function directly
            if (await showConfirm('Fach löschen', 'Sind Sie sicher, dass Sie dieses Fach endgültig löschen möchten?')) {
                const formData = new FormData();
                formData.append('subject_id', id);
                try {
                    const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/subjects/delete`, { method: 'POST', body: formData });
                     if(response.success) {
                         // Use imported function directly
                         showToast(response.message, 'success');
                         loadSubjects(); // Reload table
                     }
                      // Error handled by apiFetch
                } catch(error) {}
            }
        }
    });

    cancelBtn.addEventListener('click', resetForm);
    loadSubjects(); // Initial load
}

function initializeRoomManagement() {
    const section = document.getElementById('rooms-section');
    if (!section) return;

    const tableBody = section.querySelector('#rooms-table tbody');
    const form = section.querySelector('#room-form');
    const formTitle = section.querySelector('#room-form-container h4');
    const roomIdInput = section.querySelector('#room_id');
    const roomNameInput = section.querySelector('#room_name');
    const cancelBtn = section.querySelector('#cancel-edit-room');

    const resetForm = () => {
        form.dataset.mode = 'create';
        form.reset();
        roomIdInput.value = '';
        formTitle.textContent = 'Neuen Raum anlegen';
        cancelBtn.style.display = 'none';
    };

    const renderTable = (rooms) => {
        tableBody.innerHTML = rooms.length > 0 ? rooms.map(room => `
            <tr data-id="${room.room_id}">
                <td>${room.room_id}</td>
                <td>${room.room_name}</td>
                <td class="actions">
                    <button class="btn btn-warning btn-small edit-room" data-name="${room.room_name}">Bearbeiten</button>
                    <button class="btn btn-danger btn-small delete-room">Löschen</button>
                </td>
            </tr>
        `).join('') : '<tr><td colspan="3">Keine Räume gefunden.</td></tr>';
    };

    const loadRooms = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/rooms`);
            if (response.success) {
                renderTable(response.data);
            }
            // Error handled by apiFetch
        } catch (error) {
             tableBody.innerHTML = '<tr><td colspan="3" class="message error">Fehler beim Laden der Räume.</td></tr>';
        }
    };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const mode = form.dataset.mode;
        const formData = new FormData(form);
        const url = mode === 'create'
            ? `${window.APP_CONFIG.baseUrl}/api/admin/rooms/create`
            : `${window.APP_CONFIG.baseUrl}/api/admin/rooms/update`;

        try {
            const response = await apiFetch(url, { method: 'POST', body: formData });
            if(response.success) {
                 // Use imported function directly
                 showToast(response.message, 'success');
                 resetForm();
                 loadRooms(); // Reload table
            }
             // Error handled by apiFetch
        } catch(error) {}
    });

    tableBody.addEventListener('click', async (e) => {
        const target = e.target;
        const row = target.closest('tr');
        if (!row) return;

        const id = row.dataset.id;

        if (target.classList.contains('edit-room')) {
            form.dataset.mode = 'update';
            roomIdInput.value = id;
            roomNameInput.value = target.dataset.name;
            formTitle.textContent = 'Raum bearbeiten';
            cancelBtn.style.display = 'inline-block';
            roomNameInput.focus();
        }

        if (target.classList.contains('delete-room')) {
             // Use imported function directly
            if (await showConfirm('Raum löschen', 'Sind Sie sicher, dass Sie diesen Raum endgültig löschen möchten?')) {
                const formData = new FormData();
                formData.append('room_id', id);
                try {
                    const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/rooms/delete`, { method: 'POST', body: formData });
                     if(response.success) {
                         // Use imported function directly
                         showToast(response.message, 'success');
                         loadRooms(); // Reload table
                     }
                      // Error handled by apiFetch
                } catch(error) {}
            }
        }
    });

    cancelBtn.addEventListener('click', resetForm);
    loadRooms(); // Initial load
}

function initializeTeacherManagement() {
    const section = document.getElementById('teachers-section');
    if (!section) return;

    const tableBody = section.querySelector('#teachers-table tbody');
    const form = section.querySelector('#teacher-form');
    const formTitle = section.querySelector('#teacher-form-container h4');
    const teacherIdInput = section.querySelector('#teacher_id');
    const cancelBtn = section.querySelector('#cancel-edit-teacher');

    const resetForm = () => {
        form.dataset.mode = 'create';
        form.reset();
        teacherIdInput.value = '';
        formTitle.textContent = 'Lehrer anlegen/bearbeiten';
        cancelBtn.style.display = 'none';
    };

    const renderTable = (teachers) => {
        tableBody.innerHTML = teachers.length > 0 ? teachers.map(t => `
            <tr data-id="${t.teacher_id}">
                <td>${t.teacher_id}</td>
                <td>${t.teacher_shortcut}</td>
                <td>${t.first_name}</td>
                <td>${t.last_name}</td>
                <td>${t.email || ''}</td>
                <td class="actions">
                    <button class="btn btn-warning btn-small edit-teacher">Bearbeiten</button>
                    <button class="btn btn-danger btn-small delete-teacher">Löschen</button>
                </td>
            </tr>
        `).join('') : '<tr><td colspan="6">Keine Lehrer gefunden.</td></tr>';
    };

    const loadTeachers = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/teachers`);
            if (response.success) {
                renderTable(response.data);
            }
            // Error handled by apiFetch
        } catch (error) {
            tableBody.innerHTML = '<tr><td colspan="6" class="message error">Fehler beim Laden der Lehrer.</td></tr>';
        }
    };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const mode = form.dataset.mode;
        const formData = new FormData(form);
        const url = mode === 'create'
            ? `${window.APP_CONFIG.baseUrl}/api/admin/teachers/create`
            : `${window.APP_CONFIG.baseUrl}/api/admin/teachers/update`;

        try {
            const response = await apiFetch(url, { method: 'POST', body: formData });
            if(response.success) {
                 // Use imported function directly
                 showToast(response.message, 'success');
                 resetForm();
                 loadTeachers(); // Reload table
            }
             // Error handled by apiFetch
        } catch(error) {}
    });

    tableBody.addEventListener('click', async (e) => {
        const target = e.target;
        const row = target.closest('tr');
        if (!row) return;

        const id = row.dataset.id;

        if (target.classList.contains('edit-teacher')) {
            form.dataset.mode = 'update';
            teacherIdInput.value = id;
            form.querySelector('#teacher_shortcut').value = row.cells[1].textContent;
            form.querySelector('#first_name').value = row.cells[2].textContent;
            form.querySelector('#last_name').value = row.cells[3].textContent;
            form.querySelector('#email').value = row.cells[4].textContent;
            formTitle.textContent = 'Lehrer bearbeiten';
            cancelBtn.style.display = 'inline-block';
        }

        if (target.classList.contains('delete-teacher')) {
             // Use imported function directly
            if (await showConfirm('Lehrer löschen', 'Sind Sie sicher? Dies kann Stundenpläne beeinflussen.')) {
                const formData = new FormData();
                formData.append('teacher_id', id);
                try {
                    const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/teachers/delete`, { method: 'POST', body: formData });
                     if(response.success) {
                         // Use imported function directly
                         showToast(response.message, 'success');
                         loadTeachers(); // Reload table
                     }
                      // Error handled by apiFetch
                } catch(error) {}
            }
        }
    });

    cancelBtn.addEventListener('click', resetForm);
    loadTeachers(); // Initial load
}

function initializeClassManagement() {
    const section = document.getElementById('classes-section');
    if (!section) return;

    const tableBody = section.querySelector('#classes-table tbody');
    const form = section.querySelector('#class-form');
    const formTitle = section.querySelector('#class-form-container h4');
    const classIdInput = section.querySelector('#class_id_input'); // Input for ID (readonly in edit mode)
    const classIdHiddenInput = section.querySelector('#class_id_hidden'); // Hidden input for submit
    const classNameInput = section.querySelector('#class_name');
    const teacherSelect = section.querySelector('#class_teacher_id');
    const cancelBtn = section.querySelector('#cancel-edit-class');

    const resetForm = () => {
        form.dataset.mode = 'create';
        form.reset();
        classIdHiddenInput.value = '';
        formTitle.textContent = 'Neue Klasse anlegen';
        cancelBtn.style.display = 'none';
        classIdInput.readOnly = false; // Allow editing ID when creating
        classIdInput.disabled = false;
    };

    const renderTable = (classes) => {
        tableBody.innerHTML = classes.length > 0 ? classes.map(c => `
            <tr data-id="${c.class_id}" data-teacher-id="${c.class_teacher_id || ''}">
                <td>${c.class_id}</td>
                <td>${c.class_name}</td>
                <td>${c.teacher_name || 'Kein Klassenlehrer'}</td>
                <td class="actions">
                    <button class="btn btn-warning btn-small edit-class" data-name="${c.class_name}">Bearbeiten</button>
                    <button class="btn btn-danger btn-small delete-class">Löschen</button>
                </td>
            </tr>
        `).join('') : '<tr><td colspan="4">Keine Klassen gefunden.</td></tr>';
    };

    const loadTeachersForSelect = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/teachers`);
            if (response.success) {
                teacherSelect.innerHTML = '<option value="">Kein Klassenlehrer</option>' + response.data.map(t =>
                    `<option value="${t.teacher_id}">${t.first_name} ${t.last_name} (${t.teacher_shortcut})</option>`
                ).join('');
            }
             // Error handled by apiFetch
        } catch (error) {
            teacherSelect.innerHTML = '<option value="">Lehrer konnten nicht geladen werden</option>';
        }
    };

    const loadClasses = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/classes`);
            if (response.success) {
                renderTable(response.data);
            }
            // Error handled by apiFetch
        } catch (error) {
            tableBody.innerHTML = '<tr><td colspan="4" class="message error">Fehler beim Laden der Klassen.</td></tr>';
        }
    };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const mode = form.dataset.mode;
        const formData = new FormData(form);
        // Ensure the correct class_id is submitted (from hidden input in update mode)
        if (mode === 'update') {
            formData.set('class_id', classIdHiddenInput.value); // Use hidden input value
             formData.delete('class_id_input'); // Remove the potentially disabled input value
        } else {
             formData.set('class_id', classIdInput.value); // Use visible input value for create
             formData.delete('class_id_input'); // Remove the input field with suffix
             formData.delete('class_id_hidden'); // Remove hidden field for create
        }

        const url = mode === 'create'
            ? `${window.APP_CONFIG.baseUrl}/api/admin/classes/create`
            : `${window.APP_CONFIG.baseUrl}/api/admin/classes/update`;

        try {
            const response = await apiFetch(url, { method: 'POST', body: formData });
            if(response.success) {
                 // Use imported function directly
                 showToast(response.message, 'success');
                 resetForm();
                 loadClasses(); // Reload table
            }
            // Error (like duplicate ID) handled by apiFetch
        } catch(error) {}
    });

    tableBody.addEventListener('click', async (e) => {
        const target = e.target;
        const row = target.closest('tr');
        if (!row) return;

        const id = row.dataset.id;

        if (target.classList.contains('edit-class')) {
            form.dataset.mode = 'update';
            classIdInput.value = id; // Show ID in input
            classIdInput.readOnly = true; // Make ID readonly
            classIdInput.disabled = true; // Disable ID input visually
            classIdHiddenInput.value = id; // Set hidden input for submission
            classNameInput.value = target.dataset.name;
            teacherSelect.value = row.dataset.teacherId;
            formTitle.textContent = 'Klasse bearbeiten';
            cancelBtn.style.display = 'inline-block';
            classNameInput.focus();
        }

        if (target.classList.contains('delete-class')) {
            // Use imported function directly
            if (await showConfirm('Klasse löschen', 'Sind Sie sicher? Dies kann Stundenpläne und Benutzerzuweisungen beeinflussen.')) {
                const formData = new FormData();
                formData.append('class_id', id);
                try {
                    const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/classes/delete`, { method: 'POST', body: formData });
                     if(response.success) {
                         // Use imported function directly
                         showToast(response.message, 'success');
                         loadClasses(); // Reload table
                     }
                      // Error handled by apiFetch
                } catch(error) {}
            }
        }
    });

    cancelBtn.addEventListener('click', resetForm);
    loadTeachersForSelect(); // Load teachers for the dropdown
    loadClasses(); // Initial load
}

export function initializeAdminStammdaten() {
    initializeTabbedInterface();
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-stammdaten.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-users.js ---
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js'; // Import notification functions

export function initializeAdminUsers() {
    const userManagement = document.getElementById('user-management');
    if (!userManagement) return;

    const tableBody = userManagement.querySelector('#users-table tbody');
    const form = userManagement.querySelector('#user-form');
    const formTitle = userManagement.querySelector('#user-form-title');
    const userIdInput = userManagement.querySelector('#user_id');
    const passwordInput = userManagement.querySelector('#password');
    const cancelBtn = userManagement.querySelector('#cancel-edit-user');

    // Role specific fields
    const roleSelect = userManagement.querySelector('#role');
    const classSelectContainer = userManagement.querySelector('#class-select-container');
    const classSelect = userManagement.querySelector('#class_id');
    const teacherSelectContainer = userManagement.querySelector('#teacher-select-container');
    const teacherSelect = userManagement.querySelector('#teacher_id');
    // NEU: Community Ban Checkbox
    const communityBanContainer = userManagement.querySelector('#community-ban-container');
    const communityBanCheckbox = userManagement.querySelector('#is_community_banned');


    let allData = {}; // To store roles, classes, teachers

    const resetForm = () => {
        form.dataset.mode = 'create';
        form.reset();
        userIdInput.value = '';
        formTitle.textContent = 'Neuen Benutzer anlegen';
        passwordInput.setAttribute('required', 'required');
        passwordInput.parentElement.querySelector('label').textContent = 'Passwort*';
        cancelBtn.style.display = 'none';
        toggleRoleSpecificFields(); // Reset visibility
    };

    const toggleRoleSpecificFields = () => {
        const selectedRole = roleSelect.value;
        classSelectContainer.style.display = selectedRole === 'schueler' ? 'block' : 'none';
        teacherSelectContainer.style.display = selectedRole === 'lehrer' ? 'block' : 'none';
        // NEU: Zeige Ban-Checkbox nur für Schüler
        communityBanContainer.style.display = selectedRole === 'schueler' ? 'block' : 'none';


        // Reset selections when role changes
        if (selectedRole !== 'schueler') {
            classSelect.value = '';
            communityBanCheckbox.checked = false; // NEU
        }
        if (selectedRole !== 'lehrer') {
            teacherSelect.value = '';
        }
    };

    const renderTable = (users) => {
        // KORREKTUR: HTML für die neue Spalte "Community" hinzugefügt
        tableBody.innerHTML = users.length > 0 ? users.map(user => {
            let details = '';
            if (user.role === 'schueler' && user.class_name) {
                details = `Klasse: ${user.class_name}`;
            } else if (user.role === 'lehrer' && user.teacher_name) {
                details = `Lehrerprofil: ${user.teacher_name}`;
            }

            // NEU: Community-Status
            let communityStatus = '-';
            if (user.role === 'schueler') {
                communityStatus = user.is_community_banned == 1 
                    ? '<span style="color: var(--color-danger); font-weight: 600;">Gesperrt</span>' 
                    : '<span style="color: var(--color-success);">Aktiv</span>';
            }

            return `
                <tr data-id="${user.user_id}" data-user='${JSON.stringify(user)}'>
                    <td>${user.user_id}</td>
                    <td><strong>${user.first_name} ${user.last_name}</strong><br><small>${user.username}</small></td>
                    <td>${user.role}</td>
                    <td>${details}</td>
                    <td>${communityStatus}</td>
                    <td class="actions">
                        <button class="btn btn-warning btn-small edit-user">Bearbeiten</button>
                        <button class="btn btn-danger btn-small delete-user">Löschen</button>
                    </td>
                </tr>
            `;
        }).join('') : '<tr><td colspan="6">Keine Benutzer gefunden.</td></tr>'; // KORREKTUR: colspan="6"
    };


    const populateSelects = (data) => {
        allData = data; // Store for later use
        roleSelect.innerHTML = data.roles.map(r => `<option value="${r}">${r.charAt(0).toUpperCase() + r.slice(1)}</option>`).join('');
        classSelect.innerHTML = '<option value="">Keine Klasse</option>' + data.classes.map(c => `<option value="${c.class_id}">${c.class_name}</option>`).join('');
        teacherSelect.innerHTML = '<option value="">Kein Lehrerprofil</option>' + data.teachers.map(t => `<option value="${t.teacher_id}">${t.first_name} ${t.last_name} (${t.teacher_shortcut})</option>`).join('');
    };

    const loadUsers = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/users`);
            if (response.success) {
                renderTable(response.data.users);
                populateSelects(response.data);
                // After populating, ensure the correct fields are shown based on the initial role value (might be pre-selected)
                toggleRoleSpecificFields();
            }
             // Error handled by apiFetch
        } catch (error) {
            tableBody.innerHTML = '<tr><td colspan="6" class="message error">Fehler beim Laden der Benutzer.</td></tr>'; // KORREKTUR: colspan="6"
        }
    };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const mode = form.dataset.mode;
        const formData = new FormData(form);
        const url = mode === 'create'
            ? `${window.APP_CONFIG.baseUrl}/api/admin/users/create`
            : `${window.APP_CONFIG.baseUrl}/api/admin/users/update`;

        try {
            const response = await apiFetch(url, { method: 'POST', body: formData });
            if (response.success) {
                // Use imported function directly
                showToast(response.message, 'success');
                resetForm();
                loadUsers(); // Reload table and selects
            }
             // Error handled by apiFetch
        } catch (error) { /* Handled by apiFetch */ }
    });

    tableBody.addEventListener('click', async (e) => {
        const target = e.target;
        const row = target.closest('tr');
        if (!row) return;

        const id = row.dataset.id;
        let user;
        try {
            user = JSON.parse(row.dataset.user);
        } catch(e) {
            console.error("Could not parse user data from row:", row.dataset.user);
            return;
        }


        if (target.classList.contains('edit-user')) {
            form.dataset.mode = 'update';
            formTitle.textContent = 'Benutzer bearbeiten';
            cancelBtn.style.display = 'inline-block';
            passwordInput.removeAttribute('required');
            passwordInput.parentElement.querySelector('label').textContent = 'Neues Passwort';


            // Populate form
            userIdInput.value = user.user_id;
            form.querySelector('#username').value = user.username;
            form.querySelector('#email').value = user.email;
            form.querySelector('#first_name').value = user.first_name;
            form.querySelector('#last_name').value = user.last_name;
            form.querySelector('#birth_date').value = user.birth_date;
            roleSelect.value = user.role;
            // Ensure selects are populated before setting value
            if (allData.classes) classSelect.value = user.class_id || '';
            if (allData.teachers) teacherSelect.value = user.teacher_id || '';
            
            // NEU: Setze den Status der Ban-Checkbox
            if (communityBanCheckbox) {
                communityBanCheckbox.checked = (user.is_community_banned == 1);
            }

            toggleRoleSpecificFields(); // Show/hide fields based on populated role
            form.querySelector('#username').focus(); // Focus first editable field
        }

        if (target.classList.contains('delete-user')) {
            // Use imported function directly
            if (await showConfirm('Benutzer löschen', `Sind Sie sicher, dass Sie ${user.first_name} ${user.last_name} löschen möchten?`)) {
                const formData = new FormData();
                formData.append('user_id', id);
                try {
                    const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/users/delete`, { method: 'POST', body: formData });
                    if (response.success) {
                        // Use imported function directly
                        showToast(response.message, 'success');
                        loadUsers(); // Reload table
                    }
                     // Error handled by apiFetch
                } catch (error) { /* Handled by apiFetch */ }
            }
        }
    });

    roleSelect.addEventListener('change', toggleRoleSpecificFields);
    cancelBtn.addEventListener('click', resetForm);

    loadUsers(); // Initial load
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-users.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\api-client.js ---
import { showToast } from './notifications.js'; // Import showToast

/**
 * Zentraler API-Client zum Senden von Anfragen an das Backend.
 * @param {string} url - Der API-Endpunkt (z.B. '/api/admin/users').
 * @param {object} options - Die Konfigurationsoptionen für den Fetch-Aufruf (z.B. method, body).
 * @returns {Promise<any>} - Ein Promise, das die JSON-Antwort des Servers zurückgibt.
 * @throws {Error} - Wirft einen Fehler bei Netzwerkproblemen oder wenn die API 'success: false' zurückgibt.
 */
export async function apiFetch(url, options = {}) {
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');

    const defaultHeaders = {
        'X-Requested-With': 'XMLHttpRequest',
    };

    // Füge das CSRF-Token zu allen POST-Anfragen hinzu, wenn es nicht FormData ist.
    // Bei FormData wird es im Body hinzugefügt.
    if (csrfToken && options.method === 'POST' && !(options.body instanceof FormData)) {
        defaultHeaders['X-CSRF-TOKEN'] = csrfToken;
    }
    // Für GET oder andere Methoden (falls CSRF im Header benötigt wird)
    // else if (csrfToken && options.method !== 'POST') { // Beispiel, anpassen falls nötig
    //     defaultHeaders['X-CSRF-TOKEN'] = csrfToken;
    // }


    // Content-Type nur setzen, wenn es kein FormData ist und einer vorhanden ist
    if (!(options.body instanceof FormData) && options.headers && options.headers['Content-Type']) {
         defaultHeaders['Content-Type'] = options.headers['Content-Type'];
    } else if (!(options.body instanceof FormData) && options.body && typeof options.body === 'string') {
        // Default auf application/json wenn body ein String ist (wahrscheinlich JSON.stringify)
         defaultHeaders['Content-Type'] = 'application/json';
    }


    const config = {
        ...options,
        headers: {
            ...defaultHeaders,
            // Überschreibe mit spezifischen Headern, außer Content-Type bei FormData
            ...(options.headers && !(options.body instanceof FormData) ? options.headers : {}),
        },
    };

    // Füge CSRF-Token zum FormData Body hinzu, falls nötig.
    if (config.body instanceof FormData && csrfToken && options.method === 'POST') {
        if (!config.body.has('_csrf_token')) {
            config.body.append('_csrf_token', csrfToken);
        }
    }


    try {
        const response = await fetch(url, config);

        // Zuerst den Text der Antwort abrufen
        const responseText = await response.text();

        if (!response.ok) {
            // Server hat einen HTTP-Fehlerstatus zurückgegeben (z.B. 400, 403, 500)
            let errorMessage = `Serverfehler: ${response.status}`;
            // Versuchen, eine JSON-Fehlermeldung aus dem Text zu parsen
            try {
                const errorData = JSON.parse(responseText);
                errorMessage = errorData.message || errorMessage;
            } catch (e) {
                // Der Text war kein JSON (z.B. eine HTML-Fehlerseite), verwende den Status-Text
                errorMessage = `Serverfehler: ${response.status} (${response.statusText})`;
                // Bei 404 eine spezifischere Meldung
                if (response.status === 404) {
                    errorMessage = `API-Endpunkt nicht gefunden (404): ${url}`;
                }
            }
            
            // Spezifische Behandlung für 403 CSRF Fehler
            if (response.status === 403 && (errorMessage.includes('CSRF') || errorMessage.includes('Sicherheit') || responseText.includes('CSRF'))) {
                throw new Error("Sicherheitsüberprüfung fehlgeschlagen. Bitte laden Sie die Seite neu und versuchen Sie es erneut.");
            }
            throw new Error(errorMessage);
        }

        // Response war OK (2xx), jetzt versuchen wir zu parsen
        let data;
        try {
            data = JSON.parse(responseText);
        } catch (e) {
            // Response war 200 OK, aber der Body war KEIN JSON
            // (Sehr wahrscheinlich ein PHP-Notice/Warning)
            console.error("API-Antwort war kein gültiges JSON:", responseText);
            throw new Error(`Ungültige JSON-Antwort vom Server erhalten. (Möglicherweise ein PHP-Fehler). Antwort-Anfang: ${responseText.substring(0, 100)}...`);
        }


        if (data.success === false) {
            // Die API meldet einen Anwendungsfehler (z.B. ungültige Eingabe)
            throw new Error(data.message || 'Ein unbekannter Anwendungsfehler ist aufgetreten.');
        }

        return data;

    } catch (error) {
        // Zeigt dem Benutzer eine Fehlermeldung an und leitet den Fehler weiter
        console.error('API Fehler:', error);
        // Verwende die importierte Funktion direkt
        showToast(error.message, 'error');

        // Wirft den Fehler erneut, damit aufrufende try/catch-Blöcke darauf reagieren können
        throw error;
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\api-client.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard-community.js ---
// public/assets/js/dashboard-community.js
import { apiFetch } from './api-client.js';
import { showToast } from './notifications.js';
import { escapeHtml } from './planer-utils.js';

/**
 * Initialisiert die Funktionen des Schwarzen Bretts im Dashboard.
 */
export function initializeDashboardCommunity() {
    const section = document.getElementById('section-community-board');
    if (!section) return;

    const form = document.getElementById('community-post-form');
    const titleInput = document.getElementById('post-title');
    const contentInput = document.getElementById('post-content');
    const createButton = document.getElementById('create-post-btn');
    const postSpinner = document.getElementById('post-create-spinner');
    const postListContainer = document.getElementById('community-posts-list');
    
    let hasLoaded = false; // Status-Flag, ob Daten schon geladen wurden

    // 1. Beiträge laden
    const loadCommunityPosts = async () => {
        // KORREKTUR: Nur laden, wenn noch nicht geladen
        if (hasLoaded) return; 
        
        hasLoaded = true; // Sofort als "Ladevorgang gestartet" markieren
        postListContainer.innerHTML = '<div class="loading-spinner"></div>';
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/posts`);
            if (response.success && response.data) {
                renderPosts(response.data);
            } else {
                throw new Error(response.message || 'Beiträge konnten nicht geladen werden.');
            }
        } catch (error) {
            console.error("Fehler beim Laden der Community-Beiträge:", error);
            postListContainer.innerHTML = `<p class="message error">${escapeHtml(error.message)}</p>`;
            hasLoaded = false; // Laden erneut erlauben, wenn es fehlgeschlagen ist
        }
    };

    // 2. Beiträge rendern
    const renderPosts = (posts) => {
        if (posts.length === 0) {
            postListContainer.innerHTML = '<p class="message info" style="margin: 0;">Keine Beiträge am Schwarzen Brett vorhanden.</p>';
            return;
        }

        postListContainer.innerHTML = posts.map(post => {
            const contentHtml = post.content_html || '<p><em>Kein Inhalt.</em></p>'; // Verwende vorgerendertes HTML
            const postDate = new Date(post.created_at).toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
            
            const authorName = `${escapeHtml(post.first_name)} ${escapeHtml(post.last_name[0])}.`;
            const emailLink = post.email 
                ? `(<a href="mailto:${escapeHtml(post.email)}" title="E-Mail an ${escapeHtml(post.first_name)}">${escapeHtml(post.username)}</a>)`
                : `(${escapeHtml(post.username)})`;

            return `
            <div class="community-post-item" data-id="${post.post_id}">
                <div class="post-header">
                    <strong class="post-title">${escapeHtml(post.title)}</strong>
                    <span class="post-meta">
                        Von: ${authorName} ${emailLink}
                        <br>
                        Am: ${postDate} Uhr
                    </span>
                </div>
                <div class="post-content-preview">
                    ${contentHtml}
                </div>
            </div>
            `;
        }).join('');
    };

    // 3. Formular-Handler
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        
        const title = titleInput.value.trim();
        const content = contentInput.value.trim();

        if (!title || !content) {
            showToast("Titel und Inhalt dürfen nicht leer sein.", "error");
            return;
        }

        createButton.disabled = true;
        postSpinner.style.display = 'block';

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/posts/create`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ title, content })
            });

            if (response.success) {
                showToast(response.message, 'success');
                form.reset(); // Formular leeren
                // Wenn der Beitrag sofort freigeschaltet wurde, Liste neu laden
                if (response.status === 'approved') {
                    hasLoaded = false; // Erzwinge Neuladen der Liste
                    loadCommunityPosts();
                }
            }
            // Fehler werden von apiFetch als Toast angezeigt
        } catch (error) {
            console.error("Fehler beim Erstellen des Beitrags:", error);
        } finally {
            createButton.disabled = false;
            postSpinner.style.display = 'none';
        }
    });

    // 4. KORRIGIERTES Laden (Lazy Loading)
    const tabButton = document.querySelector('.tab-button[data-target="section-community-board"]');
    
    if (tabButton) {
        // Diese Funktion wird *nur* auf den Klick hin ausgeführt.
        const loadOnVisible = () => {
            if (!hasLoaded) { // Lade nur, wenn noch nicht geladen
                loadCommunityPosts();
            }
        };

        // Beim Klick auf den Tab-Button (erneut) prüfen
        tabButton.addEventListener('click', loadOnVisible);

        // Prüfe beim Start NICHT, da "Mein Tag" der Standard-Tab ist.
        // Die Tab-Umschaltlogik in dashboard.js (die wir nicht sehen)
        // ändert die 'active'-Klasse, und dieser Klick-Listener
        // wird ausgelöst, WENN der Benutzer auf den Tab klickt.
        
    } else {
        // Fallback, falls die Tab-Logik fehlschlägt
        loadCommunityPosts();
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard-community.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard-my-posts.js ---
// public/assets/js/dashboard-my-posts.js
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js';
import { escapeHtml } from './planer-utils.js'; // Stellt sicher, dass diese Hilfsfunktion existiert

/**
 * Initialisiert die "Meine Beiträge"-Sektion im Dashboard.
 */
export function initializeMyCommunityPosts() {
    const section = document.getElementById('section-my-posts');
    if (!section) return;

    const postListContainer = document.getElementById('my-posts-list');
    const postModal = document.getElementById('my-post-edit-modal');
    const postForm = document.getElementById('my-post-edit-form');
    const postTitleInput = document.getElementById('edit-post-title');
    const postContentInput = document.getElementById('edit-post-content');
    const postIdInput = document.getElementById('edit-post-id');
    const postSpinner = document.getElementById('edit-post-spinner');
    const cancelEditBtn = document.getElementById('my-post-modal-cancel-btn');
    const closeEditBtn = document.getElementById('my-post-modal-close-btn');

    let hasLoaded = false;
    let isSaving = false;

    /**
     * Lädt die Beiträge des Benutzers.
     */
    const loadMyPosts = async () => {
        if (hasLoaded) return; // Nur einmal laden, es sei denn, es wird explizit neu geladen
        hasLoaded = true;

        if (!postListContainer) return;
        postListContainer.innerHTML = '<div class="loading-spinner"></div>';

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/my-posts`);
            if (response.success && response.data) {
                renderMyPosts(response.data);
            } else {
                throw new Error(response.message || 'Beiträge konnten nicht geladen werden.');
            }
        } catch (error) {
            console.error("Fehler beim Laden meiner Beiträge:", error);
            if (postListContainer) {
                postListContainer.innerHTML = `<p class="message error">${escapeHtml(error.message)}</p>`;
            }
            hasLoaded = false; // Erlaube erneutes Laden bei Fehler
        }
    };

    /**
     * Rendert die Liste der Beiträge.
     * @param {Array} posts - Array von Post-Objekten.
     */
    const renderMyPosts = (posts) => {
        if (!postListContainer) return;
        if (posts.length === 0) {
            postListContainer.innerHTML = '<p class="message info" style="margin: 0;">Du hast noch keine Beiträge erstellt.</p>';
            return;
        }

        // KORRIGIERTES STYLING (flexibel)
        postListContainer.innerHTML = posts.map(post => {
            const postDate = new Date(post.created_at).toLocaleString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }) + ' Uhr';
            const contentHtml = post.content_html || '<p><em>Kein Inhalt.</em></p>';
            
            let statusClass = '';
            let statusText = '';
            switch (post.status) {
                case 'pending':
                    statusClass = 'status-pending';
                    statusText = 'Ausstehend';
                    break;
                case 'approved':
                    statusClass = 'status-approved';
                    statusText = 'Genehmigt';
                    break;
                case 'rejected':
                    statusClass = 'status-rejected';
                    statusText = 'Abgelehnt';
                    break;
            }

            return `
                <div class="community-post-item my-post-item" data-id="${post.post_id}" data-title="${escapeHtml(post.title)}" data-content="${escapeHtml(post.content)}">
                    <div class="post-content-preview">
                        <strong class="post-title">${escapeHtml(post.title)}</strong>
                        ${contentHtml}
                    </div>
                    <div class="my-post-meta">
                        <div class="post-status">
                            <span>Erstellt am: ${postDate}</span>
                            <span class="status-badge ${statusClass}">${statusText}</span>
                        </div>
                        <div class="post-actions">
                            <button class="btn btn-secondary btn-small edit-my-post-btn">Bearbeiten</button>
                            <button class="btn btn-danger btn-small delete-my-post-btn">Löschen</button>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    };

    /**
     * Öffnet das Bearbeiten-Modal und füllt es.
     * @param {HTMLElement} postItem - Das angeklickte Beitrags-Element.
     */
    const openEditModal = (postItem) => {
        if (!postModal) return;
        
        // Daten aus data-Attributen holen (sicherer gegen XSS als innerHTML)
        const id = postItem.dataset.id;
        const title = postItem.dataset.title;
        const content = postItem.dataset.content; // Roh-Markdown holen

        postIdInput.value = id;
        postTitleInput.value = title;
        postContentInput.value = content;
        
        postModal.classList.add('visible');
        postTitleInput.focus();
    };

    /**
     * Schließt das Bearbeiten-Modal.
     */
    const closeEditModal = () => {
        if (postModal) {
            postModal.classList.remove('visible');
            postForm.reset();
            postIdInput.value = '';
            postSpinner.style.display = 'none';
            postForm.querySelector('button[type="submit"]').disabled = false;
        }
    };

    /**
     * Behandelt das Speichern (Aktualisieren) eines Beitrags.
     * @param {Event} e - Das Submit-Event.
     */
    const handleUpdatePost = async (e) => {
        e.preventDefault();
        if (isSaving) return;

        const id = postIdInput.value;
        const title = postTitleInput.value.trim();
        const content = postContentInput.value.trim();

        if (!id || !title || !content) {
            showToast("Titel und Inhalt dürfen nicht leer sein.", "error");
            return;
        }

        isSaving = true;
        postSpinner.style.display = 'block';
        postForm.querySelector('button[type="submit"]').disabled = true;

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/post/update`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ post_id: id, title: title, content: content })
            });

            if (response.success) {
                showToast(response.message, 'success');
                closeEditModal();
                hasLoaded = false; // Erzwinge Neuladen der Liste, um Status zu aktualisieren
                loadMyPosts();
            }
            // Fehler wird von apiFetch als Toast angezeigt
        } catch (error) {
            console.error("Fehler beim Aktualisieren des Beitrags:", error);
            // Fehler-Toast wird bereits von apiFetch angezeigt
        } finally {
            isSaving = false;
            postSpinner.style.display = 'none';
            // Button wird im closeEditModal() wieder aktiviert
        }
    };

    /**
     * Behandelt das Löschen eines Beitrags.
     * @param {HTMLElement} postItem - Das Beitrags-Element.
     */
    const handleDeletePost = async (postItem) => {
        const id = postItem.dataset.id;
        const title = postItem.dataset.title;

        if (await showConfirm("Beitrag löschen", `Möchtest du deinen Beitrag "${escapeHtml(title)}" wirklich endgültig löschen?`)) {
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/post/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ post_id: id })
                });

                if (response.success) {
                    showToast(response.message, 'success');
                    // Beitrag aus der Liste entfernen
                    postItem.style.transition = 'opacity 0.3s ease, height 0.3s ease, margin 0.3s ease, padding 0.3s ease';
                    postItem.style.opacity = '0';
                    postItem.style.height = '0px';
                    postItem.style.paddingTop = '0';
                    postItem.style.paddingBottom = '0';
                    postItem.style.margin = '0';
                    setTimeout(() => {
                        postItem.remove();
                        if (postListContainer.childElementCount === 0) {
                            renderMyPosts([]);
                        }
                    }, 300);
                }
                // Fehler wird von apiFetch angezeigt
            } catch (error) {
                console.error("Fehler beim Löschen des Beitrags:", error);
            }
        }
    };

    // --- Event Listeners ---

    // Event Delegation für Bearbeiten- und Löschen-Buttons
    postListContainer.addEventListener('click', (e) => {
        const editButton = e.target.closest('.edit-my-post-btn');
        const deleteButton = e.target.closest('.delete-my-post-btn');
        
        if (editButton) {
            const postItem = editButton.closest('.my-post-item');
            if (postItem) openEditModal(postItem);
            return;
        }
        
        if (deleteButton) {
            const postItem = deleteButton.closest('.my-post-item');
            if (postItem) handleDeletePost(postItem);
            return;
        }
    });

    // Formular-Speichern
    if (postForm) {
        postForm.addEventListener('submit', handleUpdatePost);
    }

    // Modal schließen
    if (cancelEditBtn) {
        cancelEditBtn.addEventListener('click', closeEditModal);
    }
    if (closeEditBtn) {
        closeEditBtn.addEventListener('click', closeEditModal);
    }
    if (postModal) {
        postModal.addEventListener('click', (e) => {
            if (e.target.id === 'my-post-edit-modal') {
                closeEditModal();
            }
        });
    }

    // Tab-Lazy-Loading (wird von dashboard.js gesteuert)
    const tabButton = document.querySelector('.tab-button[data-target="section-my-posts"]');
    if (tabButton) {
        const loadOnVisible = () => {
            if (section.classList.contains('active') && !hasLoaded) {
                loadMyPosts();
            }
        };
        // Beim Klick auf den Tab (wird von dashboard.js gehandhabt)
        tabButton.addEventListener('click', loadOnVisible);
        // Beim Initial-Load (falls der Tab bereits aktiv ist, obwohl das nicht der Standard sein sollte)
        if (section.classList.contains('active')) {
            loadOnVisible();
        }
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard-my-posts.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard.js ---
// public/assets/js/dashboard.js
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js';
import { escapeHtml } from './planer-utils.js';
// NEU: Importiere die Lazy-Loading-Funktion für "Meine Beiträge"
import { initializeMyCommunityPosts } from './dashboard-my-posts.js';


/**
 * Helper function to get week and year for a date according to ISO 8601.
 * @param {Date} date - The date object.
 * @returns {{week: number, year: number}} - Calendar week and year.
 */
function getWeekAndYear(date) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    return { week: weekNo, year: d.getUTCFullYear() };
}

/**
 * Gets the date of the Monday of a given calendar week and year.
 * @param {number} week - The calendar week.
 * @param {number} year - The year.
 * @returns {Date} The Date object for Monday (local time).
*/
function getDateOfISOWeek(week, year) {
    const simple = new Date(Date.UTC(year, 0, 1 + (week - 1) * 7));
    const dow = simple.getUTCDay();
    const ISOweekStart = simple;
    ISOweekStart.setUTCDate(simple.getUTCDate() - (dow || 7) + 1);
    return new Date(ISOweekStart.getUTCFullYear(), ISOweekStart.getUTCMonth(), ISOweekStart.getUTCDate());
}

/**
 * Formats a time slot index (1-based) into HH:MM (start time).
 * @param {number} period - The period number (1 to 10).
 * @returns {string} Formatted time string like "08:00".
 */
function formatTimeSlot(period) {
    const times = [
        "08:00", "08:55", "09:40", "10:35", "11:20",
        "13:05", "13:50", "14:45", "15:30", "16:25"
    ];
    return times[period - 1] || '??:??';
}

/**
 * Formats a YYYY-MM-DD Datum in ein lesbares deutsches Format.
 * @param {string} dateString - YYYY-MM-DD
 * @returns {string} TT.MM.YYYY
 */
function formatGermanDate(dateString) {
    if (!dateString) return '';
    try {
        const parts = dateString.split('-');
        if (parts.length === 3) {
            return `${parts[2]}.${parts[1]}.${parts[0]}`;
        }
        return dateString;
    } catch(e) {
        return dateString;
    }
}
/**
 * Formatiert HH:MM:SS zu HH:MM.
 * @param {string} timeString - HH:MM:SS
 * @returns {string} HH:MM
 */
function formatShortTime(timeString) {
    if (!timeString) return '';
    const parts = timeString.split(':');
    if (parts.length >= 2) {
        return `${parts[0]}:${parts[1]}`;
    }
    return timeString;
}

// NEU: Globaler State für Dashboard-Daten (Stammdaten, Pläne)
const dashboardState = {
    stammdaten: null,
    currentTimetable: [],
    currentSubstitutions: [],
    studentNotes: {}, // NEU: Objekt für Notizen
    currentPublishStatus: { student: false, teacher: false }
    // currentViewMode, selectedClassId, etc. werden in planer-state.js verwaltet,
    // aber wir brauchen sie hier nicht, da das Dashboard seine eigene Logik hat.
};

// --- Module-Level Constants (MOVED HERE) ---
const days = ["Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag"];
const timeSlotsDisplay = [
     "08:00 - 08:45", "08:55 - 09:40", "09:40 - 10:25", "10:35 - 11:20",
     "11:20 - 12:05", "13:05 - 13:50", "13:50 - 14:35", "14:45 - 15:30",
     "15:30 - 16:15", "16:25 - 17:10"
];
// --- Module-Level DOM Elements & Constants (MOVED HERE) ---
const userRole = window.APP_CONFIG.userRole;
const today = new Date();
const todayDateString = today.toISOString().split('T')[0];
const todayDayOfWeek = (today.getDay() === 0) ? 7 : today.getDay(); // 1=Mo

// --- DOM Elements (defined at module scope) ---
const yearSelector = document.getElementById('year-selector');
const weekSelector = document.getElementById('week-selector');
const planHeaderInfo = document.getElementById('plan-header-info');
const timetableContainer = document.getElementById('timetable-container');
const announcementsList = document.getElementById('announcements-list');
const todayScheduleContainer = document.getElementById('today-schedule-container');
const icalUrlInput = document.getElementById('ical-url');
const copyIcalUrlButton = document.getElementById('copy-ical-url');
const pdfButton = document.getElementById('export-pdf-btn');
const printableSection = document.getElementById('weekly-timetable-section-printable');
const detailModal = document.getElementById('plan-detail-modal');
const detailCloseBtn = document.getElementById('plan-detail-close-btn');
const noteRow = document.getElementById('detail-notes-row');
const noteInput = document.getElementById('detail-notes-input');
const noteSaveBtn = document.getElementById('plan-detail-save-note-btn');
const noteSpinner = document.getElementById('note-save-spinner');

/**
 * Loads and renders announcements into the sidebar, now using content_html.
 */
const loadAnnouncements = async () => {
    if (!announcementsList) return;
    announcementsList.innerHTML = '<div class="loading-spinner"></div>';
    try {
        const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/announcements`);
        if (response.success && response.data) {
            if (response.data.length === 0) {
                announcementsList.innerHTML = '<p class="message info" style="padding: 20px; margin: 0; text-align: center;">Keine aktuellen Ankündigungen.</p>';
                return;
            }
            announcementsList.style.padding = '0';
            announcementsList.innerHTML = response.data.map(item => {
                let targetInfo = '';
                let visibilityText = item.is_global ? 'Global' : 'Klasse';
                let badgeClass = item.is_global ? 'global' : 'class';
                if (!item.is_global && item.target_class_name) {
                    targetInfo = ` (Klasse: ${escapeHtml(item.target_class_name)})`;
                }

                const attachmentLink = item.file_url
                    ? `<p class="announcement-attachment"><a href="${escapeHtml(item.file_url)}" target="_blank" download>📎 Anhang herunterladen</a></p>`
                    : '';

                const contentHtml = item.content_html || '<p><em>Kein Inhalt.</em></p>';

                return `
                <div class="announcement-item">
                    <div class="announcement-header">
                        <div class="announcement-title-meta">
                            <strong>${escapeHtml(item.title)}</strong> <small>Von ${escapeHtml(item.author_name)}${targetInfo} • ${new Date(item.created_at).toLocaleDateString('de-DE')}</small>
                        </div>
                        <span class="announcement-badge ${badgeClass}">${visibilityText}</span>
                    </div>
                    <div class="announcement-content"> ${contentHtml} </div>
                    ${attachmentLink}
                </div>
                `;
            }).join('');
        } else {
            throw new Error(response.message || "Ankündigungen konnten nicht geladen werden.");
        }
    } catch (error) {
        console.error("Announcement loading error:", error);
        announcementsList.innerHTML = `<p class="message error" style="margin: 20px;">${error.message || 'Ankündigungen konnten nicht geladen werden.'}</p>`;
    }
};

/**
 * Populates year and week selector dropdowns.
 */
const populateSelectors = () => {
    if (!yearSelector || !weekSelector) return; 
    const currentYear = new Date().getFullYear();
    let yearOptions = '';
    for (let i = currentYear - 1; i <= currentYear + 1; i++) {
        yearOptions += `<option value="${i}">${i}</option>`;
    }
    yearSelector.innerHTML = yearOptions;

    let weekOptions = '';
    for (let i = 1; i <= 53; i++) {
        weekOptions += `<option value="${i}">KW ${i}</option>`;
    }
    weekSelector.innerHTML = weekOptions;

    const { week, year } = getWeekAndYear(today);
    yearSelector.value = year;
    weekSelector.value = week;
};

/**
 * Loads all data for the selected week and renders both weekly and daily views.
 */
const loadAndRenderWeeklyData = async () => {
    if (!yearSelector || !weekSelector) return; 
    
    const year = yearSelector.value;
    const week = weekSelector.value;

    timetableContainer.innerHTML = '<div class="loading-spinner"></div>';
    if (todayScheduleContainer) {
        todayScheduleContainer.innerHTML = '<div class="loading-spinner small"></div>';
    }

    const monday = getDateOfISOWeek(Number(week), Number(year));
    const friday = new Date(monday.getTime() + 4 * 24 * 60 * 60 * 1000);
    planHeaderInfo.textContent = `Stundenplan für die ${week}. Kalenderwoche (${monday.toLocaleDateString('de-DE')} - ${friday.toLocaleDateString('de-DE')})`;

    let timetable = [];
    let substitutions = [];
    let academicEvents = [];
    let appointments = [];
    let studentNotes = {}; // NEU: Notizen hier empfangen

    try {
        // --- Schritt 1: Plandaten & Termine (Kritisch) ---
        const planUrl = `${window.APP_CONFIG.baseUrl}/api/dashboard/weekly-data?year=${year}&week=${week}`;
        const planResponse = await apiFetch(planUrl);
        
        if (!planResponse.success || !planResponse.data) {
            throw new Error(planResponse.message || "Plandaten konnten nicht geladen werden.");
        }

        timetable = planResponse.data.timetable || [];
        substitutions = planResponse.data.substitutions || [];
        appointments = planResponse.data.appointments || [];
        studentNotes = (userRole === 'schueler') ? (planResponse.data.studentNotes || {}) : {}; // NEU

        
        // NEU: Daten im globalen State speichern
        dashboardState.currentTimetable = timetable;
        dashboardState.currentSubstitutions = substitutions;
        dashboardState.studentNotes = studentNotes; // NEU

        // --- Schritt 2: Wochenplan sofort rendern ---
        renderWeeklyTimetable(timetable, substitutions, studentNotes); // NEU: Notizen übergeben

        // --- Schritt 3: Events (Zusätzlich, nur für Schüler) ---
        if (userRole === 'schueler') {
            try {
                const eventsUrl = `${window.APP_CONFIG.baseUrl}/api/student/events?year=${year}&week=${week}`;
                const eventsResponse = await apiFetch(eventsUrl);
                if (eventsResponse.success && eventsResponse.data) {
                    academicEvents = eventsResponse.data;
                } else {
                    console.warn("Zusatz-Events (Aufgaben/Klausuren) konnten nicht geladen werden:", eventsResponse.message || "Unbekannter Fehler");
                }
            } catch (eventError) {
                console.error("Fehler beim Laden der Events:", eventError);
            }
        }

        // --- Schritt 4: "Mein Tag" rendern (mit Plandaten, Events UND Terminen) ---
        renderTodaySchedule(timetable, substitutions, academicEvents, appointments, studentNotes); // NEU: Notizen übergeben

    } catch (error) { 
        console.error("Fehler beim Laden der Wochendaten (kritisch):", error);
        timetableContainer.innerHTML = `<p class="message error">${error.message || 'Der Wochenplan konnte nicht geladen werden.'}</p>`;
        if (todayScheduleContainer) {
            todayScheduleContainer.innerHTML = `<p class="message error small">Heutiger Plan nicht verfügbar.</p>`;
        }
    }
};

/**
 * Extracts and renders today's schedule into the "Mein Tag" container.
 */
const renderTodaySchedule = (weeklyTimetable, weeklySubstitutions, academicEvents, appointments, studentNotes) => {
    if (!todayScheduleContainer) return;

    const currentDayNum = todayDayOfWeek;
    if (currentDayNum < 1 || currentDayNum > 5) {
        todayScheduleContainer.innerHTML = '<p class="message info" style="padding: 10px; margin: 0;">Heute ist kein Schultag. Genieße die freie Zeit! 🎉</p>';
        return;
    }

    // A. Ermittle die aktuelle Zeit in HHMM (z.B. 1030 für 10:30)
    const PERIOD_END_TIMES = [
        845, 940, 1025, 1120, 1205, // Vormittag
        1350, 1435, 1530, 1615, 1710  // Nachmittag (basierend auf Standard-Definition)
    ];
    const now = new Date();
    // Hole die Zeit in der korrekten Zeitzone (Europe/Berlin)
    const timeFormatter = new Intl.DateTimeFormat('de-DE', {
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'Europe/Berlin', 
        hour12: false
    });
    const parts = timeFormatter.format(now).split(':'); // z.B. ["11", "21"]
    const currentHHMM = parseInt(parts[0], 10) * 100 + parseInt(parts[1], 10); // z.B. 1121


    const todaysEntries = weeklyTimetable.filter(entry => entry.day_of_week == currentDayNum);
    const todaysSubstitutions = weeklySubstitutions.filter(sub => sub.date === todayDateString);
    const todaysEvents = (academicEvents || []).filter(event => event.due_date === todayDateString);
    const todaysAppointments = (appointments || []).filter(app => app.appointment_date === todayDateString);

    let combinedSchedule = [];

    // 1. Reguläre Einträge und Vertretungen
    for (let period = 1; period <= timeSlotsDisplay.length; period++) {
        const periodEndTime = PERIOD_END_TIMES[period - 1]; // z.B. 845

        // *** NEUE FILTERLOGIK: Überspringe, wenn die Stunde vorbei ist ***
        if (currentHHMM > periodEndTime) {
            continue; 
        }
        // *** ENDE NEUE LOGIK ***

        const substitution = todaysSubstitutions.find(sub => sub.period_number === period);
        const regularEntry = todaysEntries.find(entry => entry.period_number === period);
        const noteKey = `${todayDayOfWeek}-${period}`; // NEU
        const note = studentNotes[noteKey] || ''; // NEU

        if (substitution) {
            combinedSchedule.push({
                sortKey: period * 10,
                period: period,
                time: formatTimeSlot(period),
                type: substitution.substitution_type,
                id: substitution.substitution_id, // ID für ICS-Link (Sonderevent)
                subject: substitution.new_subject_shortcut || regularEntry?.subject_shortcut || (substitution.substitution_type === 'Sonderevent' ? 'EVENT' : '---'),
                mainText: substitution.substitution_type === 'Vertretung'
                    ? (userRole === 'teacher' ? (substitution.class_name || regularEntry?.class_name) : substitution.new_teacher_shortcut)
                    : (substitution.substitution_type === 'Entfall' ? '' : (regularEntry ? (userRole === 'schueler' ? regularEntry.teacher_shortcut : regularEntry.class_name) : '')),
                room: substitution.new_room_name || regularEntry?.room_name || '',
                comment: substitution.comment || '',
                note: note, // NEU
                icsType: (substitution.substitution_type === 'Sonderevent') ? 'sub' : null // ICS-Typ für Sonderevent
            });
        } else if (regularEntry) {
            combinedSchedule.push({
                sortKey: period * 10,
                period: period,
                time: formatTimeSlot(period),
                type: 'regular',
                id: regularEntry.entry_id,
                subject: regularEntry.subject_shortcut || '---',
                mainText: userRole === 'schueler' ? regularEntry.teacher_shortcut : regularEntry.class_name,
                room: regularEntry.room_name || '---',
                comment: regularEntry.comment || '',
                note: note, // NEU
                icsType: null
            });
        }
    }
    
    // 2. Klausuren/Aufgaben (Ganztägig - werden immer angezeigt)
    todaysEvents.forEach(event => {
        combinedSchedule.push({
            sortKey: 1, // Ganztägig, an den Anfang
            time: 'Ganztägig',
            type: event.event_type,
            subject: event.title,
            mainText: event.subject_shortcut || (userRole === 'schueler' ? `${event.teacher_first_name} ${event.teacher_last_name}` : ''),
            room: '',
            comment: event.description || '',
            note: '', // NEU (Keine Notizen für Events)
            id: event.event_id, // ID für ICS-Link
            icsType: 'acad' // Typ für ICS-Link
        });
    });

    // 3. Sprechstunden (Termine)
    todaysAppointments.forEach(app => {
        const appTime = formatShortTime(app.appointment_time);
        const sortKeyTime = parseInt(appTime.replace(':', ''), 10); // z.B. 1400

        // *** NEUE FILTERLOGIK für Termine (Sprechstunden) ***
        const timeParts = app.appointment_time.split(':'); // "14:00:00"
        const duration = parseInt(app.duration, 10) || 15; // z.B. 15
        
        if (timeParts.length >= 2) {
            const startH = parseInt(timeParts[0], 10);
            const startM = parseInt(timeParts[1], 10);
            
            // Simuliere das Enddatum
            const endM = startM + duration; // z.B. 0 + 15 = 15
            const endH = startH + Math.floor(endM / 60); // z.B. 14 + 0 = 14
            const finalEndM = endM % 60; // z.B. 15
            
            const endHHMM = (endH * 100) + finalEndM; // z.B. 1400 + 15 = 1415

            if (currentHHMM > endHHMM) {
                return; // Dieser Termin ist vorbei, überspringe ihn
            }
        }
        // *** ENDE NEUE LOGIK ***

        combinedSchedule.push({
            sortKey: sortKeyTime,
            time: appTime,
            type: 'appointment',
            subject: userRole === 'schueler' ? `Sprechstunde (${escapeHtml(app.teacher_shortcut || app.teacher_name)})` : `Sprechstunde (${escapeHtml(app.student_name)})`,
            mainText: userRole === 'lehrer' ? (app.class_name ? `Klasse: ${escapeHtml(app.class_name)}` : 'Schüler') : '',
            room: 'Sprechzimmer',
            comment: app.notes || '',
            note: '', // NEU (Keine Notizen für Termine)
            id: app.appointment_id,
            icsType: null 
        });
    });

    combinedSchedule.sort((a, b) => a.sortKey - b.sortKey);

    if (combinedSchedule.length === 0) {
        todayScheduleContainer.innerHTML = '<p class="message info" style="padding: 10px; margin: 0;">Für heute sind keine Einträge (mehr) vorhanden.</p>';
        return;
    }

    // SVG-Icon für den Kalender-Download
    const icsIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M14 0H2a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2M2 1a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v1H2zM14 15H2a1 1 0 0 1-1-1V5h14v9a1 1 0 0 1-1 1M9 7.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5zM6.5 9a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5m-3 2a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5z"/></svg>`;
    // NEU: SVG-Icon für Notiz
    const noteIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 0A1.5 1.5 0 0 0 0 1.5V13a1 1 0 0 0 1 1V1.5a.5.5 0 0 1 .5-.5H14a1 1 0 0 0-1-1zM3.5 2A1.5 1.5 0 0 0 2 3.5v11A1.5 1.5 0 0 0 3.5 16h9a1.5 1.5 0 0 0 1.5-1.5v-11A1.5 1.5 0 0 0 12.5 2zM3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5z"/></svg>`;


    todayScheduleContainer.innerHTML = combinedSchedule.map(item => {
        const typeClass = `type-${item.type.replace(' ', '')}`;
        
        // NEU: Kombiniere Kommentar und Notiz
        let commentHtml = '';
        if (item.comment) {
            commentHtml += `<small class="entry-comment" title="${escapeHtml(item.comment)}">📝 ${escapeHtml(item.comment)}</small>`;
        }
        if (item.note) {
            commentHtml += `<small class="entry-note" title="${escapeHtml(item.note)}">${noteIcon} ${escapeHtml(item.note)}</small>`;
        }

        
        let detailsHtml = `<strong>${escapeHtml(item.subject)}</strong>`;
        if(item.mainText && item.type !== 'Entfall') detailsHtml += `<span>${escapeHtml(item.mainText)}</span>`;
        if(item.room && item.type !== 'Entfall') detailsHtml += `<span>${escapeHtml(item.room)}</span>`;

        let actionButton = '';
        if (item.type === 'appointment') {
            actionButton = `<button class="btn btn-danger btn-small cancel-appointment-btn" data-id="${item.id}" title="Termin stornieren">&times;</button>`;
        }

        let icsButtonHtml = '';
        if (item.icsType === 'acad') { // Für Aufgaben, Klausuren, Infos
            const icsUrl = `${window.APP_CONFIG.baseUrl}/ics/event/acad/${item.id}`;
            icsButtonHtml = `<a href="${icsUrl}" class="btn-ics" title="Zum Kalender hinzufügen">${icsIcon}</a>`;
        } else if (item.icsType === 'sub') { // Für Sonderevents
            const icsUrl = `${window.APP_CONFIG.baseUrl}/ics/event/sub/${item.id}`;
            icsButtonHtml = `<a href="${icsUrl}" class="btn-ics" title="Zum Kalender hinzufügen">${icsIcon}</a>`;
        }

        return `
        <div class="today-entry ${typeClass}">
            <div class="time">${escapeHtml(item.time)}</div>
            <div class="details">
                ${detailsHtml}
                ${commentHtml}
            </div>
            <div class="entry-actions">
                <span class="type-badge ${typeClass}">${item.type === 'regular' ? 'Plan' : (item.type === 'klausur' ? 'Klausur' : (item.type === 'aufgabe' ? 'Aufgabe' : (item.type === 'info' ? 'Info' : (item.type === 'appointment' ? 'Termin' : item.type))))}</span>
                ${icsButtonHtml}
                ${actionButton}
            </div>
        </div>
        `;
    }).join('');

    todayScheduleContainer.querySelectorAll('.cancel-appointment-btn').forEach(btn => {
        btn.addEventListener('click', handleCancelAppointment);
    });
};

/**
 * Renders the weekly timetable grid.
 */
const renderWeeklyTimetable = (weeklyTimetableData, allWeeklySubstitutions, studentNotes) => {
    const processedCellKeys = new Set();
    const blockSpans = new Map();

    // 1. Reguläre Blöcke
    const blocks = new Map();
    weeklyTimetableData.forEach(entry => {
        if (entry.block_id) {
            if (!blocks.has(entry.block_id)) blocks.set(entry.block_id, []);
            blocks.get(entry.block_id).push(entry);
        }
    });
    blocks.forEach(entries => {
        if (entries.length === 0) return;
        entries.sort((a, b) => a.period_number - b.period_number);
        const startEntry = entries[0];
        const span = entries[entries.length - 1].period_number - startEntry.period_number + 1;
        blockSpans.set(`${startEntry.day_of_week}-${startEntry.period_number}`, span);
        for (let i = 1; i < span; i++) {
            processedCellKeys.add(`${startEntry.day_of_week}-${startEntry.period_number + i}`);
        }
    });

    // 2. Vertretungs-Blöcke
    const substitutionBlocks = new Map();
    allWeeklySubstitutions.forEach(sub => {
        if (!sub.day_of_week) return;
        const key = `${sub.date}-${sub.class_id}-${sub.substitution_type}-${sub.comment || ''}-${sub.new_room_id || ''}-${sub.new_teacher_id || ''}-${sub.new_subject_id || ''}`;
        if (!substitutionBlocks.has(key)) substitutionBlocks.set(key, []);
        substitutionBlocks.get(key).push(sub);
    });
    substitutionBlocks.forEach(subs => {
        if (subs.length > 1) { 
            subs.sort((a, b) => a.period_number - b.period_number);
            let isConsecutive = true;
            for (let i = 0; i < subs.length - 1; i++) {
                if (subs[i + 1].period_number !== subs[i].period_number + 1) {
                    isConsecutive = false; break;
                }
            }
            if (isConsecutive) { 
                const startSub = subs[0];
                const span = subs.length;
                const dayNum = startSub.day_of_week;
                if (dayNum) {
                    blockSpans.set(`${dayNum}-${startSub.period_number}`, span);
                    for (let i = 1; i < span; i++) {
                        processedCellKeys.add(`${dayNum}-${startSub.period_number + i}`);
                    }
                }
            }
        }
    });

    // 3. Grid HTML rendern
    let gridHTML = '<div class="timetable-grid">';
    gridHTML += '<div class="grid-header">Zeit</div>';
    days.forEach(day => gridHTML += `<div class="grid-header">${day}</div>`);

    const settings = window.APP_CONFIG.settings || {};
    const startHour = parseInt(settings.default_start_hour, 10) || 1;
    const endHour = parseInt(settings.default_end_hour, 10) || 10;

    timeSlotsDisplay.forEach((slot, index) => {
        const period = index + 1;
        gridHTML += `<div class="grid-header period-header">${slot}</div>`;

        days.forEach((day, dayIndex) => {
            const dayNum = dayIndex + 1; // 1=Mon, ..., 5=Fri
            const cellKey = `${dayNum}-${period}`;
            const noteKey = cellKey; // NEU

            if (processedCellKeys.has(cellKey)) { return; }

            let cellContent = '', cellClass = 'empty', dataAttrs = `data-day="${dayNum}" data-period="${period}"`, style = '';
            const span = blockSpans.get(cellKey);
            if (span) {
                style = `grid-row: span ${span};`;
                cellClass += ' block-start';
            }

            const substitution = allWeeklySubstitutions.find(s => s.day_of_week == dayNum && s.period_number == period);
            const entryToRender = weeklyTimetableData.find(e => e.day_of_week == dayNum && e.period_number == period);
            const note = (userRole === 'schueler' && studentNotes[noteKey]) ? studentNotes[noteKey] : null; // NEU

            dataAttrs = `data-day="${dayNum}" data-period="${period}"`; // Basis-Attribute

            if (substitution) {
                cellClass = `has-entry substitution-${substitution.substitution_type}`;
                dataAttrs += ` data-substitution-id="${substitution.substitution_id}"`;
                if (substitution.comment) dataAttrs += ` data-comment="${escapeHtml(substitution.comment)}"`;
                const regularEntry = entryToRender; 
                if(regularEntry) { // Füge reguläre IDs hinzu, falls vorhanden
                    dataAttrs += ` data-entry-id="${regularEntry.entry_id}"`;
                    if (regularEntry.block_id) dataAttrs += ` data-block-id="${regularEntry.block_id}"`;
                }
                dataAttrs += ` data-class-id="${substitution.class_id}"`; 
                cellContent = createCellEntryHtml(
                    substitution.substitution_type === 'Vertretung'
                        ? (substitution.new_subject_shortcut || regularEntry?.subject_shortcut)
                        : (substitution.substitution_type === 'Sonderevent' ? 'EVENT' : regularEntry?.subject_shortcut),
                    substitution.substitution_type === 'Vertretung'
                        ? (userRole === 'teacher' ? (substitution.class_name || regularEntry?.class_name) : substitution.new_teacher_shortcut)
                        : (substitution.substitution_type === 'Entfall' ? 'Entfällt' : (regularEntry ? (userRole === 'schueler' ? regularEntry.teacher_shortcut : regularEntry.class_name) : '---')),
                    substitution.new_room_name || regularEntry?.room_name,
                    substitution.comment, 
                    substitution.substitution_type,
                    note // NEU
                );
            } else if (entryToRender) {
                cellClass = 'has-entry';
                dataAttrs += ` data-entry-id="${entryToRender.entry_id}"`;
                dataAttrs += ` data-class-id="${entryToRender.class_id}"`;
                if (entryToRender.block_id) dataAttrs += ` data-block-id="${entryToRender.block_id}"`;
                const mainText = userRole === 'schueler' ? entryToRender.teacher_shortcut : entryToRender.class_name;
                cellContent += createCellEntryHtml(entryToRender.subject_shortcut, mainText, entryToRender.room_name, entryToRender.comment, null, note); // NEU
            } else if (period >= startHour && period <= endHour) {
                // KORREKTUR: Logik für FU
                if (period === startHour || period === endHour) {
                    cellClass = 'default-entry';
                    cellContent = createCellEntryHtml('FU', 'Förderunterricht', '', ''); // FU anzeigen
                } else {
                    // Bleibt leer (cellClass = 'empty')
                }
            } else {
                // Außerhalb des Rasters (z.B. Stunde 11, 12)
                // Bleibt leer (cellClass = 'empty')
            }
            
            // NEU: Füge Notiz-Indikator hinzu, wenn Notiz vorhanden ist
            if (note) {
                cellClass += ' has-note';
            }

            gridHTML += `<div class="grid-cell ${cellClass}" ${dataAttrs} style="${style}">${cellContent}</div>`;
        });
    });

    gridHTML += '</div>';
    timetableContainer.innerHTML = gridHTML;
};

/**
 * Helper to create HTML content for a single cell entry.
 */
const createCellEntryHtml = (subject, mainText, room, comment = null, substitutionType = null, note = null) => {
    let commentHtml = comment ? `<small class="entry-comment" title="${escapeHtml(comment)}">📝 ${escapeHtml(comment.substring(0, 15))}${comment.length > 15 ? '...' : ''}</small>` : '';
    let roomHtml = room ? `<small class="entry-room">${escapeHtml(room)}</small>` : '';
    let mainHtml = mainText ? `<span>${escapeHtml(mainText)}</span>` : '';
    let subjectHtml = subject ? `<strong>${escapeHtml(subject)}</strong>` : '';
    // NEU: Notiz-Icon (SVG)
    const noteIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 0A1.5 1.5 0 0 0 0 1.5V13a1 1 0 0 0 1 1V1.5a.5.5 0 0 1 .5-.5H14a1 1 0 0 0-1-1zM3.5 2A1.5 1.5 0 0 0 2 3.5v11A1.5 1.5 0 0 0 3.5 16h9a1.5 1.5 0 0 0 1.5-1.5v-11A1.5 1.5 0 0 0 12.5 2zM3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5z"/></svg>`;
    let noteHtml = (note && userRole === 'schueler') ? `<small class="entry-note" title="${escapeHtml(note)}">${noteIcon}</small>` : '';


    if (substitutionType === 'Entfall') {
        subjectHtml = `<strong>${escapeHtml(subject)}</strong>`;
        mainHtml = `<span>Entfällt</span>`;
        roomHtml = '';
        commentHtml = comment ? `<small class="entry-comment" title="${escapeHtml(comment)}">📝 ${escapeHtml(comment.substring(0, 15))}${comment.length > 15 ? '...' : ''}</small>` : '';
    }
    if (substitutionType === 'Raumänderung') {
        roomHtml = room ? `<small class="entry-room" style="font-weight:bold; color: var(--color-warning);">${escapeHtml(room)}</small>` : '';
    }
    if (substitutionType === 'Sonderevent') {
        subjectHtml = `<strong>EVENT</strong>`;
        const safeComment = escapeHtml(comment);
        mainHtml = safeComment ? `<span title="${safeComment}">${safeComment.substring(0, 20)}${safeComment.length > 20 ? '...' : ''}</span>` : `<span>Sonderveranst.</span>`;
        commentHtml = '';
    }

    // NEU: Setze Notiz-Icon in die Zelle
    return `<div class="cell-entry">${noteHtml}${subjectHtml}${mainHtml}${roomHtml}${commentHtml}</div>`;
};

/** Function to handle PDF export by redirecting to server */
const handlePdfExport = () => {
    const year = yearSelector.value;
    const week = weekSelector.value;
    if (!year || !week) {
        showToast("Bitte Jahr und KW auswählen.", 'error');
        return;
    }
    const pdfUrl = `${window.APP_CONFIG.baseUrl}/pdf/timetable/${year}/${week}`;
    window.open(pdfUrl, '_blank');
};

/** Storniert einen Termin */
const handleCancelAppointment = async (e) => {
    const button = e.target.closest('.cancel-appointment-btn');
    if (!button) return;
    
    const appointmentId = button.dataset.id;
    const entryElement = button.closest('.today-entry');
    const title = entryElement.querySelector('.details strong').textContent;

    if (await showConfirm("Termin stornieren", `Möchten Sie den Termin "${escapeHtml(title)}" wirklich stornieren?`)) {
        button.disabled = true;
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/appointment/cancel`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ appointment_id: appointmentId })
            });

            if (response.success) {
                showToast(response.message, 'success');
                entryElement.style.transition = 'opacity 0.3s ease, height 0.3s ease, margin 0.3s ease, padding 0.3s ease';
                entryElement.style.opacity = '0';
                entryElement.style.height = '0px';
                entryElement.style.paddingTop = '0';
                entryElement.style.paddingBottom = '0';
                entryElement.style.margin = '0';
                setTimeout(() => {
                    entryElement.remove();
                    if (todayScheduleContainer && todayScheduleContainer.childElementCount === 0) {
                        renderTodaySchedule([], [], [], [], {});
                    }
                }, 300);
            }
        } catch (error) {
            console.error("Fehler beim Stornieren:", error);
            button.disabled = false;
        }
    }
};


export function initializeDashboard() {
    const container = document.querySelector('.dashboard-wrapper');
    if (!container) return;
    
    // Lade Stammdaten sofort
    dashboardState.stammdaten = window.APP_CONFIG.settings.stammdaten || {
        subjects: [], teachers: [], rooms: [], classes: []
    };

    // --- Event Listeners ---
    if (yearSelector) yearSelector.addEventListener('change', loadAndRenderWeeklyData);
    if (weekSelector) weekSelector.addEventListener('change', loadAndRenderWeeklyData);
    if (pdfButton) pdfButton.addEventListener('click', handlePdfExport);

    if (copyIcalUrlButton && icalUrlInput) {
        copyIcalUrlButton.addEventListener('click', async () => {
            try {
                icalUrlInput.select();
                icalUrlInput.setSelectionRange(0, 99999);
                let copied = false;
                try { copied = document.execCommand('copy'); } catch(err) { copied = false; }
                if (copied) {
                    showToast('iCal URL in Zwischenablage kopiert!', 'success', 2000);
                } else if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(icalUrlInput.value);
                    showToast('iCal URL in Zwischenablage kopiert!', 'success', 2000);
                } else {
                    throw new Error('Copy command failed and Clipboard API not available.');
                }
            } catch (err) {
                console.error('Fehler beim Kopieren der iCal URL: ', err);
                showToast('Kopieren fehlgeschlagen. Bitte manuell kopieren.', 'error');
            }
            if (window.getSelection) { window.getSelection().removeAllRanges(); }
            else if (document.selection) { document.selection.empty(); }
            icalUrlInput.blur();
        });
    }

    // --- Tab-Interface Initialisierung ---
    initializeTabbedInterface();

    // --- Initialisierung des Sprechstunden-Widgets (nur für Schüler) ---
    if (userRole === 'schueler') {
        initializeAppointmentBooking();
    }
    
    // --- NEU: Event-Listener für Wochenplan-Detail-Modal ---
    initializePlanDetailModal(timetableContainer, detailModal, detailCloseBtn, noteRow, noteInput, noteSaveBtn, noteSpinner);

    // --- Initialization ---
    populateSelectors();
    loadAndRenderWeeklyData(); // Lädt "Mein Tag" und "Wochenplan"
    loadAnnouncements(); // Lädt Ankündigungen

    // Hide elements for admin if applicable
    if(userRole === 'admin') {
        const printExportActions = document.querySelector('.print-export-actions');
        if(printExportActions) printExportActions.style.display = 'none';
        const icalBox = document.querySelector('.ical-subscription-box');
        if(icalBox) icalBox.style.display = 'none';
    }
}


/**
 * Initialisiert das Sprechstunden-Buchungs-Widget für Schüler.
 */
function initializeAppointmentBooking() {
    const widget = document.getElementById('appointment-booking-widget');
    if (!widget) return;

    const form = document.getElementById('appointment-booking-form');
    const teacherSearchInput = document.getElementById('teacher-search-input');
    const teacherSearchResults = document.getElementById('teacher-search-results');
    const selectedTeacherIdInput = document.getElementById('selected-teacher-id');
    const datePicker = document.getElementById('appointment-date-picker');
    const slotsContainer = document.getElementById('available-slots-container');
    const notesContainer = document.getElementById('appointment-notes-container');
    const notesInput = document.getElementById('appointment-notes');
    const bookButton = document.getElementById('book-appointment-btn');
    const bookSpinner = document.getElementById('appointment-book-spinner');

    let searchTimeout;
    let selectedSlot = null; 

    datePicker.min = new Date().toISOString().split('T')[0];

    // --- 1. Lehrer-Suche ---
    teacherSearchInput.addEventListener('input', () => {
        clearTimeout(searchTimeout);
        resetSlotSelection();
        datePicker.disabled = true;
        datePicker.value = '';
        selectedTeacherIdInput.value = '';

        const query = teacherSearchInput.value.trim();
        if (query.length < 2) {
            teacherSearchResults.innerHTML = '';
            teacherSearchResults.classList.remove('visible');
            return;
        }

        searchTimeout = setTimeout(async () => {
            try {
                // KORREKTUR: API-Endpunkt angepasst (search-colleagues statt -teachers)
                // KORREKTUR: Sende die Stammdaten-ID (teacher_id), nicht die user_id
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/search-colleagues?query=${encodeURIComponent(query)}`);
                if (response.success && response.data) {
                    const filteredTeachers = response.data.filter(t => t.teacher_shortcut !== 'SGL');
                    if (filteredTeachers.length > 0) {
                        teacherSearchResults.innerHTML = filteredTeachers.map(teacher => {
                            // KORREKTUR: Verwende teacher.teacher_id (Stammdaten-ID)
                            return `
                                <div class="search-result-item" data-id="${teacher.teacher_id}" data-name="${escapeHtml(teacher.first_name)} ${escapeHtml(teacher.last_name)} (${escapeHtml(teacher.teacher_shortcut)})">
                                    <strong>${escapeHtml(teacher.last_name)}, ${escapeHtml(teacher.first_name)}</strong> (${escapeHtml(teacher.teacher_shortcut)})
                                </div>
                            `;
                        }).join('');
                        teacherSearchResults.classList.add('visible');
                    } else {
                        teacherSearchResults.innerHTML = '<div class="search-result-item none">Keine Treffer</div>';
                        teacherSearchResults.classList.add('visible');
                    }
                } else {
                    teacherSearchResults.innerHTML = '<div class="search-result-item none">Keine Treffer</div>';
                    teacherSearchResults.classList.add('visible');
                }
            } catch (error) {
                console.error("Fehler bei Lehrersuche:", error);
                teacherSearchResults.innerHTML = `<div class="search-result-item none">Fehler: ${escapeHtml(error.message)}</div>`;
                teacherSearchResults.classList.add('visible');
            }
        }, 300);
    });

    // --- 2. Lehrer-Auswahl ---
    teacherSearchResults.addEventListener('click', (e) => {
        const item = e.target.closest('.search-result-item');
        if (!item || !item.dataset.id) return;

        selectedTeacherIdInput.value = item.dataset.id; // Speichert die teacher_id (Stammdaten)
        teacherSearchInput.value = item.dataset.name;
        teacherSearchResults.innerHTML = '';
        teacherSearchResults.classList.remove('visible');
        
        datePicker.disabled = false;
        datePicker.focus();
    });

    // --- 3. Datums-Auswahl (lädt Slots) ---
    datePicker.addEventListener('change', async () => {
        resetSlotSelection();
        const teacherId = selectedTeacherIdInput.value; // Dies ist die teacher_id (Stammdaten)
        const date = datePicker.value;

        if (!teacherId || !date) return;
        
        const dayOfWeek = new Date(date + 'T00:00:00').getDay();
        if (dayOfWeek === 0 || dayOfWeek === 6) {
            slotsContainer.innerHTML = '<small class="form-hint error-hint">Sprechstunden finden nur Mo-Fr statt.</small>';
            return;
        }

        slotsContainer.innerHTML = '<div class="loading-spinner small"></div>';
        
        try {
            // KORREKTUR: Sendet teacher_id (Stammdaten-ID)
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/student/available-slots?teacher_id=${teacherId}&date=${date}`);
            if (response.success && response.data) {
                if (response.data.length > 0) {
                    slotsContainer.innerHTML = response.data.map(slot => `
                        <button type="button" class="btn-slot" data-time="${slot.time}" data-duration="${slot.duration}">
                            ${escapeHtml(slot.display)}
                        </button>
                    `).join('');
                } else {
                    slotsContainer.innerHTML = '<small class="form-hint">Keine freien Termine an diesem Tag.</small>';
                }
            } else {
                throw new Error(response.message || 'Fehler beim Laden der Slots.');
            }
        } catch (error) {
            slotsContainer.innerHTML = `<small class="form-hint error-hint">${escapeHtml(error.message)}</small>`;
        }
    });

    // --- 4. Slot-Auswahl ---
    slotsContainer.addEventListener('click', (e) => {
        const button = e.target.closest('.btn-slot');
        if (!button) return;

        slotsContainer.querySelectorAll('.btn-slot').forEach(btn => btn.classList.remove('selected'));
        
        button.classList.add('selected');
        selectedSlot = {
            time: button.dataset.time,
            duration: button.dataset.duration
        };
        
        notesContainer.style.display = 'block';
        bookButton.disabled = false;
    });
    
    const resetSlotSelection = () => {
        selectedSlot = null;
        slotsContainer.innerHTML = '<small class="form-hint">Bitte Lehrer und Datum wählen.</small>';
        notesContainer.style.display = 'none';
        if (notesInput) notesInput.value = '';
        if (bookButton) bookButton.disabled = true;
    };

    // --- 5. Buchen ---
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (!selectedSlot || !selectedTeacherIdInput.value || !datePicker.value) {
            showToast("Bitte Lehrer, Datum und einen Slot auswählen.", "error");
            return;
        }

        bookButton.disabled = true;
        bookSpinner.style.display = 'block';

        const body = {
            // KORREKTUR: Sendet teacher_id (Stammdaten-ID)
            teacher_id: selectedTeacherIdInput.value,
            date: datePicker.value,
            time: selectedSlot.time,
            duration: selectedSlot.duration,
            notes: notesInput.value.trim() || null
        };
        
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/student/book-appointment`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            if (response.success) {
                showToast(response.message, 'success');
                form.reset();
                selectedTeacherIdInput.value = '';
                datePicker.disabled = true;
                resetSlotSelection();
                loadAndRenderWeeklyData(); // Lädt "Mein Tag" neu
            }
        } catch (error) {
             console.error("Fehler beim Buchen:", error);
             if (error.message.includes('gebu')) {
                 datePicker.dispatchEvent(new Event('change')); // Löst Neuladen der Slots aus
             }
        } finally {
            bookButton.disabled = false;
            bookSpinner.style.display = 'none';
        }
    });

    document.addEventListener('click', (e) => {
        if (widget && !widget.contains(e.target)) {
            teacherSearchResults.classList.remove('visible');
        }
    });
}

/**
 * NEU: Initialisiert das Tab-Interface.
 */
function initializeTabbedInterface() {
    const wrapper = document.querySelector('.dashboard-wrapper');
    if (!wrapper) return;
    const tabContainer = wrapper.querySelector('.tab-navigation');
    const contentContainer = wrapper.querySelector('.tab-content');
    if (!tabContainer || !contentContainer) return;

    const tabButtons = tabContainer.querySelectorAll('.tab-button');
    const tabContents = contentContainer.querySelectorAll('.dashboard-section');

    // Tabs, die bereits initial geladen werden
    const loadedTabs = {
        'section-my-day': true,
        'section-weekly-plan': true,
        'section-announcements': true,
    };


    tabContainer.addEventListener('click', (e) => {
        const clickedButton = e.target.closest('.tab-button');
        if (!clickedButton || clickedButton.classList.contains('active')) return;
        
        tabButtons.forEach(btn => btn.classList.remove('active'));
        tabContents.forEach(content => content.classList.remove('active'));

        clickedButton.classList.add('active');
        const targetId = clickedButton.dataset.target;
        const targetContent = document.getElementById(targetId);

        if (targetContent) {
            targetContent.classList.add('active');
            
            // Prüfen, ob der Tab-Inhalt "lazy loaded" werden muss
            if (!loadedTabs[targetId]) {
                // Lazy loading für Community Board (Schüler)
                if (targetId === 'section-community-board') {
                    if (window.initializeDashboardCommunity) {
                        window.initializeDashboardCommunity();
                    }
                }
                // NEU: Lazy loading für "Meine Beiträge" (Schüler)
                else if (targetId === 'section-my-posts') {
                    if (initializeMyCommunityPosts) { // Verwende die importierte Funktion
                        initializeMyCommunityPosts();
                    }
                }
                // Lazy loading für Lehrer-Tabs
                else if (targetId === 'section-attendance' || targetId === 'section-events' || targetId === 'section-office-hours' || targetId === 'section-colleague-search') {
                     if (window.initializeTeacherCockpit) {
                         // Diese Funktion initialisiert ALLE Lehrer-Tabs beim ersten Klick auf einen von ihnen
                         window.initializeTeacherCockpit(); 
                         // Markiere alle Lehrer-Tabs als geladen, um Mehrfach-Initialisierung zu vermeiden
                         loadedTabs['section-attendance'] = true;
                         loadedTabs['section-events'] = true;
                         loadedTabs['section-office-hours'] = true;
                         loadedTabs['section-colleague-search'] = true;
                     }
                }
                
                loadedTabs[targetId] = true; // Markiere diesen Tab als geladen
            }
        }
    });
}

/**
 * NEU: Initialisiert das Modal für die Stundendetails.
 */
function initializePlanDetailModal(timetableContainer, modal, closeBtn, noteRow, noteInput, noteSaveBtn, noteSpinner) {
    if (!timetableContainer || !modal || !closeBtn) {
        console.warn("Detail-Modal-Initialisierung übersprungen: Elemente fehlen.", {timetableContainer, modal, closeBtn});
        return;
    }

    const state = {
        currentSlotKey: null, // z.B. "1-2" (day-period)
        isSaving: false
    };

    const close = () => modal.classList.remove('visible');

    closeBtn.addEventListener('click', close);
    modal.addEventListener('click', (e) => {
        if (e.target.id === 'plan-detail-modal') {
            close();
        }
    });

    // Event-Listener am Haupt-Grid-Container (nur für den Wochenplan-Tab)
    timetableContainer.addEventListener('click', (e) => {
        const cell = e.target.closest('.grid-cell.has-entry');
        if (!cell || e.target.closest('a') || cell.classList.contains('dragging')) {
            return;
        }
        
        // Daten aus dem globalen State holen
        const { stammdaten, currentTimetable, currentSubstitutions, studentNotes } = dashboardState;
        
        // IDs aus der Zelle extrahieren
        const day = cell.dataset.day;
        const period = cell.dataset.period;
        const entryId = cell.dataset.entryId;
        const blockId = cell.dataset.blockId;
        const substitutionId = cell.dataset.substitutionId;

        state.currentSlotKey = `${day}-${period}`; // Speichere den Slot für das Speichern der Notiz

        let data = {}; // Hier sammeln wir die Infos
        let status = "Regulär";
        let statusClass = "status-regular";

        let entry = null;
        if (blockId) {
            entry = currentTimetable.find(e => e.block_id === blockId && e.day_of_week == day);
        } else if (entryId) {
            entry = currentTimetable.find(e => e.entry_id == entryId);
        }
        
        let substitution = substitutionId ? currentSubstitutions.find(s => s.substitution_id == substitutionId) : null;

        if (substitution) {
            const regularEntry = entry; 
            status = substitution.substitution_type;
            statusClass = `status-${substitution.substitution_type.toLowerCase()}`;
            
            data.subject = substitution.new_subject_shortcut || regularEntry?.subject_shortcut || 'N/A';
            data.teacher = substitution.new_teacher_shortcut || (userRole === 'schueler' ? regularEntry?.teacher_shortcut : null) || 'N/A';
            data.room = substitution.new_room_name || regularEntry?.room_name || 'N/A';
            data.class = substitution.class_name || regularEntry?.class_name || 'N/A';
            data.comment = substitution.comment || regularEntry?.comment || '';
        
        } else if (entry) { // Regulärer Eintrag
            status = "Regulär";
            statusClass = "status-regular";
            data.subject = entry.subject_shortcut;
            data.teacher = entry.teacher_shortcut;
            data.room = entry.room_name;
            data.class = entry.class_name;
            data.comment = entry.comment || '';
        } else {
            return; // Nichts zu anzeigen (FU oder leer)
        }

        // Fülle das Modal
        document.getElementById('detail-status').textContent = status;
        document.getElementById('detail-status').className = `detail-value ${statusClass}`;
        
        // Zeit-Logik (prüft auf Block)
        // KORREKTUR: Verwende die globale Variable 'timeSlotsDisplay'
        const span = blockId ? (currentTimetable.filter(e => e.block_id === blockId).length) : 1;
        let timeText;
        if (span > 1) {
            const startPeriod = parseInt(period);
            const endPeriod = startPeriod + span - 1;
            const startTime = formatTimeSlot(startPeriod);
            const endTime = timeSlotsDisplay[endPeriod - 1]?.split(' - ')[1] || '??:??'; // KORRIGIERT
            timeText = `${days[day-1]}, ${startPeriod}. - ${endPeriod}. Stunde (${startTime} - ${endTime})`; // KORRIGIERT
        } else {
            timeText = `${days[day-1]}, ${period}. Stunde (${timeSlotsDisplay[period-1]})`; // KORRIGIERT
        }
        document.getElementById('detail-time').textContent = timeText;
        
        // Volle Namen aus Stammdaten holen (falls vorhanden)
        const subjectFull = stammdaten.subjects?.find(s => s.subject_shortcut === data.subject)?.subject_name || data.subject;
        const teacherFull = stammdaten.teachers?.find(t => t.teacher_shortcut === data.teacher);
        const teacherName = teacherFull ? `${teacherFull.first_name} ${teacherFull.last_name} (${teacherFull.teacher_shortcut})` : (data.teacher || 'N/A');
        
        document.getElementById('detail-subject').textContent = subjectFull || 'N/A';
        
        const teacherRow = document.getElementById('detail-teacher');
        const classRow = document.getElementById('detail-class');
        
        if (userRole === 'schueler' && teacherRow) {
            teacherRow.textContent = teacherName;
        } else if (userRole === 'lehrer' && classRow) {
            classRow.textContent = data.class || 'N/A';
        }
        document.getElementById('detail-room').textContent = data.room || 'N/A';

        const commentRow = document.getElementById('detail-comment-row');
        if (data.comment) {
            document.getElementById('detail-comment').textContent = data.comment;
            commentRow.style.display = 'flex';
        } else {
            commentRow.style.display = 'none';
        }

        // NEU: Notiz-Logik für Schüler
        if (userRole === 'schueler' && noteRow && noteInput) {
            const noteKey = state.currentSlotKey;
            const currentNote = studentNotes[noteKey] || '';
            noteInput.value = currentNote;
            noteRow.style.display = 'flex'; // Mache die Notiz-Sektion sichtbar
            if(noteSaveBtn) noteSaveBtn.disabled = false;
            if(noteSpinner) noteSpinner.style.display = 'none';
        }

        modal.classList.add('visible');
    });

    // NEU: Event-Listener für Notiz-Speichern (nur für Schüler)
    if (userRole === 'schueler' && noteSaveBtn && noteInput && noteSpinner) {
        noteSaveBtn.addEventListener('click', async () => {
            if (state.isSaving || !state.currentSlotKey) return;
            state.isSaving = true;
            noteSaveBtn.disabled = true;
            noteSpinner.style.display = 'inline-block';

            const [day, period] = state.currentSlotKey.split('-');
            const year = yearSelector.value;
            const week = weekSelector.value;
            const content = noteInput.value.trim();

            const body = {
                year: parseInt(year),
                calendar_week: parseInt(week),
                day_of_week: parseInt(day),
                period_number: parseInt(period),
                note_content: content
            };

            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/student/note/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                if (response.success) {
                    showToast('Notiz gespeichert!', 'success');
                    // Aktualisiere den globalen Notiz-State
                    if (content) {
                        dashboardState.studentNotes[state.currentSlotKey] = content;
                    } else {
                        delete dashboardState.studentNotes[state.currentSlotKey];
                    }
                    // Rendere die Grids neu, um Notiz-Indikatoren zu aktualisieren
                    renderWeeklyTimetable(dashboardState.currentTimetable, dashboardState.currentSubstitutions, dashboardState.studentNotes);
                    renderTodaySchedule(dashboardState.currentTimetable, dashboardState.currentSubstitutions, [], [], dashboardState.studentNotes); // TODO: Events/Appointments müssten hier neu geladen oder übergeben werden
                    close(); // Schließe das Modal nach dem Speichern
                }
                // Fehler wird von apiFetch als Toast angezeigt
            } catch (error) {
                console.error("Fehler beim Speichern der Notiz:", error);
            } finally {
                state.isSaving = false;
                noteSaveBtn.disabled = false;
                noteSpinner.style.display = 'none';
            }
        });
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\footer-ui.js ---
// public/assets/js/footer-ui.js

/**
 * Initializes footer UI interactions: Imprint toggle.
 */
export function initializeFooterUi() {
    const imprintToggle = document.getElementById('imprint-toggle');
    const imprintDetails = document.getElementById('imprint-details');
    const imprintClose = document.getElementById('imprint-close');

    if (imprintToggle && imprintDetails && imprintClose) {
        const toggleImprint = (show) => {
            if (show) {
                imprintDetails.classList.add('visible');
                imprintToggle.setAttribute('aria-expanded', 'true');
            } else {
                imprintDetails.classList.remove('visible');
                imprintToggle.setAttribute('aria-expanded', 'false');
            }
        };

        imprintToggle.addEventListener('click', () => {
            const isVisible = imprintDetails.classList.contains('visible');
            toggleImprint(!isVisible);
        });

        imprintClose.addEventListener('click', () => {
            toggleImprint(false);
        });

        // Optional: Close imprint when clicking outside of it
        document.addEventListener('click', (event) => {
            if (imprintDetails.classList.contains('visible') &&
                !imprintDetails.contains(event.target) &&
                event.target !== imprintToggle) {
                toggleImprint(false);
            }
        });

         // Optional: Close imprint with Escape key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && imprintDetails.classList.contains('visible')) {
                toggleImprint(false);
            }
        });
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\footer-ui.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\header-ui.js ---
// public/assets/js/header-ui.js

/**
 * Applies the selected theme (light/dark) to the document.
 * @param {string} theme - 'light' or 'dark'.
 */
function applyTheme(theme) {
    if (theme === 'dark') {
        document.documentElement.classList.add('dark-mode');
        // Update toggle button if it exists (might run before button is ready)
        const toggle = document.getElementById('theme-toggle');
        if (toggle) {
             toggle.setAttribute('aria-pressed', 'true'); // Indicate dark mode is active
        }
    } else {
        document.documentElement.classList.remove('dark-mode');
        // Update toggle button if it exists
        const toggle = document.getElementById('theme-toggle');
         if (toggle) {
             toggle.setAttribute('aria-pressed', 'false'); // Indicate light mode is active
        }
    }
}


/**
 * Initializes header UI interactions: mobile menu toggle, user dropdown, and theme toggle.
 */
export function initializeHeaderUi() {
    const header = document.querySelector('.page-header');
    if (!header) return;

    // --- Theme Toggle Handling ---
    const themeToggle = document.getElementById('theme-toggle');
    if (themeToggle) {
        // Set initial state of the button based on current theme (already applied by inline script)
        const currentTheme = document.documentElement.classList.contains('dark-mode') ? 'dark' : 'light';
        themeToggle.setAttribute('aria-pressed', currentTheme === 'dark');


        themeToggle.addEventListener('click', () => {
            const currentIsDark = document.documentElement.classList.contains('dark-mode');
            const newTheme = currentIsDark ? 'light' : 'dark';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
             // Update aria-pressed state after applying theme
             themeToggle.setAttribute('aria-pressed', newTheme === 'dark');
        });
    }


    // --- Mobile Menu Handling ---
    const mobileToggle = document.getElementById('mobile-menu-toggle');
    const headerNav = document.getElementById('header-nav');

    if (mobileToggle && headerNav) {

        const closeMobileMenu = () => {
            mobileToggle.classList.remove('is-open');
            headerNav.classList.remove('is-open');
            document.body.classList.remove('menu-open'); // Allow scrolling again
            mobileToggle.setAttribute('aria-expanded', 'false');
        };

        mobileToggle.addEventListener('click', () => {
            const isOpen = headerNav.classList.contains('is-open');
            if (isOpen) {
                closeMobileMenu();
            } else {
                mobileToggle.classList.add('is-open');
                headerNav.classList.add('is-open');
                document.body.classList.add('menu-open'); // Prevent scrolling
                mobileToggle.setAttribute('aria-expanded', 'true');
            }
        });

        // Close mobile menu when a navigation link inside it is clicked
        headerNav.addEventListener('click', (e) => {
            // Check if the clicked element or its parent is a link within the nav
            if (e.target.closest('a')) {
                // Check if the screen width is mobile (where the overlay is active)
                if (window.innerWidth < 769) {
                     closeMobileMenu();
                }
            }
        });
    }

    // --- User Dropdown Handling (Desktop) ---
    const userMenu = header.querySelector('.user-menu');
    // Add a check to prevent re-initializing if script runs multiple times
    if (userMenu && !userMenu.dataset.menuInitialized) {
        const toggleButton = userMenu.querySelector('.user-menu-toggle');
        const dropdown = userMenu.querySelector('.user-menu-dropdown');

        if (toggleButton && dropdown) {
            toggleButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent document click listener from closing it immediately
                const isOpen = dropdown.classList.toggle('is-open');
                toggleButton.setAttribute('aria-expanded', isOpen);
            });

            // Close dropdown if clicking outside of it
            document.addEventListener('click', (e) => {
                // Check if the click was outside the user menu and the dropdown is open
                if (!userMenu.contains(e.target) && dropdown.classList.contains('is-open')) {
                    dropdown.classList.remove('is-open');
                    toggleButton.setAttribute('aria-expanded', 'false');
                }
            });

            // Close dropdown if a link inside it is clicked
            dropdown.addEventListener('click', (e) => {
                if (e.target.closest('a')) {
                     dropdown.classList.remove('is-open');
                     toggleButton.setAttribute('aria-expanded', 'false');
                }
            });

            userMenu.dataset.menuInitialized = 'true'; // Mark as initialized
        }
    }
}

// Apply initial theme on script load (redundant with inline script but safe)
// const initialTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
// applyTheme(initialTheme);
// Removed this as the inline script in header.php handles the initial, flash-preventing application.
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\header-ui.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\main.js ---
// public/assets/js/main.js

// Importiere globale UI-Handler
import { showToast, showConfirm } from './notifications.js'; // Stellt sicher, dass showToast/showConfirm global registriert werden
import { initializeHeaderUi } from './header-ui.js';
import { initializeFooterUi } from './footer-ui.js'; // Import footer UI

// Importiere seiten-spezifische Initialisierer
import { initializeAdminStammdaten } from './admin-stammdaten.js';
import { initializeAdminUsers } from './admin-users.js';
import { initializeAdminAnnouncements } from './admin-announcements.js';
import { initializePlanerDashboard } from './planer-dashboard.js';
import { initializeDashboard } from './dashboard.js';
import { initializeAdminAuditLogs } from './admin-audit-log.js'; 
import { initializeAdminSettings } from './admin-settings.js'; 
import { initializeTeacherCockpit } from './teacher-cockpit.js';
import { initializeAdminCommunity } from './admin-community.js';
import { initializeDashboardCommunity } from './dashboard-community.js';
// NEU: Import für "Meine Beiträge"
import { initializeMyCommunityPosts } from './dashboard-my-posts.js';
// NEU: Import für "Abwesenheiten"
import { initializePlanerAbsences } from './planer-absences.js';


console.log("main.js: Skript gestartet.");

/**
 * Führt alle seiten-spezifischen JavaScript-Module aus.
 * Prüft anhand von IDs im DOM, welche Module geladen werden sollen.
 */
function runContentInitializers() {
    console.log("main.js: Führe Inhalts-Initialisierer aus...");

    // Admin: Stammdaten
    if(document.getElementById('stammdaten-management')) {
        console.log("main.js: Initialisiere Admin Stammdaten...");
        initializeAdminStammdaten();
    }
    // Admin: Benutzerverwaltung
    if(document.getElementById('user-management')) {
        console.log("main.js: Initialisiere Admin Benutzer...");
        initializeAdminUsers();
    }
    // Admin: Ankündigungen
    if(document.getElementById('announcements-management')) {
        console.log("main.js: Initialisiere Admin Ankündigungen...");
        initializeAdminAnnouncements();
    }
    // Planer: Dashboard
    if(document.querySelector('.planer-dashboard-wrapper') && document.getElementById('timetable-container')) { // Spezifischer auf Dashboard
        console.log("main.js: Initialisiere Planer Dashboard...");
        initializePlanerDashboard();
    }
    // NEU: Planer: Abwesenheiten
    if(document.getElementById('absence-management')) {
        console.log("main.js: Initialisiere Planer Abwesenheiten...");
        initializePlanerAbsences();
    }
    // Schüler/Lehrer: Dashboard
    if(document.querySelector('.dashboard-wrapper')) {
        console.log("main.js: Initialisiere (Schüler/Lehrer) Dashboard...");
        initializeDashboard();
    }
    // Admin: Audit Logs
    if(document.getElementById('audit-log-management')) {
        console.log("main.js: Initialisiere Admin Audit Logs...");
        initializeAdminAuditLogs();
    }
    // Admin: Settings
    if(document.getElementById('settings-management')) {
        console.log("main.js: Initialisiere Admin Einstellungen...");
        initializeAdminSettings();
    }
    
    // Lehrer-Cockpit (wird auf der Dashboard-Seite geladen)
    // Die Logik in dashboard.js (initializeTabbedInterface) ruft dies verzögert auf
    // if(document.getElementById('teacher-cockpit')) {
    //     console.log("main.js: Initialisiere Lehrer-Cockpit...");
    //     initializeTeacherCockpit();
    // }

    // Admin Community Moderation
    if(document.getElementById('community-moderation')) {
        console.log("main.js: Initialisiere Admin Community Moderation...");
        initializeAdminCommunity();
    }
    
    // Dashboard Community Board (Schüler)
    // Wird verzögert von dashboard.js -> initializeTabbedInterface aufgerufen
    // if(document.getElementById('section-community-board')) {
    //     console.log("main.js: Initialisiere Dashboard Community Board...");
    //     initializeDashboardCommunity();
    // }

    // NEU: Dashboard "Meine Beiträge" (Schüler)
    // Wird verzögert von dashboard.js -> initializeTabbedInterface aufgerufen
    // if(document.getElementById('section-my-posts')) {
    //     console.log("main.js: Initialisiere Dashboard Meine Beiträge...");
    //     initializeMyCommunityPosts();
    // }


    console.log("main.js: Inhalts-Initialisierer abgeschlossen.");
}

/**
 * Führt globale UI-Initialisierer aus (Header, Footer, etc.)
 */
function runGlobalInitializers() {
    console.log("main.js: Führe globale Initialisierer aus...");
    initializeHeaderUi(); // Initialize the header interactions
    initializeFooterUi(); // Initialize the footer interactions
    // Future global initializers will go here
    console.log("main.js: Globale Initialisierer abgeschlossen.");
}


// Startet die Anwendung, sobald das DOM geladen ist.
document.addEventListener('DOMContentLoaded', () => {
    console.log("main.js: DOMContentLoaded Event ausgelöst.");
    runGlobalInitializers();
    runContentInitializers();
    console.log("main.js: Alle Initialisierungen nach DOMContentLoaded abgeschlossen.");
});

// NEU: Mache die Lazy-Loading-Funktionen global verfügbar,
// damit sie von dashboard.js aufgerufen werden können.
// (Bessere Methode wäre, dashboard.js auch modular zu importieren, aber das würde dashboard.js ändern)
window.initializeDashboardCommunity = initializeDashboardCommunity;
window.initializeMyCommunityPosts = initializeMyCommunityPosts;
window.initializeTeacherCockpit = initializeTeacherCockpit;


console.log("main.js: Skript-Ende erreicht.");


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\main.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\notifications.js ---
/**
 * Erstellt und zeigt eine Toast-Benachrichtigung an.
 * @param {string} message - Die anzuzeigende Nachricht.
 * @param {'success'|'error'|'info'} type - Der Typ der Benachrichtigung.
 * @param {number} duration - Wie lange der Toast sichtbar bleibt (in ms).
 */
export function showToast(message, type = 'info', duration = 3000) {
    // Alten Toast entfernen, falls vorhanden
    const oldToast = document.querySelector('.toast-notification');
    if (oldToast) {
        oldToast.remove();
    }

    const toast = document.createElement('div');
    toast.className = `toast-notification toast-${type}`;
    toast.textContent = message;

    document.body.appendChild(toast);

    // Animation starten
    setTimeout(() => {
        toast.classList.add('visible');
    }, 10); // Kleiner Delay, damit CSS Transition greift

    // Toast nach der angegebenen Dauer ausblenden und entfernen
    setTimeout(() => {
        toast.classList.remove('visible');
        // Entferne das Element erst, nachdem die Ausblend-Animation abgeschlossen ist
        toast.addEventListener('transitionend', () => toast.remove());
    }, duration);
}

/**
 * Zeigt einen Bestätigungsdialog (Modal) an.
 * @param {string} title - Der Titel des Dialogs.
 * @param {string} message - Die Frage oder Nachricht im Dialog.
 * @returns {Promise<boolean>} - Ein Promise, das `true` bei Bestätigung und `false` bei Abbruch zurückgibt.
 */
export function showConfirm(title, message) {
    return new Promise((resolve) => {
        // Alten Dialog entfernen, falls einer existiert
        const oldOverlay = document.querySelector('.confirm-overlay');
        if (oldOverlay) {
            oldOverlay.remove();
        }

        const confirmOverlay = document.createElement('div');
        confirmOverlay.className = 'confirm-overlay';

        const confirmBox = document.createElement('div');
        confirmBox.className = 'confirm-box';

        // Verwende textContent für Sicherheit gegen XSS in title/message
        confirmBox.innerHTML = `
            <h2></h2>
            <p></p>
            <div class="confirm-actions">
                <button class="btn btn-secondary" id="confirm-cancel">Abbrechen</button>
                <button class="btn btn-danger" id="confirm-ok">Bestätigen</button>
            </div>
        `;
        confirmBox.querySelector('h2').textContent = title;
        confirmBox.querySelector('p').textContent = message;


        confirmOverlay.appendChild(confirmBox);
        document.body.appendChild(confirmOverlay);

        // Animation starten
        setTimeout(() => confirmOverlay.classList.add('visible'), 10);

        const close = (value) => {
            confirmOverlay.classList.remove('visible');
            confirmOverlay.addEventListener('transitionend', () => {
                confirmOverlay.remove();
                resolve(value);
            }, { once: true }); // Ensure listener is removed after execution
        };

        document.getElementById('confirm-ok').onclick = () => close(true);
        document.getElementById('confirm-cancel').onclick = () => close(false);

        // Schließen bei Klick außerhalb (optional)
        confirmOverlay.addEventListener('click', (e) => {
            if (e.target === confirmOverlay) {
                close(false);
            }
        });
         // Schließen bei Escape-Taste (optional)
        const escapeListener = (e) => {
             if (e.key === 'Escape') {
                 close(false);
                 document.removeEventListener('keydown', escapeListener); // Listener entfernen
             }
         };
         document.addEventListener('keydown', escapeListener);
         // Sicherstellen, dass der Listener entfernt wird, wenn das Modal anders geschlossen wird
         confirmOverlay.addEventListener('transitionend', () => {
             if (!confirmOverlay.classList.contains('visible')) {
                 document.removeEventListener('keydown', escapeListener);
             }
         }, { once: true });
    });
}

// Global assignments removed
// window.showToast = showToast;
// window.showConfirm = showConfirm;

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\notifications.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-absences.js ---
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js';
import { escapeHtml, getWeekAndYear, getDateOfISOWeek } from './planer-utils.js';
// KORREKTUR: FullCalendar wird als globales Objekt (aus header.php) verwendet, nicht als ES-Modul importiert.
// import { FullCalendar } from './fullcalendar-index.js'; // ENTFERNT

/**
 * Escapes HTML special characters.
 * @param {string} unsafe
 * @returns {string}
 */
// function escapeHtml(unsafe) { ... } // Duplikate Funktion, da sie schon in planer-utils ist. Besser aus planer-utils importieren.

/**
 * Formatiert HH:MM:SS zu HH:MM.
 * @param {string} timeString - HH:MM:SS
 * @returns {string} HH:MM
 */
function formatShortTime(timeString) {
    if (!timeString) return '';
    const parts = timeString.split(':');
    if (parts.length >= 2) {
        return `${parts[0]}:${parts[1]}`;
    }
    return timeString; // Fallback
}

/**
 * Wandelt 1-5 in Wochentage um.
 * @param {string|number} dayNum
 * @returns {string}
 */
function formatDayOfWeek(dayNum) {
    const days = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag'];
    const index = parseInt(dayNum, 10) - 1;
    return days[index] || 'Unbekannt';
}

/**
 * Hauptinitialisierungsfunktion, die jetzt exportiert wird.
 */
export function initializePlanerAbsences() {
    const container = document.getElementById('absence-management');
    if (!container) return;

    // KORREKTUR: Suche Elemente innerhalb des 'container'-Elements statt 'document'
    const calendarEl = container.querySelector('#absence-calendar');
    const form = container.querySelector('#absence-form');
    const formTitle = container.querySelector('#absence-form-title');
    const teacherSelect = container.querySelector('#absence-teacher-id');
    const reasonSelect = container.querySelector('#absence-reason');
    const startDateInput = container.querySelector('#absence-start-date');
    const endDateInput = container.querySelector('#absence-end-date');
    const absenceIdInput = container.querySelector('#absence-id');
    const saveButton = container.querySelector('#absence-save-btn');
    const cancelEditButton = container.querySelector('#absence-cancel-edit-btn');
    const deleteButton = container.querySelector('#absence-delete-btn');
    const saveSpinner = container.querySelector('#absence-save-spinner');

    let calendarInstance = null;

    // KORREKTUR: Prüfe, ob das globale FullCalendar-Objekt existiert.
    if (typeof FullCalendar === 'undefined' || typeof FullCalendar.Calendar === 'undefined') {
        console.error("FullCalendar ist nicht geladen. Stellen Sie sicher, dass es in header.php eingebunden ist.");
        if (calendarEl) {
            calendarEl.innerHTML = '<p class="message error">Kalender-Bibliothek konnte nicht geladen werden.</p>';
        }
        return;
    }

    // --- NEUE DEBUGGING-LOGS ---
    console.log("planer-absences.js: Initialisierung läuft...");
    console.log("container:", container); // Zeigt den gefundenen Container
    console.log("calendarEl (gesucht in container):", calendarEl);
    console.log("form (gesucht in container):", form);
    console.log("teacherSelect (gesucht in container):", teacherSelect);
    // --- ENDE DEBUGGING-LOGS ---

    if (!calendarEl || !form || !teacherSelect) {
        console.error("Erforderliche Elemente für das Abwesenheits-Management fehlen.");
        // --- NEUE DEBUGGING-LOGS ---
        if (!calendarEl) console.error("Element '#absence-calendar' nicht gefunden.");
        if (!form) console.error("Element '#absence-form' nicht gefunden.");
        if (!teacherSelect) console.error("Element '#absence-teacher-id' nicht gefunden.");
        // --- ENDE DEBUGGING-LOGS ---
        return;
    }

    /**
     * Setzt das Formular in den "Erstellen"-Modus zurück.
     */
    const resetForm = () => {
        form.reset();
        absenceIdInput.value = '';
        formTitle.textContent = 'Neue Abwesenheit eintragen';
        saveButton.textContent = 'Speichern';
        deleteButton.style.display = 'none';
        cancelEditButton.style.display = 'none';
        
        // Setze Start- und Enddatum zurück (falls sie durch Kalenderauswahl gesetzt wurden)
        startDateInput.value = '';
        endDateInput.value = '';
    };

    /**
     * Lädt die Abwesenheiten und zeigt sie im Kalender an.
     */
    const loadAbsences = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/absences`);
            if (response.success && response.data) {
                const events = response.data.map(abs => ({
                    id: abs.absence_id,
                    title: `${abs.teacher_shortcut}: ${abs.reason}`,
                    start: abs.start_date,
                    end: new Date(new Date(abs.end_date).getTime() + 86400000).toISOString().split('T')[0], // Enddatum ist exklusiv in FullCalendar
                    allDay: true,
                    classNames: [`absence-${abs.reason.toLowerCase()}`],
                    extendedProps: {
                        teacher_id: abs.teacher_id,
                        reason: abs.reason
                    }
                }));
                
                if (calendarInstance) {
                    calendarInstance.removeAllEvents();
                    calendarInstance.addEventSource(events);
                }
            } else {
                throw new Error(response.message || "Abwesenheiten konnten nicht geladen werden.");
            }
        } catch (error) {
            console.error("Fehler beim Laden der Abwesenheiten:", error);
            showToast(error.message, 'error');
        }
    };

    /**
     * Initialisiert den FullCalendar.
     */
    const initializeCalendar = () => {
        // KORREKTUR: Verwende das globale FullCalendar-Objekt
        calendarInstance = new FullCalendar.Calendar(calendarEl, {
            locale: 'de', // Deutsches Sprachpaket
            initialView: 'dayGridMonth',
            headerToolbar: {
                left: 'prev,next today',
                center: 'title',
                right: 'dayGridMonth,listWeek'
            },
            buttonText: {
                today: 'Heute',
                month: 'Monat',
                list: 'Liste'
            },
            selectable: true, // Erlaube das Auswählen von Tagen
            select: (selectionInfo) => {
                // Bei Auswahl eines Zeitraums, fülle das Formular
                resetForm();
                startDateInput.value = selectionInfo.startStr;
                // FullCalendar's Enddatum ist exklusiv. Wir müssen einen Tag abziehen.
                const endDate = new Date(new Date(selectionInfo.endStr).getTime() - 86400000);
                endDateInput.value = endDate.toISOString().split('T')[0];
                formTitle.textContent = 'Neue Abwesenheit eintragen';
                teacherSelect.focus();
            },
            eventClick: (clickInfo) => {
                // Bei Klick auf ein Event, fülle das Formular zum Bearbeiten
                const event = clickInfo.event;
                formTitle.textContent = 'Abwesenheit bearbeiten';
                absenceIdInput.value = event.id;
                teacherSelect.value = event.extendedProps.teacher_id;
                reasonSelect.value = event.extendedProps.reason;
                startDateInput.value = event.startStr;
                
                // Enddatum ist exklusiv, ziehe einen Tag ab für die Anzeige
                const endDate = new Date(new Date(event.endStr).getTime() - 86400000);
                endDateInput.value = endDate.toISOString().split('T')[0];

                saveButton.textContent = 'Aktualisieren';
                deleteButton.style.display = 'inline-block';
                cancelEditButton.style.display = 'inline-block';
            }
        });
        calendarInstance.render();
        loadAbsences(); // Lade Events nach der Initialisierung
    };

    /**
     * Behandelt das Speichern (Erstellen/Aktualisieren) einer Abwesenheit.
     */
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        saveButton.disabled = true;
        saveSpinner.style.display = 'inline-block';

        const formData = new FormData(form);
        const data = Object.fromEntries(formData.entries());
        const url = `${window.APP_CONFIG.baseUrl}/api/planer/absences/save`;

        try {
            // KORREKTUR: Validierung Start-/Enddatum
            if (data.start_date > data.end_date) {
                throw new Error("Das Startdatum darf nicht nach dem Enddatum liegen.");
            }
            
            const response = await apiFetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (response.success) {
                showToast(response.message, 'success');
                resetForm();
                loadAbsences(); // Kalender neu laden
            }
            // Fehler wird von apiFetch als Toast angezeigt
        } catch (error) {
            console.error("Fehler beim Speichern der Abwesenheit:", error);
            // Fehler-Toast wird bereits von apiFetch angezeigt (oder hier, falls Validierung fehlschlägt)
            if (!error.message.includes('API')) { // Zeige Validierungsfehler
                 showToast(error.message, 'error');
            }
        } finally {
            saveButton.disabled = false;
            saveSpinner.style.display = 'none';
        }
    });

    /**
     * Behandelt das Löschen einer Abwesenheit.
     */
    deleteButton.addEventListener('click', async () => {
        const absenceId = absenceIdInput.value;
        if (!absenceId) return;

        if (await showConfirm("Löschen bestätigen", "Möchten Sie diese Abwesenheit wirklich löschen?")) {
            saveButton.disabled = true;
            deleteButton.disabled = true;
            saveSpinner.style.display = 'inline-block';

            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/absences/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ absence_id: absenceId })
                });

                if (response.success) {
                    showToast(response.message, 'success');
                    resetForm();
                    loadAbsences(); // Kalender neu laden
                }
            } catch (error) {
                console.error("Fehler beim Löschen:", error);
            } finally {
                saveButton.disabled = false;
                deleteButton.disabled = false;
                saveSpinner.style.display = 'none';
            }
        }
    });

    /**
     * Behandelt das Abbrechen des Bearbeitungsmodus.
     */
    cancelEditButton.addEventListener('click', () => {
        resetForm();
    });

    // --- Initialisierung ---
    // (Lehrer-Select wurde bereits durch PHP/Stammdaten geladen)
    initializeCalendar();
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-absences.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-api.js ---
 import { apiFetch } from './api-client.js';
 import * as DOM from './planer-dom.js';
 import { updateState, getState } from './planer-state.js';
 import { populateAllModalSelects, populateClassSelector, populateTeacherSelector, populateTemplateSelects, updatePublishControls } from './planer-ui.js';
 import { renderTimetable } from './planer-timetable.js';
 // renderTemplatesList wird in planer-interactions-2.js importiert und dort nach dem API-Aufruf verwendet.
 // import { renderTemplatesList } from './planer-interactions-2.js';
 
 /** Lädt Stammdaten (Klassen, Lehrer, etc.) UND VORLAGEN */
 export const loadInitialData = async () => {
     console.log("planer-api: Lade initiale Stammdaten..."); // Logging
     try {
         // Fetch base data including templates
         // The initial call to /api/planer/data without class_id/teacher_id should return base data
         // KORREKTUR: API-Aufruf, um sicherzustellen, dass 'absences' enthalten sind
         const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/data`);
         console.log("planer-api: Antwort für Initialdaten:", response); // Logging
         if (response.success && response.data) {
             console.log("planer-api: Initialdaten erfolgreich geladen:", response.data); // Logging
             updateState({
                 // Ensure stammdaten contains the base data (classes, teachers etc.)
                 stammdaten: response.data, // Speichere ALLE Stammdaten, inkl. 'absences'
                 templates: response.data.templates || [] // Ensure templates array exists
             });
             // UI-Updates
             // Pass the specific arrays to the populating functions
             populateClassSelector(response.data.classes);
             populateTeacherSelector(response.data.teachers);
             populateAllModalSelects(response.data); // Populates modal selects using the full data object
             populateTemplateSelects(response.data.templates || []); // Populates template selects in modals
 
             // Setzt die Vorauswahl und lädt den ersten Plan
             if (DOM.classSelector && DOM.classSelector.options.length > 1) { // Check if classes were loaded and selector exists
                 console.log("planer-api: Setze Standardauswahl auf erste Klasse."); // Logging
                 DOM.classSelector.selectedIndex = 1; // Select the first actual class
                 updateState({ selectedClassId: DOM.classSelector.value });
                 await loadPlanData(); // Load plan for the initially selected class
             } else {
                  console.log("planer-api: Keine Klassen zum Auswählen gefunden, lade leeren Plan."); // Logging
                  await loadPlanData(); // Attempt to load plan data even if no class selected (will show message)
             }
         } else {
             // Throw error if API call failed or data format is unexpected
             throw new Error(response.message || "Stammdaten konnten nicht geladen werden oder haben ein unerwartetes Format.");
         }
     } catch (error) {
         console.error("planer-api: Fehler beim Laden der Initialdaten:", error);
         if (DOM.timetableContainer) { // Check if container exists before updating
             DOM.timetableContainer.innerHTML = `<p class="message error">${error.message || 'Stammdaten konnten nicht geladen werden.'}</p>`;
         }
         // Optionally disable UI elements if initial load fails
     }
 };
 
 
 /** Lädt die Plandaten für die ausgewählte Ansicht/Woche */
 export const loadPlanData = async () => {
     console.log("planer-api: Lade Plandaten..."); // Logging hinzugefügt
     let { currentViewMode, selectedClassId, selectedTeacherId } = getState();
     // Re-read selected values directly from DOM elements as they are the source of truth
     selectedClassId = DOM.classSelector ? DOM.classSelector.value : null;
     selectedTeacherId = DOM.teacherSelector ? DOM.teacherSelector.value : null;
 
     const selectedYear = DOM.yearSelector ? DOM.yearSelector.value : null;
     const selectedWeek = DOM.weekSelector ? DOM.weekSelector.value : null;
 
     // Check if selectors exist and have values before proceeding
      if (!selectedYear || !selectedWeek) {
          console.warn("planer-api: Jahr oder Woche nicht ausgewählt.");
          if(DOM.timetableContainer) DOM.timetableContainer.innerHTML = '<p class="message info">Bitte Jahr und Kalenderwoche auswählen.</p>';
          updatePublishControls({ student: false, teacher: false });
          return;
      }
 
     // Base URL for the API endpoint
     let url = `${window.APP_CONFIG.baseUrl}/api/planer/data?year=${selectedYear}&week=${selectedWeek}`;
 
     // Append class_id or teacher_id based on the current view mode
     if (currentViewMode === 'class') {
         if (!selectedClassId) {
             console.log("planer-api: Keine Klasse ausgewählt, breche Plandaten-Ladevorgang ab."); // Logging hinzugefügt
             if (DOM.timetableContainer) DOM.timetableContainer.innerHTML = '<p class="message info">Bitte eine Klasse auswählen.</p>';
             updatePublishControls({ student: false, teacher: false }); // Reset publish status display
             // Clear relevant state parts but keep stammdaten
             updateState({ selectedClassId: null, selectedTeacherId: null, currentTimetable: [], currentSubstitutions: [], currentPublishStatus: { student: false, teacher: false } });
             return;
         }
         // Update state and URL for class view
         updateState({ selectedClassId: selectedClassId, selectedTeacherId: null });
         url += `&class_id=${selectedClassId}`;
     } else { // Teacher view
         if (!selectedTeacherId) {
              console.log("planer-api: Kein Lehrer ausgewählt, breche Plandaten-Ladevorgang ab."); // Logging hinzugefügt
             if (DOM.timetableContainer) DOM.timetableContainer.innerHTML = '<p class="message info">Bitte einen Lehrer auswählen.</p>';
             updatePublishControls({ student: false, teacher: false });
              // Clear relevant state parts but keep stammdaten
             updateState({ selectedClassId: null, selectedTeacherId: null, currentTimetable: [], currentSubstitutions: [], currentPublishStatus: { student: false, teacher: false } });
             return;
         }
         // Update state and URL for teacher view
         updateState({ selectedClassId: null, selectedTeacherId: selectedTeacherId });
         url += `&teacher_id=${selectedTeacherId}`;
     }
 
     // Show loading spinner while fetching data
     if (DOM.timetableContainer) DOM.timetableContainer.innerHTML = '<div class="loading-spinner"></div>';
     try {
         // Fetch timetable data from the API
         const response = await apiFetch(url);
         console.log("planer-api: Antwort für Plandaten:", response); // Logging hinzugefügt
         if (response.success && response.data) {
              console.log("planer-api: Plandaten erfolgreich geladen, rufe renderTimetable auf...", response.data); // Logging hinzugefügt
             // Update the application state with the fetched data
             updateState({
                 // Ensure timetable and substitutions are always arrays
                 currentTimetable: response.data.timetable || [],
                 currentSubstitutions: response.data.substitutions || [],
                 currentPublishStatus: response.data.publishStatus || { student: false, teacher: false },
                 // KORREKTUR: Aktualisiere auch die Abwesenheiten im Stammdaten-Teil des States
                 stammdaten: { ...getState().stammdaten, absences: response.data.absences || [] }
             });
             // Render the timetable grid with the new data
             renderTimetable(getState()); // <--- HIER WIRD GERENDERT
             // Update the publish control buttons based on the fetched status
             updatePublishControls(getState().currentPublishStatus);
         } else {
             // If API call was not successful, throw an error
             throw new Error(response.message || "Plandaten konnten nicht geladen werden.")
         }
     } catch (error) {
         // Log error and display an error message in the timetable container
         console.error("planer-api: Fehler beim Laden der Plandaten:", error);
          if (DOM.timetableContainer) { // Check if container exists
              DOM.timetableContainer.innerHTML = `<p class="message error">${error.message || 'Stundenplan konnte nicht geladen werden.'}</p>`;
          }
         // Reset publish controls in case of error
         updatePublishControls({ student: false, teacher: false });
     }
 };
 
 /** API-Aufruf zum Veröffentlichen/Zurückziehen */
 export const publishWeek = async (target, publish = true) => {
     // const { year, week } = getState(); // Get current year/week from state // This might be wrong if selectors changed
     const currentYear = DOM.yearSelector.value; // Get selected year from DOM
     const currentWeek = DOM.weekSelector.value; // Get selected week from DOM
     if (!currentYear || !currentWeek) {
         window.showToast("Bitte Jahr und KW auswählen.", 'error');
         throw new Error("Jahr oder Woche nicht ausgewählt."); // Prevent API call
     }
     const url = publish ? `${window.APP_CONFIG.baseUrl}/api/planer/publish` : `${window.APP_CONFIG.baseUrl}/api/planer/unpublish`;
     const body = JSON.stringify({ year: currentYear, week: currentWeek, target });
     // Make the API call using apiFetch
     return await apiFetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body });
 };
 
 /** API-Aufruf zur Konfliktprüfung */
 export const checkConflicts = async (data) => {
      // Make the API call to check for conflicts
     return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/check-conflicts`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(data)
     });
 };
 
 /** API-Aufruf zum Speichern eines Eintrags */
 export const saveEntry = async (data) => {
       // Make the API call to save a regular timetable entry or block
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/entry/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
      });
 };
 
 /** API-Aufruf zum Löschen eines Eintrags/Blocks */
 export const deleteEntry = async (body) => {
     // Body should contain { entry_id: id } or { block_id: id }
     const url = `${window.APP_CONFIG.baseUrl}/api/planer/entry/delete`;
     // Make the API call to delete an entry or block
     return await apiFetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
 };
 
 /** API-Aufruf zum Speichern einer Vertretung */
 export const saveSubstitution = async (data) => {
       // Make the API call to save a substitution entry
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/substitution/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
      });
 };
 
 /** API-Aufruf zum Löschen einer Vertretung */
 export const deleteSubstitution = async (id) => {
     const url = `${window.APP_CONFIG.baseUrl}/api/planer/substitution/delete`;
      // Make the API call to delete a substitution entry
      return await apiFetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ substitution_id: id }) });
 };
 
 /** API-Aufruf zum Kopieren einer Woche */
 export const copyWeek = async (body) => {
       // Make the API call to copy timetable data from one week to another
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/copy-week`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
      });
 };
 
 /** API-Aufruf zum Laden aller Vorlagen - returns data instead of calling render */
 export const loadTemplates = async () => {
     try {
         // Fetch the list of available templates
         const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates`);
         if (response.success) {
             const templates = response.data || [];
             // Update state and UI selects
             updateState({ templates: templates });
             populateTemplateSelects(templates); // Update selects in modals
             // Return the data for the caller to handle rendering the list
             return templates;
         } else {
             throw new Error(response.message || "Vorlagen konnten nicht geladen werden.");
         }
     } catch (error) {
         // Handle errors during template loading
         updateState({ templates: [] }); // Clear templates in state
         console.error("Fehler beim Laden der Vorlagen:", error);
         // Display error messages in relevant UI elements
         if (DOM.applyTemplateSelect) DOM.applyTemplateSelect.innerHTML = '<option value="">Fehler beim Laden</option>';
         if (DOM.manageTemplatesList) DOM.manageTemplatesList.innerHTML = '<p class="message error">Fehler beim Laden.</p>';
         return []; // Return empty array on error
     }
 };
 
 
 /** API-Aufruf zum Erstellen einer Vorlage */
 export const createTemplate = async (body) => {
       // Make the API call to create a new template
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/create`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
      });
 };
 
 /** API-Aufruf zum Anwenden einer Vorlage */
 export const applyTemplate = async (body) => {
       // Make the API call to apply a template to a specific week
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/apply`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
      });
 };
 
 /** API-Aufruf zum Löschen einer Vorlage */
 export const deleteTemplate = async (templateId) => {
       // Make the API call to delete a template
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/delete`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ templateId: templateId })
      });
 };
 
 // --- NEUE API-FUNKTIONEN (HINZUGEFÜGT) ---
 
 /** API-Aufruf zum Laden der Details einer einzelnen Vorlage */
 export const loadTemplateDetails = async (templateId) => {
       // Dieser Endpunkt muss noch in routes.php und PlanController.php erstellt werden
       // Annahme: GET-Anfrage, gibt { success: true, data: { template: {...}, entries: [...] } } zurück
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/${templateId}`);
 };
 
 /** API-Aufruf zum Speichern/Aktualisieren einer Vorlage aus dem Editor */
 export const saveTemplate = async (templateData) => {
       // Dieser Endpunkt muss noch in routes.php und PlanController.php erstellt werden
       // Annahme: POST-Anfrage, sendet { template_id (optional), name, description, entries: [...] }
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(templateData)
      });
 };

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-api.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-dashboard.js ---
// public/assets/js/planer-dashboard.js
import { initializePlanerInteractions } from './planer-interactions-2.js'; // Importiere Teil 2
import { loadInitialData } from './planer-api.js';

/**
 * Initialisiert das Planer-Dashboard.
 */
export function initializePlanerDashboard() {
    console.log("planer-dashboard: Initialisiere Planer Interaktionen..."); // Log hinzugefügt
    // 1. Alle Event-Listener und Interaktionslogik initialisieren (jetzt in Teil 2)
    initializePlanerInteractions();

    console.log("planer-dashboard: Lade initiale Daten..."); // Log hinzugefügt
    // 2. Die initialen Stammdaten laden (was wiederum das Laden des Plans auslöst)
    loadInitialData(); // Aufruf wieder aktiviert
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-dashboard.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-dom.js ---
 // --- DOM Referenzen ---
 export const viewModeSelector = document.getElementById('view-mode-selector');
 export const classSelectorContainer = document.getElementById('class-selector-container');
 export const classSelector = document.getElementById('class-selector');
 export const teacherSelectorContainer = document.getElementById('teacher-selector-container');
 export const teacherSelector = document.getElementById('teacher-selector');
 export const yearSelector = document.getElementById('year-selector');
 export const weekSelector = document.getElementById('week-selector');
 export const dateSelector = document.getElementById('date-selector');
 export const timetableContainer = document.getElementById('timetable-container');
 export const modal = document.getElementById('timetable-modal');
 // Verhindere Fehler, wenn das Modal (z.B. auf anderen Seiten) nicht existiert
 export const modalTitle = document.getElementById('modal-title');
 export const form = document.getElementById('timetable-entry-form');
 export const deleteBtn = document.getElementById('delete-entry-btn');
 export const modalTabs = modal ? modal.querySelectorAll('.modal-tabs .tab-button') : [];
 export const regularFields = document.getElementById('regular-fields');
 export const substitutionFields = document.getElementById('substitution-fields');
 export const substitutionTypeSelect = document.getElementById('substitution_type');
 export const publishWeekLabel = document.getElementById('publish-week-label');
 export const publishStatusStudent = document.getElementById('publish-status-student');
 export const publishStatusTeacher = document.getElementById('publish-status-teacher');
 export const publishStudentBtn = document.getElementById('publish-student-btn');
 export const publishTeacherBtn = document.getElementById('publish-teacher-btn');
 export const unpublishStudentBtn = document.getElementById('unpublish-student-btn');
 export const unpublishTeacherBtn = document.getElementById('unpublish-teacher-btn');
 export const regularCommentInput = document.getElementById('regular_comment');
 export const substitutionCommentInput = document.getElementById('substitution_comment');
 
 // *** Konflikt-Warnung ***
 export const conflictWarningBox = document.getElementById('modal-conflict-warning');
 export const saveButton = document.getElementById('modal-save-btn');
 // Füge eine Prüfung hinzu, ob 'modal' existiert
 export const conflictCheckFields = modal ? modal.querySelectorAll('.conflict-check') : []; // Alle Felder, die Prüfung auslösen
 
 // *** DOM Referenzen für Kopiermodal ***
 export const copyWeekBtn = document.getElementById('copy-week-btn');
 export const copyWeekModal = document.getElementById('copy-week-modal');
 export const copyWeekForm = document.getElementById('copy-week-form');
 export const copySourceDisplay = document.getElementById('copy-source-display');
 export const copyTargetYear = document.getElementById('copy-target-year');
 export const copyTargetWeek = document.getElementById('copy-target-week');
 export const copyWeekConfirmBtn = document.getElementById('copy-week-confirm-btn');
 export const copyWeekCancelBtn = document.getElementById('copy-week-cancel-btn');
 
 // *** NEUE DOM Referenzen für Vorlagen ***
 export const createTemplateBtn = document.getElementById('create-template-btn');
 export const applyTemplateBtn = document.getElementById('apply-template-btn');
 export const manageTemplatesBtn = document.getElementById('manage-templates-btn');
 export const manageTemplatesModal = document.getElementById('manage-templates-modal');
 export const manageTemplatesViewContainer = document.getElementById('manage-templates-view-container'); // Container für Ansichten
 export const templateListView = document.getElementById('template-list-view'); // Ansicht: Liste
 export const templateEditorView = document.getElementById('template-editor-view'); // Ansicht: Editor
 export const manageTemplatesForm = document.getElementById('create-template-form'); // Form zum Erstellen aus Woche
 export const createEmptyTemplateBtn = document.getElementById('create-empty-template-btn'); // Button für leere Vorlage
 export const manageTemplatesList = document.getElementById('templates-list-container');
 export const manageTemplatesCloseBtn = document.getElementById('manage-templates-close-btn');
 export const templateEditorTitle = document.getElementById('template-editor-title');
 export const templateEditorGridContainer = document.getElementById('template-editor-grid-container'); // Grid-Container
 export const backToTemplateListBtn = document.getElementById('back-to-template-list-btn'); // Zurück zur Liste
 export const saveTemplateEditorBtn = document.getElementById('save-template-editor-btn'); // Speichern im Editor
 export const applyTemplateModal = document.getElementById('apply-template-modal');
 export const applyTemplateForm = document.getElementById('apply-template-form');
 export const applyTemplateSelect = document.getElementById('apply-template-select');
 export const applyTemplateConfirmBtn = document.getElementById('apply-template-confirm-btn');
 export const applyTemplateCancelBtn = document.getElementById('apply-template-cancel-btn');
 
 // *** Konstanten für Grid-Rendering ***
 export const days = ["Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag"];
 export const timeSlots = [
     "08:00 - 08:45", "08:55 - 09:40", "09:40 - 10:25", "10:35 - 11:20",
     "11:20 - 12:05", "13:05 - 13:50", "13:50 - 14:35", "14:45 - 15:30",
     "15:30 - 16:15", "16:25 - 17:10"
 ];


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-dom.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-1.js ---
 import * as DOM from './planer-dom.js';
 import { getState, updateState, clearSelectionState, setSelectionState } from './planer-state.js';
 import { getWeekAndYear, getDateOfISOWeek, getDateForDayInWeek, escapeHtml } from './planer-utils.js';
 // Import API functions used locally
 // KORREKTUR: loadPlanData hinzugefügt
 import { checkConflicts, saveEntry, deleteEntry, saveSubstitution, deleteSubstitution, loadPlanData } from './planer-api.js';
 // KORRIGIERTER IMPORT: populateYearSelector und populateWeekSelector hinzugefügt
 import { showConflicts, hideConflicts, populateYearSelector, populateWeekSelector } from './planer-ui.js';
 // Import notifications
 import { showToast, showConfirm } from './notifications.js';

 // --- Interaktionen Teil 1: Modal-Logik ---

 /**
  * Definiert die debounced Conflict Check Funktion auf Modulebene,
  * damit sie von openModal, switchMode und initializeEntryModal aufgerufen werden kann.
  */
 const debouncedConflictCheck = () => {
     clearTimeout(getState().conflictCheckTimeout);
     updateState({
         conflictCheckTimeout: setTimeout(async () => {
             const state = getState();
             // Konfliktprüfung nur im 'regular' Modus und NICHT im Template-Editor
             if (state.activeMode !== 'regular' || (DOM.form && DOM.form.querySelector('#modal_editing_template').value === 'true')) {
                 hideConflicts();
                 return;
             }
 
             if (!state.selection || state.selection.cells.length === 0) {
                 hideConflicts();
                 return;
             }
 
             const startPeriod = Math.min(...state.selection.cells.map(c => parseInt(c.dataset.period)));
             const endPeriod = Math.max(...state.selection.cells.map(c => parseInt(c.dataset.period)));
 
             const data = {
                 year: DOM.yearSelector.value,
                 calendar_week: DOM.weekSelector.value,
                 day_of_week: DOM.form.querySelector('#modal_day_of_week').value,
                 start_period_number: startPeriod,
                 end_period_number: endPeriod,
                 teacher_id: DOM.form.querySelector('#teacher_id').value,
                 room_id: DOM.form.querySelector('#room_id').value,
                 class_id: state.editingClassId, // Use the stored class ID
                 entry_id: DOM.form.querySelector('#entry_id').value || null,
                 block_id: DOM.form.querySelector('#block_id').value || null,
             };
 
             // Don't check if essential data is missing
             if (!data.teacher_id || !data.room_id || !data.class_id || !data.day_of_week || !data.start_period_number) {
                 hideConflicts();
                 return;
             }
 
             try {
                 // This will throw an error if conflicts exist, handled by apiFetch and catch block
                 await checkConflicts(data);
                 // If checkConflicts didn't throw, hide any previous warnings
                 hideConflicts();
             } catch (error) {
                 // Error is already handled by apiFetch (shows toast)
                 // We need to show the conflict details in the modal
                 console.error("Fehler bei Konfliktprüfung (gefangen):", error);
                 if (error.message) {
                     showConflicts(error.message.split("\n"));
                 } else {
                     showConflicts(["Unbekannter Fehler bei der Konfliktprüfung."]);
                 }
             }
         }, 300) // 300ms debounce time
     });
 };
 
 /** Setzt die Haupt-Selektoren auf die aktuelle Woche */
 export function setDefaultSelectors() {
     const today = new Date();
     const { week, year } = getWeekAndYear(today);
     populateYearSelector(DOM.yearSelector, year);
     populateWeekSelector(DOM.weekSelector, week);
 
     const dayOfWeek = today.getDay();
     if (dayOfWeek >= 1 && dayOfWeek <= 5) {
         DOM.dateSelector.value = today.toISOString().split('T')[0];
     } else {
         DOM.dateSelector.value = '';
     }
 }
 
 /** * Behandelt Klicks auf Zellen im Grid
  * @param {HTMLElement} cell - Die angeklickte Zelle
  * @param {HTMLElement} container - Der Grid-Container (timetableContainer oder templateEditorGridContainer)
  */
 export function handleCellClick(cell, container) {
     if (!container) { // Fallback, falls Container nicht übergeben wird
         container = DOM.timetableContainer;
     }
     const clickedDay = cell.dataset.day;
     const clickedPeriod = parseInt(cell.dataset.period);
     const state = getState();
 
     // Prevent re-selection actions if the same single cell is clicked again (unless empty)
     if (state.selection.cells.length === 1 && state.selection.cells[0] === cell && !cell.classList.contains('empty')) {
         // Allow opening modal on double click, handled elsewhere
         return;
     }
 
     const startCellData = state.selection.start ? state.selection.start.cell.dataset : {};
     // Check if the clicked cell belongs to the same block/entry/substitution group as the start cell
     const isSameGroupAsStart = (startCellData.blockId && cell.dataset.blockId === startCellData.blockId) ||
                               (startCellData.entryId && cell.dataset.entryId === startCellData.entryId) ||
                               (startCellData.substitutionId && cell.dataset.substitutionId === startCellData.substitutionId); // Added substitution check
 
     const startIsEmpty = !startCellData.entryId && !startCellData.blockId && !startCellData.substitutionId;
     const currentIsEmpty = !cell.dataset.entryId && !cell.dataset.blockId && !cell.dataset.substitutionId;
 
     // Allow selecting multiple empty cells or multiple cells of the same group
     // Reset selection if:
     // 1. No start cell exists OR
     // 2. Different day OR
     // 3. Clicked cell is FU/empty placeholder OR
     // 4. Start and current cell are not empty AND not part of the same group
     if (
         !state.selection.start ||
         clickedDay !== state.selection.start.day ||
         cell.classList.contains('default-entry') || // Prevent selecting FU cells
         (!isSameGroupAsStart && !(startIsEmpty && currentIsEmpty))
     ) {
         clearSelectionState(state.selection.cells); // Clear previous visual selection
         setSelectionState({ start: { day: clickedDay, period: clickedPeriod, cell: cell }, end: null, cells: [cell] });
         cell.classList.add('selected');
         return;
     }
 
     // --- Extend selection ---
     state.selection.end = { day: clickedDay, period: clickedPeriod };
     const startPeriod = Math.min(state.selection.start.period, state.selection.end.period);
     const endPeriod = Math.max(state.selection.start.period, state.selection.end.period);
 
     // Clear previous visual selection
     state.selection.cells.forEach(c => c.classList.remove('selected'));
     const newSelectionCells = [];
 
     // Select cells within the new range
     for (let p = startPeriod; p <= endPeriod; p++) {
         // *** KORREKTUR: Verwende den übergebenen 'container' ***
         const cellToSelect = container.querySelector(`.grid-cell[data-day='${clickedDay}'][data-period='${p}']`);
         if (cellToSelect) {
             const currentCellData = cellToSelect.dataset;
             // Ensure the cells being added to the range are compatible (either all empty or all part of the initial group)
             const isCurrentSameGroup = (startCellData.blockId && currentCellData.blockId === startCellData.blockId) ||
                                        (startCellData.entryId && currentCellData.entryId === startCellData.entryId) ||
                                        (startCellData.substitutionId && currentCellData.substitutionId === startCellData.substitutionId);
             const isCurrentEmpty = !currentCellData.entryId && !currentCellData.blockId && !currentCellData.substitutionId;
 
             // If the start was empty, only allow selecting other empty cells
             // If the start was not empty, only allow selecting cells from the same group
             if ((startIsEmpty && !isCurrentEmpty) || (!startIsEmpty && !isCurrentSameGroup)) {
                 // Incompatible cell found in range, reset selection to the *currently clicked* cell
                 clearSelectionState(state.selection.cells.concat(newSelectionCells)); // Clear old and potentially partially new selection
                 setSelectionState({ start: { day: clickedDay, period: clickedPeriod, cell: cell }, end: null, cells: [cell] }); // Select only the clicked cell
                 cell.classList.add('selected');
                 return; // Stop extending
             }
 
             cellToSelect.classList.add('selected');
             newSelectionCells.push(cellToSelect);
         }
     }
     // Update state with the new selection range
     state.selection.cells = newSelectionCells;
     // Ensure start cell and period reflect the actual start of the selected block
     state.selection.start.cell = newSelectionCells[0];
     state.selection.start.period = parseInt(newSelectionCells[0].dataset.period);
     setSelectionState(state.selection); // Update the global state
 }
 
 
 /** Logik für das Haupt-Eintragsmodal */
 export function initializeEntryModal() {
     // --- Konfliktprüfung ---
     // Die Funktion debouncedConflictCheck ist jetzt auf Modulebene definiert.
     // Wir fügen hier nur die Event-Listener hinzu.
 
     DOM.conflictCheckFields.forEach(field => {
         field.addEventListener('change', debouncedConflictCheck);
     });
     // --- Ende Konfliktprüfung ---
 
 
     DOM.modalTabs.forEach(tab => tab.addEventListener('click', () => switchMode(tab.dataset.mode)));
     DOM.substitutionTypeSelect.addEventListener('change', () => {
         updateSubstitutionFields();
         hideConflicts(); // Hide conflicts when switching substitution type
     });
 
     // --- Form Submit ---
     DOM.form.addEventListener('submit', async (e) => {
         e.preventDefault();
         // Prevent saving if conflict warning is visible
         if (DOM.conflictWarningBox && DOM.conflictWarningBox.style.display !== 'none') {
             showToast("Speichern nicht möglich: Es bestehen Konflikte.", 'error');
             return;
         }
 
         const formData = new FormData(DOM.form);
         const state = getState();
 
         // Clean up form data based on mode
         if (state.activeMode === 'regular') {
             formData.set('comment', DOM.regularCommentInput.value); // Ensure correct comment is set
             // Remove substitution-specific fields
             formData.delete('substitution_type');
             formData.delete('new_teacher_id');
             formData.delete('new_subject_id');
             formData.delete('new_room_id');
             formData.delete('original_subject_id'); // Make sure this is not sent
         } else { // Substitution mode
             formData.set('comment', DOM.substitutionCommentInput.value); // Ensure correct comment is set
         }
 
         const data = Object.fromEntries(formData.entries());
         let promise;
 
         if (state.activeMode === 'substitution') {
             // Add date and potentially original subject ID for substitution save
             const dayOfWeek = DOM.form.querySelector('#modal_day_of_week').value;
             data.date = getDateForDayInWeek(dayOfWeek, DOM.yearSelector.value, DOM.weekSelector.value);
 
             // Find original subject ID from the first selected cell's regular entry
             const startCell = state.selection.cells[0];
             const entryId = startCell.dataset.entryId || '';
             const blockId = startCell.dataset.blockId || '';
             // Find the regular entry associated with the first cell of the selection
             const regularEntry = blockId
                 ? state.currentTimetable.find(e => e.block_id === blockId && e.day_of_week == dayOfWeek && e.period_number == startCell.dataset.period)
                 : state.currentTimetable.find(e => e.entry_id == entryId);
 
             data.original_subject_id = regularEntry?.subject_id || null;
             data.class_id = state.editingClassId; // Ensure class_id is set for substitution
             if (!data.class_id) {
                 showToast("Fehler: Klasse für Vertretung konnte nicht ermittelt werden.", 'error');
                 return; // Stop if class ID is missing
             }
             promise = saveSubstitution(data);
         } else { // Regulärer Modus
             // Add multi-period info, year, week, and class_id
             const startPeriod = Math.min(...state.selection.cells.map(c => parseInt(c.dataset.period)));
             const endPeriod = Math.max(...state.selection.cells.map(c => parseInt(c.dataset.period)));
             data.start_period_number = startPeriod;
             data.end_period_number = endPeriod;
             data.year = DOM.yearSelector.value;
             data.calendar_week = DOM.weekSelector.value;
             data.class_id = state.editingClassId; // Verwende die gespeicherte Klasse
             if (!data.class_id) {
                 // If class ID is still null/undefined here (e.g., in teacher mode without selecting a class in template editor)
                  if (state.currentViewMode === 'class' && state.selectedClassId) {
                      data.class_id = state.selectedClassId;
                  } else if (DOM.form.querySelector('#modal_editing_template').value === 'true') {
                      data.class_id = DOM.modal.querySelector('#template_class_id').value || '0'; // Use selected or default '0' for template
                  }
                  else {
                      showToast("Fehler: Konnte Klasse nicht ermitteln.", 'error');
                      return; // Prevent saving without class_id
                  }
             }
              // Ensure class_id is '0' if it's explicitly set to that (e.g., from template editor default)
             if (data.class_id === '0') data.class_id = '0'; // Explicitly keep '0' if selected
 
             promise = saveEntry(data);
         }
 
         // Execute save and handle response
         try {
             const response = await promise;
             if (response.success) {
                 showToast("Änderungen erfolgreich gespeichert.", 'success');
                 closeModal();
                 loadPlanData(); // Reload data after saving
             }
             // Errors are handled by apiFetch
         } catch (error) { /* Error already shown by apiFetch */ }
     });
 
     // --- Delete Button ---
     DOM.deleteBtn.addEventListener('click', async () => {
         let body, confirmMsg;
         const state = getState();
         const promises = []; // Array für mehrere Lösch-Promises
 
         if (state.activeMode === 'substitution') {
             const subId = DOM.form.querySelector('#substitution_id').value;
             if (!subId) {
                 showToast("Fehler: Keine Vertretungs-ID gefunden.", 'error');
                 return;
             }
             
             confirmMsg = 'Soll diese Vertretung UND die zugrundeliegende reguläre Stunde gelöscht werden?';
             
             // 1. Promise: Vertretung löschen
             promises.push(deleteSubstitution(subId));
 
             // 2. Promise: Zugrundeliegenden regulären Eintrag/Block finden und löschen
             const dayOfWeek = DOM.form.querySelector('#modal_day_of_week').value;
             const period = DOM.form.querySelector('#modal_period_number').value;
             
             // Finde den regulären Eintrag, der zu dieser Zelle gehört
             // Verwende die gespeicherte editingClassId, um den richtigen Eintrag im Lehrermodus zu finden
             const regularEntry = state.currentTimetable.find(e => 
                 e.day_of_week == dayOfWeek && 
                 e.period_number == period &&
                 e.class_id == state.editingClassId // Stelle sicher, dass wir den Eintrag der richtigen Klasse löschen
             );
 
             if (regularEntry) {
                 if (regularEntry.block_id) {
                     body = { block_id: regularEntry.block_id };
                     console.log("Lösche auch regulären Block:", body);
                     promises.push(deleteEntry(body));
                 } else if (regularEntry.entry_id) {
                     body = { entry_id: regularEntry.entry_id };
                     console.log("Lösche auch reguläre Stunde:", body);
                     promises.push(deleteEntry(body));
                 }
             } else {
                  console.log("Keine zugrundeliegende reguläre Stunde zum Mitlöschen gefunden.");
             }
             
             // Führe beide Löschvorgänge aus
             if (await showConfirm("Löschen bestätigen", confirmMsg)) {
                 try {
                     const responses = await Promise.all(promises);
                     // Prüfe ob alle erfolgreich waren
                     const success = responses.every(r => r && r.success);
                     if (success) {
                         showToast("Einträge erfolgreich gelöscht.", 'success');
                         closeModal();
                         loadPlanData();
                     } else {
                         throw new Error("Einige Einträge konnten nicht gelöscht werden.");
                     }
                 } catch (error) { /* Fehler wird von apiFetch oder Promise.all behandelt */ }
             }
 
         } else { // Regular mode
             const blockId = DOM.form.querySelector('#block_id').value;
             const entryId = DOM.form.querySelector('#entry_id').value;
             if (blockId) {
                 body = { block_id: blockId };
                 confirmMsg = 'Soll dieser gesamte Block wirklich gelöscht werden?';
             } else if (entryId) {
                 body = { entry_id: entryId };
                 confirmMsg = 'Soll diese reguläre Stunde wirklich gelöscht werden?';
             } else {
                 showToast("Kein Eintrag zum Löschen ausgewählt.", 'error'); return;
             }
             
             // Nur ein Promise für regulären Modus
             if (await showConfirm("Löschen bestätigen", confirmMsg)) {
                 try {
                     const response = await deleteEntry(body);
                     if (response.success) {
                         showToast("Eintrag erfolgreich gelöscht.", 'success');
                         closeModal();
                         loadPlanData(); // Reload data after deleting
                     }
                 } catch (error) { /* Error already shown */ }
             }
         }
     });
 
     // --- Cancel / Close Modal ---
     DOM.modal.addEventListener('click', (e) => {
         // Close if clicking outside the modal box or on the cancel button
         if (e.target.id === 'timetable-modal' || e.target.id === 'modal-cancel-btn') {
             closeModal();
         }
     });
 }
 
 
 /** Öffnet das Eintragsmodal und füllt es basierend auf der Auswahl */
 export function openModal(isTemplateEdit = false) {
     const state = getState();
     if (state.selection.cells.length === 0) return; // Don't open if nothing is selected
 
     DOM.form.reset(); // Clear previous data
     hideConflicts(); // Clear old conflicts
 
     const startCell = state.selection.cells[0];
     const endCell = state.selection.cells[state.selection.cells.length - 1];
     const { day, period } = startCell.dataset; // Use start cell for day/period context
     let { entryId, substitutionId, blockId, classId } = startCell.dataset; // Get IDs from start cell
 
     // Override IDs if in template edit mode
     if (isTemplateEdit) {
         entryId = startCell.dataset.templateEntryId || null; // Use template ID
         substitutionId = null; // No substitutions in templates
         blockId = startCell.dataset.blockId || null; // This is actually block_ref for templates
         DOM.form.querySelector('#modal_editing_template').value = 'true';
     } else {
         DOM.form.querySelector('#modal_editing_template').value = 'false';
     }
 
     // Set hidden fields
     DOM.form.querySelector('#modal_day_of_week').value = day;
     DOM.form.querySelector('#modal_period_number').value = period; // Base period for single selection
     // WICHTIG: Leere #entry_id und #block_id Felder; sie werden unten neu befüllt
     DOM.form.querySelector('#entry_id').value = '';
     DOM.form.querySelector('#block_id').value = '';
     DOM.form.querySelector('#substitution_id').value = substitutionId || '';
 
     // Set Modal Title
     let title;
     if (state.selection.cells.length > 1) {
         const startTime = DOM.timeSlots[startCell.dataset.period - 1].split(' - ')[0];
         const endTime = DOM.timeSlots[endCell.dataset.period - 1].split(' - ')[1];
         title = `Block bearbeiten (${DOM.days[day-1]}, ${startTime} - ${endTime})`;
     } else {
         title = `Eintrag bearbeiten (${DOM.days[day-1]}, ${DOM.timeSlots[startCell.dataset.period - 1]})`;
     }
     DOM.modalTitle.textContent = title;
 
     // --- Determine entry data and mode ---
     let entryToEdit = null;
     let regularEntryForSub = null;
     let editingClassId = null;
     let modeToSwitchTo = 'regular'; // Default mode
 
     if (isTemplateEdit) {
         DOM.modal.querySelector('#template-class-select-container').style.display = 'block'; // Show class select for templates
         // Find template entry data
         const templateData = state.currentTemplateEditorData || []; // Use current editor data
         if (blockId) entryToEdit = templateData.find(e => e.block_ref === blockId);
         else if (entryId) entryToEdit = templateData.find(e => e.template_entry_id == entryId);
         editingClassId = entryToEdit ? entryToEdit.class_id : '0'; // Default to '0' if new template entry
         modeToSwitchTo = 'regular'; // Templates only use regular mode
         DOM.modal.querySelector('.modal-tabs .tab-button[data-mode="substitution"]').style.display = 'none'; // Hide substitution tab
     } else { // Not template editor
         DOM.modal.querySelector('#template-class-select-container').style.display = 'none'; // Hide class select
         DOM.modal.querySelector('.modal-tabs .tab-button[data-mode="substitution"]').style.display = 'block'; // Show substitution tab
 
         if (substitutionId) {
             entryToEdit = state.currentSubstitutions.find(s => s.substitution_id == substitutionId);
             if(entryToEdit) {
                 // Find the corresponding regular entry for context
                 const subDayNum = entryToEdit.day_of_week; // Use pre-calculated day_of_week
                 regularEntryForSub = state.currentTimetable.find(e => e.day_of_week == subDayNum && e.period_number == entryToEdit.period_number && e.class_id == entryToEdit.class_id);
                 
                 // Fallback: Manchmal ist die Zelle im DOM die einzige Quelle (z.B. wenn Lehrer-Ansicht)
                 if(!regularEntryForSub) {
                      const originalCell = DOM.timetableContainer.querySelector(`.grid-cell[data-day='${subDayNum}'][data-period='${entryToEdit.period_number}']`);
                      if (originalCell?.dataset?.blockId) {
                          regularEntryForSub = state.currentTimetable.find(e => e.block_id === originalCell.dataset.blockId);
                      } else if(originalCell?.dataset?.entryId) {
                           regularEntryForSub = state.currentTimetable.find(e => e.entry_id == originalCell.dataset.entryId);
                      }
                 }
                 editingClassId = entryToEdit.class_id; // Use the class ID from the substitution
             }
             modeToSwitchTo = 'substitution';
         } else if (blockId) {
             entryToEdit = state.currentTimetable.find(e => e.block_id === blockId);
             if(entryToEdit) editingClassId = entryToEdit.class_id;
             modeToSwitchTo = 'regular';
         } else if (entryId) {
             entryToEdit = state.currentTimetable.find(e => e.entry_id == entryId);
             if(entryToEdit) editingClassId = entryToEdit.class_id;
             modeToSwitchTo = 'regular';
         } else { // New entry
              if(state.currentViewMode === 'class') editingClassId = state.selectedClassId;
              // classId is from the cell dataset, might be null in teacher view for empty cells
              else editingClassId = classId || null; // Use cell's classId if available (teacher view) or null
              modeToSwitchTo = 'regular';
         }
     }
     updateState({ editingClassId: editingClassId }); // Store the class ID being edited
 
      // *** NEU: Setze entry_id und block_id NACH der Logik ***
      if (regularEntryForSub) {
         // Wenn wir eine Vertretung bearbeiten, speichere die IDs des zugrundeliegenden Eintrags
         DOM.form.querySelector('#entry_id').value = regularEntryForSub.entry_id || '';
         DOM.form.querySelector('#block_id').value = regularEntryForSub.block_id || '';
     } else if (entryToEdit && modeToSwitchTo === 'regular') {
         // Wenn wir einen regulären Eintrag bearbeiten
         DOM.form.querySelector('#entry_id').value = isTemplateEdit ? (entryToEdit.template_entry_id || '') : (entryToEdit.entry_id || '');
         DOM.form.querySelector('#block_id').value = isTemplateEdit ? (entryToEdit.block_ref || '') : (entryToEdit.block_id || '');
     } else {
         // Neuer Eintrag
         DOM.form.querySelector('#entry_id').value = '';
         DOM.form.querySelector('#block_id').value = '';
     }
     // substitutionId wurde bereits oben gesetzt
     // *** ENDE NEU ***
 
     // --- Fill form fields based on determined entry data and mode ---
     switchMode(modeToSwitchTo, isTemplateEdit); // Switch tabs *before* filling
 
     if (modeToSwitchTo === 'regular') {
         if(entryToEdit){ // Editing existing regular entry
             DOM.form.querySelector('#subject_id').value = entryToEdit.subject_id;
             DOM.form.querySelector('#teacher_id').value = entryToEdit.teacher_id;
             DOM.form.querySelector('#room_id').value = entryToEdit.room_id;
             DOM.regularCommentInput.value = entryToEdit.comment || '';
              if (isTemplateEdit) DOM.modal.querySelector('#template_class_id').value = entryToEdit.class_id || '0';
         } else { // Creating new regular entry
             DOM.regularCommentInput.value = '';
             // Pre-select first options if available
             const { stammdaten } = getState();
             if (stammdaten.subjects?.[0]) DOM.form.querySelector('#subject_id').value = stammdaten.subjects[0].subject_id;
             if (stammdaten.teachers?.[0]) DOM.form.querySelector('#teacher_id').value = stammdaten.teachers[0].teacher_id;
             if (stammdaten.rooms?.[0]) DOM.form.querySelector('#room_id').value = stammdaten.rooms[0].room_id;
             if (isTemplateEdit) DOM.modal.querySelector('#template_class_id').value = editingClassId || '0';
         }
     } else if (modeToSwitchTo === 'substitution') {
          // Pre-fill regular fields with original entry data (disabled visually but needed for context)
          DOM.form.querySelector('#subject_id').value = regularEntryForSub?.subject_id || '';
          DOM.form.querySelector('#teacher_id').value = regularEntryForSub?.teacher_id || '';
          DOM.form.querySelector('#room_id').value = regularEntryForSub?.room_id || '';
          DOM.form.querySelector('#original_subject_id').value = regularEntryForSub?.subject_id || ''; // Hidden field
          DOM.regularCommentInput.value = regularEntryForSub?.comment || ''; // Show original comment
 
          if(entryToEdit){ // Editing existing substitution
              DOM.form.querySelector('#substitution_type').value = entryToEdit.substitution_type;
              DOM.form.querySelector('#new_teacher_id').value = entryToEdit.new_teacher_id || '';
              DOM.form.querySelector('#new_subject_id').value = entryToEdit.new_subject_id || '';
              DOM.form.querySelector('#new_room_id').value = entryToEdit.new_room_id || '';
              DOM.substitutionCommentInput.value = entryToEdit.comment || '';
          } else { // Creating new substitution for a regular entry
              DOM.form.querySelector('#substitution_type').value = 'Vertretung'; // Default to 'Vertretung'
              DOM.substitutionCommentInput.value = '';
              // Pre-fill with original data where applicable
              DOM.form.querySelector('#new_subject_id').value = regularEntryForSub?.subject_id || '';
              DOM.form.querySelector('#new_room_id').value = regularEntryForSub?.room_id || '';
              DOM.form.querySelector('#new_teacher_id').value = ''; // Default to empty teacher
          }
          updateSubstitutionFields(); // Show/hide relevant fields
     }
 
     updateDeleteButtonVisibility(); // Show/hide delete button based on context
     DOM.modal.classList.add('visible'); // Show the modal
     // *** KORREKTUR: Verwende die debouncedConflictCheck-Funktion ***
     if (!isTemplateEdit) debouncedConflictCheck(); // Perform initial conflict check if not in template editor
 }
 
 
 /** Schließt das Eintragsmodal */
 export function closeModal() {
     clearSelectionState(getState().selection.cells); // Clear visual selection in grid
     DOM.modal.classList.remove('visible'); // Hide modal
     hideConflicts(); // Clear conflict messages
     updateState({ editingClassId: null }); // Clear editing class ID
     // Reset template editor flag and class select visibility
     if (DOM.form) { // Add check if DOM.form exists
         DOM.form.querySelector('#modal_editing_template').value = 'false';
         const templateClassSelect = DOM.form.querySelector('#template-class-select-container');
         if (templateClassSelect) {
             templateClassSelect.style.display = 'none';
         }
     }
 }
 
 
 /** Wechselt den Modus (Tab) im Eintragsmodal */
 export function switchMode(mode, isTemplateEditor = false) {
     updateState({ activeMode: mode }); // Update global state
 
     // Toggle active classes for tabs and content panes
     DOM.modalTabs.forEach(tab => tab.classList.toggle('active', tab.dataset.mode === mode));
     DOM.regularFields.classList.toggle('active', mode === 'regular');
     DOM.substitutionFields.classList.toggle('active', mode === 'substitution');
 
     hideConflicts(); // Hide conflicts when switching mode
 
     if (mode === 'substitution') {
         // --- Pre-fill context for substitution ---
         const dayOfWeek = DOM.form.querySelector('#modal_day_of_week').value;
         if (!dayOfWeek) { // Should not happen if modal opened correctly
             showToast("Kann keine Vertretung ohne ausgewählten Tag erstellen.", 'error');
             // Force back to regular mode if day is missing
             setTimeout(() => switchMode('regular', isTemplateEditor), 0);
             return;
         }
         // Store the date for saving later
         updateState({ selectedDate: getDateForDayInWeek(dayOfWeek, DOM.yearSelector.value, DOM.weekSelector.value) });
 
         // Find the original regular entry data based on the first selected cell
         const { selection, currentTimetable } = getState();
         const startCell = selection.cells[0];
         // *** KORREKTUR: Verwende die bereits im Formular gespeicherten IDs ***
         const entryId = DOM.form.querySelector('#entry_id').value || '';
         const blockId = DOM.form.querySelector('#block_id').value || '';
 
         // Find the regular entry associated with this time slot
         const regularEntry = blockId
             ? currentTimetable.find(e => e.block_id === blockId) // Finde *irgendeinen* Eintrag des Blocks
             : currentTimetable.find(e => e.entry_id == entryId);
 
         // Store the original subject ID (important for substitution logic)
         DOM.form.querySelector('#original_subject_id').value = regularEntry?.subject_id || '';
 
         // Pre-fill substitution fields if creating a *new* substitution
         if (!DOM.form.querySelector('#substitution_id').value) {
             DOM.form.querySelector('#new_subject_id').value = regularEntry?.subject_id || '';
             DOM.form.querySelector('#new_room_id').value = regularEntry?.room_id || '';
             DOM.form.querySelector('#new_teacher_id').value = ''; // Default new teacher to empty
             DOM.substitutionCommentInput.value = ''; // Clear comment for new substitution
         }
         updateSubstitutionFields(); // Show/hide fields based on the selected substitution type
     }
     updateDeleteButtonVisibility(); // Update delete button visibility based on mode/IDs
     // *** KORREKTUR: Verwende die debouncedConflictCheck-Funktion ***
     if (!isTemplateEditor) debouncedConflictCheck(); // Check conflicts unless in template editor
 }
 
 
 /** Zeigt/Versteckt Felder im Vertretungs-Tab basierend auf dem Typ */
 export function updateSubstitutionFields() {
     const type = DOM.substitutionTypeSelect.value;
     DOM.modal.querySelectorAll('#substitution-details .sub-field').forEach(field => {
         const types = field.dataset.types ? JSON.parse(field.dataset.types) : [];
         field.style.display = types.includes(type) ? 'block' : 'none';
     });
 }
 
 /** Zeigt/Versteckt den Löschen-Button im Modal */
 export function updateDeleteButtonVisibility() {
     const entryId = DOM.form.querySelector('#entry_id').value;
     const substitutionId = DOM.form.querySelector('#substitution_id').value;
     const blockId = DOM.form.querySelector('#block_id').value;
     const isTemplateEdit = DOM.form.querySelector('#modal_editing_template').value === 'true';
 
     // Can delete if:
     // - In substitution mode AND have a substitutionId
     // - In regular mode AND (have an entryId OR blockId)
     // AND NOT in template edit mode (template entries deleted via manage modal)
     const canDelete = !isTemplateEdit && (
         (getState().activeMode === 'substitution' && substitutionId) ||
         (getState().activeMode === 'regular' && (entryId || blockId))
     );
     // *** KORREKTUR: Tippfehler 'SO' zu 'DOM' ***
     DOM.deleteBtn.style.display = canDelete ? 'block' : 'none';
 }


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-1.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-2.js ---
 import * as DOM from './planer-dom.js';
 import { getState, updateState, clearSelectionState, setSelectionState } from './planer-state.js';
 import { getWeekAndYear, getDateOfISOWeek, getDateForDayInWeek, escapeHtml } from './planer-utils.js';
 // Corrected import: Import saveEntry and saveSubstitution from planer-api
 import { loadPlanData, publishWeek, checkConflicts, saveEntry, deleteEntry, saveSubstitution, deleteSubstitution, copyWeek, loadTemplates, createTemplate, applyTemplate, deleteTemplate, loadTemplateDetails, saveTemplate } from './planer-api.js';
 import { renderTimetable } from './planer-timetable.js';
 import { populateYearSelector, populateWeekSelector, populateTemplateSelects, showTemplateView, showConflicts, hideConflicts, populateAllModalSelects } from './planer-ui.js';
 // Import notifications
 import { showToast, showConfirm } from './notifications.js';
 // Import functions from part 1
 import { setDefaultSelectors, handleCellClick, initializeEntryModal, openModal, closeModal, switchMode, updateSubstitutionFields, updateDeleteButtonVisibility } from './planer-interactions-1.js';

 /**
  * Initialisiert alle Event-Listener und Hauptinteraktionen für die Planer-Oberfläche.
  */
 export function initializePlanerInteractions() {

     // --- Setze Standardwerte für Selektoren ---
     setDefaultSelectors();
     // --- Initialisiere Modal-Logik (Submit, Delete etc.) ---
     initializeEntryModal(); // From part 1

     // --- Allgemeine UI-Handler ---
     const handleDateOrWeekChange = () => {
         const dateVal = DOM.dateSelector.value;
         if (dateVal) {
             const dateObj = new Date(dateVal + 'T00:00:00'); // Ensure local time interpretation
             const { week, year } = getWeekAndYear(dateObj);
             // If date change resulted in a new week/year, update selectors and reload
             if (DOM.yearSelector.value != year || DOM.weekSelector.value != week) {
                 DOM.yearSelector.value = year;
                 DOM.weekSelector.value = week;
                 loadPlanData(); // Reload plan for the new week/year
                 return; // Prevent double loading
             }
         }
         // If only week/year changed, or date didn't change the week/year, just reload
         loadPlanData();
     };
     const handleViewModeChange = () => {
         updateState({ currentViewMode: DOM.viewModeSelector.value });
         if (getState().currentViewMode === 'class') {
             DOM.classSelectorContainer.classList.remove('hidden');
             DOM.teacherSelectorContainer.classList.add('hidden');
             DOM.teacherSelector.value = ''; // Reset teacher selection
         } else {
             DOM.classSelectorContainer.classList.add('hidden');
             DOM.teacherSelectorContainer.classList.remove('hidden');
             DOM.classSelector.value = ''; // Reset class selection
         }
         loadPlanData(); // Load data for the new view mode
     };
     const handlePublishAction = async (target, publish = true) => {
         const year = DOM.yearSelector.value;
         const week = DOM.weekSelector.value;
         if (!year || !week) {
             showToast("Bitte Jahr und KW auswählen.", 'error');
             return;
         }
         try {
             const response = await publishWeek(target, publish); // API call from planer-api.js
             if (response.success) {
                 showToast(response.message, 'success');
                 loadPlanData(); // Reload data to reflect new publish status
             }
             // Errors handled by apiFetch
         } catch(error) {}
     };

     // --- Top-Level Event Listeners ---
     DOM.viewModeSelector.addEventListener('change', handleViewModeChange);
     DOM.classSelector.addEventListener('change', loadPlanData);
     DOM.teacherSelector.addEventListener('change', loadPlanData);
     DOM.yearSelector.addEventListener('change', loadPlanData);
     DOM.weekSelector.addEventListener('change', loadPlanData);
     DOM.dateSelector.addEventListener('change', handleDateOrWeekChange);

     DOM.publishStudentBtn.addEventListener('click', () => handlePublishAction('student', true));
     DOM.unpublishStudentBtn.addEventListener('click', () => handlePublishAction('student', false));
     DOM.publishTeacherBtn.addEventListener('click', () => handlePublishAction('teacher', true));
     DOM.unpublishTeacherBtn.addEventListener('click', () => handlePublishAction('teacher', false));

     // --- Timetable Grid Interaktionen (Click for selection, Double Click for modal) ---
     DOM.timetableContainer.addEventListener('click', (e) => {
         const cell = e.target.closest('.grid-cell');
         const state = getState();
         // Ignore clicks outside cells or if no class/teacher is selected
         if (!cell || !(state.selectedClassId || state.selectedTeacherId)) {
             clearSelectionState(state.selection.cells); // Clear selection if clicking outside valid area
             return;
         }
         // KORREKTUR: Übergebe den Container an handleCellClick
         handleCellClick(cell, DOM.timetableContainer);
 
         // Open modal on double click if a cell is selected
         if (e.detail === 2 && getState().selection.cells.length > 0) {
             openModal(false); // Open regular entry modal ('false' means not template editor)
         }
     });


     // --- Drag & Drop ---
     DOM.timetableContainer.addEventListener('dragstart', (e) => {
         const cell = e.target.closest('.grid-cell[draggable="true"]');
         const state = getState();
         if (!cell || !(state.selectedClassId || state.selectedTeacherId)) {
             e.preventDefault(); return;
         }

         const entryId = cell.dataset.entryId;
         const blockId = cell.dataset.blockId;
         const substitutionId = cell.dataset.substitutionId;

         let entryData = null; // Data of the dragged item (first entry of block, or single)
         let entryType = null;
         let span = 1;
         let blockStartCell = cell; // Cell representing the start of the block/entry
         let originalSubIds = []; // Stores IDs for each hour of a substitution block
         let originalRegularEntryId = null; // Store ID of underlying regular entry/block start
         let originalRegularBlockId = null;
         let underlyingRegularEntries = []; // *** Store ALL underlying entries ***

         if (substitutionId) {
             entryType = 'substitution';
             // Find the actual start cell of the substitution block in the DOM
             let currentPeriodCheck = parseInt(cell.dataset.period);
             while (currentPeriodCheck > 1) {
                 const prevCell = DOM.timetableContainer.querySelector(`.grid-cell[data-day='${cell.dataset.day}'][data-period='${currentPeriodCheck - 1}']`);
                 // Adjusted check: Use substitutionId from the initial cell if moving within the block
                 // Important: Check if prevCell even has a substitution ID before comparing
                 if (prevCell && prevCell.dataset.substitutionId && prevCell.dataset.substitutionId === substitutionId) {
                     blockStartCell = prevCell;
                     currentPeriodCheck--;
                 } else {
                     break;
                 }
             }
             // Get data associated with the start cell
             entryData = state.currentSubstitutions.find(s => s.substitution_id == blockStartCell.dataset.substitutionId);
             
             if (!entryData) { // Fallback if entryData not found (should not happen)
                 console.error("DragStart Error: Could not find substitution data for start cell.", blockStartCell.dataset);
                 e.preventDefault();
                 return;
             }

             // Calculate span based on DOM grid-row style (most reliable way)
             if (blockStartCell && blockStartCell.style.gridRow) {
                 const spanMatch = blockStartCell.style.gridRow.match(/span\s*(\d+)/);
                 if (spanMatch && spanMatch[1]) {
                     span = parseInt(spanMatch[1]);
                 }
             } else {
                 // Fallback: check consecutive entries in data
                 const relatedSubs = state.currentSubstitutions.filter(s =>
                     s.day_of_week == blockStartCell.dataset.day &&
                     s.class_id == entryData.class_id &&
                     s.substitution_type == entryData.substitution_type &&
                     s.new_teacher_id == entryData.new_teacher_id &&
                     s.new_subject_id == entryData.new_subject_id &&
                     s.new_room_id == entryData.new_room_id &&
                     s.comment == entryData.comment
                 ).sort((a, b) => a.period_number - b.period_number);

                 let consecutiveCount = 0;
                 if (relatedSubs.length > 0) {
                     const startPeriodInBlock = parseInt(blockStartCell.dataset.period);
                     const startIndex = relatedSubs.findIndex(s => s.period_number == startPeriodInBlock);
                     if (startIndex > -1) {
                         consecutiveCount = 1;
                         for (let i = startIndex; i < relatedSubs.length - 1; i++) {
                             if (relatedSubs[i+1].period_number == relatedSubs[i].period_number + 1) {
                                 consecutiveCount++;
                             } else {
                                 break;
                             }
                         }
                     }
                 }
                 span = consecutiveCount > 0 ? consecutiveCount : 1;
             }
             // *** ENDE SPAN-ERMITTLUNG ***


             // Store all original substitution IDs AND find underlying regular entry info
             originalSubIds = []; // Reset array
             underlyingRegularEntries = []; // Reset array

             for (let i = 0; i < span; i++) {
                 const currentPeriod = parseInt(blockStartCell.dataset.period) + i;
                 // Find the cell in the DOM for this hour
                 const cellInBlock = DOM.timetableContainer.querySelector(`.grid-cell[data-day='${blockStartCell.dataset.day}'][data-period='${currentPeriod}']`);
                 // Find the data entry for this substitution hour
                 const subForThisHour = state.currentSubstitutions.find(s => 
                     s.day_of_week == blockStartCell.dataset.day &&
                     s.period_number == currentPeriod &&
                     // Check properties against the *first* entry's data to ensure it's the same block
                     s.class_id == entryData.class_id &&
                     s.substitution_type == entryData.substitution_type &&
                     s.new_teacher_id == entryData.new_teacher_id &&
                     s.new_subject_id == entryData.new_subject_id &&
                     s.new_room_id == entryData.new_room_id &&
                     s.comment == entryData.comment
                 );

                 if (subForThisHour) {
                     originalSubIds.push(subForThisHour.substitution_id); // Push the ID found in the data
                 } else {
                     // Fallback to DOM cell ID if data search fails (less reliable)
                     const subIdForThisHour = cellInBlock?.dataset?.substitutionId;
                     if (subIdForThisHour) {
                         originalSubIds.push(subIdForThisHour);
                         console.warn(`DragStart: Using fallback DOM ID for sub period ${currentPeriod}`);
                     } else {
                         console.error(`DragStart: Could not find substitution ID for period ${currentPeriod} in dragged block (Sub ID group: ${entryData?.substitution_id}).`);
                         originalSubIds.push(null); // Add null placeholder
                     }
                 }


                 // Find underlying regular entry for this specific hour
                 const regularEntry = state.currentTimetable.find(e => e.day_of_week == blockStartCell.dataset.day && e.period_number == currentPeriod);
                 if (regularEntry) {
                     underlyingRegularEntries.push(regularEntry); // Store the full entry
                     if (i === 0) { // Store first entry's IDs for API check
                         originalRegularBlockId = regularEntry.block_id || null;
                         originalRegularEntryId = regularEntry.entry_id || null;
                     }
                 } else {
                     underlyingRegularEntries.push(null); // Push null if no underlying entry
                 }
             }

         } else if (blockId) {
             entryType = 'block';
             entryData = state.currentTimetable.find(e => e.block_id == blockId);
             blockStartCell = DOM.timetableContainer.querySelector(`.grid-cell[data-block-id='${blockId}'][style*='grid-row: span']`) || cell;
             const periods = state.currentTimetable.filter(e => e.block_id == blockId).map(e => parseInt(e.period_number));
             span = periods.length > 0 ? Math.max(...periods) - Math.min(...periods) + 1 : 1;
             originalRegularBlockId = blockId; // Store the block ID itself

         } else if (entryId) {
             entryType = 'entry';
             entryData = state.currentTimetable.find(e => e.entry_id == entryId);
             blockStartCell = cell;
             span = 1;
             originalRegularEntryId = entryId; // Store the entry ID itself
         }

         if (!entryData) {
             console.error("DragStart Error: Could not find entry data for dragged item.", { entryId, blockId, substitutionId });
             e.preventDefault();
             return;
          }

         clearSelectionState(state.selection.cells);
         updateState({
             dragData: {
                 type: entryType,
                 data: entryData,
                 span: span,
                 originalDay: blockStartCell.dataset.day,
                 originalPeriod: parseInt(blockStartCell.dataset.period),
                 originalSubIds: originalSubIds, // Store substitution IDs
                 originalRegularEntryId: originalRegularEntryId, // Store underlying entry ID (of first hour)
                 originalRegularBlockId: originalRegularBlockId,  // Store underlying block ID (of first hour)
                 underlyingRegularEntries: underlyingRegularEntries || [] // *** Store ALL underlying entries ***
             }
         });
         console.log("Drag Start Data:", getState().dragData); // Log drag data

         setTimeout(() => {
             for (let i = 0; i < span; i++) {
                 const currentPeriod = parseInt(blockStartCell.dataset.period) + i;
                 const cellInBlock = DOM.timetableContainer.querySelector(`.grid-cell[data-day='${blockStartCell.dataset.day}'][data-period='${currentPeriod}']`);
                 if (cellInBlock) {
                     cellInBlock.classList.add('dragging');
                 }
             }
         }, 0);
         DOM.timetableContainer.classList.add('is-dragging');
     });

     DOM.timetableContainer.addEventListener('dragover', async (e) => {
         e.preventDefault(); // Necessary to allow dropping
         const cell = e.target.closest('.grid-cell');
         const state = getState();

         // Ignore if not over a valid cell, no drag data, or same cell as before
         if (!cell || !state.dragData || cell === state.lastDragOverCell) return;

         // Clear previous target styling
         if (state.lastDragOverCell) {
             state.lastDragOverCell.classList.remove('drop-target', 'drop-target-valid', 'drop-target-invalid');
             delete state.lastDragOverCell.dataset.conflictError;
         }
         updateState({ lastDragOverCell: cell }); // Store current cell
         cell.classList.add('drop-target'); // Basic target styling

         const targetDay = cell.dataset.day;
         const targetStartPeriod = parseInt(cell.dataset.period);
         const targetEndPeriod = targetStartPeriod + state.dragData.span - 1;

         // --- Basic validity checks ---
         // Check if it fits vertically
         if (targetEndPeriod > DOM.timeSlots.length) {
             cell.classList.add('drop-target-invalid');
             cell.dataset.conflictError = "Eintrag passt nicht auf den Plan (zu lang).";
             return;
         }

         // Check if any target cell is already occupied (by a DIFFERENT entry/block/sub)
          for (let p = targetStartPeriod; p <= targetEndPeriod; p++) {
              const targetCell = DOM.timetableContainer.querySelector(`.grid-cell[data-day='${targetDay}'][data-period='${p}']`);
              // Check if targetCell exists AND has an entry (ignore placeholders like FU)
              if (targetCell && targetCell.classList.contains('has-entry') ) {
                  let isSelf = false; // Is the occupied cell part of the item being dragged?
                  const draggedItemType = state.dragData.type;
                  
                  // *** KORRIGIERTE isSelf LOGIK ***
                  if (draggedItemType === 'substitution') {
                      // Check if the target substitution ID is one of the IDs being dragged
                      isSelf = targetCell.dataset.substitutionId && state.dragData.originalSubIds.includes(targetCell.dataset.substitutionId);
                  } else if (draggedItemType === 'block') {
                      // Check if the target cell belongs to the dragged block
                      isSelf = targetCell.dataset.blockId && targetCell.dataset.blockId === state.dragData.originalRegularBlockId;
                  } else if (draggedItemType === 'entry') {
                      // Check if the target cell is the dragged entry
                      isSelf = targetCell.dataset.entryId && targetCell.dataset.entryId === state.dragData.originalRegularEntryId;
                  }
                  // *** ENDE KORREKTUR ***

                  if (!isSelf) { // If occupied by something else
                      cell.classList.add('drop-target-invalid');
                      const conflictType = targetCell.dataset.substitutionId ? "Vertretung" : "Unterricht";
                      cell.dataset.conflictError = `KONFLIKT (Slot belegt): In diesem Zeitraum existiert bereits ${conflictType}.`;
                      return; // Stop further checks if occupied
                  }
              }
          }


         // --- Conflict check via API (only for regular entries/blocks AND substitutions if underlying entry exists) ---
         // Substitutions moving to an empty slot don't need API check.
         // If moving a substitution AND the underlying regular entry exists, we need to check conflicts for the regular entry move.
         let needsApiCheck = state.dragData.type !== 'substitution' || (state.dragData.originalRegularEntryId || state.dragData.originalRegularBlockId);

         if (!needsApiCheck) {
             cell.classList.add('drop-target-valid');
             updateState({ lastConflictCheckPromise: Promise.resolve({ success: true, conflicts: [] }) }); // Mock promise
             return;
         }

         // Prepare data for API conflict check (for the REGULAR entry being moved, even if dragging substitution)
          // Find the actual regular entry data using the stored IDs
          const regularEntryData = state.dragData.originalRegularBlockId
             ? state.currentTimetable.find(e => e.block_id === state.dragData.originalRegularBlockId)
             : state.currentTimetable.find(e => e.entry_id == state.dragData.originalRegularEntryId);

         // Only run API check if we found the underlying regular entry data
         if (!regularEntryData) {
             // If dragging a substitution without an underlying entry, treat as valid
             cell.classList.add('drop-target-valid');
             updateState({ lastConflictCheckPromise: Promise.resolve({ success: true, conflicts: [] }) });
             return;
         }


         const checkData = {
             year: DOM.yearSelector.value,
             calendar_week: DOM.weekSelector.value,
             day_of_week: targetDay,
             start_period_number: targetStartPeriod,
             end_period_number: targetEndPeriod,
             teacher_id: regularEntryData.teacher_id, // Use teacher from the actual regular entry
             room_id: regularEntryData.room_id,     // Use room from the actual regular entry
             class_id: regularEntryData.class_id,   // Use class from the actual regular entry
             // Exclude the original entry/block being moved from the check
             entry_id: state.dragData.originalRegularEntryId,
             block_id: state.dragData.originalRegularBlockId,
         };

         try {
             // Store the promise in state immediately
             const conflictCheckPromise = checkConflicts(checkData);
              updateState({ lastConflictCheckPromise: conflictCheckPromise });
             // Await the result
             await conflictCheckPromise;
             // If the promise resolves without error, it's valid (checkConflicts throws on error)
             // Check if we are still hovering over the same cell
              if (cell === getState().lastDragOverCell) {
                  cell.classList.add('drop-target-valid');
              }
         } catch (error) {
             // If checkConflicts throws an error, it's invalid
              if (cell === getState().lastDragOverCell) {
                  cell.classList.add('drop-target-invalid');
                  cell.dataset.conflictError = error.message; // Store the conflict message
              }
         }
     });

     DOM.timetableContainer.addEventListener('dragleave', (e) => {
         const cell = e.target.closest('.grid-cell');
         const state = getState();
         // Remove styling only if leaving the cell we were last over
         if (cell && cell === state.lastDragOverCell) {
             cell.classList.remove('drop-target', 'drop-target-valid', 'drop-target-invalid');
             delete cell.dataset.conflictError;
             updateState({ lastDragOverCell: null }); // Reset last hovered cell
         }
     });

     DOM.timetableContainer.addEventListener('dragend', (e) => {
         // Clean up visual styles from all potentially dragged cells
          const draggedCells = DOM.timetableContainer.querySelectorAll('.grid-cell.dragging');
          draggedCells.forEach(cell => cell.classList.remove('dragging'));

         DOM.timetableContainer.classList.remove('is-dragging'); // Remove grid container class

         const state = getState();
         // Clean up target styling from the last hovered cell
         if (state.lastDragOverCell) {
             state.lastDragOverCell.classList.remove('drop-target', 'drop-target-valid', 'drop-target-invalid');
             delete state.lastDragOverCell.dataset.conflictError;
         }
         // Reset drag-related state
         updateState({ dragData: null, lastDragOverCell: null, lastConflictCheckPromise: null });
     });

     DOM.timetableContainer.addEventListener('drop', async (e) => {
         e.preventDefault(); // Prevent default drop behavior
         const cell = e.target.closest('.grid-cell');
         const state = getState();
         if (!cell || !state.dragData) return; // Exit if no drop target or no drag data

         // --- Final validation before saving ---
         // 1. Check for explicit invalid marker from dragover
         if (cell.classList.contains('drop-target-invalid')) {
             const errorMessage = cell.dataset.conflictError || "Ablegen nicht möglich: Konflikt.";
             showToast(errorMessage.split("\n")[0], 'error', 4000); // Show first line of error
             return;
         }
         // 2. Check if the cell wasn't marked valid (e.g., dragover check pending or failed silently)
         if (!cell.classList.contains('drop-target-valid')) {
             // Attempt to re-validate using the stored promise if available
             try {
                 let needsApiCheck = state.dragData.type !== 'substitution' || (state.dragData.originalRegularEntryId || state.dragData.originalRegularBlockId);
                 if (state.lastConflictCheckPromise && needsApiCheck) {
                     await state.lastConflictCheckPromise; // Wait for the check result
                 } else if (needsApiCheck) {
                     // If no promise exists and API check is needed, assume invalid
                     showToast("Ablegen nicht möglich: Konfliktprüfung unvollständig.", 'error');
                     return;
                 }
                  // If it's a substitution moving to empty or over itself, basic checks suffice
             } catch (error) {
                 // Conflict confirmed by awaiting the promise
                 showToast(error.message.split("\n")[0], 'error', 4000);
                 return;
             }
         }
          // 3. Re-check vertical fit (redundant but safe)
          const targetStartPeriod = parseInt(cell.dataset.period);
          const targetEndPeriod = targetStartPeriod + state.dragData.span - 1;
          if (targetEndPeriod > DOM.timeSlots.length) {
              showToast("Ablegen nicht möglich: Eintrag passt nicht in den Plan.", 'error');
              return;
          }

         // --- Prepare save data ---
         const targetDay = cell.dataset.day;
         const entryData = state.dragData.data; // Data of the first entry
         const savePromises = []; // Array to hold all promises for saving

         const currentYear = DOM.yearSelector.value;
         const currentWeek = DOM.weekSelector.value;
         const newDate = getDateForDayInWeek(targetDay, currentYear, currentWeek);

         console.log("--- Drop Event ---"); // Log drop event start
         console.log("Drag Data:", state.dragData); // Log the full drag data
         console.log("Target Cell:", { day: targetDay, period: targetStartPeriod }); // Log target cell

         // --- Handle Moving Substitution (and potentially underlying regular entry) ---
         if (state.dragData.type === 'substitution') {
             const originalSubIds = state.dragData.originalSubIds || [];
             const underlyingRegularEntries = state.dragData.underlyingRegularEntries || [];
             console.log("Moving Substitution Block - Original Sub IDs:", originalSubIds);
             console.log("Moving underlying regular entries:", underlyingRegularEntries);

             // 1. Move the underlying regular entries/blocks
             const movedRegularIds = new Set(); // Track moved regular entries/blocks
             for (let i = 0; i < underlyingRegularEntries.length; i++) {
                 const regularEntry = underlyingRegularEntries[i];
                 if (!regularEntry) continue; // Skip if underlying entry was null

                 const idToMove = regularEntry.block_id || regularEntry.entry_id;
                 const idType = regularEntry.block_id ? 'block_id' : 'entry_id';
                 
                 if (!idToMove || movedRegularIds.has(idToMove)) {
                     continue; // Skip if no ID or already processed (part of a block)
                 }
                 
                 movedRegularIds.add(idToMove);

                 // Calculate the span of this specific regular entry/block
                 let regularEntrySpan = 1;
                 if (regularEntry.block_id) {
                     const periods = state.currentTimetable
                         .filter(e => e.block_id === regularEntry.block_id)
                         .map(e => parseInt(e.period_number));
                     regularEntrySpan = periods.length > 0 ? Math.max(...periods) - Math.min(...periods) + 1 : 1;
                 }
                 
                 // Calculate new start/end period for this regular entry
                 // Find the *original* period for this regular entry
                 const originalPeriodForThisEntry = parseInt(regularEntry.period_number);
                 // Calculate its offset from the *start* of the dragged block
                 const periodOffset = originalPeriodForThisEntry - state.dragData.originalPeriod;
                 
                 const newStartPeriod = targetStartPeriod + periodOffset;
                 const newEndPeriod = newStartPeriod + regularEntrySpan - 1;

                 // Check if the move is valid (within bounds, etc.) - simple check
                 if (newEndPeriod > DOM.timeSlots.length) {
                     console.warn(`Skipping move of underlying entry ${idToMove}, would fall off grid.`);
                     continue;
                 }

                 const regularSaveData = {
                     entry_id: (idType === 'entry_id' ? idToMove : null),
                     block_id: (idType === 'block_id' ? idToMove : null),
                     year: currentYear,
                     calendar_week: currentWeek,
                     day_of_week: targetDay,
                     start_period_number: newStartPeriod,
                     end_period_number: newEndPeriod,
                     class_id: regularEntry.class_id,
                     teacher_id: regularEntry.teacher_id,
                     subject_id: regularEntry.subject_id,
                     room_id: regularEntry.room_id,
                     comment: regularEntry.comment || null
                 };
                 console.log("Moving underlying regular entry:", regularSaveData);
                 savePromises.push(saveEntry(regularSaveData));
             }

             // 2. Move each substitution entry
             for (let i = 0; i < state.dragData.span; i++) {
                 const currentTargetPeriod = targetStartPeriod + i;
                 const originalSubId = originalSubIds[i]; // Use the ID stored for this index

                 console.log(`Processing hour ${i + 1}/${state.dragData.span}: TargetPeriod=${currentTargetPeriod}, OriginalSubId=${originalSubId}`);

                 if (!originalSubId) {
                     console.error(`Drop Error: Missing original substitution ID for index ${i} in dragged block.`);
                     showToast(`Fehler beim Verschieben von Stunde (Index ${i}). Original-ID fehlt.`, 'error');
                     continue; // Skip this part
                 }

                 // Find the full original data using the ID (needed for details like comment etc.)
                 const originalSubData = state.currentSubstitutions.find(s => s.substitution_id == originalSubId);

                 if (!originalSubData) {
                     console.error(`Drop Error: Could not find original substitution data for ID ${originalSubId}.`);
                     showToast(`Fehler beim Verschieben von Stunde mit ID ${originalSubId}. Originaldaten nicht gefunden.`, 'error');
                     continue; // Skip this part
                 }

                 const subSaveData = {
                     ...originalSubData, // Copy all existing details
                     substitution_id: originalSubData.substitution_id, // The ID of the entry being updated
                     date: newDate, // The NEW date
                     period_number: currentTargetPeriod, // The NEW period
                 };
                  console.log(`Substitution Save Data (ID: ${originalSubId}):`, subSaveData);
                 savePromises.push(saveSubstitution(subSaveData));
             }

         }
         // --- Handle Moving Regular Entry/Block ---
         else {
              console.log("Moving Regular Entry/Block:", { id: state.dragData.originalRegularEntryId || state.dragData.originalRegularBlockId, type: state.dragData.type });
             const saveData = {
                 entry_id: state.dragData.originalRegularEntryId, // Use stored original ID
                 block_id: state.dragData.originalRegularBlockId, // Use stored original ID
                 year: currentYear,
                 calendar_week: currentWeek,
                 day_of_week: targetDay,
                 start_period_number: targetStartPeriod,
                 end_period_number: targetEndPeriod,
                 class_id: entryData.class_id, // Data from the first entry of the block
                 teacher_id: entryData.teacher_id,
                 subject_id: entryData.subject_id,
                 room_id: entryData.room_id,
                 comment: entryData.comment || null
             };
              console.log("Regular Save Data:", saveData);
             savePromises.push(saveEntry(saveData)); // Single promise for regular entry/block
         }

         // --- Execute all save operations ---
         try {
              console.log(`Executing ${savePromises.length} save operations...`);
             const results = await Promise.all(savePromises);
             console.log("Save Results:", results);
             // Check if all promises resolved successfully
             const success = results.every(response => response && response.success);

             if (success) {
                 showToast("Eintrag erfolgreich verschoben.", 'success');
                 loadPlanData(); // Reload grid
             } else {
                 // Find the first error message if any promise failed
                 const firstErrorResult = results.find(r => !(r && r.success));
                 const firstError = firstErrorResult?.message; // Get message from the failed response
                 console.error("Fehler beim Speichern (Promise.all):", firstErrorResult);
                 throw new Error(firstError || "Unbekannter Fehler beim Verschieben.");
             }
         } catch (error) {
             // Error handled by apiFetch for individual calls, or thrown above for Promise.all failure
             console.error("Drop save error (catch):", error); // Log the specific error
             // Reload grid anyway to revert visual changes on error
             loadPlanData();
         }
     });


     // --- Action Modal Handlers (Copy, Templates) ---
     initializeActionModals(); // From this file

      // --- Template Editor Grid Handler ---
      DOM.templateEditorGridContainer.addEventListener('click', (e) => {
          const cell = e.target.closest('.grid-cell.template-cell');
          if (!cell) {
              clearSelectionState(getState().selection.cells); // Clear selection if clicking outside cells
              return;
          }
          // KORREKTUR: Übergebe den Template-Container an handleCellClick
          handleCellClick(cell, DOM.templateEditorGridContainer);

          // Open modal on double click
          if (e.detail === 2) {
              openModal(true); // 'true' = Template-Editor mode
          }
      });

     // --- Starte den Ladevorgang --- // Moved to planer-dashboard.js
     // loadInitialData().then(() => { ... });
 }


 /**
  * Initialisiert die Event-Listener für die Aktions-Modals (Kopieren, Vorlagen).
  */
 function initializeActionModals() {
     // --- Kopiermodal ---
     const openCopyModal = () => {
         const state = getState();
         if (!state.selectedClassId && !state.selectedTeacherId) {
             showToast("Bitte zuerst eine Klasse oder einen Lehrer auswählen.", 'error');
             return;
         }
         DOM.copySourceDisplay.value = `KW ${DOM.weekSelector.value} / ${DOM.yearSelector.value}`;
         // Calculate next week for default target
         const currentMonday = getDateOfISOWeek(parseInt(DOM.weekSelector.value), parseInt(DOM.yearSelector.value));
         const nextWeekDate = new Date(currentMonday.getTime() + 7 * 24 * 60 * 60 * 1000);
         const { week: nextWeek, year: nextYear } = getWeekAndYear(nextWeekDate);
         populateYearSelector(DOM.copyTargetYear, nextYear);
         populateWeekSelector(DOM.copyTargetWeek, nextWeek);
         DOM.copyWeekModal.classList.add('visible');
     };
     const closeCopyModal = () => DOM.copyWeekModal.classList.remove('visible');

     DOM.copyWeekBtn.addEventListener('click', openCopyModal);
     DOM.copyWeekCancelBtn.addEventListener('click', closeCopyModal);
     DOM.copyWeekModal.addEventListener('click', (e) => { if (e.target.id === 'copy-week-modal') closeCopyModal(); });

     DOM.copyWeekForm.addEventListener('submit', async (e) => {
         e.preventDefault();
         const state = getState();
         const sourceYear = parseInt(DOM.yearSelector.value);
         const sourceWeek = parseInt(DOM.weekSelector.value);
         const targetYear = parseInt(DOM.copyTargetYear.value);
         const targetWeek = parseInt(DOM.copyTargetWeek.value);

         if (sourceYear === targetYear && sourceWeek === targetWeek) {
             showToast("Fehler: Quell- und Zielwoche dürfen nicht identisch sein.", 'error');
             return;
         }
         const entityName = state.currentViewMode === 'class'
             ? `Klasse ${state.selectedClassId}`
             : `Lehrer ${DOM.teacherSelector.options[DOM.teacherSelector.selectedIndex]?.text || state.selectedTeacherId}`; // Add fallback

         if (await showConfirm("Kopieren bestätigen", `Sind Sie sicher, dass Sie den Plan für '${escapeHtml(entityName)}' von KW ${sourceWeek}/${sourceYear} nach KW ${targetWeek}/${targetYear} kopieren möchten? Alle Einträge in der Zielwoche werden überschrieben.`)) {
             const body = { sourceYear, sourceWeek, targetYear, targetWeek, classId: state.selectedClassId, teacherId: state.selectedTeacherId };
             try {
                 const response = await copyWeek(body);
                 if (response.success) {
                     showToast(response.message, 'success');
                     closeCopyModal();
                     // Switch view to the target week
                     DOM.yearSelector.value = targetYear;
                     DOM.weekSelector.value = targetWeek;
                     loadPlanData();
                 }
                 // Errors handled by apiFetch
             } catch (error) { /* Error already shown */ }
         }
     });

     // --- Vorlagen-Modals ---
     const openManageTemplatesModal = async () => {
         DOM.manageTemplatesForm.reset();
         const templates = await loadTemplates(); // Lädt Vorlagen neu und gibt Daten zurück
         renderTemplatesList(templates); // Rendert die Liste
         showTemplateView('list'); // Start in list view
         DOM.manageTemplatesModal.classList.add('visible');
     };
     const closeManageTemplatesModal = () => DOM.manageTemplatesModal.classList.remove('visible');
     const openApplyTemplateModal = async () => {
         const state = getState();
         if (!state.selectedClassId && !state.selectedTeacherId) {
             showToast("Bitte zuerst eine Klasse oder einen Lehrer auswählen.", 'error');
             return;
         }
         await loadTemplates(); // Stellt sicher, dass Liste aktuell ist (rendert Select neu)
         DOM.applyTemplateForm.reset();
         DOM.applyTemplateModal.classList.add('visible');
     };
     const closeApplyTemplateModal = () => DOM.applyTemplateModal.classList.remove('visible');

     DOM.createTemplateBtn.addEventListener('click', () => {
         const state = getState();
         if (!state.selectedClassId && !state.selectedTeacherId) {
             showToast("Bitte zuerst eine Klasse oder einen Lehrer auswählen, um eine Vorlage zu erstellen.", 'error');
             return;
         }
         if (state.currentTimetable.length === 0) {
             showToast("Die aktuelle Woche enthält keine Einträge zum Speichern als Vorlage.", 'info');
             return;
         }
         openManageTemplatesModal(); // Opens the manage modal where the create form is
     });
     DOM.applyTemplateBtn.addEventListener('click', openApplyTemplateModal);
     DOM.manageTemplatesBtn.addEventListener('click', openManageTemplatesModal);
     DOM.manageTemplatesCloseBtn.addEventListener('click', closeManageTemplatesModal);
     DOM.applyTemplateCancelBtn.addEventListener('click', closeApplyTemplateModal);
     // Close modals on overlay click
     DOM.manageTemplatesModal.addEventListener('click', (e) => { if (e.target.id === 'manage-templates-modal') closeManageTemplatesModal(); });
     DOM.applyTemplateModal.addEventListener('click', (e) => { if (e.target.id === 'apply-template-modal') closeApplyTemplateModal(); });

     // Submit: Create template from current week
     DOM.manageTemplatesForm.addEventListener('submit', async (e) => {
         e.preventDefault();
         const templateNameInput = DOM.manageTemplatesForm.querySelector('#template-name');
         const templateDescriptionInput = DOM.manageTemplatesForm.querySelector('#template-description');

         const templateName = templateNameInput ? templateNameInput.value.trim() : '';
         const templateDescription = templateDescriptionInput ? templateDescriptionInput.value.trim() : '';

         if (!templateName) {
             showToast("Bitte geben Sie einen Namen für die Vorlage ein.", 'error');
             return;
         }
         const state = getState();
         const body = {
             name: templateName,
             description: templateDescription || null,
             sourceYear: DOM.yearSelector.value,
             sourceWeek: DOM.weekSelector.value,
             sourceClassId: state.selectedClassId,
             sourceTeacherId: state.selectedTeacherId
         };
         try {
             const response = await createTemplate(body);
             if (response.success) {
                 showToast(response.message, 'success');
                 DOM.manageTemplatesForm.reset();
                 const templates = await loadTemplates(); // Reload list and return data
                 renderTemplatesList(templates); // Render updated list
             }
              // Errors (like duplicate name) handled by apiFetch
         } catch (error) { /* Error already shown */ }
     });

      // Submit: Apply selected template to current week
     DOM.applyTemplateForm.addEventListener('submit', async (e) => {
         e.preventDefault();
         const templateId = DOM.applyTemplateSelect.value;
         if (!templateId) {
             showToast("Bitte wählen Sie eine Vorlage aus.", 'error');
             return;
         }
         const targetYear = DOM.yearSelector.value;
         const targetWeek = DOM.weekSelector.value;
         if (!targetYear || !targetWeek) return; // Should not happen
         const state = getState();

         if (await showConfirm("Vorlage anwenden", "Sind Sie sicher? Alle Einträge für die aktuelle Auswahl in dieser Woche werden überschrieben.")) {
             const body = {
                 templateId: templateId,
                 targetYear: targetYear,
                 targetWeek: targetWeek,
                 targetClassId: state.selectedClassId,
                 targetTeacherId: state.selectedTeacherId
             };
             try {
                 const response = await applyTemplate(body);
                 if (response.success) {
                     showToast(response.message, 'success');
                     closeApplyTemplateModal();
                     loadPlanData(); // Reload grid with applied template
                 }
                  // Errors handled by apiFetch
             } catch (error) { /* Error already shown */ }
         }
     });

     // --- Template Editor Buttons ---
      DOM.createEmptyTemplateBtn.addEventListener('click', () => {
          updateState({ 
             currentTemplateEditorData: [], // Start with empty data
             currentEditingTemplateId: null // Ensure no ID is set
          }); 
          DOM.templateEditorTitle.textContent = 'Neue leere Vorlage erstellen';
          const nameInput = DOM.manageTemplatesModal.querySelector('#template-editor-name');
          const descInput = DOM.manageTemplatesModal.querySelector('#template-editor-description');
          if(nameInput) nameInput.value = '';
          if(descInput) descInput.value = '';
          populateAllModalSelects(getState().stammdaten); // Ensure modal selects are populated
          renderTimetable(getState(), true); // Render empty grid in editor mode
          showTemplateView('editor');
      });

      DOM.backToTemplateListBtn.addEventListener('click', () => {
          // TODO: Add warning if changes are unsaved
          showTemplateView('list');
          updateState({ 
             currentTemplateEditorData: null, // Clear editor data
             currentEditingTemplateId: null // Clear editing ID
         }); 
      });

      DOM.saveTemplateEditorBtn.addEventListener('click', async () => {
         const state = getState();
         const name = DOM.manageTemplatesModal.querySelector('#template-editor-name').value.trim();
         const description = DOM.manageTemplatesModal.querySelector('#template-editor-description').value.trim();
         const templateId = state.currentEditingTemplateId; // Get ID (null if new)
         const entries = state.currentTemplateEditorData || [];

         if (!name) {
             showToast("Bitte einen Vorlagennamen eingeben.", 'error');
             return;
         }

         const templateData = {
             template_id: templateId,
             name: name,
             description: description || null,
             entries: entries
         };

         try {
             const response = await saveTemplate(templateData);
             if (response.success) {
                 showToast(response.message, 'success');
                 updateState({ currentTemplateEditorData: null, currentEditingTemplateId: null });
                 const templates = await loadTemplates(); // Reload all templates
                 renderTemplatesList(templates); // Re-render the list
                 showTemplateView('list'); // Switch back to list view
             }
             // Errors (like duplicate name) handled by apiFetch
         } catch (error) { /* Error already shown */ }
      });
 }

 /** Rendert die Liste der Vorlagen im Verwalten-Modal */
 export const renderTemplatesList = (templates) => {
     if (!DOM.manageTemplatesList) return;
     if (!Array.isArray(templates)) { // Add check if templates is an array
         console.error("renderTemplatesList: Input 'templates' is not an array.", templates);
         DOM.manageTemplatesList.innerHTML = '<p class="message error">Fehler beim Anzeigen der Vorlagen.</p>';
         return;
     }
     if (templates.length === 0) {
         DOM.manageTemplatesList.innerHTML = '<p>Keine Vorlagen vorhanden.</p>';
         return;
     }
     DOM.manageTemplatesList.innerHTML = `
         <table class="data-table templates-list-table">
             <thead><tr><th>Name</th><th>Beschreibung</th><th>Aktion</th></tr></thead>
             <tbody>
                 ${templates.map(t => `
                     <tr data-id="${t.template_id}">
                         <td>${escapeHtml(t.name)}</td>
                         <td>${escapeHtml(t.description) || '-'}</td>
                         <td class="actions">
                             <button class="btn btn-warning btn-small edit-template" data-id="${t.template_id}">Bearbeiten</button>
                             <button class="btn btn-danger btn-small delete-template" data-name="${escapeHtml(t.name)}">Löschen</button>
                         </td>
                     </tr>
                 `).join('')}
             </tbody>
         </table>
     `;
     // Add event listeners AFTER rendering
     DOM.manageTemplatesList.querySelectorAll('.delete-template').forEach(button => {
         button.addEventListener('click', handleDeleteTemplateClick);
     });
     // NEU: Event listener for Edit buttons
     DOM.manageTemplatesList.querySelectorAll('.edit-template').forEach(button => {
         button.addEventListener('click', handleEditTemplateClick);
     });
 };

 /** Behandelt Klick auf "Vorlage bearbeiten" */
 async function handleEditTemplateClick(e) {
     const button = e.target;
     const templateId = button.dataset.id;
     if (!templateId) return;

     try {
         const response = await loadTemplateDetails(templateId);
         if (response.success && response.data) {
             const { template, entries } = response.data;
             // Populate state for the editor
             updateState({
                 currentTemplateEditorData: entries || [],
                 currentEditingTemplateId: template.template_id
             });
             // Set editor form fields
             DOM.templateEditorTitle.textContent = 'Vorlage bearbeiten';
             const nameInput = DOM.manageTemplatesModal.querySelector('#template-editor-name');
             const descInput = DOM.manageTemplatesModal.querySelector('#template-editor-description');
             if (nameInput) nameInput.value = template.name;
             if (descInput) descInput.value = template.description || '';
             
             // Render the grid with the template entries
             renderTimetable(getState(), true); 
             // Switch to the editor view
             showTemplateView('editor');
         }
     } catch (error) { /* Error handled by apiFetch */ }
 }


 /** Behandelt Klick auf "Vorlage löschen" */
 async function handleDeleteTemplateClick(e) {
     const button = e.target;
     const row = button.closest('tr');
     if (!row) return; // Should not happen
     const templateId = row.dataset.id;
     const templateName = button.dataset.name;

     if (await showConfirm("Vorlage löschen", `Sind Sie sicher, dass Sie die Vorlage "${templateName}" endgültig löschen möchten?`)) {
         try {
             const response = await deleteTemplate(templateId);
             if (response.success) {
                 showToast(response.message, 'success');
                 const updatedTemplates = await loadTemplates(); // Reload templates and return data
                 renderTemplatesList(updatedTemplates); // Render updated list
             }
              // Errors handled by apiFetch
         } catch (error) { /* Error already shown */ }
     }
 }


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-2.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-state.js ---
// --- State Management ---
let state = {
    stammdaten: {}, 
    currentTimetable: [], 
    currentSubstitutions: [],
    currentViewMode: 'class', 
    selectedClassId: null, 
    selectedTeacherId: null,
    selectedDate: null, 
    activeMode: 'regular',
    selection: { start: null, end: null, cells: [] },
    currentPublishStatus: { student: false, teacher: false },
    conflictCheckTimeout: null, // Für Debouncing
    dragData: null, // Für Drag & Drop
    lastDragOverCell: null, // Für Drag & Drop
    lastConflictCheckPromise: null, // Für Drag & Drop
    editingClassId: null, // Speichert die Klasse, die im Modal bearbeitet wird
    templates: [], // Array für geladene Vorlagen
    currentTemplateEditorData: null, // NEU: Daten für den Template-Editor
    currentEditingTemplateId: null // NEU: ID der Vorlage, die bearbeitet wird
};

/**
 * Gibt eine Kopie des aktuellen Zustands zurück.
 * @returns {object} Der aktuelle Zustand.
 */
export function getState() {
    // Gibt eine Kopie zurück, um direkte Mutationen zu verhindern (optional, aber gute Praxis)
    return { ...state };
}

/**
 * Aktualisiert Teile des Zustands.
 * @param {object} newState - Ein Objekt mit den zu aktualisierenden Schlüsseln.
 */
export function updateState(newState) {
    state = { ...state, ...newState };
}

/**
 * Setzt den Auswahlstatus zurück.
 * @param {HTMLElement[]} cells - Die Zellen, deren 'selected'-Klasse entfernt werden soll.
 */
export function clearSelectionState(cells) {
    cells.forEach(cell => cell.classList.remove('selected'));
    state.selection = { start: null, end: null, cells: [] };
}

/**
 * Setzt die Auswahl im Status.
 * @param {object} newSelection - Das neue Auswahl-Objekt.
 */
export function setSelectionState(newSelection) {
    state.selection = newSelection;
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-state.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-timetable.js ---
        import * as DOM from './planer-dom.js';
        import { escapeHtml, getDateForDayInWeek } from './planer-utils.js'; // getDateForDayInWeek importieren
        import { getState } from './planer-state.js'; // Import getState

        /**
         * Rendert das Haupt-Stundenplan-Grid oder das Template-Editor-Grid.
        * @param {object} state - Das aktuelle Anwendungs-State-Objekt.
        * @param {boolean} [isTemplateEditor=false] - Ob das Grid für den Template-Editor gerendert wird.
        */
        export const renderTimetable = (state, isTemplateEditor = false) => {
            console.log("Starte renderTimetable...", { isTemplateEditor }); // Logging hinzugefügt
            const container = isTemplateEditor ? DOM.templateEditorGridContainer : DOM.timetableContainer;
            if (!container) {
                console.error("renderTimetable: Container nicht gefunden!", { isTemplateEditor });
                return;
            }

            // Determine data source based on mode
            const timetableData = isTemplateEditor ? (state.currentTemplateEditorData || []) : state.currentTimetable;
            const substitutionsData = isTemplateEditor ? [] : state.currentSubstitutions;
            // NEU: Abwesenheiten aus dem State holen
            const absencesData = isTemplateEditor ? [] : (state.stammdaten?.absences || []);
            const viewMode = isTemplateEditor ? 'class' : state.currentViewMode; // Default to class view for template editor
            const { stammdaten } = state; // Get Stammdaten from state
            // KORREKTUR: userRole aus globalem Config-Objekt holen
            const userRole = window.APP_CONFIG.userRole || 'guest';

            console.log("Daten für Rendering:", { timetableData, substitutionsData, absencesData, viewMode }); // Logging hinzugefügt

            // --- Block Processing (same as before) ---
            const processedCellKeys = new Set();
            const blockSpans = new Map();

            // 1. Process regular blocks (using block_id or block_ref)
            const blocks = new Map();
            timetableData.forEach(entry => {
                const blockIdentifier = isTemplateEditor ? entry.block_ref : entry.block_id;
                if (blockIdentifier) {
                    if (!blocks.has(blockIdentifier)) blocks.set(blockIdentifier, []);
                    blocks.get(blockIdentifier).push(entry);
                }
            });
            blocks.forEach(entries => {
                if (entries.length > 0) { // Ensure block has entries
                    entries.sort((a, b) => a.period_number - b.period_number);
                    const startEntry = entries[0];
                    const span = entries[entries.length - 1].period_number - startEntry.period_number + 1;
                    blockSpans.set(`${startEntry.day_of_week}-${startEntry.period_number}`, span);
                    // Mark cells covered by the block as processed
                    for (let i = 1; i < span; i++) {
                        processedCellKeys.add(`${startEntry.day_of_week}-${startEntry.period_number + i}`);
                    }
                }
            });

            // 2. Process substitution blocks (only in main dashboard view)
            if (!isTemplateEditor) {
                const substitutionBlocks = new Map();
                substitutionsData.forEach(sub => {
                    // day_of_week should already be calculated in the API response or planer-api.js
                    if (!sub.day_of_week) return;
                    // Group potentially related substitutions (same day, class, type, comment, new room etc.)
                    const key = `${sub.date}-${sub.class_id}-${sub.substitution_type}-${sub.comment || ''}-${sub.new_room_id || ''}-${sub.new_teacher_id || ''}-${sub.new_subject_id || ''}`;
                    if (!substitutionBlocks.has(key)) substitutionBlocks.set(key, []);
                    substitutionBlocks.get(key).push(sub);
                });
                substitutionBlocks.forEach(subs => {
                    if (subs.length > 1) { // Only process groups with more than one entry
                        subs.sort((a, b) => a.period_number - b.period_number);
                        let isConsecutive = true;
                        // Check if periods are consecutive
                        for (let i = 0; i < subs.length - 1; i++) {
                            if (subs[i + 1].period_number !== subs[i].period_number + 1) {
                                isConsecutive = false; break;
                            }
                        }
                        if (isConsecutive) { // If consecutive, treat as a block
                            const startSub = subs[0];
                            const span = subs.length;
                            const dayNum = startSub.day_of_week;
                            if (dayNum) {
                                blockSpans.set(`${dayNum}-${startSub.period_number}`, span);
                                // Mark cells covered by the substitution block as processed
                                for (let i = 1; i < span; i++) {
                                    processedCellKeys.add(`${dayNum}-${startSub.period_number + i}`);
                                }
                            }
                        }
                    }
                });
            }

            // 3. Render Grid HTML
            let gridHTML = `<div class="timetable-grid ${isTemplateEditor ? 'template-editor-grid' : ''}">`;
            // Add header row (Time + Days)
            gridHTML += '<div class="grid-header"></div>'; // Empty top-left cell
            DOM.days.forEach(day => gridHTML += `<div class="grid-header">${day}</div>`); // Day headers

            // NEU: Aktuelles Jahr und Woche für Datumsberechnung holen
            const currentYear = DOM.yearSelector ? DOM.yearSelector.value : new Date().getFullYear();
            const currentWeek = DOM.weekSelector ? DOM.weekSelector.value : 1;

            // Add rows for each time slot
            DOM.timeSlots.forEach((slot, index) => {
                const period = index + 1;
                // Add time slot header for the row
                gridHTML += `<div class="grid-header period-header">${slot}</div>`;

                // Add cells for each day in the current row
                DOM.days.forEach((day, dayIndex) => {
                    const dayNum = dayIndex + 1; // 1=Mon, ..., 5=Fri
                    const cellKey = `${dayNum}-${period}`;
                    const noteKey = cellKey; // NEU

                    // Skip rendering if this cell is covered by a block starting earlier
                    if (processedCellKeys.has(cellKey)) { return; }

                    // --- Prepare cell data ---
                    let cellContent = '', cellClass = 'empty', dataAttrs = `data-day="${dayNum}" data-period="${period}"`, style = '';
                    if (isTemplateEditor) cellClass += ' template-cell'; // Add class for template editor cells

                    // Check if this cell is the start of a block
                    const span = blockSpans.get(cellKey);
                    if (span) {
                        style = `grid-row: span ${span};`; // Apply rowspan styling
                        cellClass += ' block-start'; // Add class for block start
                    }

                    // Find substitution or regular entry for this cell
                    const substitution = isTemplateEditor ? null : substitutionsData.find(s => s.day_of_week == dayNum && s.period_number == period);
                    const entryToRender = timetableData.find(e => e.day_of_week == dayNum && e.period_number == period);
                    // KORREKTUR: Verwende die definierte userRole Variable und prüfe, ob studentNotes existiert
                    const note = (userRole === 'schueler' && state.studentNotes && state.studentNotes[noteKey]) ? state.studentNotes[noteKey] : null;

                    // NEU: Abwesenheitsprüfung (nur im Haupt-Dashboard, nicht im Template-Editor)
                    let isTeacherAbsent = false;
                    if (!isTemplateEditor && entryToRender && entryToRender.teacher_id) {
                        const entryDate = getDateForDayInWeek(dayNum, currentYear, currentWeek);
                        isTeacherAbsent = absencesData.some(abs => 
                            abs.teacher_id == entryToRender.teacher_id && 
                            entryDate >= abs.start_date && 
                            entryDate <= abs.end_date
                        );
                    }


                    dataAttrs = `data-day="${dayNum}" data-period="${period}"`; // Basis-Attribute

                    // --- Populate cell content and attributes ---
                    if (substitution) { // Substitution exists
                        cellClass = `has-entry substitution-${substitution.substitution_type}`;
                        dataAttrs += ` data-substitution-id="${substitution.substitution_id}"`;
                        if (substitution.comment) dataAttrs += ` data-comment="${escapeHtml(substitution.comment)}"`;
                        dataAttrs += ` draggable="true"`; // Substitutions are draggable
                        const regularEntry = entryToRender; // Find corresponding regular entry for context
                        dataAttrs += ` data-class-id="${substitution.class_id}"`; // Add class ID for context

                        // Generate HTML content for the substitution cell
                        // KORREKTUR: 'note' als 7. Argument übergeben
                        cellContent = createCellEntryHtml(
                            // Determine subject (new, original, or default)
                            substitution.substitution_type === 'Vertretung' ? (substitution.new_subject_shortcut || regularEntry?.subject_shortcut) : (substitution.substitution_type === 'Sonderevent' ? 'EVENT' : regularEntry?.subject_shortcut),
                            // Determine main text (teacher/class or status)
                            substitution.substitution_type === 'Vertretung'
                                ? (viewMode === 'teacher' ? (substitution.class_name || regularEntry?.class_name) : substitution.new_teacher_shortcut)
                                : (substitution.substitution_type === 'Entfall' ? 'Entfällt' : (regularEntry ? (viewMode === 'class' ? regularEntry.teacher_shortcut : regularEntry.class_name) : '---')),
                            // Determine room (new or original)
                            substitution.new_room_name || regularEntry?.room_name,
                            substitution.comment, // Substitution comment
                            substitution.substitution_type, // Type for specific styling
                            false, // isTeacherAbsent (false für Vertretungen)
                            note // note
                        );
                    } else if (entryToRender) { // Regular entry exists
                        cellClass = 'has-entry';
                        // NEU: Klasse hinzufügen, wenn Lehrer abwesend ist
                        if (isTeacherAbsent) {
                            cellClass += ' teacher-absent';
                        }
                        // Add entry/block IDs and class ID as data attributes
                        dataAttrs += isTemplateEditor ? ` data-template-entry-id="${entryToRender.template_entry_id}"` : ` data-entry-id="${entryToRender.entry_id}"`;
                        dataAttrs += ` data-class-id="${entryToRender.class_id}"`;
                        const blockIdentifier = isTemplateEditor ? entryToRender.block_ref : entryToRender.block_id;
                        if (blockIdentifier) dataAttrs += ` data-block-id="${blockIdentifier}"`;
                        dataAttrs += ` draggable="true"`; // Regular entries/blocks are draggable
                        
                        // Get display names from Stammdaten if in template editor, otherwise use pre-joined names
                        const subject = isTemplateEditor ? (stammdaten.subjects?.find(s => s.subject_id == entryToRender.subject_id)?.subject_shortcut || '?!') : entryToRender.subject_shortcut;
                        const teacher = isTemplateEditor ? (stammdaten.teachers?.find(t => t.teacher_id == entryToRender.teacher_id)?.teacher_shortcut || '?!') : entryToRender.teacher_shortcut;
                        const room = isTemplateEditor ? (stammdaten.rooms?.find(r => r.room_id == entryToRender.room_id)?.room_name || '?!') : entryToRender.room_name;
                        const className = isTemplateEditor ? (stammdaten.classes?.find(c => c.class_id == entryToRender.class_id)?.class_name || '?!') : entryToRender.class_name;
                        // Determine main text based on view mode
                        const mainText = viewMode === 'class' ? teacher : className;
                        
                        // Generate HTML content for the regular cell
                        // KORREKTUR: 'isTeacherAbsent' als 6. und 'note' als 7. Argument übergeben
                        cellContent += createCellEntryHtml(subject, mainText, room, entryToRender.comment, null, isTeacherAbsent, note);
                    } else if (!isTemplateEditor && (period === 1 || period === 10)) { // Default entry (FU) - only in main dashboard
                        cellClass = 'default-entry';
                        // KORREKTUR: Argumente korrekt übergeben
                        cellContent = createCellEntryHtml('FU', 'Förderunterricht', '', '', null, false, null); // FU anzeigen
                        dataAttrs += ` draggable="false"`; // FU is not draggable
                    } else {
                        // Empty cell (draggable only in template editor for adding new entries)
                        if (isTemplateEditor) dataAttrs += ` draggable="false"`; // Empty cells in template editor are not draggable sources
                        else dataAttrs += ` draggable="false"`; // Empty cells in main view are not draggable
                    }

                    // Append the cell HTML to the grid row
                    gridHTML += `<div class="grid-cell ${cellClass}" ${dataAttrs} style="${style}">${cellContent}</div>`;
                });
            });

            gridHTML += '</div>'; // Close timetable-grid
            container.innerHTML = gridHTML; // Set the generated HTML into the container
            console.log("renderTimetable abgeschlossen."); // Logging hinzugefügt
        };


        /**
         * Erstellt das HTML-Markup für den Inhalt einer einzelnen Zelle.
        * @param {string} subject - Fach-Kürzel
        * @param {string} mainText - Lehrer-Kürzel oder Klassenname oder Status ('Entfällt')
        * @param {string} room - Raumname
        * @param {string} [comment=null] - Optionaler Kommentar
        * @param {string} [substitutionType=null] - Optionaler Vertretungstyp
        * @param {boolean} [isTeacherAbsent=false] - NEU: Flag für Abwesenheit
        * @param {string} [note=null] - NEU: Flag für Notiz
        * @returns {string} - Das gerenderte HTML für die Zelle
        */
        export const createCellEntryHtml = (subject, mainText, room, comment = null, substitutionType = null, isTeacherAbsent = false, note = null) => {
            // Escape all input values to prevent XSS
            const safeSubject = escapeHtml(subject);
            const safeMainText = escapeHtml(mainText);
            const safeRoom = escapeHtml(room);
            const safeComment = escapeHtml(comment);
        
            // Prepare HTML parts
            let commentHtml = safeComment ? `<small class="entry-comment" title="${safeComment}">📝 ${safeComment.substring(0, 15)}${safeComment.length > 15 ? '...' : ''}</small>` : '';
            let roomHtml = safeRoom ? `<small class="entry-room">${safeRoom}</small>` : '';
            let mainHtml = safeMainText ? `<span>${safeMainText}</span>` : '';
            let subjectHtml = safeSubject ? `<strong>${safeSubject}</strong>` : '';
            // NEU: HTML für Abwesenheitswarnung
            let absenceHtml = isTeacherAbsent ? `<small class="absence-warning" title="Lehrer ist als abwesend gemeldet!">⚠️ Lehrer abwesend</small>` : '';

            // NEU: Notiz-Icon (SVG)
            const noteIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 0A1.5 1.5 0 0 0 0 1.5V13a1 1 0 0 0 1 1V1.5a.5.5 0 0 1 .5-.5H14a1 1 0 0 0-1-1zM3.5 2A1.5 1.5 0 0 0 2 3.5v11A1.5 1.5 0 0 0 3.5 16h9a1.5 1.5 0 0 0 1.5-1.5v-11A1.5 1.5 0 0 0 12.5 2zM3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5z"/></svg>`;
            // KORREKTUR: Verwende window.APP_CONFIG.userRole
            let noteHtml = (note && window.APP_CONFIG.userRole === 'schueler') ? `<small class="entry-note" title="${escapeHtml(note)}">${noteIcon}</small>` : '';


            // Adjust HTML based on substitution type
            if (substitutionType === 'Entfall') {
                // Display "Entfällt" prominently, keep original subject, hide room/original main text
                subjectHtml = `<strong>${safeSubject}</strong>`; // Keep original subject visible
                mainHtml = `<span>Entfällt</span>`; // Indicate cancellation
                roomHtml = ''; // Hide room for cancellation
                // Use comment field for potential original teacher/class info if needed, or hide it
                commentHtml = safeComment ? `<small class="entry-comment" title="${safeComment}">📝 ${safeComment.substring(0, 15)}${safeComment.length > 15 ? '...' : ''}</small>` : ''; // Keep substitution comment
                absenceHtml = ''; // Keine Abwesenheitswarnung bei Entfall
            }
            if (substitutionType === 'Raumänderung') {
                // Highlight the new room
                roomHtml = safeRoom ? `<small class="entry-room" style="font-weight:bold; color: var(--color-warning);">${safeRoom}</small>` : '';
                // Bei Raumänderung ist der Lehrer ja anwesend (hoffentlich)
                absenceHtml = '';
            }
            if (substitutionType === 'Sonderevent') {
                subjectHtml = `<strong>EVENT</strong>`; // Use EVENT as subject
                // Use comment as the main description, or fallback text
                mainHtml = safeComment ? `<span title="${safeComment}">${safeComment.substring(0, 20)}${safeComment.length > 20 ? '...' : ''}</span>` : `<span>Sonderveranst.</span>`;
                commentHtml = ''; // Comment is already displayed as main text
                absenceHtml = ''; // Keine Abwesenheitswarnung bei Sonderevent
            }
        
            // Combine parts into the final cell entry HTML
            // NEU: absenceHtml hinzugefügt
            // KORREKTUR: noteHtml hinzugefügt
            return `<div class="cell-entry">${noteHtml}${subjectHtml}${mainHtml}${roomHtml}${commentHtml}${absenceHtml}</div>`;
        };


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-timetable.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-ui.js ---
import * as DOM from './planer-dom.js';
import { getState } from './planer-state.js';
import { escapeHtml } from './planer-utils.js';

/** Füllt einen Jahres-Selektor (allgemein) */
export const populateYearSelector = (selectorElement, defaultYear) => {
    if (!selectorElement) return; // Add check
    const currentYear = new Date().getFullYear();
    let options = '';
    for (let i = currentYear - 2; i <= currentYear + 2; i++) {
        options += `<option value="${i}">${i}</option>`;
    }
    selectorElement.innerHTML = options;
    selectorElement.value = defaultYear;
};

/** Füllt einen Wochen-Selektor (allgemein) */
export const populateWeekSelector = (selectorElement, defaultWeek) => {
     if (!selectorElement) return; // Add check
    let options = '';
    for (let i = 1; i <= 53; i++) {
        options += `<option value="${i}">KW ${i}</option>`;
    }
    selectorElement.innerHTML = options;
    selectorElement.value = defaultWeek;
};

/** Füllt den Klassen-Hauptselektor */
export const populateClassSelector = (classes = []) => { // Default to empty array
    if (!DOM.classSelector) return; // Add check
    console.log(`planer-ui: Populating class selector with ${classes.length} classes...`); // Logging hinzugefügt
    DOM.classSelector.innerHTML = '<option value="">Bitte wählen...</option>' +
        classes.map(c => `<option value="${c.class_id}">${c.class_id} - ${escapeHtml(c.class_name)}</option>`).join(''); // Escape class name
};

/** Füllt den Lehrer-Hauptselektor */
export const populateTeacherSelector = (teachers = []) => { // Default to empty array
     if (!DOM.teacherSelector) return; // Add check
    const filteredTeachers = teachers.filter(t => t.teacher_shortcut !== 'SGL'); // Filter out 'SGL'
    console.log(`planer-ui: Populating teacher selector with ${filteredTeachers.length} teachers...`); // Logging hinzugefügt
    DOM.teacherSelector.innerHTML = '<option value="">Bitte wählen...</option>' +
        filteredTeachers.map(t => `<option value="${t.teacher_id}">${escapeHtml(t.last_name)}, ${escapeHtml(t.first_name)} (${escapeHtml(t.teacher_shortcut)})</option>`).join(''); // Escape names/shortcut
};

/** Füllt alle Selects in den Modals */
export const populateAllModalSelects = (stammdaten) => {
     if (!DOM.modal) return; // Exit if modal doesn't exist on the page
    console.log("planer-ui: Populating modal selects..."); // Logging hinzugefügt
    const { subjects = [], teachers = [], rooms = [], classes = [] } = stammdaten || {}; // Default to empty objects/arrays

    // Safely query selectors within the modal
    const subjectSelect = DOM.modal.querySelector('#subject_id');
    const newSubjectSelect = DOM.modal.querySelector('#new_subject_id');
    const teacherSelect = DOM.modal.querySelector('#teacher_id');
    const newTeacherSelect = DOM.modal.querySelector('#new_teacher_id');
    const roomSelect = DOM.modal.querySelector('#room_id');
    const newRoomSelect = DOM.modal.querySelector('#new_room_id');
    const templateClassSelect = DOM.modal.querySelector('#template_class_id');

    // Populate Subject Selects
    if (subjectSelect) {
        subjectSelect.innerHTML = subjects.map(s => `<option value="${s.subject_id}">${escapeHtml(s.subject_name)} (${escapeHtml(s.subject_shortcut)})</option>`).join('');
    }
    if (newSubjectSelect) {
        newSubjectSelect.innerHTML = '<option value="">(wie Original)</option>' + subjects.map(s => `<option value="${s.subject_id}">${escapeHtml(s.subject_name)} (${escapeHtml(s.subject_shortcut)})</option>`).join('');
    }

    // Populate Teacher Selects (filter out SGL)
    const filteredTeachers = teachers.filter(t => t.teacher_shortcut !== 'SGL');
    const teacherOptions = filteredTeachers.map(t => `<option value="${t.teacher_id}">${escapeHtml(t.first_name)} ${escapeHtml(t.last_name)}</option>`).join('');
    if (teacherSelect) {
        teacherSelect.innerHTML = teacherOptions;
    }
    if (newTeacherSelect) {
        newTeacherSelect.innerHTML = '<option value="">(kein Lehrer)</option>' + teacherOptions;
    }

    // Populate Room Selects
    const roomOptions = rooms.map(r => `<option value="${r.room_id}">${escapeHtml(r.room_name)}</option>`).join('');
    if (roomSelect) {
        roomSelect.innerHTML = roomOptions;
    }
    if (newRoomSelect) {
        newRoomSelect.innerHTML = '<option value="">(kein Raum)</option>' + roomOptions;
    }

    // Populate Class Select (for Template Editor within the modal)
    if (templateClassSelect) {
        templateClassSelect.innerHTML = '<option value="0">(Keine Klasse)</option>' + classes.map(c => `<option value="${c.class_id}">${escapeHtml(c.class_name)}</option>`).join('');
    }
};


/** Füllt die Vorlagen-Selects (Anwenden-Modal) */
export const populateTemplateSelects = (templates = []) => { // Default to empty array
     if (!DOM.applyTemplateSelect) return; // Add check
     console.log(`planer-ui: Populating template select with ${templates.length} templates...`); // Logging hinzugefügt
    DOM.applyTemplateSelect.innerHTML = templates.length > 0
        ? '<option value="">-- Vorlage wählen --</option>' + templates.map(t => `<option value="${t.template_id}">${escapeHtml(t.name)}</option>`).join('')
        : '<option value="">Keine Vorlagen verfügbar</option>';
};

/** Aktualisiert die UI für den Veröffentlichungsstatus */
export const updatePublishControls = (status = { student: false, teacher: false }) => { // Default status
     // Check if elements exist before updating
    if (DOM.publishWeekLabel) DOM.publishWeekLabel.textContent = DOM.weekSelector?.value || '--'; // Use optional chaining

    if (DOM.publishStatusStudent) {
        DOM.publishStatusStudent.textContent = status.student ? 'Schüler: Veröffentlicht' : 'Schüler: Nicht veröffentlicht';
        DOM.publishStatusStudent.classList.toggle('published', !!status.student);
        DOM.publishStatusStudent.classList.toggle('not-published', !status.student);
    }
     if (DOM.publishStudentBtn) DOM.publishStudentBtn.classList.toggle('hidden', !!status.student);
     if (DOM.unpublishStudentBtn) DOM.unpublishStudentBtn.classList.toggle('hidden', !status.student);

    if (DOM.publishStatusTeacher) {
        DOM.publishStatusTeacher.textContent = status.teacher ? 'Lehrer: Veröffentlicht' : 'Lehrer: Nicht veröffentlicht';
        DOM.publishStatusTeacher.classList.toggle('published', !!status.teacher);
        DOM.publishStatusTeacher.classList.toggle('not-published', !status.teacher);
    }
     if (DOM.publishTeacherBtn) DOM.publishTeacherBtn.classList.toggle('hidden', !!status.teacher);
     if (DOM.unpublishTeacherBtn) DOM.unpublishTeacherBtn.classList.toggle('hidden', !status.teacher);

    // Disable buttons if year or week is not selected
    const isValidWeek = DOM.yearSelector?.value && DOM.weekSelector?.value;
     if (DOM.publishStudentBtn) DOM.publishStudentBtn.disabled = !isValidWeek;
     if (DOM.publishTeacherBtn) DOM.publishTeacherBtn.disabled = !isValidWeek;
     if (DOM.unpublishStudentBtn) DOM.unpublishStudentBtn.disabled = !isValidWeek;
     if (DOM.unpublishTeacherBtn) DOM.unpublishTeacherBtn.disabled = !isValidWeek;
};

/** Zeigt Konfliktwarnungen im Modal an */
export const showConflicts = (conflictMessages = []) => { // Default to empty array
    if (DOM.conflictWarningBox) {
        DOM.conflictWarningBox.innerHTML = conflictMessages.map(msg => `<div>${escapeHtml(msg)}</div>`).join('');
        DOM.conflictWarningBox.style.display = 'block';
    }
     // Disable save button when conflicts are shown
    if (DOM.saveButton) {
        DOM.saveButton.disabled = true;
        DOM.saveButton.style.opacity = '0.5';
        DOM.saveButton.style.cursor = 'not-allowed';
    }
};

/** Versteckt Konfliktwarnungen im Modal */
export const hideConflicts = () => {
    if (DOM.conflictWarningBox) {
        DOM.conflictWarningBox.innerHTML = '';
        DOM.conflictWarningBox.style.display = 'none';
    }
     // Re-enable save button when conflicts are hidden
    if (DOM.saveButton) {
        DOM.saveButton.disabled = false;
        DOM.saveButton.style.opacity = '1';
        DOM.saveButton.style.cursor = 'pointer';
    }
};

/** Schaltet die Ansicht im "Vorlagen verwalten"-Modal um */
export const showTemplateView = (viewType) => {
     // Check if elements exist before manipulating them
     if (!DOM.templateListView || !DOM.templateEditorView || !DOM.manageTemplatesModal) return;

    if (viewType === 'editor') {
        DOM.templateListView.style.display = 'none';
        DOM.templateEditorView.style.display = 'block';
        if (DOM.templateEditorTitle) DOM.templateEditorTitle.textContent = "Neue leere Vorlage erstellen"; // Default title
        const nameInput = DOM.manageTemplatesModal.querySelector('#template-editor-name');
        if (nameInput) nameInput.focus(); // Focus on name input when editor opens
    } else { // 'list' or default
        DOM.templateListView.style.display = 'block';
        DOM.templateEditorView.style.display = 'none';
    }
};

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-ui.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-utils.js ---
/**
 * Hilfsfunktion zur Ermittlung der Kalenderwoche und des Jahres nach ISO 8601.
 */
export function getWeekAndYear(date) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    return { week: weekNo, year: d.getUTCFullYear() };
}

/**
 * Ermittelt das Datum des Montags einer gegebenen Kalenderwoche und eines Jahres.
 * @param {number} week - Die Kalenderwoche.
 * @param {number} year - Das Jahr.
 * @returns {Date} Das Datumsobjekt für den Montag.
 */
export function getDateOfISOWeek(week, year) {
    const simple = new Date(Date.UTC(year, 0, 1 + (week - 1) * 7));
    const dow = simple.getUTCDay(); // Sonntag = 0, Montag = 1 ...
    const ISOweekStart = simple;
    // Gehe zum Montag der Woche
    ISOweekStart.setUTCDate(simple.getUTCDate() - (dow || 7) + 1);
    // Konvertiere zurück in lokale Zeit für die Anzeige
    return new Date(ISOweekStart.getFullYear(), ISOweekStart.getMonth(), ISOweekStart.getDate());
}

/**
 * Berechnet den YYYY-MM-DD Datumsstring für einen Wochentag (1-5) in der aktuell gewählten Woche.
 * @param {number} dayNum - Der Wochentag (1=Mo, 5=Fr).
 * @param {string} year - Das ausgewählte Jahr.
 * @param {string} week - Die ausgewählte Woche.
 * @returns {string} Das Datum im Format YYYY-MM-DD.
 */
export function getDateForDayInWeek(dayNum, year, week) {
    const monday = getDateOfISOWeek(week, year);
    const targetDate = new Date(monday.getTime() + (dayNum - 1) * 24 * 60 * 60 * 1000);

    const yyyy = targetDate.getFullYear();
    const mm = String(targetDate.getMonth() + 1).padStart(2, '0');
    const dd = String(targetDate.getDate()).padStart(2, '0');

    return `${yyyy}-${mm}-${dd}`;
}

/**
 * Bereinigt einen String für die sichere Anzeige in HTML.
 * @param {*} unsafe - Der Eingabewert.
 * @returns {string} Der bereinigte String.
 */
export function escapeHtml(unsafe) {
    if (!unsafe) return '';
    return String(unsafe)
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-utils.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\spa-router.js ---
// Vorerst leer.

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\spa-router.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\teacher-cockpit.js ---
// public/assets/js/teacher-cockpit.js
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js';

/**
 * Escapes HTML special characters.
 * @param {string} unsafe
 * @returns {string}
 */
function escapeHtml(unsafe) {
    if (!unsafe) return '';
    return String(unsafe)
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}

// NEU: Formatiert HH:MM:SS zu HH:MM
function formatShortTime(timeString) {
    if (!timeString) return '';
    const parts = timeString.split(':');
    if (parts.length >= 2) {
        return `${parts[0]}:${parts[1]}`;
    }
    return timeString; // Fallback
}
// NEU: Wandelt 1-5 in Wochentage um
function formatDayOfWeek(dayNum) {
    const days = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag'];
    const index = parseInt(dayNum, 10) - 1;
    return days[index] || 'Unbekannt';
}

// Globale Variable für den Controller der Anwesenheitsliste
let attendanceController = null;

export function initializeTeacherCockpit() {
    const cockpit = document.getElementById('teacher-cockpit');
    if (!cockpit || window.APP_CONFIG.userRole !== 'lehrer') {
        return; // Nur für Lehrer initialisieren
    }

    // --- Feature: Kollege finden ---
    const searchInput = document.getElementById('colleague-search-input');
    const searchResults = document.getElementById('colleague-search-results');
    const resultDisplay = document.getElementById('colleague-result-display');
    const resultSpinner = resultDisplay.querySelector('.loading-spinner');
    const resultParagraph = resultDisplay.querySelector('p');
    // KORREKTUR: Cockpit-Container für Klick-Außerhalb-Erkennung
    const findColleagueFeature = document.getElementById('find-colleague-feature');


    let searchTimeout;
    let selectedTeacherId = null;

    const handleSearchInput = () => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(async () => {
            const query = searchInput.value.trim();
            if (query.length < 2) {
                searchResults.innerHTML = '';
                searchResults.classList.remove('visible');
                return;
            }
            
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/search-colleagues?query=${encodeURIComponent(query)}`);
                if (response.success && response.data) {
                     const filteredTeachers = response.data.filter(t => t.teacher_shortcut !== 'SGL');
                     if (filteredTeachers.length > 0) {
                        searchResults.innerHTML = filteredTeachers.map(teacher => `
                            <div class="search-result-item" data-id="${teacher.teacher_id}" data-name="${escapeHtml(teacher.first_name)} ${escapeHtml(teacher.last_name)} (${escapeHtml(teacher.teacher_shortcut)})">
                                <strong>${escapeHtml(teacher.last_name)}, ${escapeHtml(teacher.first_name)}</strong> (${escapeHtml(teacher.teacher_shortcut)})
                            </div>
                        `).join('');
                        searchResults.classList.add('visible');
                    } else {
                        searchResults.innerHTML = '<div class="search-result-item none">Keine Treffer</div>';
                        searchResults.classList.add('visible');
                    }
                } else {
                    searchResults.innerHTML = '<div class="search-result-item none">Keine Treffer</div>';
                    searchResults.classList.add('visible');
                }
            } catch (error) {
                console.error("Fehler bei Lehrersuche:", error);
                searchResults.innerHTML = `<div class="search-result-item none">Fehler: ${escapeHtml(error.message)}</div>`;
                searchResults.classList.add('visible');
            }
        }, 300); // 300ms Verzögerung
    };

    const handleResultClick = async (e) => {
        const item = e.target.closest('.search-result-item');
        if (!item || !item.dataset.id) return;

        selectedTeacherId = item.dataset.id;
        const selectedName = item.dataset.name;

        // UI-Vorbereitung
        searchInput.value = selectedName; // Feld füllen
        searchResults.innerHTML = ''; // Ergebnisse schließen
        searchResults.classList.remove('visible');
        resultDisplay.style.display = 'flex';
        if(resultSpinner) resultSpinner.style.display = 'block';
        if(resultParagraph) resultParagraph.innerHTML = `Suche nach ${escapeHtml(selectedName)}...`;

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/find-colleague?teacher_id=${selectedTeacherId}`);
            if (response.success) {
                // Antwort anzeigen
                if(resultParagraph) resultParagraph.innerHTML = `
                    <strong>${escapeHtml(selectedName)}:</strong><br>
                    ${escapeHtml(response.data.message)}
                `;
            } else {
                throw new Error(response.message);
            }
        } catch (error) {
            console.error("Fehler bei Standortabfrage:", error);
            if(resultParagraph) resultParagraph.innerHTML = `<span class="text-danger">Fehler: ${escapeHtml(error.message)}</span>`;
        } finally {
            if(resultSpinner) resultSpinner.style.display = 'none';
        }
    };

    if (searchInput && searchResults && resultDisplay && findColleagueFeature) {
        searchInput.addEventListener('input', handleSearchInput);
        searchResults.addEventListener('click', handleResultClick);
        // KORREKTUR: Klick außerhalb des Widgets schließt Dropdown
        document.addEventListener('click', (e) => {
            if (!findColleagueFeature.contains(e.target)) {
                searchResults.classList.remove('visible');
            }
        });
    }

    // --- Feature: Digitale Anwesenheit ---
    const attendanceContainer = document.getElementById('attendance-feature');
    if (attendanceContainer) {
        attendanceController = new AttendanceController(attendanceContainer);
        attendanceController.loadCurrentLesson();
    }
    
    // --- Feature: Aufgaben/Klausuren ---
    const eventsContainer = document.getElementById('academic-events-feature');
    if (eventsContainer) {
        const eventsController = new AcademicEventsController(eventsContainer);
        eventsController.initialize();
    }

    // --- Feature: Sprechstunden verwalten ---
    const officeHoursContainer = document.getElementById('office-hours-feature');
    if (officeHoursContainer) {
        const officeHoursController = new OfficeHoursController(officeHoursContainer);
        officeHoursController.initialize();
    }
}


/**
 * Klasse zur Verwaltung der Anwesenheits-Logik
 */
class AttendanceController {
    constructor(containerElement) {
        this.container = containerElement;
        this.lessonDisplay = document.getElementById('attendance-current-lesson');
        this.listContainer = document.getElementById('attendance-list-container');
        this.studentList = document.getElementById('attendance-student-list');
        this.saveButton = document.getElementById('save-attendance-btn');
        this.saveSpinner = document.getElementById('attendance-save-spinner');
        this.saveContext = null; 
        
        this.bindEvents();
    }

    bindEvents() {
        if (this.saveButton) {
            this.saveButton.addEventListener('click', () => this.handleSaveAttendance());
        }
        
        if (this.studentList) {
            this.studentList.addEventListener('click', (e) => {
                const button = e.target.closest('.btn-toggle');
                if (!button) return;
                
                const li = button.closest('.student-row');
                if (!li) return;
                const newStatus = button.dataset.status;
                
                li.dataset.status = newStatus;
                
                li.querySelectorAll('.btn-toggle').forEach(btn => {
                    btn.classList.remove('active');
                });
                button.classList.add('active');
            });
        }
    }

    async loadCurrentLesson() {
        if (!this.lessonDisplay || !this.listContainer) return;
        
        this.lessonDisplay.innerHTML = '<div class="loading-spinner small"></div><p>Prüfe aktuelle Stunde...</p>';
        this.listContainer.style.display = 'none';

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/current-lesson`);
            if (!response.success) throw new Error(response.message);

            const { status, lesson, students, attendance, context } = response.data;

            if (status === 'Unterricht' || status === 'Vertretung') {
                this.lessonDisplay.innerHTML = `
                    <p class="lesson-info">
                        Aktuelle Stunde: <strong>${escapeHtml(lesson.class_name)} (${escapeHtml(lesson.subject_shortcut || lesson.new_subject_shortcut || '?')})</strong>
                        in Raum <strong>${escapeHtml(lesson.room_name || lesson.new_room_name || '?')}</strong>
                        (${status === 'Vertretung' ? 'Vertretung' : 'Regulär'})
                    </p>
                `;
                this.renderStudentList(students, attendance);
                this.listContainer.style.display = 'block';
                this.saveContext = {
                    class_id: lesson.class_id,
                    date: context.date,
                    period_number: context.period
                };
                
            } else if (status === 'Freistunde') {
                this.lessonDisplay.innerHTML = '<p class="message info" style="margin: 0; padding: 0; background: transparent; border: none;">Sie haben jetzt eine Freistunde.</p>';
            } else {
                this.lessonDisplay.innerHTML = '<p class="message info" style="margin: 0; padding: 0; background: transparent; border: none;">Aktuell findet kein Unterricht statt.</p>';
            }

        } catch (error) {
            console.error("Fehler beim Laden der aktuellen Stunde:", error);
            this.lessonDisplay.innerHTML = `<p class="message error">Fehler: ${escapeHtml(error.message)}</p>`;
        }
    }

    renderStudentList(students, attendance) {
        if (!students || students.length === 0) {
            this.studentList.innerHTML = '<li>Keine Schüler für diese Klasse gefunden.</li>';
            this.saveButton.disabled = true;
            return;
        }

        this.studentList.innerHTML = students.map(student => {
            const currentStatus = attendance[student.user_id] || 'anwesend'; 
            
            return `
                <li class="student-row" data-student-id="${student.user_id}" data-status="${currentStatus}">
                    <span class="student-name">${escapeHtml(student.last_name)}, ${escapeHtml(student.first_name)}</span>
                    <div class="attendance-toggles">
                        <button class="btn-toggle status-anwesend ${currentStatus === 'anwesend' ? 'active' : ''}" data-status="anwesend">A</button>
                        <button class="btn-toggle status-abwesend ${currentStatus === 'abwesend' ? 'active' : ''}" data-status="abwesend">F</button>
                        <button class="btn-toggle status-verspaetet ${currentStatus === 'verspaetet' ? 'active' : ''}" data-status="verspaetet">V</button>
                    </div>
                </li>
            `;
        }).join('');
        this.saveButton.disabled = false;
    }

    async handleSaveAttendance() {
        if (!this.saveContext) {
            showToast("Fehler: Keine Stundendaten zum Speichern vorhanden.", "error");
            return;
        }

        this.saveButton.disabled = true;
        this.saveSpinner.style.display = 'block';

        const studentsStatus = [];
        this.studentList.querySelectorAll('.student-row').forEach(row => {
            studentsStatus.push({
                student_id: row.dataset.studentId,
                status: row.dataset.status
            });
        });

        const body = {
            ...this.saveContext,
            students: studentsStatus
        };

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/attendance/save`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            if (response.success) {
                showToast(response.message, 'success');
            }
        } catch (error) {
            console.error("Fehler beim Speichern der Anwesenheit:", error);
        } finally {
            this.saveButton.disabled = false;
            this.saveSpinner.style.display = 'none';
        }
    }
}

/**
 * Klasse zur Verwaltung der Aufgaben/Klausuren-Logik im Cockpit
 */
class AcademicEventsController {
    constructor(containerElement) {
        this.container = containerElement;
        this.form = document.getElementById('academic-event-form');
        this.classSelect = document.getElementById('event-class-id');
        this.subjectSelect = document.getElementById('event-subject-id');
        this.eventList = document.getElementById('teacher-event-list');
        this.saveButton = document.getElementById('save-event-btn');
        this.saveSpinner = document.getElementById('event-save-spinner');
        
        this.teacherClasses = [];
        this.allSubjects = [];
    }

    async initialize() {
        if (!this.form) return;
        
        this.bindEvents();
        await this.loadPrerequisites();
        await this.loadTeacherEvents();
    }

    bindEvents() {
        this.form.addEventListener('submit', (e) => this.handleSaveEvent(e));
        
        this.eventList.addEventListener('click', (e) => {
            const deleteButton = e.target.closest('.delete-event-btn');
            if (deleteButton) {
                const eventId = deleteButton.dataset.eventId;
                const eventTitle = deleteButton.dataset.eventTitle;
                this.handleDeleteEvent(eventId, eventTitle);
            }
        });
    }

    async loadPrerequisites() {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/prerequisites`);
            
            if (response.success && response.data) {
                this.allSubjects = response.data.subjects || [];
                this.teacherClasses = response.data.classes || [];

                this.subjectSelect.innerHTML = '<option value="">Kein Fach</option>' + 
                    this.allSubjects.map(s => 
                        `<option value="${s.subject_id}">${escapeHtml(s.subject_name)} (${escapeHtml(s.subject_shortcut)})</option>`
                    ).join('');
                
                if (this.teacherClasses.length > 0) {
                    this.classSelect.innerHTML = '<option value="">-- Klasse wählen --</option>' + 
                        this.teacherClasses.map(c => 
                            `<option value="${c.class_id}">${escapeHtml(c.class_name)} (ID: ${c.class_id})</option>`
                        ).join('');
                } else {
                    this.classSelect.innerHTML = '<option value="">Keine Klassen gefunden</option>';
                    this.form.querySelector('button[type="submit"]').disabled = true;
                    showToast("Es wurden keine Klassen gefunden, die Sie unterrichten.", "info", 5000);
                }
            } else {
                throw new Error(response.message || "Stammdaten konnten nicht geladen werden.");
            }
        } catch (error) {
            console.error("Fehler beim Laden der Voraussetzungen für Events:", error);
            this.classSelect.innerHTML = '<option value="">Fehler</option>';
            this.subjectSelect.innerHTML = '<option value="">Fehler</option>';
            showToast(`Fehler beim Laden der Klassen/Fächer: ${error.message}`, 'error');
        }
    }

    async loadTeacherEvents() {
        this.eventList.innerHTML = '<div class="loading-spinner small"></div>';
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/events`);
            if (response.success && response.data) {
                this.renderEventList(response.data);
            } else {
                throw new Error(response.message || "Events konnten nicht geladen werden.");
            }
        } catch (error) {
            console.error("Fehler beim Laden der Lehrer-Events:", error);
            this.eventList.innerHTML = `<p class="message error small">${escapeHtml(error.message)}</p>`;
        }
    }

    renderEventList(events) {
        if (events.length === 0) {
            this.eventList.innerHTML = '<p class="message info small" style="margin: 10px;">Keine Einträge für die nächsten 14 Tage gefunden.</p>';
            return;
        }

        const groups = events.reduce((acc, event) => {
            const date = event.due_date;
            if (!acc[date]) {
                acc[date] = [];
            }
            acc[date].push(event);
            return acc;
        }, {});

        let html = '';
        const sortedDates = Object.keys(groups).sort();

        for (const date of sortedDates) {
            html += `<div class="event-group">
                        <div class="event-group-date">${escapeHtml(formatGermanDate(date))}</div>
                        <ul class="event-list-items">`;
            
            groups[date].forEach(event => {
                let icon = 'ℹ️'; // Info
                if (event.event_type === 'klausur') icon = '🎓'; // Klausur
                if (event.event_type === 'aufgabe') icon = '📚'; // Aufgabe
                
                html += `
                    <li class="event-list-item type-${escapeHtml(event.event_type)}" data-event-id="${event.event_id}">
                        <span class="event-icon">${icon}</span>
                        <div class="event-details">
                            <strong>${escapeHtml(event.title)}</strong>
                            <span>
                                ${escapeHtml(event.class_name)} 
                                ${event.subject_shortcut ? `(${escapeHtml(event.subject_shortcut)})` : ''}
                            </span>
                            ${event.description ? `<small>${escapeHtml(event.description)}</small>` : ''}
                        </div>
                        <button class="btn btn-danger btn-small delete-event-btn" 
                                title="Eintrag löschen"
                                data-event-id="${event.event_id}" 
                                data-event-title="${escapeHtml(event.title)}">
                            &times;
                        </button>
                    </li>
                `;
            });
            
            html += `</ul></div>`;
        }
        this.eventList.innerHTML = html;
    }

    async handleSaveEvent(e) {
        e.preventDefault();
        this.saveButton.disabled = true;
        this.saveSpinner.style.display = 'block';

        const formData = new FormData(this.form);
        const data = Object.fromEntries(formData.entries());
        
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/events/create`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (response.success) {
                showToast(response.message, 'success');
                this.form.reset();
                this.loadTeacherEvents();
            }
        } catch (error) {
            console.error("Fehler beim Speichern des Events:", error);
        } finally {
            this.saveButton.disabled = false;
            this.saveSpinner.style.display = 'none';
        }
    }

    async handleDeleteEvent(eventId, eventTitle) {
        if (!eventId) return;

        if (await showConfirm("Eintrag löschen", `Möchten Sie den Eintrag "${eventTitle}" wirklich löschen?`)) {
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/events/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ event_id: eventId })
                });

                if (response.success) {
                    showToast(response.message, 'success');
                    this.loadTeacherEvents();
                }
            } catch (error) {
                console.error("Fehler beim Löschen des Events:", error);
            }
        }
    }
}

/**
 * NEU: Klasse zur Verwaltung der Sprechstunden-Logik im Cockpit
 */
class OfficeHoursController {
    constructor(containerElement) {
        this.container = containerElement;
        this.form = document.getElementById('office-hours-form');
        this.listContainer = document.getElementById('teacher-office-hours-list');
        this.saveButton = document.getElementById('save-office-hours-btn');
        this.saveSpinner = document.getElementById('office-hours-save-spinner');
    }

    async initialize() {
        if (!this.form) return;
        this.bindEvents();
        await this.loadOfficeHours();
    }

    bindEvents() {
        this.form.addEventListener('submit', (e) => this.handleSave(e));
        
        this.listContainer.addEventListener('click', (e) => {
            const deleteButton = e.target.closest('.delete-office-hour-btn');
            if (deleteButton) {
                const availabilityId = deleteButton.dataset.id;
                this.handleDelete(availabilityId);
            }
        });
    }

    async loadOfficeHours() {
        this.listContainer.innerHTML = '<div class="loading-spinner small"></div>';
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/office-hours`);
            if (response.success && response.data) {
                this.renderList(response.data);
            } else {
                throw new Error(response.message || "Sprechzeiten konnten nicht geladen werden.");
            }
        } catch (error) {
            console.error("Fehler beim Laden der Sprechzeiten:", error);
            this.listContainer.innerHTML = `<p class="message error small">${escapeHtml(error.message)}</p>`;
        }
    }

    renderList(availabilities) {
        if (availabilities.length === 0) {
            this.listContainer.innerHTML = '<p class="message info small" style="margin: 0;">Keine Sprechzeitenfenster definiert.</p>';
            return;
        }
        
        this.listContainer.innerHTML = availabilities.map(av => `
            <div class="office-hour-item" data-id="${av.availability_id}">
                <span>
                    <strong>${escapeHtml(formatDayOfWeek(av.day_of_week))}</strong>, 
                    ${escapeHtml(formatShortTime(av.start_time))} - ${escapeHtml(formatShortTime(av.end_time))} Uhr 
                    (${escapeHtml(av.slot_duration)} Min. Slots)
                </span>
                <button class="btn btn-danger btn-small delete-office-hour-btn" 
                        title="Fenster löschen" 
                        data-id="${av.availability_id}">
                    &times;
                </button>
            </div>
        `).join('');
    }

    async handleSave(e) {
        e.preventDefault();
        this.saveButton.disabled = true;
        this.saveSpinner.style.display = 'block';

        const formData = new FormData(this.form);
        const data = Object.fromEntries(formData.entries());

        try {
            // Validierung: Startzeit muss vor Endzeit liegen
            if (data.start_time >= data.end_time) {
                throw new Error("Startzeit muss vor der Endzeit liegen.");
            }

            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/office-hours/save`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (response.success) {
                showToast(response.message, 'success');
                this.form.reset();
                this.loadOfficeHours(); // Liste neu laden
            }
        } catch (error) {
            console.error("Fehler beim Speichern der Sprechzeit:", error);
            showToast(error.message, 'error'); // Zeige Fehler als Toast
        } finally {
            this.saveButton.disabled = false;
            this.saveSpinner.style.display = 'none';
        }
    }

    async handleDelete(availabilityId) {
        if (!availabilityId) return;

        if (await showConfirm("Sprechzeit löschen", `Möchten Sie dieses Zeitfenster wirklich löschen? Zukünftige Termine in diesem Fenster werden möglicherweise mit entfernt.`)) {
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/office-hours/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ availability_id: availabilityId })
                });

                if (response.success) {
                    showToast(response.message, 'success');
                    this.loadOfficeHours(); // Liste neu laden
                }
            } catch (error) {
                console.error("Fehler beim Löschen der Sprechzeit:", error);
            }
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\teacher-cockpit.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\ui-interactions.js ---
// Vorerst leer.

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\ui-interactions.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\index.php ---
<?php
// public/index.php

// Diese Datei leitet alle Anfragen an den Haupt-Controller im übergeordneten Verzeichnis weiter.
// Dies ist eine bewährte Sicherheitspraxis, da der Webserver-Root nur auf diesen
// Ordner zeigen sollte und der Anwendungscode somit geschützt ist.

// KORREKTUR: Der Pfad geht eine Ebene nach oben (../), um init.php zu finden.
require_once __DIR__ . '/../init.php';

// Die Hauptanwendungslogik wird von der index.php im Projektstammverzeichnis behandelt.
// KORREKTUR: Auch dieser Pfad muss eine Ebene nach oben gehen.
require_once __DIR__ . '/../index.php';
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\index.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\index.php ---
<?php
// index.php

// 1. Initialisiert das Projekt (Session, Autoloader, DB-Verbindung, Wartungsmodus-Check)
require_once __DIR__ . '/init.php';

// 2. NEU: Prüfe, ob der Wartungsmodus den Zugriff blockieren soll
if (defined('MAINTENANCE_MODE_ACTIVE') && MAINTENANCE_MODE_ACTIVE === true) {
    http_response_code(503); // Service Unavailable
    
    // Lade die globalen Einstellungen für die Wartungsmeldung
    $settings = \App\Core\Utils::getSettings();
    $page_title = $settings['site_title'] . ' - Wartung';
    $maintenance_message = $settings['maintenance_message']; // Wird in 503.php verwendet
    
    // Lade die Wartungsseite
    // $config ist bereits global durch init.php
    include_once __DIR__ . '/pages/partials/header.php'; // Minimaler Header
    include_once __DIR__ . '/pages/errors/503.php';      // Die Wartungsseite
    include_once __DIR__ . '/pages/partials/footer.php'; // Minimaler Footer
    
    exit(); // Beende die Skriptausführung hier
}


// 3. Router einrichten und Routen laden (zuvor Schritt 2)
$router = new \App\Core\Router();
$routes = require __DIR__ . '/config/routes.php';
foreach ($routes as $pattern => $handler) {
    $router->add($pattern, $handler);
}

// 4. Aktuelle Anfrage-URL ermitteln (zuvor Schritt 3)
$request_uri = $_GET['url'] ?? '/';
$request_path = trim(parse_url($request_uri, PHP_URL_PATH), '/');

// 5. Passende Route finden (zuvor Schritt 4)
$routeInfo = $router->resolve($request_path);

// 6. Route verarbeiten oder 404-Fehler anzeigen (zuvor Schritt 5)
if ($routeInfo) {
    $handler = $routeInfo['handler'];
    $matches = $routeInfo['matches'];

    // Prüfen, ob der Handler eine Controller-Methode ist
    if (is_array($handler) && class_exists($handler[0]) && method_exists($handler[0], $handler[1])) {
        $controllerClass = $handler[0];
        $method = $handler[1];
        $controller = new $controllerClass();
        // Ruft die Controller-Methode auf und übergibt URL-Parameter (z.B. IDs)
        call_user_func_array([$controller, $method], $matches);
    }
    // Fallback für einfache, dateibasierte Routen
    elseif (is_string($handler) && file_exists(__DIR__ . '/' . $handler)) {
        include __DIR__ . '/' . $handler;
    }
    // Wenn der Handler ungültig ist
    else {
        http_response_code(500);
        echo "Fehler: Route-Handler für '{$request_path}' ist ungültig konfiguriert.";
    }
} else {
    // Keine passende Route gefunden -> 404
    http_response_code(404);
    $page_title = '404 - Seite nicht gefunden';
    // HINWEIS: Die Pfade zu den Partials müssen vom Stammverzeichnis aus korrekt sein.
    include_once __DIR__ . '/pages/partials/header.php';
    include_once __DIR__ . '/pages/errors/404.php';
    include_once __DIR__ . '/pages/partials/footer.php';
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\index.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\init.php ---
<?php
// init.php

// Include Parsedown library (hat keine App\ Abhängigkeiten)
require_once __DIR__ . '/libs/Parsedown.php';

// 1. Session starten (MUSS vor JEDER anderen Ausgabe erfolgen)
// Setzt sicherere Session-Optionen
ini_set('session.cookie_httponly', 1);
ini_set('session.use_only_cookies', 1);
if (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on') {
    ini_set('session.cookie_secure', 1);
}
// Stellt sicher, dass die Session nicht automatisch gestartet wird, falls doch schon geschehen
if (session_status() === PHP_SESSION_NONE) {
    session_start();
}


// 2. Autoloader für alle Klassen im 'App' Namespace (MUSS VOR der Nutzung von App\ Klassen kommen)
spl_autoload_register(function ($class) {
    // Projekt-spezifischer Namespace-Präfix
    $prefix = 'App\\';

    // Basisverzeichnis für den Namespace-Präfix
    // __DIR__ ist das Verzeichnis der init.php Datei (PAUSE/)
    $base_dir = __DIR__ . '/app/'; // Sollte C:\xampp\htdocs\files\PAUSE\app\ sein

    // Prüft, ob die Klasse den Präfix verwendet
    $len = strlen($prefix);
    if (strncmp($prefix, $class, $len) !== 0) {
        // Nein, zum nächsten registrierten Autoloader wechseln
        return;
    }

    // Holt den relativen Klassennamen
    $relative_class = substr($class, $len);

    // Ersetzt den Namespace-Präfix mit dem Basisverzeichnis,
    // ersetzt Namespace-Trenner mit Verzeichnis-Trennern,
    // und hängt .php an
    $file = $base_dir . str_replace('\\', '/', $relative_class) . '.php';
    
    // Wenn die Datei existiert, lade sie
    if (file_exists($file)) {
        require $file;
    }
});

// 3. CSRF-Token generieren oder holen (Session ist bereits aktiv)
// Diese Funktion nutzt jetzt den Autoloader, um App\Core\Security zu laden.
if (session_status() === PHP_SESSION_ACTIVE) {
    \App\Core\Security::getCsrfToken();
} else {
    // Optional: Log, dass keine Session aktiv war für CSRF
    error_log("Session not active when trying to get CSRF token in init.php");
}


// 4. Konfiguration und Datenbankverbindung laden
// Globale Variable $config für leichten Zugriff in Views etc.
global $config;
try {
    $config = App\Core\Database::getConfig();
    // Stelle sicher, dass die DB-Instanz nur geholt wird, wenn nötig,
    // aber hier ist es ok, um die Verbindung früh zu testen.
    $pdo = App\Core\Database::getInstance();
} catch (RuntimeException $e) {
    // Fängt den Fehler ab, wenn die DB-Verbindung fehlschlägt
    // Zeigt eine benutzerfreundliche Fehlerseite an
    http_response_code(503); // Service Unavailable
    // Fetteres Error-Handling wäre besser (eigene Fehlerseite laden)
    die("Fehler: Die Datenbankverbindung konnte nicht hergestellt werden. Bitte überprüfen Sie die Konfiguration oder versuchen Sie es später erneut.");
} catch (Exception $e) { // Fange generische Exceptions beim Laden ab
    http_response_code(500);
    die("Ein kritischer Initialisierungsfehler ist aufgetreten: " . $e->getMessage());
}


// 5. NEU: Wartungsmodus-Prüfung
// Definiert eine Konstante, falls der Zugriff gesperrt werden soll.
try {
    $settings = \App\Core\Utils::getSettings();

    if ($settings['maintenance_mode'] === true) {
        $userRole = $_SESSION['user_role'] ?? 'guest';
        $allowedRoles = ['admin', 'planer']; // Diese Rollen dürfen immer rein
        $userIsAllowed = in_array($userRole, $allowedRoles);

        $userIP = $_SERVER['REMOTE_ADDR'] ?? 'UNKNOWN';
        
        // KORRIGIERT: Lese Whitelist aus $settings (DB) statt $config (Datei)
        $ipWhitelistString = $settings['maintenance_whitelist_ips'] ?? '';
        // Wandle den String in ein Array um, entferne Leerzeichen
        $ipWhitelist = array_map('trim', explode(',', $ipWhitelistString));
        // Entferne leere Einträge
        $ipWhitelist = array_filter($ipWhitelist); 

        $ipIsAllowed = in_array($userIP, $ipWhitelist);

        // Sperre den Benutzer, wenn er KEINE erlaubte Rolle hat UND seine IP NICHT auf der Whitelist ist
        if (!$userIsAllowed && !$ipIsAllowed) {
            
            // Ausnahme: Login-Seiten müssen erreichbar bleiben, damit Admins sich einloggen können
            $request_uri = $_GET['url'] ?? '/';
            $request_path = trim(parse_url($request_uri, PHP_URL_PATH), '/');
            $allowedPaths = ['login', 'login/process']; // Routen, die immer funktionieren

            if (!in_array($request_path, $allowedPaths)) {
                // Setze die globale Konstante. index.php wird darauf reagieren.
                define('MAINTENANCE_MODE_ACTIVE', true);
            }
        }
    }
} catch (Exception $e) {
    // Kritischer Fehler beim Laden der Einstellungen
    http_response_code(500);
    die("Fehler beim Prüfen des Wartungsstatus: " . $e->getMessage());
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\init.php ---

