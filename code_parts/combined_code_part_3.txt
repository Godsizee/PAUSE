
            } else if (user.role === 'lehrer' && user.teacher_name) {
                details = `Lehrerprofil: ${escapeHtml(user.teacher_name)}`;
            }

            let communityStatus = '-';
            if (user.role === 'schueler') {
                communityStatus = user.is_community_banned == 1
                    ? '<span style="color: var(--color-danger); font-weight: 600;">Gesperrt</span>'
                    : '<span style="color: var(--color-success);">Aktiv</span>';
            }

            const canImpersonate = (user.user_id != currentAdminId);
            const impersonateButton = canImpersonate
                ? `<button class="btn btn-secondary btn-small impersonate-user-btn" data-id="${user.user_id}" data-username="${escapeHtml(user.username)}" data-role="${escapeHtml(user.role)}" title="Anmelden als ${escapeHtml(user.username)}">
                       Anmelden als
                   </button>`
                : ``;

            // data-label Attribute hinzugef√ºgt
            return `
                <tr data-id="${user.user_id}" data-user='${JSON.stringify(user)}'>
                    <td data-label="ID">${user.user_id}</td>
                    <td data-label="Name"><strong>${escapeHtml(user.first_name)} ${escapeHtml(user.last_name)}</strong><br><small>${escapeHtml(user.username)}</small></td>
                    <td data-label="Rolle">${user.role}</td>
                    <td data-label="Details">${details}</td>
                    <td data-label="Community">${communityStatus}</td>
                    <td class="actions" data-label="Aktionen">
                        ${impersonateButton}
                        <button class="btn btn-warning btn-small edit-user">Bearbeiten</button>
                        <button class="btn btn-danger btn-small delete-user">L√∂schen</button>
                    </td>
                </tr>
            `;
        }).join('') : '<tr><td colspan="6" style="text-align: center; padding: 20px;">Keine Benutzer gefunden.</td></tr>';
    };

    const populateSelects = (data) => {
        allData = data;
        roleSelect.innerHTML = data.roles.map(r => `<option value="${r}">${r.charAt(0).toUpperCase() + r.slice(1)}</option>`).join('');
        classSelect.innerHTML = '<option value="">Keine Klasse</option>' + data.classes.map(c => `<option value="${c.class_id}">${escapeHtml(c.class_name)}</option>`).join('');
        teacherSelect.innerHTML = '<option value="">Kein Lehrerprofil</option>' + data.teachers.map(t => `<option value="${t.teacher_id}">${escapeHtml(t.first_name)} ${escapeHtml(t.last_name)} (${escapeHtml(t.teacher_shortcut)})</option>`).join('');
    };

    const loadUsers = async () => {
        tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 40px;"><div class="loading-spinner"></div></td></tr>';
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/users`);
            if (response.success) {
                renderTable(response.data.users);
                populateSelects(response.data);
                toggleRoleSpecificFields();
            }
        } catch (error) {
            tableBody.innerHTML = '<tr><td colspan="6" class="message error">Fehler beim Laden der Benutzer.</td></tr>';
        }
    };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const mode = form.dataset.mode;
        
        const formData = new FormData(form);
        let data = Object.fromEntries(formData.entries());

        data.is_community_banned = data.is_community_banned ? 1 : 0;
        
        if (data.role !== 'schueler') {
            data.class_id = null;
            data.is_community_banned = 0;
        }
        if (data.role !== 'lehrer') {
            data.teacher_id = null;
        }
        
        if (mode === 'update' && !data.password) {
            delete data.password;
        } else if (mode === 'create' && !data.password) {
             showToast("Passwort ist beim Erstellen erforderlich.", 'error');
             return;
        }

        const url = mode === 'create'
            ? `${window.APP_CONFIG.baseUrl}/api/admin/users/create`
            : `${window.APP_CONFIG.baseUrl}/api/admin/users/update`;

        try {
            const response = await apiFetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            if (response.success) {
                showToast(response.message, 'success');
                resetForm();
                loadUsers();
            }
        } catch (error) { }
    });

    tableBody.addEventListener('click', async (e) => {
        const target = e.target;
        const row = target.closest('tr');
        if (!row) return;
        const id = row.dataset.id;
        let user;
        try {
            user = JSON.parse(row.dataset.user);
        } catch(e) {
            console.error("Could not parse user data from row:", row.dataset.user);
            return;
        }

        if (target.classList.contains('edit-user')) {
            form.dataset.mode = 'update';
            formTitle.textContent = 'Benutzer bearbeiten';
            cancelBtn.style.display = 'inline-block';
            passwordInput.removeAttribute('required');
            passwordInput.parentElement.querySelector('label').textContent = 'Neues Passwort';
            
            userIdInput.value = user.user_id;
            form.querySelector('#username').value = user.username;
            form.querySelector('#email').value = user.email;
            form.querySelector('#first_name').value = user.first_name;
            form.querySelector('#last_name').value = user.last_name;
            form.querySelector('#birth_date').value = user.birth_date;
            roleSelect.value = user.role;

            toggleRoleSpecificFields(); // WICHTIG: Zuerst aufrufen, um die Selects anzuzeigen

            if (allData.classes) classSelect.value = user.class_id || '';
            if (allData.teachers) teacherSelect.value = user.teacher_id || '';
            if (communityBanCheckbox) {
                communityBanCheckbox.checked = (user.is_community_banned == 1);
            }
            
            form.querySelector('#username').focus();
        }

        if (target.classList.contains('delete-user')) {
            if (await showConfirm('Benutzer l√∂schen', `Sind Sie sicher, dass Sie ${escapeHtml(user.first_name)} ${escapeHtml(user.last_name)} l√∂schen m√∂chten?`)) {
                try {
                    const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/users/delete`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: id })
                    });
                    if (response.success) {
                        showToast(response.message, 'success');
                        loadUsers();
                    }
                } catch (error) { }
            }
        }

        if (target.classList.contains('impersonate-user-btn')) {
            const username = target.dataset.username;
            const role = target.dataset.role;
            await handleImpersonateUser(id, username, role);
        }
    });
    
    if (importForm) {
        importForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            importButton.disabled = true;
            importButton.textContent = 'Importiere...';
            importResultsContainer.style.display = 'none';
            importResultsPre.textContent = '';

            const formData = new FormData(importForm);
            
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/users/import`, {
                    method: 'POST',
                    body: formData
                    // CSRF-Token wird vom apiFetch-Handler f√ºr FormData hinzugef√ºgt
                });
                
                if (response.success && response.data) {
                    const { successCount, errors } = response.data;
                    let resultText = `Erfolgreich importiert: ${successCount}\n`;
                    resultText += `Fehlgeschlagen/√úbersprungen: ${errors.length}\n`;
                    if (errors.length > 0) {
                        resultText += "\nFehlerdetails:\n" + errors.join('\n');
                    }
                    importResultsPre.textContent = resultText;
                    importResultsContainer.style.display = 'block';
                    showToast(`Import abgeschlossen: ${successCount} erfolgreich, ${errors.length} Fehler.`, 'success');
                    loadUsers(); // Benutzertabelle neu laden
                }
            } catch (error) {
                importResultsPre.textContent = `Fehler beim Import:\n${error.message}`;
                importResultsContainer.style.display = 'block';
            } finally {
                importButton.disabled = false;
                importButton.textContent = 'Import starten';
                importForm.reset();
            }
        });
    }

    roleSelect.addEventListener('change', toggleRoleSpecificFields);
    cancelBtn.addEventListener('click', resetForm);
    loadUsers();
}

async function handleImpersonateUser(userId, username, role) {
    if (!await showConfirm(
        'Als Benutzer anmelden?',
        `M√∂chten Sie sich wirklich als <strong>${escapeHtml(username)}</strong> (Rolle: ${escapeHtml(role)}) anmelden? Sie werden vom Admin-Konto abgemeldet.`
    )) {
        return;
    }

    try {
        const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/users/impersonate`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ user_id: userId })
        });

        if (response.success && response.redirectUrl) {
            showToast(`Sie sind jetzt als ${escapeHtml(username)} angemeldet.`, 'success');
            window.location.href = response.redirectUrl;
        }
    } catch (error) {
        console.error('Impersonation failed:', error);
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-users.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\api-client.js ---
import { showToast } from './notifications.js'; 
export async function apiFetch(url, options = {}) {
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
    const defaultHeaders = {
        'X-Requested-With': 'XMLHttpRequest',
    };
    if (csrfToken && options.method === 'POST' && !(options.body instanceof FormData)) {
        defaultHeaders['X-CSRF-TOKEN'] = csrfToken;
    }
    if (!(options.body instanceof FormData) && options.headers && options.headers['Content-Type']) {
         defaultHeaders['Content-Type'] = options.headers['Content-Type'];
    } else if (!(options.body instanceof FormData) && options.body && typeof options.body === 'string') {
         defaultHeaders['Content-Type'] = 'application/json';
    }
    const config = {
        ...options,
        headers: {
            ...defaultHeaders,
            ...(options.headers && !(options.body instanceof FormData) ? options.headers : {}),
        },
    };
    if (config.body instanceof FormData && csrfToken && options.method === 'POST') {
        if (!config.body.has('_csrf_token')) {
            config.body.append('_csrf_token', csrfToken);
        }
    }
    try {
        const response = await fetch(url, config);
        const responseText = await response.text();
        if (!response.ok) {
            let errorMessage = `Serverfehler: ${response.status}`;
            try {
                const errorData = JSON.parse(responseText);
                errorMessage = errorData.message || errorMessage;
            } catch (e) {
                errorMessage = `Serverfehler: ${response.status} (${response.statusText})`;
                if (response.status === 404) {
                    errorMessage = `API-Endpunkt nicht gefunden (404): ${url}`;
                }
            }
            if (response.status === 403 && (errorMessage.includes('CSRF') || errorMessage.includes('Sicherheit') || responseText.includes('CSRF'))) {
                throw new Error("Sicherheits√ºberpr√ºfung fehlgeschlagen. Bitte laden Sie die Seite neu und versuchen Sie es erneut.");
            }
            throw new Error(errorMessage);
        }
        let data;
        try {
            data = JSON.parse(responseText);
        } catch (e) {
            console.error("API-Antwort war kein g√ºltiges JSON:", responseText);
            throw new Error(`Ung√ºltige JSON-Antwort vom Server erhalten. (M√∂glicherweise ein PHP-Fehler). Antwort-Anfang: ${responseText.substring(0, 100)}...`);
        }
        if (data.success === false) {
            throw new Error(data.message || 'Ein unbekannter Anwendungsfehler ist aufgetreten.');
        }
        return data;
    } catch (error) {
        console.error('API Fehler:', error);
        showToast(error.message, 'error');
        throw error;
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\api-client.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard-community.js ---
import { apiFetch } from './api-client.js';
import { showToast } from './notifications.js';
import { escapeHtml } from './planer-utils.js';
export function initializeDashboardCommunity() {
    const section = document.getElementById('section-community-board');
    if (!section) return;
    const form = document.getElementById('community-post-form');
    const titleInput = document.getElementById('post-title');
    const contentInput = document.getElementById('post-content');
    const createButton = document.getElementById('create-post-btn');
    const postSpinner = document.getElementById('post-create-spinner');
    const postListContainer = document.getElementById('community-posts-list');
    let hasLoaded = false; 
    const loadCommunityPosts = async () => {
        if (hasLoaded) return; 
        hasLoaded = true; 
        postListContainer.innerHTML = '<div class="loading-spinner"></div>';
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/posts`);
            if (response.success && response.data) {
                renderPosts(response.data);
            } else {
                throw new Error(response.message || 'Beitr√§ge konnten nicht geladen werden.');
            }
        } catch (error) {
            console.error("Fehler beim Laden der Community-Beitr√§ge:", error);
            postListContainer.innerHTML = `<p class="message error">${escapeHtml(error.message)}</p>`;
            hasLoaded = false; 
        }
    };
    const renderPosts = (posts) => {
        if (posts.length === 0) {
            postListContainer.innerHTML = '<p class="message info" style="margin: 0;">Keine Beitr√§ge am Schwarzen Brett vorhanden.</p>';
            return;
        }
        postListContainer.innerHTML = posts.map(post => {
            const contentHtml = post.content_html || '<p><em>Kein Inhalt.</em></p>'; 
            const postDate = new Date(post.created_at).toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
            const authorName = `${escapeHtml(post.first_name)} ${escapeHtml(post.last_name[0])}.`;
            const emailLink = post.email 
                ? `(<a href="mailto:${escapeHtml(post.email)}" title="E-Mail an ${escapeHtml(post.first_name)}">${escapeHtml(post.username)}</a>)`
                : `(${escapeHtml(post.username)})`;
            return `
            <div class="community-post-item" data-id="${post.post_id}">
                <div class="post-header">
                    <strong class="post-title">${escapeHtml(post.title)}</strong>
                    <span class="post-meta">
                        Von: ${authorName} ${emailLink}
                        <br>
                        Am: ${postDate} Uhr
                    </span>
                </div>
                <div class="post-content-preview">
                    ${contentHtml}
                </div>
            </div>
            `;
        }).join('');
    };
    if (form) {
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            const title = titleInput.value.trim();
            const content = contentInput.value.trim();
            if (!title || !content) {
                showToast("Titel und Inhalt d√ºrfen nicht leer sein.", "error");
                return;
            }
            createButton.disabled = true;
            postSpinner.style.display = 'block';
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/posts/create`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, content })
                });
                if (response.success) {
                    showToast(response.message, 'success');
                    form.reset(); 
                    if (response.status === 'approved') {
                        hasLoaded = false; 
                        loadCommunityPosts();
                    }
                }
            } catch (error) {
                console.error("Fehler beim Erstellen des Beitrags:", error);
            } finally {
                createButton.disabled = false;
                postSpinner.style.display = 'none';
            }
        });
    }
    const tabButton = document.querySelector('.tab-button[data-target="section-community-board"]');
    if (tabButton) {
        const loadOnVisible = () => {
            if (section.classList.contains('active') && !hasLoaded) {
                loadCommunityPosts();
            }
        };
        tabButton.addEventListener('click', loadOnVisible);
        if (section.classList.contains('active')) {
            loadOnVisible();
        }
    } else {
        loadCommunityPosts();
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard-community.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard-my-posts.js ---
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js';
import { escapeHtml } from './planer-utils.js'; 
export function initializeMyCommunityPosts() {
    const section = document.getElementById('section-my-posts');
    if (!section) return;
    const postListContainer = document.getElementById('my-posts-list');
    const postModal = document.getElementById('my-post-edit-modal');
    const postForm = document.getElementById('my-post-edit-form');
    const postTitleInput = document.getElementById('edit-post-title');
    const postContentInput = document.getElementById('edit-post-content');
    const postIdInput = document.getElementById('edit-post-id');
    const postSpinner = document.getElementById('edit-post-spinner');
    const cancelEditBtn = document.getElementById('my-post-modal-cancel-btn');
    const closeEditBtn = document.getElementById('my-post-modal-close-btn');
    let hasLoaded = false;
    let isSaving = false;
    const loadMyPosts = async () => {
        if (hasLoaded) return; 
        hasLoaded = true;
        if (!postListContainer) return;
        postListContainer.innerHTML = '<div class="loading-spinner"></div>';
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/my-posts`);
            if (response.success && response.data) {
                renderMyPosts(response.data);
            } else {
                throw new Error(response.message || 'Beitr√§ge konnten nicht geladen werden.');
            }
        } catch (error) {
            console.error("Fehler beim Laden meiner Beitr√§ge:", error);
            if (postListContainer) {
                postListContainer.innerHTML = `<p class="message error">${escapeHtml(error.message)}</p>`;
            }
            hasLoaded = false; 
        }
    };
    const renderMyPosts = (posts) => {
        if (!postListContainer) return;
        if (posts.length === 0) {
            postListContainer.innerHTML = '<p class="message info" style="margin: 0;">Du hast noch keine Beitr√§ge erstellt.</p>';
            return;
        }
        postListContainer.innerHTML = posts.map(post => {
            const postDate = new Date(post.created_at).toLocaleString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }) + ' Uhr';
            const contentHtml = post.content_html || '<p><em>Kein Inhalt.</em></p>';
            let statusClass = '';
            let statusText = '';
            switch (post.status) {
                case 'pending':
                    statusClass = 'status-pending';
                    statusText = 'Ausstehend';
                    break;
                case 'approved':
                    statusClass = 'status-approved';
                    statusText = 'Genehmigt';
                    break;
                case 'rejected':
                    statusClass = 'status-rejected';
                    statusText = 'Abgelehnt';
                    break;
            }
            return `
                <div class="community-post-item my-post-item" data-id="${post.post_id}" data-title="${escapeHtml(post.title)}" data-content="${escapeHtml(post.content)}">
                    <div class="post-content-preview">
                        <strong class="post-title">${escapeHtml(post.title)}</strong>
                        ${contentHtml}
                    </div>
                    <div class="my-post-meta">
                        <div class="post-status">
                            <span>Erstellt am: ${postDate}</span>
                            <span class="status-badge ${statusClass}">${statusText}</span>
                        </div>
                        <div class="post-actions">
                            <button class="btn btn-secondary btn-small edit-my-post-btn">Bearbeiten</button>
                            <button class="btn btn-danger btn-small delete-my-post-btn">L√∂schen</button>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    };
    const openEditModal = (postItem) => {
        if (!postModal) return;
        const id = postItem.dataset.id;
        const title = postItem.dataset.title;
        const content = postItem.dataset.content; 
        postIdInput.value = id;
        postTitleInput.value = title;
        postContentInput.value = content;
        postModal.classList.add('visible');
        postTitleInput.focus();
    };
    const closeEditModal = () => {
        if (postModal) {
            postModal.classList.remove('visible');
            postForm.reset();
            postIdInput.value = '';
            postSpinner.style.display = 'none';
            postForm.querySelector('button[type="submit"]').disabled = false;
        }
    };
    const handleUpdatePost = async (e) => {
        e.preventDefault();
        if (isSaving) return;
        const id = postIdInput.value;
        const title = postTitleInput.value.trim();
        const content = postContentInput.value.trim();
        if (!id || !title || !content) {
            showToast("Titel und Inhalt d√ºrfen nicht leer sein.", "error");
            return;
        }
        isSaving = true;
        postSpinner.style.display = 'block';
        postForm.querySelector('button[type="submit"]').disabled = true;
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/post/update`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ post_id: id, title: title, content: content })
            });
            if (response.success) {
                showToast(response.message, 'success');
                closeEditModal();
                hasLoaded = false; 
                loadMyPosts();
            }
        } catch (error) {
            console.error("Fehler beim Aktualisieren des Beitrags:", error);
        } finally {
            isSaving = false;
            postSpinner.style.display = 'none';
        }
    };
    const handleDeletePost = async (postItem) => {
        const id = postItem.dataset.id;
        const title = postItem.dataset.title;
        if (await showConfirm("Beitrag l√∂schen", `M√∂chtest du deinen Beitrag "${escapeHtml(title)}" wirklich endg√ºltig l√∂schen?`)) {
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/post/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ post_id: id })
                });
                if (response.success) {
                    showToast(response.message, 'success');
                    postItem.style.transition = 'opacity 0.3s ease, height 0.3s ease, margin 0.3s ease, padding 0.3s ease';
                    postItem.style.opacity = '0';
                    postItem.style.height = '0px';
                    postItem.style.paddingTop = '0';
                    postItem.style.paddingBottom = '0';
                    postItem.style.margin = '0';
                    setTimeout(() => {
                        postItem.remove();
                        if (postListContainer.childElementCount === 0) {
                            renderMyPosts([]);
                        }
                    }, 300);
                }
            } catch (error) {
                console.error("Fehler beim L√∂schen des Beitrags:", error);
            }
        }
    };
    postListContainer.addEventListener('click', (e) => {
        const editButton = e.target.closest('.edit-my-post-btn');
        const deleteButton = e.target.closest('.delete-my-post-btn');
        if (editButton) {
            const postItem = editButton.closest('.my-post-item');
            if (postItem) openEditModal(postItem);
            return;
        }
        if (deleteButton) {
            const postItem = deleteButton.closest('.my-post-item');
            if (postItem) handleDeletePost(postItem);
            return;
        }
    });
    if (postForm) {
        postForm.addEventListener('submit', handleUpdatePost);
    }
    if (cancelEditBtn) {
        cancelEditBtn.addEventListener('click', closeEditModal);
    }
    if (closeEditBtn) {
        closeEditBtn.addEventListener('click', closeEditModal);
    }
    if (postModal) {
        postModal.addEventListener('click', (e) => {
            if (e.target.id === 'my-post-edit-modal') {
                closeEditModal();
            }
        });
    }
    const tabButton = document.querySelector('.tab-button[data-target="section-my-posts"]');
    if (tabButton) {
        const loadOnVisible = () => {
            if (section.classList.contains('active') && !hasLoaded) {
                loadMyPosts();
            }
        };
        tabButton.addEventListener('click', loadOnVisible);
        if (section.classList.contains('active')) {
            loadOnVisible();
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard-my-posts.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard.js ---
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js';
import { escapeHtml } from './planer-utils.js';
import { initializeMyCommunityPosts } from './dashboard-my-posts.js';

function getWeekAndYear(date) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    return { week: weekNo, year: d.getUTCFullYear() };
}

function getDateOfISOWeek(week, year) {
    const simple = new Date(Date.UTC(year, 0, 1 + (week - 1) * 7));
    const dow = simple.getUTCDay();
    const ISOweekStart = simple;
    ISOweekStart.setUTCDate(simple.getUTCDate() - (dow || 7) + 1);
    return new Date(ISOweekStart.getUTCFullYear(), ISOweekStart.getUTCMonth(), ISOweekStart.getUTCDate());
}

function formatTimeSlot(period) {
    const times = [
        "08:00", "08:55", "09:40", "10:35", "11:20",
        "13:05", "13:50", "14:45", "15:30", "16:25"
    ];
    return times[period - 1] || '??:??';
}

function formatGermanDate(dateString) {
    if (!dateString) return '';
    try {
        const parts = dateString.split('-');
        if (parts.length === 3) {
            return `${parts[2]}.${parts[1]}.${parts[0]}`;
        }
        return dateString;
    } catch(e) {
        return dateString;
    }
}

function formatShortTime(timeString) {
    if (!timeString) return '';
    const parts = timeString.split(':');
    if (parts.length >= 2) {
        return `${parts[0]}:${parts[1]}`;
    }
    return timeString;
}

const dashboardState = {
    stammdaten: null,
    currentTimetable: [],
    currentSubstitutions: [],
    studentNotes: {}, 
    currentPublishStatus: { student: false, teacher: false }
};

const days = ["Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag"];
const timeSlotsDisplay = [
     "08:00 - 08:45", "08:55 - 09:40", "09:40 - 10:25", "10:35 - 11:20",
     "11:20 - 12:05", "13:05 - 13:50", "13:50 - 14:35", "14:45 - 15:30",
     "15:30 - 16:15", "16:25 - 17:10"
];

const userRole = window.APP_CONFIG.userRole;
const today = new Date();
const todayDateString = today.toISOString().split('T')[0];
const todayDayOfWeek = (today.getDay() === 0) ? 7 : today.getDay(); 

const yearSelector = document.getElementById('year-selector');
const weekSelector = document.getElementById('week-selector');
const planHeaderInfo = document.getElementById('plan-header-info');
const timetableContainer = document.getElementById('timetable-container');
const announcementsList = document.getElementById('announcements-list');
const todayScheduleContainer = document.getElementById('today-schedule-container');
const icalUrlInput = document.getElementById('ical-url');
const copyIcalUrlButton = document.getElementById('copy-ical-url');
const pdfButton = document.getElementById('export-pdf-btn');
const printableSection = document.getElementById('weekly-timetable-section-printable');

const detailModal = document.getElementById('plan-detail-modal');
const detailCloseBtn = document.getElementById('plan-detail-close-btn');
const noteRow = document.getElementById('detail-notes-row');
const noteInput = document.getElementById('detail-notes-input');
const noteSaveBtn = document.getElementById('plan-detail-save-note-btn');
const noteSpinner = document.getElementById('note-save-spinner');

const loadAnnouncements = async () => {
    if (!announcementsList) return;
    announcementsList.innerHTML = '<div class="loading-spinner"></div>';
    try {
        const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/announcements`);
        if (response.success && response.data) {
            if (response.data.length === 0) {
                announcementsList.innerHTML = '<p class="message info" style="padding: 20px; margin: 0; text-align: center;">Keine aktuellen Ank√ºndigungen.</p>';
                return;
            }
            announcementsList.style.padding = '0';
            announcementsList.innerHTML = response.data.map(item => {
                let targetInfo = '';
                let visibilityText = item.is_global ? 'Global' : 'Klasse';
                let badgeClass = item.is_global ? 'global' : 'class';
                if (!item.is_global && item.target_class_name) {
                    targetInfo = ` (Klasse: ${escapeHtml(item.target_class_name)})`;
                }
                const attachmentLink = item.file_url
                    ? `<p class="announcement-attachment"><a href="${escapeHtml(item.file_url)}" target="_blank" download>üìé Anhang herunterladen</a></p>`
                    : '';
                const contentHtml = item.content_html || '<p><em>Kein Inhalt.</em></p>';
                return `
                <div class="announcement-item">
                    <div class="announcement-header">
                        <div class="announcement-title-meta">
                            <strong>${escapeHtml(item.title)}</strong> <small>Von ${escapeHtml(item.author_name)}${targetInfo} ‚Ä¢ ${new Date(item.created_at).toLocaleDateString('de-DE')}</small>
                        </div>
                        <span class="announcement-badge ${badgeClass}">${visibilityText}</span>
                    </div>
                    <div class="announcement-content"> ${contentHtml} </div>
                    ${attachmentLink}
                </div>
                `;
            }).join('');
        } else {
            throw new Error(response.message || "Ank√ºndigungen konnten nicht geladen werden.");
        }
    } catch (error) {
        console.error("Announcement loading error:", error);
        announcementsList.innerHTML = `<p class="message error" style="margin: 20px;">${error.message || 'Ank√ºndigungen konnten nicht geladen werden.'}</p>`;
    }
};

const populateSelectors = () => {
    if (!yearSelector || !weekSelector) return; 
    const currentYear = new Date().getFullYear();
    let yearOptions = '';
    for (let i = currentYear - 1; i <= currentYear + 1; i++) {
        yearOptions += `<option value="${i}">${i}</option>`;
    }
    yearSelector.innerHTML = yearOptions;
    let weekOptions = '';
    for (let i = 1; i <= 53; i++) {
        weekOptions += `<option value="${i}">KW ${i}</option>`;
    }
    weekSelector.innerHTML = weekOptions;
    const { week, year } = getWeekAndYear(today);
    yearSelector.value = year;
    weekSelector.value = week;
};

const loadAndRenderWeeklyData = async () => {
    if (!yearSelector || !weekSelector) return; 
    const year = yearSelector.value;
    const week = weekSelector.value;
    timetableContainer.innerHTML = '<div class="loading-spinner"></div>';
    if (todayScheduleContainer) {
        todayScheduleContainer.innerHTML = '<div class="loading-spinner small"></div>';
    }
    const monday = getDateOfISOWeek(Number(week), Number(year));
    const friday = new Date(monday.getTime() + 4 * 24 * 60 * 60 * 1000);
    planHeaderInfo.textContent = `Stundenplan f√ºr die ${week}. Kalenderwoche (${monday.toLocaleDateString('de-DE')} - ${friday.toLocaleDateString('de-DE')})`;
    let timetable = [];
    let substitutions = [];
    let academicEvents = [];
    let appointments = [];
    let studentNotes = {}; 
    try {
        const planUrl = `${window.APP_CONFIG.baseUrl}/api/dashboard/weekly-data?year=${year}&week=${week}`;
        const planResponse = await apiFetch(planUrl);
        if (!planResponse.success || !planResponse.data) {
            throw new Error(planResponse.message || "Plandaten konnten nicht geladen werden.");
        }
        timetable = planResponse.data.timetable || [];
        substitutions = planResponse.data.substitutions || [];
        appointments = planResponse.data.appointments || [];
        studentNotes = (userRole === 'schueler') ? (planResponse.data.studentNotes || {}) : {}; 
        dashboardState.currentTimetable = timetable;
        dashboardState.currentSubstitutions = substitutions;
        dashboardState.studentNotes = studentNotes; 
        renderWeeklyTimetable(timetable, substitutions, studentNotes); 
        if (userRole === 'schueler') {
            try {
                const eventsUrl = `${window.APP_CONFIG.baseUrl}/api/student/events?year=${year}&week=${week}`;
                const eventsResponse = await apiFetch(eventsUrl);
                if (eventsResponse.success && eventsResponse.data) {
                    academicEvents = eventsResponse.data;
                } else {
                    console.warn("Zusatz-Events (Aufgaben/Klausuren) konnten nicht geladen werden:", eventsResponse.message || "Unbekannter Fehler");
                }
            } catch (eventError) {
                console.error("Fehler beim Laden der Events:", eventError);
            }
        }
        renderTodaySchedule(timetable, substitutions, academicEvents, appointments, studentNotes); 
    } catch (error) { 
        console.error("Fehler beim Laden der Wochendaten (kritisch):", error);
        timetableContainer.innerHTML = `<p class="message error">${error.message || 'Der Wochenplan konnte nicht geladen werden.'}</p>`;
        if (todayScheduleContainer) {
            todayScheduleContainer.innerHTML = `<p class="message error small">Heutiger Plan nicht verf√ºgbar.</p>`;
        }
    }
};

const renderTodaySchedule = (weeklyTimetable, weeklySubstitutions, academicEvents, appointments, studentNotes) => {
    if (!todayScheduleContainer) return;
    const currentDayNum = todayDayOfWeek;
    if (currentDayNum < 1 || currentDayNum > 5) {
        todayScheduleContainer.innerHTML = '<p class="message info" style="padding: 10px; margin: 0;">Heute ist kein Schultag. Genie√üe die freie Zeit! üéâ</p>';
        return;
    }
    const PERIOD_END_TIMES = [
        845, 940, 1025, 1120, 1205, 
        1350, 1435, 1530, 1615, 1710  
    ];
    const now = new Date();
    const timeFormatter = new Intl.DateTimeFormat('de-DE', {
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'Europe/Berlin', 
        hour12: false
    });
    const parts = timeFormatter.format(now).split(':'); 
    const currentHHMM = parseInt(parts[0], 10) * 100 + parseInt(parts[1], 10); 
    const todaysEntries = weeklyTimetable.filter(entry => entry.day_of_week == currentDayNum);
    const todaysSubstitutions = weeklySubstitutions.filter(sub => sub.date === todayDateString);
    const todaysEvents = (academicEvents || []).filter(event => event.due_date === todayDateString);
    const todaysAppointments = (appointments || []).filter(app => app.appointment_date === todayDateString);
    let combinedSchedule = [];
    for (let period = 1; period <= timeSlotsDisplay.length; period++) {
        const periodEndTime = PERIOD_END_TIMES[period - 1]; 
        if (currentHHMM > periodEndTime) {
            continue; 
        }
        const substitution = todaysSubstitutions.find(sub => sub.period_number === period);
        const regularEntry = todaysEntries.find(entry => entry.period_number === period);
        const noteKey = `${todayDayOfWeek}-${period}`; 
        const note = studentNotes[noteKey] || ''; 
        if (substitution) {
            combinedSchedule.push({
                sortKey: period * 10,
                period: period,
                time: formatTimeSlot(period),
                type: substitution.substitution_type,
                id: substitution.substitution_id, 
                class_id: substitution.class_id, 
                subject: substitution.new_subject_shortcut || regularEntry?.subject_shortcut || (substitution.substitution_type === 'Sonderevent' ? 'EVENT' : '---'),
                mainText: substitution.substitution_type === 'Vertretung'
                    ? (userRole === 'teacher' ? (substitution.class_name || regularEntry?.class_name) : substitution.new_teacher_shortcut)
                    : (substitution.substitution_type === 'Entfall' ? '' : (regularEntry ? (userRole === 'schueler' ? regularEntry.teacher_shortcut : regularEntry.class_name) : '')),
                room: substitution.new_room_name || regularEntry?.room_name || '',
                comment: substitution.comment || '',
                note: note, 
                icsType: (substitution.substitution_type === 'Sonderevent') ? 'sub' : null 
            });
        } else if (regularEntry) {
            combinedSchedule.push({
                sortKey: period * 10,
                period: period,
                time: formatTimeSlot(period),
                type: 'regular',
                id: regularEntry.entry_id,
                class_id: regularEntry.class_id, 
                subject: regularEntry.subject_shortcut || '---',
                mainText: userRole === 'schueler' ? regularEntry.teacher_shortcut : regularEntry.class_name,
                room: regularEntry.room_name || '---',
                comment: regularEntry.comment || '',
                note: note, 
                icsType: null
            });
        }
    }
    todaysEvents.forEach(event => {
        combinedSchedule.push({
            sortKey: 1, 
            time: 'Ganzt√§gig',
            type: event.event_type,
            subject: event.title,
            mainText: event.subject_shortcut || (userRole === 'schueler' ? `${event.teacher_first_name} ${event.teacher_last_name}` : ''),
            room: '',
            comment: event.description || '',
            note: '', 
            id: event.event_id, 
            icsType: 'acad' 
        });
    });
    todaysAppointments.forEach(app => {
        const appTime = formatShortTime(app.appointment_time);
        const sortKeyTime = parseInt(appTime.replace(':', ''), 10); 
        const timeParts = app.appointment_time.split(':'); 
        const duration = parseInt(app.duration, 10) || 15; 
        if (timeParts.length >= 2) {
            const startH = parseInt(timeParts[0], 10);
            const startM = parseInt(timeParts[1], 10);
            const endM = startM + duration; 
            const endH = startH + Math.floor(endM / 60); 
            const finalEndM = endM % 60; 
            const endHHMM = (endH * 100) + finalEndM; 
            if (currentHHMM > endHHMM) {
                return; 
            }
        }
        let mainText = '';
        if (userRole === 'lehrer') {
            mainText = app.class_name 
                ? `Klasse: ${escapeHtml(app.class_name)} (ID: ${escapeHtml(app.class_id)})` 
                : 'Sch√ºler';
        }
        combinedSchedule.push({
            sortKey: sortKeyTime,
            time: appTime,
            type: 'appointment',
            class_id: app.class_id, 
            subject: userRole === 'schueler' ? `Sprechstunde (${escapeHtml(app.teacher_shortcut || app.teacher_name)})` : `Sprechstunde (${escapeHtml(app.student_name)})`,
            mainText: mainText, 
            room: app.location || 'N/A', 
            comment: app.notes || '',
            note: '', 
            id: app.appointment_id,
            icsType: null 
        });
    });
    combinedSchedule.sort((a, b) => a.sortKey - b.sortKey);
    if (combinedSchedule.length === 0) {
        todayScheduleContainer.innerHTML = '<p class="message info" style="padding: 10px; margin: 0;">F√ºr heute sind keine Eintr√§ge (mehr) vorhanden.</p>';
        return;
    }
    const icsIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M14 0H2a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2M2 1a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v1H2zM14 15H2a1 1 0 0 1-1-1V5h14v9a1 1 0 0 1-1 1M9 7.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5zM6.5 9a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5m-3 2a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5z"/></svg>`;
    const noteIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 0A1.5 1.5 0 0 0 0 1.5V13a1 1 0 0 0 1 1V1.5a.5.5 0 0 1 .5-.5H14a1 1 0 0 0-1-1zM3.5 2A1.5 1.5 0 0 0 2 3.5v11A1.5 1.5 0 0 0 3.5 16h9a1.5 1.5 0 0 0 1.5-1.5v-11A1.5 1.5 0 0 0 12.5 2zM3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5z"/></svg>`;
    todayScheduleContainer.innerHTML = combinedSchedule.map(item => {
        const typeClass = `type-${item.type.replace(' ', '')}`;
        let commentHtml = '';
        if (item.comment) {
            commentHtml += `<small class="entry-comment" title="${escapeHtml(item.comment)}">üìù ${escapeHtml(item.comment)}</small>`;
        }
        if (item.note) {
            commentHtml += `<small class="entry-note" title="${escapeHtml(item.note)}">${noteIcon} ${escapeHtml(item.note)}</small>`;
        }
        let detailsHtml = `<strong>${escapeHtml(item.subject)}</strong>`;
        if(item.mainText && item.type !== 'Entfall') {
            if (userRole === 'lehrer' && item.type !== 'appointment' && item.class_id) {
                detailsHtml += `<span>${escapeHtml(item.mainText)} (ID: ${escapeHtml(item.class_id)})</span>`;
            } else {
                detailsHtml += `<span>${escapeHtml(item.mainText)}</span>`;
            }
        }
        if(item.room && item.type !== 'Entfall') detailsHtml += `<span>${escapeHtml(item.room)}</span>`;
        let actionButton = '';
        if (item.type === 'appointment') {
            actionButton = `<button class="btn btn-danger btn-small cancel-appointment-btn" data-id="${item.id}" title="Termin stornieren">&times;</button>`;
        }
        let icsButtonHtml = '';
        if (item.icsType === 'acad') { 
            const icsUrl = `${window.APP_CONFIG.baseUrl}/ics/event/acad/${item.id}`;
            icsButtonHtml = `<a href="${icsUrl}" class="btn-ics" title="Zum Kalender hinzuf√ºgen">${icsIcon}</a>`;
        } else if (item.icsType === 'sub') { 
            const icsUrl = `${window.APP_CONFIG.baseUrl}/ics/event/sub/${item.id}`;
            icsButtonHtml = `<a href="${icsUrl}" class="btn-ics" title="Zum Kalender hinzuf√ºgen">${icsIcon}</a>`;
        }
        return `
        <div class="today-entry ${typeClass}">
            <div class="time">${escapeHtml(item.time)}</div>
            <div class="details">
                ${detailsHtml}
                ${commentHtml}
            </div>
            <div class="entry-actions">
                <span class="type-badge ${typeClass}">${item.type === 'regular' ? 'Plan' : (item.type === 'klausur' ? 'Klausur' : (item.type === 'aufgabe' ? 'Aufgabe' : (item.type === 'info' ? 'Info' : (item.type === 'appointment' ? 'Termin' : item.type))))}</span>
                ${icsButtonHtml}
                ${actionButton}
            </div>
        </div>
        `;
    }).join('');
    todayScheduleContainer.querySelectorAll('.cancel-appointment-btn').forEach(btn => {
        btn.addEventListener('click', handleCancelAppointment);
    });
};

const renderWeeklyTimetable = (weeklyTimetableData, allWeeklySubstitutions, studentNotes) => {
    const processedCellKeys = new Set();
    const blockSpans = new Map();
    const blocks = new Map();
    weeklyTimetableData.forEach(entry => {
        if (entry.block_id) {
            if (!blocks.has(entry.block_id)) blocks.set(entry.block_id, []);
            blocks.get(entry.block_id).push(entry);
        }
    });
    blocks.forEach(entries => {
        if (entries.length === 0) return;
        entries.sort((a, b) => a.period_number - b.period_number);
        const startEntry = entries[0];
        const span = entries[entries.length - 1].period_number - startEntry.period_number + 1;
        blockSpans.set(`${startEntry.day_of_week}-${startEntry.period_number}`, span);
        for (let i = 1; i < span; i++) {
            processedCellKeys.add(`${startEntry.day_of_week}-${startEntry.period_number + i}`);
        }
    });
    const substitutionBlocks = new Map();
    allWeeklySubstitutions.forEach(sub => {
        if (!sub.day_of_week) return;
        const key = `${sub.date}-${sub.class_id}-${sub.substitution_type}-${sub.comment || ''}-${sub.new_room_id || ''}-${sub.new_teacher_id || ''}-${sub.new_subject_id || ''}`;
        if (!substitutionBlocks.has(key)) substitutionBlocks.set(key, []);
        substitutionBlocks.get(key).push(sub);
    });
    substitutionBlocks.forEach(subs => {
        if (subs.length > 1) { 
            subs.sort((a, b) => a.period_number - b.period_number);
            let isConsecutive = true;
            for (let i = 0; i < subs.length - 1; i++) {
                if (parseInt(subs[i + 1].period_number) !== parseInt(subs[i].period_number) + 1) {
                    isConsecutive = false; break;
                }
            }
            if (isConsecutive) { 
                const startSub = subs[0];
                const span = subs.length;
                const dayNum = startSub.day_of_week;
                if (dayNum) {
                    blockSpans.set(`${dayNum}-${startSub.period_number}`, span);
                    for (let i = 1; i < span; i++) {
                        processedCellKeys.add(`${dayNum}-${parseInt(startSub.period_number) + i}`);
                    }
                }
            }
        }
    });
    let gridHTML = '<div class="timetable-grid">';
    gridHTML += '<div class="grid-header">Zeit</div>';
    days.forEach(day => gridHTML += `<div class="grid-header">${day}</div>`);
    const settings = window.APP_CONFIG.settings || {};
    const startHour = parseInt(settings.default_start_hour, 10) || 1;
    const endHour = parseInt(settings.default_end_hour, 10) || 10;
    timeSlotsDisplay.forEach((slot, index) => {
        const period = index + 1;
        gridHTML += `<div class="grid-header period-header">${slot}</div>`;
        days.forEach((day, dayIndex) => {
            const dayNum = dayIndex + 1; 
            const cellKey = `${dayNum}-${period}`;
            const noteKey = cellKey; 
            if (processedCellKeys.has(cellKey)) { return; }
            let cellContent = '', cellClass = 'empty', dataAttrs = `data-day="${dayNum}" data-period="${period}"`, style = '';
            const span = blockSpans.get(cellKey);
            if (span) {
                style = `grid-row: span ${span};`;
                cellClass += ' block-start';
            }
            const substitution = allWeeklySubstitutions.find(s => s.day_of_week == dayNum && s.period_number == period);
            const entryToRender = weeklyTimetableData.find(e => e.day_of_week == dayNum && e.period_number == period);
            const note = (userRole === 'schueler' && studentNotes[noteKey]) ? studentNotes[noteKey] : null; 
            dataAttrs = `data-day="${dayNum}" data-period="${period}"`; 
            if (substitution) {
                cellClass = `has-entry substitution-${substitution.substitution_type}`;
                dataAttrs += ` data-substitution-id="${substitution.substitution_id}"`;
                if (substitution.comment) dataAttrs += ` data-comment="${escapeHtml(substitution.comment)}"`;
                const regularEntry = entryToRender; 
                if(regularEntry) { 
                    dataAttrs += ` data-entry-id="${regularEntry.entry_id}"`;
                    if (regularEntry.block_id) dataAttrs += ` data-block-id="${regularEntry.block_id}"`;
                }
                dataAttrs += ` data-class-id="${substitution.class_id}"`; 
                cellContent = createCellEntryHtml(
                    substitution.substitution_type === 'Vertretung'
                        ? (substitution.new_subject_shortcut || regularEntry?.subject_shortcut)
                        : (substitution.substitution_type === 'Sonderevent' ? 'EVENT' : regularEntry?.subject_shortcut),
                    substitution.substitution_type === 'Vertretung'
                        ? (userRole === 'teacher' ? (substitution.class_name || regularEntry?.class_name) : substitution.new_teacher_shortcut)
                        : (substitution.substitution_type === 'Entfall' ? 'Entf√§llt' : (regularEntry ? (userRole === 'schueler' ? regularEntry.teacher_shortcut : regularEntry.class_name) : '---')),
                    substitution.new_room_name || regularEntry?.room_name,
                    substitution.comment, 
                    substitution.substitution_type,
                    note, 
                    substitution.class_id 
                );
            } else if (entryToRender) {
                cellClass = 'has-entry';
                dataAttrs += ` data-entry-id="${entryToRender.entry_id}"`;
                dataAttrs += ` data-class-id="${entryToRender.class_id}"`;
                if (entryToRender.block_id) dataAttrs += ` data-block-id="${entryToRender.block_id}"`;
                const mainText = userRole === 'schueler' ? entryToRender.teacher_shortcut : entryToRender.class_name;
                cellContent += createCellEntryHtml(entryToRender.subject_shortcut, mainText, entryToRender.room_name, entryToRender.comment, null, note, entryToRender.class_id); 
            } else if (period >= startHour && period <= endHour) {
                if (period === startHour || period === endHour) {
                    cellClass = 'default-entry';
                    cellContent = createCellEntryHtml('FU', 'F√∂rderunterricht', '', '', null, null, null); 
                } else {
                }
            } else {
            }
            if (note) {
                cellClass += ' has-note';
            }
            gridHTML += `<div class="grid-cell ${cellClass}" ${dataAttrs} style="${style}">${cellContent}</div>`;
        });
    });
    gridHTML += '</div>';
    timetableContainer.innerHTML = gridHTML;
};
const createCellEntryHtml = (subject, mainText, room, comment = null, substitutionType = null, note = null, class_id = null) => {
    let commentHtml = comment ? `<small class="entry-comment" title="${escapeHtml(comment)}">üìù ${escapeHtml(comment.substring(0, 15))}${comment.length > 15 ? '...' : ''}</small>` : '';
    let roomHtml = room ? `<small class="entry-room">${escapeHtml(room)}</small>` : '';
    let mainHtml = ''; 
    if (mainText) {
        if (userRole === 'lehrer' && class_id) { 
            mainHtml = `<span>${escapeHtml(mainText)} (ID: ${escapeHtml(class_id)})</span>`;
        } else {
            mainHtml = `<span>${escapeHtml(mainText)}</span>`;
        }
    }
    let subjectHtml = subject ? `<strong>${escapeHtml(subject)}</strong>` : '';
    const noteIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 0A1.5 1.5 0 0 0 0 1.5V13a1 1 0 0 0 1 1V1.5a.5.5 0 0 1 .5-.5H14a1 1 0 0 0-1-1zM3.5 2A1.5 1.5 0 0 0 2 3.5v11A1.5 1.5 0 0 0 3.5 16h9a1.5 1.5 0 0 0 1.5-1.5v-11A1.5 1.5 0 0 0 12.5 2zM3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5z"/></svg>`;
    let noteHtml = (note && userRole === 'schueler') ? `<small class="entry-note" title="${escapeHtml(note)}">${noteIcon}</small>` : '';
    if (substitutionType === 'Entfall') {
        subjectHtml = `<strong>${escapeHtml(subject)}</strong>`;
        mainHtml = `<span>Entf√§llt</span>`;
        roomHtml = '';
        commentHtml = comment ? `<small class="entry-comment" title="${escapeHtml(comment)}">üìù ${escapeHtml(comment.substring(0, 15))}${comment.length > 15 ? '...' : ''}</small>` : '';
    }
    if (substitutionType === 'Raum√§nderung') {
        roomHtml = room ? `<small class="entry-room" style="font-weight:bold; color: var(--color-warning);">${escapeHtml(room)}</small>` : '';
    }
    if (substitutionType === 'Sonderevent') {
        subjectHtml = `<strong>EVENT</strong>`;
        const safeComment = escapeHtml(comment);
        mainHtml = safeComment ? `<span title="${safeComment}">${safeComment.substring(0, 20)}${safeComment.length > 20 ? '...' : ''}</span>` : `<span>Sonderveranst.</span>`;
        commentHtml = '';
    }
    return `<div class="cell-entry">${noteHtml}${subjectHtml}${mainHtml}${roomHtml}${commentHtml}</div>`;
};
const handlePdfExport = () => {
    const year = yearSelector.value;
    const week = weekSelector.value;
    if (!year || !week) {
        showToast("Bitte Jahr und KW ausw√§hlen.", 'error');
        return;
    }
    const pdfUrl = `${window.APP_CONFIG.baseUrl}/pdf/timetable/${year}/${week}`;
    window.open(pdfUrl, '_blank');
};
const handleCancelAppointment = async (e) => {
    const button = e.target.closest('.cancel-appointment-btn');
    if (!button) return;
    const appointmentId = button.dataset.id;
    const entryElement = button.closest('.today-entry');
    const title = entryElement.querySelector('.details strong').textContent;
    if (await showConfirm("Termin stornieren", `M√∂chten Sie den Termin "${escapeHtml(title)}" wirklich stornieren?`)) {
        button.disabled = true;
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/appointment/cancel`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ appointment_id: appointmentId })
            });
            if (response.success) {
                showToast(response.message, 'success');
                entryElement.style.transition = 'opacity 0.3s ease, height 0.3s ease, margin 0.3s ease, padding 0.3s ease';
                entryElement.style.opacity = '0';
                entryElement.style.height = '0px';
                entryElement.style.paddingTop = '0';
                entryElement.style.paddingBottom = '0';
                entryElement.style.margin = '0';
                setTimeout(() => {
                    entryElement.remove();
                    if (todayScheduleContainer && todayScheduleContainer.childElementCount === 0) {
                        renderTodaySchedule([], [], [], [], {});
                    }
                }, 300);
            }
        } catch (error) {
            console.error("Fehler beim Stornieren:", error);
            button.disabled = false;
        }
    }
};
export function initializeDashboard() {
    const container = document.querySelector('.dashboard-wrapper');
    if (!container) return;
    dashboardState.stammdaten = window.APP_CONFIG.settings.stammdaten || {
        subjects: [], teachers: [], rooms: [], classes: []
    };
    if (yearSelector) yearSelector.addEventListener('change', loadAndRenderWeeklyData);
    if (weekSelector) weekSelector.addEventListener('change', loadAndRenderWeeklyData);
    if (pdfButton) pdfButton.addEventListener('click', handlePdfExport);
    if (copyIcalUrlButton && icalUrlInput) {
        copyIcalUrlButton.addEventListener('click', async () => {
            try {
                icalUrlInput.select();
                icalUrlInput.setSelectionRange(0, 99999);
                let copied = false;
                try { copied = document.execCommand('copy'); } catch(err) { copied = false; }
                if (copied) {
                    showToast('iCal URL in Zwischenablage kopiert!', 'success', 2000);
                } else if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(icalUrlInput.value);
                    showToast('iCal URL in Zwischenablage kopiert!', 'success', 2000);
                } else {
                    throw new Error('Copy command failed and Clipboard API not available.');
                }
            } catch (err) {
                console.error('Fehler beim Kopieren der iCal URL: ', err);
                showToast('Kopieren fehlgeschlagen. Bitte manuell kopieren.', 'error');
            }
            if (window.getSelection) { window.getSelection().removeAllRanges(); }
            else if (document.selection) { document.selection.empty(); }
            icalUrlInput.blur();
        });
    }
    initializeTabbedInterface();
    if (userRole === 'schueler') {
        initializeAppointmentBooking();
    }
    initializePlanDetailModal(timetableContainer, detailModal, detailCloseBtn, noteRow, noteInput, noteSaveBtn, noteSpinner);
    populateSelectors();
    loadAndRenderWeeklyData(); 
    loadAnnouncements(); 
    if(userRole === 'admin') {
        const printExportActions = document.querySelector('.print-export-actions');
        if(printExportActions) printExportActions.style.display = 'none';
        const icalBox = document.querySelector('.ical-subscription-box');
        if(icalBox) icalBox.style.display = 'none';
    }
}

// --- FUNKTIONEN F√úR SPRECHSTUNDEN (SCH√úLER) ---
function initializeAppointmentBooking() {
    const widget = document.getElementById('appointment-booking-widget');
    if (!widget) return;

    const form = document.getElementById('appointment-booking-form');
    const teacherSearchInput = document.getElementById('teacher-search-input');
    const teacherSearchResults = document.getElementById('teacher-search-results');
    const selectedTeacherIdInput = document.getElementById('selected-teacher-id');
    const datePicker = document.getElementById('appointment-date-picker'); 
    const slotsContainer = document.getElementById('available-slots-container');
    const notesContainer = document.getElementById('appointment-notes-container');
    const notesInput = document.getElementById('appointment-notes');
    const bookButton = document.getElementById('book-appointment-btn');
    const bookSpinner = document.getElementById('appointment-book-spinner');

    let searchTimeout;
    let selectedSlot = null; 
    let datePickerInstance = null; // Variable f√ºr die Flatpickr-Instanz
    let allTeacherSlots = []; // Cache f√ºr die Slots des ausgew√§hlten Lehrers

    // 1. Flatpickr (Kalender) initialisieren
    if(datePicker) {
        // Zerst√∂re alte Instanz, falls vorhanden (wichtig f√ºr Hot-Reloading)
        if (datePicker._flatpickr) {
            datePicker._flatpickr.destroy();
        }
        
        datePickerInstance = flatpickr(datePicker, {
            locale: "de", // Deutsche Lokalisierung (wird in header.php geladen)
            minDate: "today",
            dateFormat: "Y-m-d", // Format, das die API versteht
            altInput: true, // Zeigt ein benutzerfreundliches Format an
            altFormat: "d.m.Y",
            disable: [() => true], // Startet komplett deaktiviert
            onChange: function(selectedDates, dateStr, instance) {
                // Dies wird ausgel√∂st, wenn ein (aktivierter) Tag ausgew√§hlt wird
                if (selectedDates.length > 0) {
                    renderSlotsForDate(dateStr, allTeacherSlots);
                }
            },
        });
        // datePicker.disabled = true; // KORREKTUR: Entfernt. Steuerung nur √ºber flatpickr 'disable'.
    } else {
        console.error("Element #appointment-date-picker nicht gefunden!");
        return; // Abbruch, wenn das Hauptelement fehlt
    }

    // 2. Live-Suche f√ºr Lehrer
    teacherSearchInput.addEventListener('input', () => {
        clearTimeout(searchTimeout);
        resetSlotSelection();
        
        // Kalender zur√ºcksetzen und deaktivieren
        datePickerInstance.clear();
        // KORREKTUR: Nicht mehr komplett sperren, sondern nur die aktivierten Tage l√∂schen.
        // ALT: datePickerInstance.set('disable', [() => true]);
        datePickerInstance.set('enable', []); // Setzt die aktivierten Tage zur√ºck (deaktiviert effektiv alles)
        
        datePicker.placeholder = "Bitte zuerst einen Lehrer ausw√§hlen.";
        allTeacherSlots = [];

        selectedTeacherIdInput.value = '';
        
        const query = teacherSearchInput.value.trim();
        if (query.length < 2) {
            teacherSearchResults.innerHTML = '';
            teacherSearchResults.classList.remove('visible');
            return;
        }

        searchTimeout = setTimeout(async () => {
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/search-colleagues?query=${encodeURIComponent(query)}`);
                if (response.success && response.data) {
                    const filteredTeachers = response.data.filter(t => t.teacher_shortcut !== 'SGL');
                    if (filteredTeachers.length > 0) {
                        teacherSearchResults.innerHTML = filteredTeachers.map(teacher => {
                            return `
                                <div class="search-result-item" data-id="${teacher.teacher_id}" data-name="${escapeHtml(teacher.first_name)} ${escapeHtml(teacher.last_name)} (${escapeHtml(teacher.teacher_shortcut)})">
                                    <strong>${escapeHtml(teacher.last_name)}, ${escapeHtml(teacher.first_name)}</strong> (${escapeHtml(teacher.teacher_shortcut)})
                                </div>
                            `;
                        }).join('');
                        teacherSearchResults.classList.add('visible');
                    } else {
                        teacherSearchResults.innerHTML = '<div class="search-result-item none">Keine Treffer</div>';
                        teacherSearchResults.classList.add('visible');
                    }
                } else {
                    teacherSearchResults.innerHTML = '<div class="search-result-item none">Keine Treffer</div>';
                    teacherSearchResults.classList.add('visible');
                }
            } catch (error) {
                console.error("Fehler bei Lehrersuche:", error);
                teacherSearchResults.innerHTML = `<div class="search-result-item none">Fehler: ${escapeHtml(error.message)}</div>`;
                teacherSearchResults.classList.add('visible');
            }
        }, 300); 
    });

    // 3. Auswahl eines Lehrers -> L√ÑDT SLOTS UND AKTIVIERT KALENDER
    teacherSearchResults.addEventListener('click', async (e) => {
        const item = e.target.closest('.search-result-item');
        if (!item || !item.dataset.id) return;
        
        selectedTeacherIdInput.value = item.dataset.id; 
        teacherSearchInput.value = item.dataset.name;
        teacherSearchResults.innerHTML = '';
        teacherSearchResults.classList.remove('visible');
        
        // Kalender und Slots auf Ladezustand setzen
        // datePicker.disabled = true; // KORREKTUR: Entfernt
        datePicker.placeholder = "Lade verf√ºgbare Tage...";
        slotsContainer.innerHTML = '<div class="loading-spinner small"></div>';
        resetSlotSelection();

        try {
            const teacherId = selectedTeacherIdInput.value;
            // Alle verf√ºgbaren Slots f√ºr diesen Lehrer holen
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/student/upcoming-slots?teacher_id=${teacherId}`);
            
            if (response.success && response.data) {
                allTeacherSlots = response.data || [];
                // Ein Set von einzigartigen Datumswerten erstellen
                const availableDates = [...new Set(allTeacherSlots.map(slot => slot.date))];
                
                // Flatpickr-Instanz aktualisieren, um NUR DIESE TAGE zu aktivieren
                datePickerInstance.set('enable', availableDates);
                
                // datePicker.disabled = false; // KORREKTUR: Entfernt
                datePicker.placeholder = "Datum ausw√§hlen...";
                slotsContainer.innerHTML = '<small class="form-hint">Bitte ein verf√ºgbares Datum w√§hlen.</small>';

            } else {
                throw new Error(response.message || 'Fehler beim Laden der Slots.');
            }
        } catch (error) {
            slotsContainer.innerHTML = `<small class="form-hint error-hint">${escapeHtml(error.message)}</small>`;
            datePicker.placeholder = "Fehler beim Laden";
        }
    });

    // 4. (ENTFERNT) Der alte 'change'-Listener auf datePicker wird durch Flatpickr's onChange ersetzt.

    // 5. NEUE Funktion: Rendert die Slots f√ºr ein ausgew√§hltes Datum
    function renderSlotsForDate(selectedDate, allSlots) {
        resetSlotSelection(); // Alte Auswahl l√∂schen
        
        // Slots f√ºr das gew√§hlte Datum filtern
        const slotsForDate = allSlots.filter(slot => slot.date === selectedDate);

        if (slotsForDate.length > 0) {
            slotsContainer.innerHTML = slotsForDate.map(slot => {
                const locationHtml = slot.location ? `<small>${escapeHtml(slot.location)}</small>` : '<small><i>Kein Ort</i></small>';
                return `
                    <button type="button" class="btn-slot" 
                            data-time="${slot.time}" 
                            data-duration="${slot.duration}"
                            data-availability-id="${slot.availability_id}"
                            data-location="${escapeHtml(slot.location || '')}">
                        <strong>${escapeHtml(slot.display)} Uhr</strong>
                        ${locationHtml}
                    </button>
                `;
            }).join('');
        } else {
            // Sollte dank 'enable' nicht passieren, aber als Fallback
            slotsContainer.innerHTML = '<small class="form-hint">Keine freien Termine an diesem Tag.</small>';
        }
    }
    
    // 6. Auswahl eines Slots
    slotsContainer.addEventListener('click', (e) => {
        const button = e.target.closest('.btn-slot');
        if (!button) return;
        
        slotsContainer.querySelectorAll('.btn-slot').forEach(btn => btn.classList.remove('selected'));
        button.classList.add('selected');
        
        selectedSlot = {
            time: button.dataset.time,
            duration: button.dataset.duration,
            availability_id: button.dataset.availabilityId,
            location: button.dataset.location
        };
        
        notesContainer.style.display = 'block';
        bookButton.disabled = false;
    });

    // 7. Formular absenden (Buchen)
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (!selectedSlot || !selectedTeacherIdInput.value || !datePicker.value) {
            showToast("Bitte Lehrer, Datum und einen Slot ausw√§hlen.", "error");
            return;
        }

        const location = selectedSlot.location; 

        bookButton.disabled = true;
        bookSpinner.style.display = 'block';
        
        const body = {
            teacher_id: selectedTeacherIdInput.value,
            date: datePicker.value, // Flatpickr stellt sicher, dass dies YYYY-MM-DD ist
            time: selectedSlot.time,
            duration: selectedSlot.duration,
            availability_id: selectedSlot.availability_id,
            location: location, 
            notes: notesInput.value.trim() || null
        };
        
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/student/book-appointment`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            if (response.success) {
                showToast(response.message, 'success');
                form.reset();
                selectedTeacherIdInput.value = '';
                datePickerInstance.clear();
                datePickerInstance.set('disable', [() => true]);
                // datePicker.disabled = true; // KORREKTUR: Entfernt
                datePicker.placeholder = "Bitte zuerst einen Lehrer ausw√§hlen.";
                resetSlotSelection();
                loadAndRenderWeeklyData(); // L√§dt "Mein Tag" neu, um Termin anzuzeigen
            }
        } catch (error) {
             console.error("Fehler beim Buchen:", error);
             if (error.message.includes('gebu')) { // Slot wurde zwischenzeitlich gebucht
                 // Lade Slots f√ºr den Lehrer neu, um den Kalender zu aktualisieren
                 teacherSearchResults.dispatchEvent(new Event('click', { target: document.querySelector(`.search-result-item[data-id="${selectedTeacherIdInput.value}"]`) }));
             }
        } finally {
            bookButton.disabled = false;
            bookSpinner.style.display = 'none';
        }
    });

    // 8. Hilfsfunktion zum Zur√ºcksetzen der Slot-Auswahl
    const resetSlotSelection = () => {
        selectedSlot = null;
        slotsContainer.innerHTML = '<small class="form-hint">Bitte Lehrer und Datum ausw√§hlen.</small>';
        notesContainer.style.display = 'none';
        if (notesInput) notesInput.value = '';
        if (bookButton) bookButton.disabled = true;
    };

    // 9. Klick ausserhalb schliesst die Lehrersuche
    document.addEventListener('click', (e) => {
        if (widget && !widget.contains(e.target)) {
            teacherSearchResults.classList.remove('visible');
        }
    });
}
// --- ENDE SPRECHSTUNDEN-FUNKTIONEN ---


function initializeTabbedInterface() {
    const wrapper = document.querySelector('.dashboard-wrapper');
    if (!wrapper) return;
    const tabContainer = wrapper.querySelector('.tab-navigation');
    const contentContainer = wrapper.querySelector('.tab-content');
    if (!tabContainer || !contentContainer) return;
    const tabButtons = tabContainer.querySelectorAll('.tab-button');
    const tabContents = contentContainer.querySelectorAll('.dashboard-section');
    const loadedTabs = {
        'section-my-day': true,
        'section-weekly-plan': true,
        'section-announcements': true,
    };
    tabContainer.addEventListener('click', (e) => {
        const clickedButton = e.target.closest('.tab-button');
        if (!clickedButton || clickedButton.classList.contains('active')) return;
        tabButtons.forEach(btn => btn.classList.remove('active'));
        tabContents.forEach(content => content.classList.remove('active'));
        clickedButton.classList.add('active');
        const targetId = clickedButton.dataset.target;
        const targetContent = document.getElementById(targetId);
        if (targetContent) {
            targetContent.classList.add('active');
            if (!loadedTabs[targetId]) {
                if (targetId === 'section-community-board') {
                    if (window.initializeDashboardCommunity) {
                        window.initializeDashboardCommunity();
                    }
                }
                else if (targetId === 'section-my-posts') {
                    if (initializeMyCommunityPosts) { 
                        initializeMyCommunityPosts();
                    }
                }
                else if (targetId === 'section-attendance' || targetId === 'section-events' || targetId === 'section-office-hours' || targetId === 'section-colleague-search') {
                     if (window.initializeTeacherCockpit) {
                         window.initializeTeacherCockpit(); 
                         loadedTabs['section-attendance'] = true;
                         loadedTabs['section-events'] = true;
                         loadedTabs['section-office-hours'] = true;
                         loadedTabs['section-colleague-search'] = true;
                     }
                }
                loadedTabs[targetId] = true; 
            }
        }
    });
}
function initializePlanDetailModal(timetableContainer, modal, closeBtn, noteRow, noteInput, noteSaveBtn, noteSpinner) {
    if (!timetableContainer || !modal || !closeBtn) {
        console.warn("Detail-Modal-Initialisierung √ºbersprungen: Elemente fehlen.", {timetableContainer, modal, closeBtn});
        return;
    }
    const state = {
        currentSlotKey: null, 
        isSaving: false
    };
    const close = () => modal.classList.remove('visible');
    closeBtn.addEventListener('click', close);
    modal.addEventListener('click', (e) => {
        if (e.target.id === 'plan-detail-modal') {
            close();
        }
    });
    timetableContainer.addEventListener('click', (e) => {
        const cell = e.target.closest('.grid-cell.has-entry');
        if (!cell || e.target.closest('a') || cell.classList.contains('dragging')) {
            return;
        }
        const { stammdaten, currentTimetable, currentSubstitutions, studentNotes } = dashboardState;
        const day = cell.dataset.day;
        const period = cell.dataset.period;
        const entryId = cell.dataset.entryId;
        const blockId = cell.dataset.blockId;
        const substitutionId = cell.dataset.substitutionId;
        state.currentSlotKey = `${day}-${period}`; 
        let data = {}; 
        let status = "Regul√§r";
        let statusClass = "status-regular";
        let entry = null;
        if (blockId) {
            entry = currentTimetable.find(e => e.block_id === blockId && e.day_of_week == day);
        } else if (entryId) {
            entry = currentTimetable.find(e => e.entry_id == entryId);
        }
        let substitution = substitutionId ? currentSubstitutions.find(s => s.substitution_id == substitutionId) : null;
        if (substitution) {
            const regularEntry = entry; 
            status = substitution.substitution_type;
            statusClass = `status-${substitution.substitution_type.toLowerCase()}`;
            data.subject = substitution.new_subject_shortcut || regularEntry?.subject_shortcut || 'N/A';
            data.teacher = substitution.new_teacher_shortcut || (userRole === 'schueler' ? regularEntry?.teacher_shortcut : null) || 'N/A';
            data.room = substitution.new_room_name || regularEntry?.room_name || 'N/A';
            data.class = substitution.class_name || regularEntry?.class_name || 'N/A';
            data.comment = substitution.comment || regularEntry?.comment || '';
        } else if (entry) { 
            status = "Regul√§r";
            statusClass = "status-regular";
            data.subject = entry.subject_shortcut;
            data.teacher = entry.teacher_shortcut;
            data.room = entry.room_name;
            data.class = entry.class_name;
            data.comment = entry.comment || '';
        } else {
            return; 
        }
        document.getElementById('detail-status').textContent = status;
        document.getElementById('detail-status').className = `detail-value ${statusClass}`;
        const span = blockId ? (currentTimetable.filter(e => e.block_id === blockId).length) : 1;
        let timeText;
        if (span > 1) {
            const startPeriod = parseInt(period);
            const endPeriod = startPeriod + span - 1;
            const startTime = formatTimeSlot(startPeriod);
            const endTime = timeSlotsDisplay[endPeriod - 1]?.split(' - ')[1] || '??:??'; 
            timeText = `${days[day-1]}, ${startPeriod}. - ${endPeriod}. Stunde (${startTime} - ${endTime})`; 
        } else {
            timeText = `${days[day-1]}, ${period}. Stunde (${timeSlotsDisplay[period-1]})`; 
        }
        document.getElementById('detail-time').textContent = timeText;
        const subjectFull = stammdaten.subjects?.find(s => s.subject_shortcut === data.subject)?.subject_name || data.subject;
        const teacherFull = stammdaten.teachers?.find(t => t.teacher_shortcut === data.teacher);
        const teacherName = teacherFull ? `${teacherFull.first_name} ${teacherFull.last_name} (${teacherFull.teacher_shortcut})` : (data.teacher || 'N/A');
        document.getElementById('detail-subject').textContent = subjectFull || 'N/A';
        const teacherRow = document.getElementById('detail-teacher');
        const classRow = document.getElementById('detail-class');
        if (userRole === 'schueler' && teacherRow) {
            teacherRow.textContent = teacherName;
        } else if (userRole === 'lehrer' && classRow) {
            classRow.textContent = data.class || 'N/A';
        }
        document.getElementById('detail-room').textContent = data.room || 'N/A';
        const commentRow = document.getElementById('detail-comment-row');
        if (data.comment) {
            document.getElementById('detail-comment').textContent = data.comment;
            commentRow.style.display = 'flex';
        } else {
            commentRow.style.display = 'none';
        }
        if (userRole === 'schueler' && noteRow && noteInput) {
            const noteKey = state.currentSlotKey;
            const currentNote = studentNotes[noteKey] || '';
            noteInput.value = currentNote;
            noteRow.style.display = 'flex'; 
            if(noteSaveBtn) noteSaveBtn.disabled = false;
            if(noteSpinner) noteSpinner.style.display = 'none';
        }
        modal.classList.add('visible');
    });
    if (userRole === 'schueler' && noteSaveBtn && noteInput && noteSpinner) {
        noteSaveBtn.addEventListener('click', async () => {
            if (state.isSaving || !state.currentSlotKey) return;
            state.isSaving = true;
            noteSaveBtn.disabled = true;
            noteSpinner.style.display = 'inline-block';
            const [day, period] = state.currentSlotKey.split('-');
            const year = yearSelector.value;
            const week = weekSelector.value;
            const content = noteInput.value.trim();
            const body = {
                year: parseInt(year),
                calendar_week: parseInt(week),
                day_of_week: parseInt(day),
                period_number: parseInt(period),
                note_content: content
            };
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/student/note/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                if (response.success) {
                    showToast('Notiz gespeichert!', 'success');
                    if (content) {
                        dashboardState.studentNotes[state.currentSlotKey] = content;
                    } else {
                        delete dashboardState.studentNotes[state.currentSlotKey];
                    }
                    renderWeeklyTimetable(dashboardState.currentTimetable, dashboardState.currentSubstitutions, dashboardState.studentNotes);
                    renderTodaySchedule(dashboardState.currentTimetable, dashboardState.currentSubstitutions, [], [], dashboardState.studentNotes); 
                    close(); 
                }
            } catch (error) {
                console.error("Fehler beim Speichern der Notiz:", error);
            } finally {
                state.isSaving = false;
                noteSaveBtn.disabled = false;
                noteSpinner.style.display = 'none';
            }
        });
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\footer-ui.js ---
export function initializeFooterUi() {
    const imprintToggle = document.getElementById('imprint-toggle');
    const imprintDetails = document.getElementById('imprint-details');
    const imprintClose = document.getElementById('imprint-close');
    if (imprintToggle && imprintDetails && imprintClose) {
        const toggleImprint = (show) => {
            if (show) {
                imprintDetails.classList.add('visible');
                imprintToggle.setAttribute('aria-expanded', 'true');
            } else {
                imprintDetails.classList.remove('visible');
                imprintToggle.setAttribute('aria-expanded', 'false');
            }
        };
        imprintToggle.addEventListener('click', () => {
            const isVisible = imprintDetails.classList.contains('visible');
            toggleImprint(!isVisible);
        });
        imprintClose.addEventListener('click', () => {
            toggleImprint(false);
        });
        document.addEventListener('click', (event) => {
            if (imprintDetails.classList.contains('visible') &&
                !imprintDetails.contains(event.target) &&
                event.target !== imprintToggle) {
                toggleImprint(false);
            }
        });
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && imprintDetails.classList.contains('visible')) {
                toggleImprint(false);
            }
        });
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\footer-ui.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\header-ui.js ---
function applyTheme(theme) {
    if (theme === 'dark') {
        document.documentElement.classList.add('dark-mode');
        const toggle = document.getElementById('theme-toggle');
        if (toggle) {
             toggle.setAttribute('aria-pressed', 'true'); 
        }
    } else {
        document.documentElement.classList.remove('dark-mode');
        const toggle = document.getElementById('theme-toggle');
         if (toggle) {
             toggle.setAttribute('aria-pressed', 'false'); 
        }
    }
}
export function initializeHeaderUi() {
    const header = document.querySelector('.page-header');
    if (!header) return;
    const themeToggle = document.getElementById('theme-toggle');
    if (themeToggle) {
        const currentTheme = document.documentElement.classList.contains('dark-mode') ? 'dark' : 'light';
        themeToggle.setAttribute('aria-pressed', currentTheme === 'dark');
        themeToggle.addEventListener('click', () => {
            const currentIsDark = document.documentElement.classList.contains('dark-mode');
            const newTheme = currentIsDark ? 'light' : 'dark';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
             themeToggle.setAttribute('aria-pressed', newTheme === 'dark');
        });
    }
    const mobileToggle = document.getElementById('mobile-menu-toggle');
    const headerNav = document.getElementById('header-nav');
    if (mobileToggle && headerNav) {
        const closeMobileMenu = () => {
            mobileToggle.classList.remove('is-open');
            headerNav.classList.remove('is-open');
            document.body.classList.remove('menu-open'); 
            mobileToggle.setAttribute('aria-expanded', 'false');
        };
        mobileToggle.addEventListener('click', () => {
            const isOpen = headerNav.classList.contains('is-open');
            if (isOpen) {
                closeMobileMenu();
            } else {
                mobileToggle.classList.add('is-open');
                headerNav.classList.add('is-open');
                document.body.classList.add('menu-open'); 
                mobileToggle.setAttribute('aria-expanded', 'true');
            }
        });
        headerNav.addEventListener('click', (e) => {
            if (e.target.closest('a')) {
                if (window.innerWidth < 769) {
                     closeMobileMenu();
                }
            }
        });
    }
    const userMenu = header.querySelector('.user-menu');
    if (userMenu && !userMenu.dataset.menuInitialized) {
        const toggleButton = userMenu.querySelector('.user-menu-toggle');
        const dropdown = userMenu.querySelector('.user-menu-dropdown');
        if (toggleButton && dropdown) {
            toggleButton.addEventListener('click', (e) => {
                e.stopPropagation(); 
                const isOpen = dropdown.classList.toggle('is-open');
                toggleButton.setAttribute('aria-expanded', isOpen);
            });
            document.addEventListener('click', (e) => {
                if (!userMenu.contains(e.target) && dropdown.classList.contains('is-open')) {
                    dropdown.classList.remove('is-open');
                    toggleButton.setAttribute('aria-expanded', 'false');
                }
            });
            dropdown.addEventListener('click', (e) => {
                if (e.target.closest('a')) {
                     dropdown.classList.remove('is-open');
                     toggleButton.setAttribute('aria-expanded', 'false');
                }
            });
            userMenu.dataset.menuInitialized = 'true'; 
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\header-ui.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\main.js ---
import { showToast, showConfirm } from './notifications.js';¬†
import { initializeHeaderUi } from './header-ui.js';
import { initializeFooterUi } from './footer-ui.js';¬†
import { initializeAdminStammdaten } from './admin-stammdaten.js';
import { initializeAdminUsers } from './admin-users.js';
import { initializeAdminAnnouncements } from './admin-announcements.js';
import { initializePlanerDashboard } from './planer-dashboard.js';
import { initializeDashboard } from './dashboard.js';
import { initializeAdminAuditLogs } from './admin-audit-log.js';¬†
import { initializeAdminSettings } from './admin-settings.js';¬†
import { initializeTeacherCockpit } from './teacher-cockpit.js';
import { initializeAdminCommunity } from './admin-community.js';
import { initializeDashboardCommunity } from './dashboard-community.js';
import { initializeMyCommunityPosts } from './dashboard-my-posts.js';
import { initializePlanerAbsences } from './planer-absences.js';
console.log("main.js: Skript gestartet.");
function runContentInitializers() {
¬† ¬† console.log("main.js: F√ºhre Inhalts-Initialisierer aus...");
¬† ¬† if(document.getElementById('stammdaten-management')) {
¬† ¬† ¬† ¬† console.log("main.js: Initialisiere Admin Stammdaten...");
¬† ¬† ¬† ¬† initializeAdminStammdaten();
¬† ¬† }
¬† ¬† if(document.getElementById('user-management')) {
¬† ¬† ¬† ¬† console.log("main.js: Initialisiere Admin Benutzer...");
¬† ¬† ¬† ¬† initializeAdminUsers();
¬† ¬† }
¬† ¬† if(document.getElementById('announcements-management')) {
¬† ¬† ¬† ¬† console.log("main.js: Initialisiere Admin Ank√ºndigungen...");
¬† ¬† ¬† ¬† initializeAdminAnnouncements();
¬† ¬† }
¬† ¬† if(document.getElementById('audit-log-management')) {
¬† ¬† ¬† ¬† console.log("main.js: Initialisiere Admin Audit Logs...");
¬† ¬† ¬† ¬† initializeAdminAuditLogs();
¬† ¬† }
¬† ¬† if(document.getElementById('settings-management')) {
¬† ¬† ¬† ¬† console.log("main.js: Initialisiere Admin Einstellungen...");
¬† ¬† ¬† ¬† initializeAdminSettings();
¬† ¬† }
¬† ¬† if(document.getElementById('community-moderation')) {
¬† ¬† ¬† ¬† console.log("main.js: Initialisiere Admin Community Moderation...");
¬† ¬† ¬† ¬† initializeAdminCommunity();
¬† ¬† }
¬† ¬† if(document.querySelector('.planer-dashboard-wrapper') && document.getElementById('planer-main-content')) {¬†
¬† ¬† ¬† ¬† console.log("main.js: Initialisiere Planer Dashboard...");
¬† ¬† ¬† ¬† initializePlanerDashboard(); // Diese Funktion ruft jetzt alle 5 'interactions'-Module auf
¬† ¬† }
¬† ¬† if(document.getElementById('absence-management')) {
¬† ¬† ¬† ¬† console.log("main.js: Initialisiere Planer Abwesenheiten...");
¬† ¬† ¬† ¬† initializePlanerAbsences();
¬† ¬† }
¬† ¬† if(document.querySelector('.dashboard-wrapper') && !document.querySelector('.admin-dashboard-wrapper') && !document.querySelector('.planer-dashboard-wrapper')) {
¬† ¬† ¬† ¬† console.log("main.js: Initialisiere (Sch√ºler/Lehrer) Dashboard...");
¬† ¬† ¬† ¬† initializeDashboard();
¬† ¬† }
¬† ¬† console.log("main.js: Inhalts-Initialisierer abgeschlossen.");
}
function runGlobalInitializers() {
¬† ¬† console.log("main.js: F√ºhre globale Initialisierer aus...");
¬† ¬† initializeHeaderUi();¬†
¬† ¬† initializeFooterUi();¬†
¬† ¬† console.log("main.js: Globale Initialisierer abgeschlossen.");
}
document.addEventListener('DOMContentLoaded', () => {
¬† ¬† console.log("main.js: DOMContentLoaded Event ausgel√∂st.");
¬† ¬† runGlobalInitializers();
¬† ¬† runContentInitializers();
¬† ¬† console.log("main.js: Alle Initialisierungen nach DOMContentLoaded abgeschlossen.");
});
window.initializeDashboardCommunity = initializeDashboardCommunity;
window.initializeMyCommunityPosts = initializeMyCommunityPosts;
window.initializeTeacherCockpit = initializeTeacherCockpit;
console.log("main.js: Skript-Ende erreicht.");
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\main.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\notifications.js ---
export function showToast(message, type = 'info', duration = 3000) {
    const oldToast = document.querySelector('.toast-notification');
    if (oldToast) {
        oldToast.remove();
    }
    const toast = document.createElement('div');
    toast.className = `toast-notification toast-${type}`;
    toast.textContent = message;
    document.body.appendChild(toast);
    setTimeout(() => {
        toast.classList.add('visible');
    }, 10); 
    setTimeout(() => {
        toast.classList.remove('visible');
        toast.addEventListener('transitionend', () => toast.remove());
    }, duration);
}
export function showConfirm(title, message) {
    return new Promise((resolve) => {
        const oldOverlay = document.querySelector('.confirm-overlay');
        if (oldOverlay) {
            oldOverlay.remove();
        }
        const confirmOverlay = document.createElement('div');
        confirmOverlay.className = 'confirm-overlay';
        const confirmBox = document.createElement('div');
        confirmBox.className = 'confirm-box';
        confirmBox.innerHTML = `
            <h2></h2>
            <p></p>
            <div class="confirm-actions">
                <button class="btn btn-secondary" id="confirm-cancel">Abbrechen</button>
                <button class="btn btn-danger" id="confirm-ok">Best√§tigen</button>
            </div>
        `;
        confirmBox.querySelector('h2').textContent = title;
        confirmBox.querySelector('p').textContent = message;
        confirmOverlay.appendChild(confirmBox);
        document.body.appendChild(confirmOverlay);
        setTimeout(() => confirmOverlay.classList.add('visible'), 10);
        const close = (value) => {
            confirmOverlay.classList.remove('visible');
            confirmOverlay.addEventListener('transitionend', () => {
                confirmOverlay.remove();
                resolve(value);
            }, { once: true }); 
        };
        document.getElementById('confirm-ok').onclick = () => close(true);
        document.getElementById('confirm-cancel').onclick = () => close(false);
        confirmOverlay.addEventListener('click', (e) => {
            if (e.target === confirmOverlay) {
                close(false);
            }
        });
        const escapeListener = (e) => {
             if (e.key === 'Escape') {
                 close(false);
                 document.removeEventListener('keydown', escapeListener); 
             }
         };
         document.addEventListener('keydown', escapeListener);
         confirmOverlay.addEventListener('transitionend', () => {
             if (!confirmOverlay.classList.contains('visible')) {
                 document.removeEventListener('keydown', escapeListener);
             }
         }, { once: true });
    });
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\notifications.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-absences.js ---
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js';
import { escapeHtml, getWeekAndYear, getDateOfISOWeek } from './planer-utils.js';
function formatShortTime(timeString) {
    if (!timeString) return '';
    const parts = timeString.split(':');
    if (parts.length >= 2) {
        return `${parts[0]}:${parts[1]}`;
    }
    return timeString; 
}
function formatDayOfWeek(dayNum) {
    const days = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag'];
    const index = parseInt(dayNum, 10) - 1;
    return days[index] || 'Unbekannt';
}
export function initializePlanerAbsences() {
    const container = document.getElementById('absence-management');
    if (!container) return;
    const calendarEl = container.querySelector('#absence-calendar');
    const form = container.querySelector('#absence-form');
    const formTitle = container.querySelector('#absence-form-title');
    const teacherSelect = container.querySelector('#absence-teacher-id');
    const reasonSelect = container.querySelector('#absence-reason');
    const startDateInput = container.querySelector('#absence-start-date');
    const endDateInput = container.querySelector('#absence-end-date');
    const absenceIdInput = container.querySelector('#absence-id');
    const saveButton = container.querySelector('#absence-save-btn');
    const cancelEditButton = container.querySelector('#absence-cancel-edit-btn');
    const deleteButton = container.querySelector('#absence-delete-btn');
    const saveSpinner = container.querySelector('#absence-save-spinner');
    let calendarInstance = null;
    if (typeof FullCalendar === 'undefined' || typeof FullCalendar.Calendar === 'undefined') {
        console.error("FullCalendar ist nicht geladen. Stellen Sie sicher, dass es in header.php eingebunden ist.");
        if (calendarEl) {
            calendarEl.innerHTML = '<p class="message error">Kalender-Bibliothek konnte nicht geladen werden.</p>';
        }
        return;
    }
    console.log("planer-absences.js: Initialisierung l√§uft...");
    console.log("container:", container); 
    console.log("calendarEl (gesucht in container):", calendarEl);
    console.log("form (gesucht in container):", form);
    console.log("teacherSelect (gesucht in container):", teacherSelect);
    if (!calendarEl || !form || !teacherSelect) {
        console.error("Erforderliche Elemente f√ºr das Abwesenheits-Management fehlen.");
        if (!calendarEl) console.error("Element '#absence-calendar' nicht gefunden.");
        if (!form) console.error("Element '#absence-form' nicht gefunden.");
        if (!teacherSelect) console.error("Element '#absence-teacher-id' nicht gefunden.");
        return;
    }
    const resetForm = () => {
        form.reset();
        absenceIdInput.value = '';
        formTitle.textContent = 'Neue Abwesenheit eintragen';
        saveButton.textContent = 'Speichern';
        deleteButton.style.display = 'none';
        cancelEditButton.style.display = 'none';
        startDateInput.value = '';
        endDateInput.value = '';
    };
    const loadAbsences = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/absences`);
            if (response.success && response.data) {
                const events = response.data.map(abs => ({
                    id: abs.absence_id,
                    title: `${abs.teacher_shortcut}: ${abs.reason}`,
                    start: abs.start_date,
                    end: new Date(new Date(abs.end_date).getTime() + 86400000).toISOString().split('T')[0], 
                    allDay: true,
                    classNames: [`absence-${abs.reason.toLowerCase()}`],
                    extendedProps: {
                        teacher_id: abs.teacher_id,
                        reason: abs.reason
                    }
                }));
                if (calendarInstance) {
                    calendarInstance.removeAllEvents();
                    calendarInstance.addEventSource(events);
                }
            } else {
                throw new Error(response.message || "Abwesenheiten konnten nicht geladen werden.");
            }
        } catch (error) {
            console.error("Fehler beim Laden der Abwesenheiten:", error);
            showToast(error.message, 'error');
        }
    };
    const initializeCalendar = () => {
        calendarInstance = new FullCalendar.Calendar(calendarEl, {
            locale: 'de', 
            initialView: 'dayGridMonth',
            headerToolbar: {
                left: 'prev,next today',
                center: 'title',
                right: 'dayGridMonth,listWeek'
            },
            buttonText: {
                today: 'Heute',
                month: 'Monat',
                list: 'Liste'
            },
            selectable: true, 
            select: (selectionInfo) => {
                resetForm();
                startDateInput.value = selectionInfo.startStr;
                const endDate = new Date(new Date(selectionInfo.endStr).getTime() - 86400000);
                endDateInput.value = endDate.toISOString().split('T')[0];
                formTitle.textContent = 'Neue Abwesenheit eintragen';
                teacherSelect.focus();
            },
            eventClick: (clickInfo) => {
                const event = clickInfo.event;
                formTitle.textContent = 'Abwesenheit bearbeiten';
                absenceIdInput.value = event.id;
                teacherSelect.value = event.extendedProps.teacher_id;
                reasonSelect.value = event.extendedProps.reason;
                startDateInput.value = event.startStr;
                const endDate = new Date(new Date(event.endStr).getTime() - 86400000);
                endDateInput.value = endDate.toISOString().split('T')[0];
                saveButton.textContent = 'Aktualisieren';
                deleteButton.style.display = 'inline-block';
                cancelEditButton.style.display = 'inline-block';
            }
        });
        calendarInstance.render();
        loadAbsences(); 
    };
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        saveButton.disabled = true;
        saveSpinner.style.display = 'inline-block';
        const formData = new FormData(form);
        const data = Object.fromEntries(formData.entries());
        const url = `${window.APP_CONFIG.baseUrl}/api/planer/absences/save`;
        try {
            if (data.start_date > data.end_date) {
                throw new Error("Das Startdatum darf nicht nach dem Enddatum liegen.");
            }
            const response = await apiFetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            if (response.success) {
                showToast(response.message, 'success');
                resetForm();
                loadAbsences(); 
            }
        } catch (error) {
            console.error("Fehler beim Speichern der Abwesenheit:", error);
            if (!error.message.includes('API')) { 
                 showToast(error.message, 'error');
            }
        } finally {
            saveButton.disabled = false;
            saveSpinner.style.display = 'none';
        }
    });
    deleteButton.addEventListener('click', async () => {
        const absenceId = absenceIdInput.value;
        if (!absenceId) return;
        if (await showConfirm("L√∂schen best√§tigen", "M√∂chten Sie diese Abwesenheit wirklich l√∂schen?")) {
            saveButton.disabled = true;
            deleteButton.disabled = true;
            saveSpinner.style.display = 'inline-block';
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/absences/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ absence_id: absenceId })
                });
                if (response.success) {
                    showToast(response.message, 'success');
                    resetForm();
                    loadAbsences(); 
                }
            } catch (error) {
                console.error("Fehler beim L√∂schen:", error);
            } finally {
                saveButton.disabled = false;
                deleteButton.disabled = false;
                saveSpinner.style.display = 'none';
            }
        }
    });
    cancelEditButton.addEventListener('click', () => {
        resetForm();
    });
    initializeCalendar();
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-absences.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-api.js ---
import { apiFetch } from './api-client.js';
import * as DOM from './planer-dom.js';
import { updateState, getState, processTimetableData } from './planer-state.js';
import { populateAllModalSelects, populateClassSelector, populateTeacherSelector, populateTemplateSelects, updatePublishControls } from './planer-ui.js';
import { renderTimetableGrid } from './planer-timetable.js';
export const loadInitialData = async () => {
    console.log("planer-api: Lade initiale Stammdaten..."); 
    try {
        const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/data`);
        console.log("planer-api: Antwort f√ºr Initialdaten:", response); 
        if (response.success && response.data) {
            console.log("planer-api: Initialdaten erfolgreich geladen:", response.data); 
            updateState({
                stammdaten: response.data, 
                templates: response.data.templates || [] 
            });
            populateClassSelector(response.data.classes);
            populateTeacherSelector(response.data.teachers);
            populateAllModalSelects(response.data); 
            populateTemplateSelects(response.data.templates || []); 
            if (DOM.classSelector && DOM.classSelector.options.length > 1) { 
                console.log("planer-api: Setze Standardauswahl auf erste Klasse."); 
                DOM.classSelector.selectedIndex = 1; 
                updateState({ selectedClassId: DOM.classSelector.value });
                await loadPlanData(); // L√§dt den Plan f√ºr die erste Klasse
            } else {
                 console.log("planer-api: Keine Klassen zum Ausw√§hlen gefunden, lade leeren Plan."); 
                 await loadPlanData(); // L√§dt leeren Plan (oder den des ersten Lehrers, falls das die Standardansicht w√§re)
            }
        } else {
            throw new Error(response.message || "Stammdaten konnten nicht geladen werden oder haben ein unerwartetes Format.");
        }
    } catch (error) {
        console.error("planer-api: Fehler beim Laden der Initialdaten:", error);
        if (DOM.timetableContainer) { 
            DOM.timetableContainer.innerHTML = `<p class="message error">${error.message || 'Stammdaten konnten nicht geladen werden.'}</p>`;
        }
    }
};
export const loadPlanData = async () => {
    console.log("planer-api: Lade Plandaten..."); 
    let { currentViewMode, selectedClassId, selectedTeacherId } = getState();
    selectedClassId = DOM.classSelector ? DOM.classSelector.value : null;
    selectedTeacherId = DOM.teacherSelector ? DOM.teacherSelector.value : null;
    const selectedYear = DOM.yearSelector ? DOM.yearSelector.value : null;
    const selectedWeek = DOM.weekSelector ? DOM.weekSelector.value : null;
    if (!selectedYear || !selectedWeek) {
        console.warn("planer-api: Jahr oder Woche nicht ausgew√§hlt.");
        if(DOM.timetableContainer) DOM.timetableContainer.innerHTML = '<p class="message info">Bitte Jahr und Kalenderwoche ausw√§hlen.</p>';
        updatePublishControls({ student: false, teacher: false });
        return;
    }
    const cacheBuster = `_t=${new Date().getTime()}`;
    let url = `${window.APP_CONFIG.baseUrl}/api/planer/data?year=${selectedYear}&week=${selectedWeek}&${cacheBuster}`;
    if (currentViewMode === 'class') {
        if (!selectedClassId) {
            console.log("planer-api: Keine Klasse ausgew√§hlt, breche Plandaten-Ladevorgang ab."); 
            if (DOM.timetableContainer) DOM.timetableContainer.innerHTML = '<p class="message info">Bitte einen Lehrer oder eine Klasse ausw√§hlen.</p>';
            updatePublishControls({ student: false, teacher: false }); 
            updateState({ selectedClassId: null, selectedTeacherId: null, currentTimetable: {}, currentSubstitutions: {}, currentPublishStatus: { student: false, teacher: false } });
            return;
        }
        updateState({ selectedClassId: selectedClassId, selectedTeacherId: null });
        url += `&class_id=${selectedClassId}`;
    } else { // currentViewMode === 'teacher'
        if (!selectedTeacherId) {
             console.log("planer-api: Kein Lehrer ausgew√§hlt, breche Plandaten-Ladevorgang ab."); 
            if (DOM.timetableContainer) DOM.timetableContainer.innerHTML = '<p class="message info">Bitte einen Lehrer oder eine Klasse ausw√§hlen.</p>';
            updatePublishControls({ student: false, teacher: false });
            updateState({ selectedClassId: null, selectedTeacherId: null, currentTimetable: {}, currentSubstitutions: {}, currentPublishStatus: { student: false, teacher: false } });
            return;
        }
        updateState({ selectedClassId: null, selectedTeacherId: selectedTeacherId });
        url += `&teacher_id=${selectedTeacherId}`;
    }
    if (DOM.timetableContainer) DOM.timetableContainer.innerHTML = '<div class="loading-spinner"></div>';
    try {
        const response = await apiFetch(url);
        console.log("planer-api: Antwort f√ºr Plandaten:", response); 
        if (response.success && response.data) {
             console.log("planer-api: Plandaten erfolgreich geladen, rufe processTimetableData auf...", response.data); 
             processTimetableData(response.data);
             renderTimetableGrid(); 
             updatePublishControls(getState().currentPublishStatus);
        } else {
            throw new Error(response.message || "Plandaten konnten nicht geladen werden.");
        }
    } catch (error) {
        console.error("planer-api: Fehler beim Laden der Plandaten:", error);
         if (DOM.timetableContainer) { 
             DOM.timetableContainer.innerHTML = `<p class="message error">${error.message || 'Stundenplan konnte nicht geladen werden.'}</p>`;
         }
        updatePublishControls({ student: false, teacher: false });
    }
};
export const publishWeek = async (target, publish = true) => {
    const currentYear = DOM.yearSelector.value; 
    const currentWeek = DOM.weekSelector.value; 
    if (!currentYear || !currentWeek) {
        window.showToast("Bitte Jahr und KW ausw√§hlen.", 'error');
        throw new Error("Jahr oder Woche nicht ausgew√§hlt."); 
    }
    const url = publish ? `${window.APP_CONFIG.baseUrl}/api/planer/publish` : `${window.APP_CONFIG.baseUrl}/api/planer/unpublish`;
    const body = JSON.stringify({ year: currentYear, week: currentWeek, target });
    return await apiFetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body });
};
export const checkConflicts = async (data) => {
     return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/check-conflicts`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(data)
     });
};
export const saveEntry = async (data) => {
     return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/entry/save`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(data)
     });
};
export const deleteEntry = async (body) => {
    const url = `${window.APP_CONFIG.baseUrl}/api/planer/entry/delete`;
    return await apiFetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
};
export const saveSubstitution = async (data) => {
     return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/substitution/save`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(data)
     });
};
export const deleteSubstitution = async (id) => {
    const url = `${window.APP_CONFIG.baseUrl}/api/planer/substitution/delete`;
     return await apiFetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ substitution_id: id }) });
};
export const copyWeek = async (body) => {
     return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/copy-week`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(body)
     });
};
export const loadTemplates = async () => {
    try {
        const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates`);
        if (response.success) {
            const templates = response.data || [];
            updateState({ templates: templates });
            populateTemplateSelects(templates); 
            return templates;
        } else {
            throw new Error(response.message || "Vorlagen konnten nicht geladen werden.");
        }
    } catch (error) {
        updateState({ templates: [] }); 
        console.error("Fehler beim Laden der Vorlagen:", error);
        if (DOM.applyTemplateSelect) DOM.applyTemplateSelect.innerHTML = '<option value="">Fehler beim Laden</option>';
        if (DOM.manageTemplatesList) DOM.manageTemplatesList.innerHTML = '<p class="message error">Fehler beim Laden.</p>';
        return []; 
    }
};
export const createTemplate = async (body) => {
     return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/create`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(body)
     });
};
export const applyTemplate = async (body) => {
     return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/apply`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(body)
     });
};
export const deleteTemplate = async (templateId) => {
     return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/delete`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({ templateId: templateId })
     });
};
export const loadTemplateDetails = async (templateId) => {
     return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/${templateId}`);
};
export const saveTemplate = async (templateData) => {
     return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/save`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(templateData)
     });
};
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-api.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-dashboard.js ---
import { loadInitialData } from './planer-api.js';
import { initializePageActionHandlers } from './planer-interactions-1.js';
import { initializeEntryClickHandlers } from './planer-interactions-2.js';
import { initializeGridInteractions } from './planer-interactions-3.js';
import { initializeEntryModalInteractions } from './planer-interactions-4.js';
import { initializeActionModals } from './planer-interactions-5.js';
export function initializePlanerDashboard() {
¬† ¬† console.log("planer-dashboard: Initialisiere Planer-Module...");
¬† ¬† initializePageActionHandlers();
¬† ¬† initializeEntryClickHandlers();
¬† ¬† initializeGridInteractions();
¬† ¬† initializeEntryModalInteractions();
¬† ¬† initializeActionModals();
¬† ¬† console.log("planer-dashboard: Lade initiale Daten...");¬†
¬† ¬† loadInitialData();¬†
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-dashboard.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-dom.js ---
export const viewModeSelector = document.getElementById('view-mode-selector');
¬†export const classSelectorContainer = document.getElementById('class-selector-container');
¬†export const classSelector = document.getElementById('class-selector');
¬†export const teacherSelectorContainer = document.getElementById('teacher-selector-container');
¬†export const teacherSelector = document.getElementById('teacher-selector');
¬†export const yearSelector = document.getElementById('year-selector');
¬†export const weekSelector = document.getElementById('week-selector');
¬†export const timetableContainer = document.getElementById('timetable-container');
¬†export const modal = document.getElementById('timetable-modal');
¬†export const modalTitle = document.getElementById('modal-title');
¬†export const form = document.getElementById('timetable-entry-form');
¬†export const deleteBtn = document.getElementById('delete-entry-btn');
¬†export const modalTabs = modal ? modal.querySelectorAll('.modal-tabs .tab-button') : [];
¬†export const regularFields = document.getElementById('regular-fields');
¬†export const substitutionFields = document.getElementById('substitution-fields');
¬†export const substitutionTypeSelect = document.getElementById('substitution_type');
¬†export const publishWeekLabel = document.getElementById('publish-week-label');
¬†export const publishStatusStudent = document.getElementById('publish-status-student');
¬†export const publishStatusTeacher = document.getElementById('publish-status-teacher');
¬†export const publishStudentBtn = document.getElementById('publish-student-btn');
¬†export const publishTeacherBtn = document.getElementById('publish-teacher-btn');
¬†export const unpublishStudentBtn = document.getElementById('unpublish-student-btn');
¬†export const unpublishTeacherBtn = document.getElementById('unpublish-teacher-btn');
¬†export const regularCommentInput = document.getElementById('regular_comment');
¬†export const substitutionCommentInput = document.getElementById('substitution_comment');
¬†export const conflictWarningBox = document.getElementById('modal-conflict-warning');
¬†export const saveButton = document.getElementById('modal-save-btn');
¬†export const conflictCheckFields = modal ? modal.querySelectorAll('.conflict-check') : [];¬†
¬†export const copyWeekBtn = document.getElementById('copy-week-btn');
¬†export const copyWeekModal = document.getElementById('copy-week-modal');
¬†export const copyWeekForm = document.getElementById('copy-week-form');
¬†export const copySourceDisplay = document.getElementById('copy-source-display');
¬†export const copyTargetYear = document.getElementById('copy-target-year');
¬†export const copyTargetWeek = document.getElementById('copy-target-week');
¬†export const copyWeekConfirmBtn = document.getElementById('copy-week-confirm-btn');
¬†export const copyWeekCancelBtn = document.getElementById('copy-week-cancel-btn');
¬†export const createTemplateBtn = document.getElementById('create-template-btn');
¬†export const applyTemplateBtn = document.getElementById('apply-template-btn');
¬†export const manageTemplatesBtn = document.getElementById('manage-templates-btn');
¬†export const manageTemplatesModal = document.getElementById('manage-templates-modal');
¬†export const manageTemplatesViewContainer = document.getElementById('manage-templates-view-container');¬†
¬†export const templateListView = document.getElementById('template-list-view');¬†
¬†export const templateEditorView = document.getElementById('template-editor-view');¬†
¬†export const manageTemplatesForm = document.getElementById('create-template-form');¬†
¬†export const createEmptyTemplateBtn = document.getElementById('create-empty-template-btn');¬†
¬†export const manageTemplatesList = document.getElementById('templates-list-container');
¬†export const manageTemplatesCloseBtn = document.getElementById('manage-templates-close-btn');
¬†export const templateEditorTitle = document.getElementById('template-editor-title');
¬†export const templateEditorGridContainer = document.getElementById('template-editor-grid-container');¬†
¬†export const backToTemplateListBtn = document.getElementById('back-to-template-list-btn');¬†
¬†export const saveTemplateEditorBtn = document.getElementById('save-template-editor-btn');¬†
¬†export const applyTemplateModal = document.getElementById('apply-template-modal');
¬†export const applyTemplateForm = document.getElementById('apply-template-form');
¬†export const applyTemplateSelect = document.getElementById('apply-template-select');
¬†export const applyTemplateConfirmBtn = document.getElementById('apply-template-confirm-btn');
¬†export const applyTemplateCancelBtn = document.getElementById('apply-template-cancel-btn');
¬†export const days = ["Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag"];
¬†export const timeSlots = [
¬† ¬† ¬†"08:00 - 08:45", "08:55 - 09:40", "09:40 - 10:25", "10:35 - 11:20",
¬† ¬† ¬†"11:20 - 12:05", "13:05 - 13:50", "13:50 - 14:35", "14:45 - 15:30",
¬† ¬† ¬†"15:30 - 16:15", "16:25 - 17:10"
¬†];
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-dom.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-1.js ---
import * as DOM from './planer-dom.js';
import { getState, updateState } from './planer-state.js';
import { getWeekAndYear } from './planer-utils.js';
import { loadPlanData, publishWeek } from './planer-api.js';
import { populateYearSelector, populateWeekSelector, updatePublishControls } from './planer-ui.js';
import { showToast } from './notifications.js';

const WEEK_SELECTION_KEY = 'planer_week_selection';

export function initializePageActionHandlers() {
¬† ¬† setDefaultSelectors();

¬† ¬† DOM.viewModeSelector.addEventListener('change', handleViewModeChange);
¬† ¬† DOM.classSelector.addEventListener('change', () => loadPlanData());
¬† ¬† DOM.teacherSelector.addEventListener('change', () => loadPlanData());
¬† ¬† DOM.yearSelector.addEventListener('change', () => {
¬† ¬† ¬† ¬† saveSelection();
¬† ¬† ¬† ¬† loadPlanData();
¬† ¬† });
¬† ¬† DOM.weekSelector.addEventListener('change', () => {
¬† ¬† ¬† ¬† saveSelection();
¬† ¬† ¬† ¬† loadPlanData();
¬† ¬† });

¬† ¬† DOM.publishStudentBtn.addEventListener('click', () => handlePublishAction('student', true));
¬† ¬† DOM.unpublishStudentBtn.addEventListener('click', () => handlePublishAction('student', false));
¬† ¬† DOM.publishTeacherBtn.addEventListener('click', () => handlePublishAction('teacher', true));
¬† ¬† DOM.unpublishTeacherBtn.addEventListener('click', () => handlePublishAction('teacher', false));
}

function saveSelection() {
¬† ¬† try {
¬† ¬† ¬† ¬† const selection = {
¬† ¬† ¬† ¬† ¬† ¬† year: DOM.yearSelector.value,
¬† ¬† ¬† ¬† ¬† ¬† week: DOM.weekSelector.value
¬† ¬† ¬† ¬† };
¬† ¬† ¬† ¬† localStorage.setItem(WEEK_SELECTION_KEY, JSON.stringify(selection));
¬† ¬† } catch (e) {
¬† ¬† ¬† ¬† console.warn("Speichern der Wochenauswahl im localStorage fehlgeschlagen:", e);
¬† ¬† }
}

export function setDefaultSelectors() {
¬† ¬† let defaultYear, defaultWeek;
¬† ¬† try {
¬† ¬† ¬† ¬† const savedSelection = localStorage.getItem(WEEK_SELECTION_KEY);
¬† ¬† ¬† ¬† if (savedSelection) {
¬† ¬† ¬† ¬† ¬† ¬† const parsed = JSON.parse(savedSelection);
¬† ¬† ¬† ¬† ¬† ¬† if (parsed.year && parsed.week) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† defaultYear = parseInt(parsed.year, 10);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† defaultWeek = parseInt(parsed.week, 10);
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }
¬† ¬† } catch (e) {
¬† ¬† ¬† ¬† console.warn("Laden der Wochenauswahl aus localStorage fehlgeschlagen:", e);
¬† ¬† }

¬† ¬† if (!defaultYear || !defaultWeek) {
¬† ¬† ¬† ¬† const today = new Date();
¬† ¬† ¬† ¬† const { week, year } = getWeekAndYear(today);
¬† ¬† ¬† ¬† defaultYear = year;
¬† ¬† ¬† ¬† defaultWeek = week;
¬† ¬† ¬† ¬† saveSelection();¬†
¬† ¬† }

¬† ¬† populateYearSelector(DOM.yearSelector, defaultYear);
¬† ¬† populateWeekSelector(DOM.weekSelector, defaultWeek);
}

function handleViewModeChange() {
¬† ¬† updateState({ currentViewMode: DOM.viewModeSelector.value });
¬† ¬† if (getState().currentViewMode === 'class') {
¬† ¬† ¬† ¬† DOM.classSelectorContainer.classList.remove('hidden');
¬† ¬† ¬† ¬† DOM.teacherSelectorContainer.classList.add('hidden');
¬† ¬† ¬† ¬† DOM.teacherSelector.value = ''; // Auswahl zur√ºcksetzen
¬† ¬† } else {
¬† ¬† ¬† ¬† DOM.classSelectorContainer.classList.add('hidden');
¬† ¬† ¬† ¬† DOM.teacherSelectorContainer.classList.remove('hidden');
¬† ¬† ¬† ¬† DOM.classSelector.value = ''; // Auswahl zur√ºcksetzen
¬† ¬† }
¬† ¬† loadPlanData(); // Plandaten f√ºr die neue Ansicht laden
}

async function handlePublishAction(target, publish = true) {
¬† ¬† const year = DOM.yearSelector.value;
¬† ¬† const week = DOM.weekSelector.value;
¬† ¬† if (!year || !week) {
¬† ¬† ¬† ¬† showToast("Bitte Jahr und KW ausw√§hlen.", 'error');
¬† ¬† ¬† ¬† throw new Error("Jahr oder Woche nicht ausgew√§hlt.");¬†
¬† ¬† }

¬† ¬† try {
¬† ¬† ¬† ¬† const response = await publishWeek(target, publish);¬†

¬† ¬† ¬† ¬† // KORREKTUR: Die Antwort der API (die den neuen Status enth√§lt) direkt verwenden.
¬† ¬† ¬† ¬† if (response.success && response.data && response.data.publishStatus) {
¬† ¬† ¬† ¬† ¬† ¬† showToast(response.message, 'success');
¬† ¬† ¬† ¬† ¬† ¬† // 1. Globalen Status aktualisieren
¬† ¬† ¬† ¬† ¬† ¬† updateState({ currentPublishStatus: response.data.publishStatus });
¬† ¬† ¬† ¬† ¬† ¬† // 2. UI-Komponenten (Buttons, Status-Text) aktualisieren
¬† ¬† ¬† ¬† ¬† ¬† updatePublishControls(getState().currentPublishStatus);
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† // Fallback oder Fehler, falls die Antwort nicht wie erwartet aussieht
¬† ¬† ¬† ¬† ¬† ¬† showToast("Aktion erfolgreich, aber Status konnte nicht aktualisiert werden. Lade neu...", 'info');
¬† ¬† ¬† ¬† ¬† ¬† await loadPlanData(); // Fallback: Neu laden
¬† ¬† ¬† ¬† }
¬† ¬† } catch(error) {
¬† ¬† ¬† ¬† console.error(`Fehler bei Aktion '${publish ? 'publish' : 'unpublish'}' f√ºr '${target}':`, error);
¬† ¬† }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-1.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-2.js ---
import * as DOM from './planer-dom.js';
import { getState, updateState, clearSelectionState, setSelectionState } from './planer-state.js';
import { openModal } from './planer-interactions-4.js';
export function initializeEntryClickHandlers() {
¬† ¬† DOM.timetableContainer.addEventListener('click', (e) => {
¬† ¬† ¬† ¬† const cell = e.target.closest('.grid-cell');
¬† ¬† ¬† ¬† const state = getState();
¬† ¬† ¬† ¬† if (!cell || !(state.selectedClassId || state.selectedTeacherId)) {
¬† ¬† ¬† ¬† ¬† ¬† clearSelectionState(state.selection.cells);¬†
¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† handleCellClick(cell, DOM.timetableContainer);
¬† ¬† ¬† ¬† if (e.detail === 2) {
¬† ¬† ¬† ¬† ¬† ¬† openModal(e, false); // false = kein Template-Editor
¬† ¬† ¬† ¬† }
¬† ¬† });
}
export function handleCellClick(cell, container) {
¬† ¬† if (!container) {
¬† ¬† ¬† ¬† container = DOM.timetableContainer;
¬† ¬† }
¬† ¬† const clickedDay = cell.dataset.day;
¬† ¬† const clickedPeriod = parseInt(cell.dataset.period);
¬† ¬† const state = getState();
¬† ¬† const firstEntryInCell = cell.querySelector('.planner-entry');
¬† ¬† const cellData = firstEntryInCell ? firstEntryInCell.dataset : {};
¬† ¬† const startCellData = state.selection.start ? state.selection.start.cellData : {};
¬† ¬† const isSameGroupAsStart = (startCellData.blockId && cellData.blockId === startCellData.blockId) ||
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† (startCellData.entryId && cellData.entryId === startCellData.entryId) ||
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† (startCellData.substitutionId && cellData.substitutionId === startCellData.substitutionId);
¬† ¬† const startIsEmpty = !startCellData.entryId && !startCellData.blockId && !startCellData.substitutionId;
¬† ¬† const currentIsEmpty = !cellData.entryId && !cellData.blockId && !cellData.substitutionId;
¬† ¬† if (
¬† ¬† ¬† ¬† !state.selection.start ||
¬† ¬† ¬† ¬† clickedDay !== state.selection.start.day ||
¬† ¬† ¬† ¬† cell.classList.contains('default-entry') ||
¬† ¬† ¬† ¬† (!isSameGroupAsStart && !(startIsEmpty && currentIsEmpty))
¬† ¬† ) {
¬† ¬† ¬† ¬† clearSelectionState(state.selection.cells);
¬† ¬† ¬† ¬† setSelectionState({ start: { day: clickedDay, period: clickedPeriod, cell: cell, cellData: cellData }, end: null, cells: [cell] });
¬† ¬† ¬† ¬† cell.classList.add('selected');
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬† state.selection.end = { day: clickedDay, period: clickedPeriod };
¬† ¬† const startPeriod = Math.min(state.selection.start.period, state.selection.end.period);
¬† ¬† const endPeriod = Math.max(state.selection.start.period, state.selection.end.period);
¬† ¬† state.selection.cells.forEach(c => c.classList.remove('selected'));
¬† ¬† const newSelectionCells = [];
¬† ¬† for (let p = startPeriod; p <= endPeriod; p++) {
¬† ¬† ¬† ¬† const cellToSelect = container.querySelector(`.grid-cell[data-day='${clickedDay}'][data-period='${p}']`);
¬† ¬† ¬† ¬† if (cellToSelect) {
¬† ¬† ¬† ¬† ¬† ¬† const firstEntryInCellToSelect = cellToSelect.querySelector('.planner-entry');
¬† ¬† ¬† ¬† ¬† ¬† const currentCellData = firstEntryInCellToSelect ? firstEntryInCellToSelect.dataset : {};
¬† ¬† ¬† ¬† ¬† ¬† const isCurrentSameGroup = (startCellData.blockId && currentCellData.blockId === startCellData.blockId) ||
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†(startCellData.entryId && currentCellData.entryId === startCellData.entryId) ||
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†(startCellData.substitutionId && currentCellData.substitutionId === startCellData.substitutionId);
¬† ¬† ¬† ¬† ¬† ¬† const isCurrentEmpty = !currentCellData.entryId && !currentCellData.blockId && !currentCellData.substitutionId;
¬† ¬† ¬† ¬† ¬† ¬† if ((startIsEmpty && !isCurrentEmpty) || (!startIsEmpty && !isCurrentSameGroup)) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† clearSelectionState(state.selection.cells.concat(newSelectionCells));
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† setSelectionState({ start: { day: clickedDay, period: clickedPeriod, cell: cell, cellData: cellData }, end: null, cells: [cell] });
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† cell.classList.add('selected');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† cellToSelect.classList.add('selected');
¬† ¬† ¬† ¬† ¬† ¬† newSelectionCells.push(cellToSelect);
¬† ¬† ¬† ¬† }
¬† ¬† }
¬† ¬† state.selection.cells = newSelectionCells;
¬† ¬† state.selection.start.cell = newSelectionCells[0]; // Startzelle aktualisieren (falls r√ºckw√§rts ausgew√§hlt wurde)
¬† ¬† state.selection.start.period = parseInt(newSelectionCells[0].dataset.period);
¬† ¬† setSelectionState(state.selection);
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-2.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-3.js ---
import * as DOM from './planer-dom.js';
import { getState, updateState, clearSelectionState } from './planer-state.js';
import { checkConflicts, saveEntry, deleteEntry, saveSubstitution, deleteSubstitution, loadPlanData } from './planer-api.js';
import { renderTimetableGrid } from './planer-timetable.js';
import { getDateForDayInWeek } from './planer-utils.js';
import { showToast } from './notifications.js';
export function initializeGridInteractions() {
    const grid = DOM.timetableContainer;
    if (!grid) return;
    grid.addEventListener('dragstart', handleDragStart);
    grid.addEventListener('dragover', handleDragOver);
    grid.addEventListener('dragend', handleDragEnd);
    grid.addEventListener('drop', handleDrop);
}
function handleDragStart(e) {
    const cell = e.target.closest('.grid-cell');
    const entryElement = cell ? cell.querySelector('.planner-entry') : null;
    const state = getState();
    if (!cell || !entryElement || !cell.classList.contains('has-entry') || !(state.selectedClassId || state.selectedTeacherId)) {
        e.preventDefault();
        return;
    }
    const entryId = entryElement.dataset.entryId;
    const blockId = entryElement.dataset.blockId;
    const substitutionId = entryElement.dataset.substitutionId;
    let entryData = null; 
    let entryType = null;
    let span = 1;
    let blockStartCell = cell; 
    let originalSubIds = []; 
    let originalRegularEntryId = null; 
    let originalRegularBlockId = null;
    let underlyingRegularEntries = []; 
    const currentDay = cell.dataset.day;
    const currentPeriod = parseInt(cell.dataset.period);
    const cellKey = `${currentDay}-${currentPeriod}`; // state.timetable und state.substitutions verwenden diesen Key
    if (substitutionId) {
        entryType = 'substitution';
        const subsInCell = (state.substitutions[cellKey] || []);
        entryData = subsInCell.find(s => s.substitution_id == substitutionId);
        if (!entryData) {
            console.error("DragStart Error: Konnte Vertretungsdaten nicht finden.", substitutionId);
            e.preventDefault(); return;
        }
        const key = `${entryData.date}-${entryData.class_id}-${entryData.substitution_type}-${entryData.comment || ''}-${entryData.new_room_id || ''}-${entryData.new_teacher_id || ''}-${entryData.new_subject_id || ''}`;
        const substitutionBlocks = new Map();
        state.currentSubstitutions.forEach(sub => {
            if (!sub.day_of_week) return;
            const subKey = `${sub.date}-${sub.class_id}-${sub.substitution_type}-${sub.comment || ''}-${sub.new_room_id || ''}-${sub.new_teacher_id || ''}-${sub.new_subject_id || ''}`;
            if (!substitutionBlocks.has(subKey)) substitutionBlocks.set(subKey, []);
            substitutionBlocks.get(subKey).push(sub);
        });
        const subsInBlock = substitutionBlocks.get(key) || [];
        if (subsInBlock.length > 1) {
            subsInBlock.sort((a, b) => a.period_number - b.period_number);
            let isConsecutive = true;
            for (let i = 0; i < subsInBlock.length - 1; i++) {
                if (parseInt(subsInBlock[i + 1].period_number) !== parseInt(subsInBlock[i].period_number) + 1) {
                    isConsecutive = false; break;
                }
            }
            if (isConsecutive) {
                const startSub = subsInBlock[0];
                if (startSub.substitution_id == substitutionId) {
                    span = subsInBlock.length;
                    entryData = startSub; 
                    blockStartCell = cell;
                } else {
                    span = subsInBlock.length;
                    entryData = startSub;
                    blockStartCell = DOM.timetableContainer.querySelector(`.grid-cell[data-day='${startSub.day_of_week}'][data-period='${startSub.period_number}']`);
                }
            }
        }
        originalSubIds = [];
        underlyingRegularEntries = [];
        const allSubsMap = state.substitutions;
        const allTimetableMap = state.timetable;
        for (let i = 0; i < span; i++) {
            const periodToCheck = parseInt(entryData.period_number) + i;
            const keyToCheck = `${entryData.day_of_week}-${periodToCheck}`;
            const subForThisHour = (allSubsMap[keyToCheck] || []).find(s =>
                s.class_id == entryData.class_id &&
                s.substitution_type == entryData.substitution_type &&
                s.new_teacher_id == entryData.new_teacher_id &&
                s.new_subject_id == entryData.new_subject_id &&
                s.new_room_id == entryData.new_room_id &&
                s.comment == entryData.comment
            );
            if (subForThisHour) {
                originalSubIds.push(subForThisHour.substitution_id);
                const regularEntry = (allTimetableMap[keyToCheck] || []).find(e =>
                    e.class_id == subForThisHour.class_id &&
                    e.subject_id == subForThisHour.original_subject_id
                );
                if (regularEntry) {
                    underlyingRegularEntries.push(regularEntry);
                    if (i === 0) {
                        originalRegularBlockId = regularEntry.block_id || null;
                        originalRegularEntryId = regularEntry.entry_id || null;
                    }
                } else {
                    underlyingRegularEntries.push(null);
                }
            } else {
                originalSubIds.push(null);
                underlyingRegularEntries.push(null);
                console.warn(`DragStart: Konnte Vertretung f√ºr Periode ${periodToCheck} im Block nicht finden.`);
            }
        }
    } else if (blockId) {
        entryType = 'block';
        const entriesInCell = (state.timetable[cellKey] || []);
        entryData = entriesInCell.find(e => e.block_id == blockId);
        if (!entryData) { e.preventDefault(); return; }
        const allEntriesInBlock = state.currentTimetable.filter(e => e.block_id === blockId);
        if (allEntriesInBlock.length > 0) {
             allEntriesInBlock.sort((a, b) => a.period_number - b.period_number);
             const startEntry = allEntriesInBlock[0];
             span = parseInt(allEntriesInBlock[allEntriesInBlock.length - 1].period_number) - parseInt(startEntry.period_number) + 1;
             if (startEntry.entry_id !== entryData.entry_id) {
                 blockStartCell = DOM.timetableContainer.querySelector(`.grid-cell[data-day='${startEntry.day_of_week}'][data-period='${startEntry.period_number}']`);
                 entryData = startEntry; // Drag-Daten auf den Start des Blocks setzen
             }
        } else {
            span = 1;
        }
        originalRegularBlockId = blockId;
    } else if (entryId) {
        entryType = 'entry';
        const entriesInCell = (state.timetable[cellKey] || []);
        entryData = entriesInCell.find(e => e.entry_id == entryId);
        if (!entryData) { e.preventDefault(); return; }
        span = 1;
        originalRegularEntryId = entryId;
    }
    if (!entryData) {
        console.error("DragStart Error: Konnte Eintragsdaten nicht finden.", { entryId, blockId, substitutionId });
        e.preventDefault();
        return;
     }
    clearSelectionState(state.selection.cells);
    updateState({
        dragData: {
            type: entryType,
            data: entryData, // Enth√§lt immer den *Start*-Eintrag eines Blocks
            span: span,
            originalDay: blockStartCell.dataset.day,
            originalPeriod: parseInt(blockStartCell.dataset.period),
            originalSubIds: originalSubIds, // Array von IDs f√ºr Vertretungsbl√∂cke
            originalRegularEntryId: originalRegularEntryId, // ID f√ºr Einzeleintrag
            originalRegularBlockId: originalRegularBlockId, // ID f√ºr Block
            underlyingRegularEntries: underlyingRegularEntries || [] // Regul√§re Eintr√§ge *unter* einer Vertretung
        }
    });
    setTimeout(() => {
        if (blockStartCell) blockStartCell.classList.add('dragging');
        if (span > 1) {
            for (let i = 1; i < span; i++) {
                const nextPeriod = parseInt(blockStartCell.dataset.period) + i;
                const cellInBlock = DOM.timetableContainer.querySelector(`.grid-cell[data-day='${blockStartCell.dataset.day}'][data-period='${nextPeriod}']`);
                if (cellInBlock) {
                    cellInBlock.classList.add('dragging');
                }
            }
        }
    }, 0);
    DOM.timetableContainer.classList.add('is-dragging');
}
async function handleDragOver(e) {
    e.preventDefault(); 
    const cell = e.target.closest('.grid-cell');
    const state = getState();
    if (!cell || !state.dragData || cell === state.lastDragOverCell) return;
    if (state.lastDragOverCell) {
        state.lastDragOverCell.classList.remove('drop-target', 'drop-target-valid', 'drop-target-invalid');
        delete state.lastDragOverCell.dataset.conflictError;
    }
    updateState({ lastDragOverCell: cell }); 
    cell.classList.add('drop-target'); 
    const targetDay = cell.dataset.day;
    const targetStartPeriod = parseInt(cell.dataset.period);
    const targetEndPeriod = targetStartPeriod + state.dragData.span - 1;
    if (targetEndPeriod > DOM.timeSlots.length) {
        cell.classList.add('drop-target-invalid');
        cell.dataset.conflictError = "Eintrag passt nicht auf den Plan (zu lang).";
        return;
    }
    for (let p = targetStartPeriod; p <= targetEndPeriod; p++) {
        const targetCell = DOM.timetableContainer.querySelector(`.grid-cell[data-day='${targetDay}'][data-period='${p}']`);
        if (targetCell && (targetCell.classList.contains('has-entry') || targetCell.classList.contains('has-substitution')) ) {
            let isSelf = false; 
            const draggedItemType = state.dragData.type;
            if (draggedItemType === 'substitution') {
                const targetSubElements = Array.from(targetCell.querySelectorAll('.planner-entry[data-substitution-id]'));
                isSelf = targetSubElements.some(el => state.dragData.originalSubIds.includes(parseInt(el.dataset.substitutionId)));
            } else if (draggedItemType === 'block') {
                const targetEntryElements = Array.from(targetCell.querySelectorAll('.planner-entry[data-block-id]'));
                isSelf = targetEntryElements.some(el => el.dataset.blockId === state.dragData.originalRegularBlockId);
            } else if (draggedItemType === 'entry') {
                const targetEntryElements = Array.from(targetCell.querySelectorAll('.planner-entry[data-entry-id]'));
                isSelf = targetEntryElements.some(el => el.dataset.entryId == state.dragData.originalRegularEntryId);
            }
            if (!isSelf) { 
                cell.classList.add('drop-target-invalid');
                const conflictType = targetCell.classList.contains('has-substitution') ? "Vertretung" : "Unterricht";
                cell.dataset.conflictError = `KONFLIKT (Slot belegt): In diesem Zeitraum existiert bereits ${conflictType}.`;
                return;
            }
        }
    }
    let needsApiCheck = state.dragData.type !== 'substitution' || (state.dragData.originalRegularEntryId || state.dragData.originalRegularBlockId);
    if (!needsApiCheck) {
        cell.classList.add('drop-target-valid');
        updateState({ lastConflictCheckPromise: Promise.resolve({ success: true, conflicts: [] }) }); 
        return;
    }
    const regularEntryData = state.dragData.originalRegularBlockId
        ? (state.currentTimetable.find(e => e.block_id == state.dragData.originalRegularBlockId) || (state.dragData.underlyingRegularEntries[0] || null))
        : (state.currentTimetable.find(e => e.entry_id == state.dragData.originalRegularEntryId) || (state.dragData.underlyingRegularEntries[0] || null));
    if (!regularEntryData) {
        cell.classList.add('drop-target-valid');
        updateState({ lastConflictCheckPromise: Promise.resolve({ success: true, conflicts: [] }) });
        return;
    }
    const checkData = {
        year: DOM.yearSelector.value,
        calendar_week: DOM.weekSelector.value,
        day_of_week: targetDay,
        start_period_number: targetStartPeriod,
        end_period_number: targetEndPeriod,
        teacher_id: regularEntryData.teacher_id, 
        room_id: regularEntryData.room_id,    
        class_id: regularEntryData.class_id,    
        entry_id: state.dragData.originalRegularEntryId,
        block_id: state.dragData.originalRegularBlockId,
    };
    try {
        const conflictCheckPromise = checkConflicts(checkData);
        updateState({ lastConflictCheckPromise: conflictCheckPromise });
        await conflictCheckPromise;
        if (cell === getState().lastDragOverCell) {
            cell.classList.add('drop-target-valid');
        }
    } catch (error) {
        if (cell === getState().lastDragOverCell) {
            cell.classList.add('drop-target-invalid');
            cell.dataset.conflictError = error.message; 
        }
    }
}
function handleDragEnd(e) {
    const draggedCells = DOM.timetableContainer.querySelectorAll('.grid-cell.dragging');
    draggedCells.forEach(cell => cell.classList.remove('dragging'));
    DOM.timetableContainer.classList.remove('is-dragging'); 
    const state = getState();
    if (state.lastDragOverCell) {
        state.lastDragOverCell.classList.remove('drop-target', 'drop-target-valid', 'drop-target-invalid');
        delete state.lastDragOverCell.dataset.conflictError;
    }
    updateState({ dragData: null, lastDragOverCell: null, lastConflictCheckPromise: null });
}
async function handleDrop(e) {
    e.preventDefault();
    const cell = e.target.closest('.grid-cell');
    const state = getState();
    if (!cell || !state.dragData) return;
    if (cell.classList.contains('drop-target-invalid')) {
        const errorMessage = cell.dataset.conflictError || "Ablegen nicht m√∂glich: Konflikt.";
        showToast(errorMessage.split("\n")[0], 'error', 4000); 
        return;
    }
    if (!cell.classList.contains('drop-target-valid')) {
        try {
            let needsApiCheck = state.dragData.type !== 'substitution' || (state.dragData.originalRegularEntryId || state.dragData.originalRegularBlockId);
            if (state.lastConflictCheckPromise && needsApiCheck) {
                await state.lastConflictCheckPromise; 
            } else if (needsApiCheck) {
                showToast("Ablegen nicht m√∂glich: Konfliktpr√ºfung unvollst√§ndig.", 'error');
                return;
            }
        } catch (error) {
            showToast(error.message.split("\n")[0], 'error', 4000);
            return;
        }
    }
    const targetStartPeriod = parseInt(cell.dataset.period);
    const targetEndPeriod = targetStartPeriod + state.dragData.span - 1;
    if (targetEndPeriod > DOM.timeSlots.length) {
        showToast("Ablegen nicht m√∂glich: Eintrag passt nicht in den Plan.", 'error');
        return;
    }
    const targetDay = cell.dataset.day;
    const entryData = state.dragData.data; 
    const savePromises = []; 
    const currentYear = DOM.yearSelector.value;
    const currentWeek = DOM.weekSelector.value;
    const newDate = getDateForDayInWeek(targetDay, currentYear, currentWeek);
    const mainContent = document.querySelector('.dashboard-content');
    const scrollY = mainContent ? mainContent.scrollTop : window.scrollY;
    if (state.dragData.type === 'substitution') {
        const originalSubIds = state.dragData.originalSubIds || [];
        const underlyingRegularEntries = state.dragData.underlyingRegularEntries || [];
        const movedRegularIds = new Set(); 
        for (let i = 0; i < underlyingRegularEntries.length; i++) {
            const regularEntry = underlyingRegularEntries[i];
            if (!regularEntry) continue; 
            const idToMove = regularEntry.block_id || regularEntry.entry_id;
            const idType = regularEntry.block_id ? 'block_id' : 'entry_id';
            if (!idToMove || movedRegularIds.has(idToMove)) {
                continue; // Verhindert doppeltes Verschieben von Bl√∂cken
            }
            movedRegularIds.add(idToMove);
            let regularEntrySpan = 1;
            if (regularEntry.block_id) {
                const periods = state.currentTimetable
                    .filter(e => e.block_id === regularEntry.block_id)
                    .map(e => parseInt(e.period_number));
                regularEntrySpan = periods.length > 0 ? Math.max(...periods) - Math.min(...periods) + 1 : 1;
            }
            const originalPeriodForThisEntry = parseInt(regularEntry.period_number);
            const periodOffset = originalPeriodForThisEntry - state.dragData.originalPeriod;
            const newStartPeriod = targetStartPeriod + periodOffset;
            const newEndPeriod = newStartPeriod + regularEntrySpan - 1;
            if (newEndPeriod > DOM.timeSlots.length) {
                console.warn(`√úberspringe Verschiebung des regul√§ren Eintrags ${idToMove}, w√ºrde aus dem Raster fallen.`);
                continue;
            }
            const regularSaveData = {
                entry_id: (idType === 'entry_id' ? idToMove : null),
                block_id: (idType === 'block_id' ? idToMove : null),
                year: currentYear,
                calendar_week: currentWeek,
                day_of_week: targetDay,
                start_period_number: newStartPeriod,
                end_period_number: newEndPeriod,
                class_id: regularEntry.class_id,
                teacher_id: regularEntry.teacher_id,
                subject_id: regularEntry.subject_id,
                room_id: regularEntry.room_id,
                comment: regularEntry.comment || null
            };
            savePromises.push(saveEntry(regularSaveData));
        }
        for (let i = 0; i < state.dragData.span; i++) {
            const currentTargetPeriod = targetStartPeriod + i;
            const originalSubId = originalSubIds[i]; 
            if (!originalSubId) {
                console.error(`Drop Error: Fehlende Original-Sub-ID f√ºr Index ${i}.`);
                showToast(`Fehler beim Verschieben (Index ${i}). Original-ID fehlt.`, 'error');
                continue; 
            }
            const originalSubData = state.currentSubstitutions.find(s => s.substitution_id == originalSubId);
            if (!originalSubData) {
                console.error(`Drop Error: Original-Sub-Daten f√ºr ID ${originalSubId} nicht gefunden.`);
                showToast(`Fehler beim Verschieben (ID ${originalSubId}). Originaldaten nicht gefunden.`, 'error');
                continue; 
            }
            const subSaveData = {
                ...originalSubData, 
                substitution_id: originalSubData.substitution_id, 
                date: newDate, 
                period_number: currentTargetPeriod, 
            };
            savePromises.push(saveSubstitution(subSaveData));
        }
    } else {
        const saveData = {
            entry_id: state.dragData.originalRegularEntryId, 
            block_id: state.dragData.originalRegularBlockId, 
            year: currentYear,
            calendar_week: currentWeek,
            day_of_week: targetDay,
            start_period_number: targetStartPeriod,
            end_period_number: targetEndPeriod,
            class_id: entryData.class_id, 
            teacher_id: entryData.teacher_id,
            subject_id: entryData.subject_id,
            room_id: entryData.room_id,
            comment: entryData.comment || null
        };
        savePromises.push(saveEntry(saveData)); 
    }
    try {
        const results = await Promise.all(savePromises);
        const success = results.every(response => response && response.success);
        if (success) {
            showToast("Eintrag erfolgreich verschoben.", 'success');
            await loadPlanData(); // Lade das Grid neu (await)
        } else {
            const firstErrorResult = results.find(r => !(r && r.success));
            const firstError = firstErrorResult?.message; 
            console.error("Fehler beim Speichern (Promise.all):", firstErrorResult);
            await loadPlanData(); // Lade auch bei Fehler neu (await)
            throw new Error(firstError || "Unbekannter Fehler beim Verschieben.");
        }
    } catch (error) {
        console.error("Drop save error (catch):", error);
    } finally {
        requestAnimationFrame(() => {
            if (mainContent) {
                mainContent.scrollTop = scrollY;
            } else {
                window.scrollTo(0, scrollY);
            }
        });
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-3.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-4.js ---
import * as DOM from './planer-dom.js';
import { getState, updateState, clearSelectionState } from './planer-state.js';
import {
¬† ¬† checkConflicts, saveEntry, deleteEntry, saveSubstitution, deleteSubstitution,
¬† ¬† loadPlanData
} from './planer-api.js';
import { showConflicts, hideConflicts } from './planer-ui.js';
import { renderTimetableGrid } from './planer-timetable.js';
import { showToast, showConfirm } from './notifications.js';
import { getDateForDayInWeek, escapeHtml } from './planer-utils.js';
export function initializeEntryModalInteractions() {
¬† ¬† initializeEntryModal();
}
function initializeEntryModal() {
¬† ¬† DOM.conflictCheckFields.forEach(field => {
¬† ¬† ¬† ¬† field.addEventListener('change', debouncedConflictCheck);
¬† ¬† });
¬† ¬† DOM.modalTabs.forEach(tab => tab.addEventListener('click', () => {
¬† ¬† ¬† ¬† const isTemplateEdit = DOM.form.querySelector('#modal_editing_template').value === 'true';
¬† ¬† ¬† ¬† switchMode(tab.dataset.mode, isTemplateEdit);
¬† ¬† }));
¬† ¬† DOM.substitutionTypeSelect.addEventListener('change', () => {
¬† ¬† ¬† ¬† updateSubstitutionFields();
¬† ¬† ¬† ¬† hideConflicts(); // Konflikte zur√ºcksetzen, da sich die Logik √§ndert
¬† ¬† });
¬† ¬† DOM.form.addEventListener('submit', handleSaveEntry);
¬† ¬† DOM.deleteBtn.addEventListener('click', handleDeleteEntry);
¬† ¬† DOM.modal.addEventListener('click', (e) => {
¬† ¬† ¬† ¬† if (e.target.id === 'timetable-modal' || e.target.id === 'modal-cancel-btn') {
¬† ¬† ¬† ¬† ¬† ¬† closeModal();
¬† ¬† ¬† ¬† }
¬† ¬† });
}
export function openModal(event, isTemplateEditor = false) {
¬† ¬† const state = getState();
¬† ¬† DOM.form.reset();
¬† ¬† hideConflicts();
¬† ¬† const target = event.target;
¬† ¬† const clickedCellElement = target.closest('.grid-cell');
¬† ¬† if (!clickedCellElement) return;
¬† ¬† const clickedEntryElement = clickedCellElement.querySelector('.planner-entry');
¬† ¬† const day = clickedCellElement.dataset.day;
¬† ¬† const period = clickedCellElement.dataset.period;
¬† ¬† const cellKey = `${day}-${period}`;
¬† ¬† let entryId = null;
¬† ¬† let substitutionId = null;
¬† ¬† let blockId = null;
¬† ¬† let entryToEdit = null;
¬† ¬† let regularEntryForSub = null;
¬† ¬† let modeToSwitchTo = 'regular';
¬† ¬† let editingClassId = null;
¬† ¬† DOM.form.querySelector('#modal_day_of_week').value = day;
¬† ¬† DOM.form.querySelector('#modal_period_number').value = period;
¬† ¬† DOM.form.querySelector('#modal_editing_template').value = isTemplateEditor ? 'true' : 'false';
¬† ¬† if (isTemplateEditor) {
¬† ¬† ¬† ¬† DOM.modal.querySelector('#template-class-select-container').style.display = 'block';
¬† ¬† ¬† ¬† DOM.modal.querySelector('.modal-tabs .tab-button[data-mode="substitution"]').style.display = 'none';
¬† ¬† ¬† ¬† const templateData = state.currentTemplateEditorData || [];
¬† ¬† ¬† ¬† if (clickedEntryElement) { // KORREKTUR: Verwendet die neue Variable
¬† ¬† ¬† ¬† ¬† ¬† entryId = clickedEntryElement.dataset.templateEntryId || null;
¬† ¬† ¬† ¬† ¬† ¬† blockId = clickedEntryElement.dataset.blockId || null;
¬† ¬† ¬† ¬† ¬† ¬† if (blockId) entryToEdit = templateData.find(e => e.block_ref === blockId);
¬† ¬† ¬† ¬† ¬† ¬† else if (entryId) entryToEdit = templateData.find(e => e.template_entry_id == entryId);
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† editingClassId = entryToEdit ? entryToEdit.class_id : '0'; // Standard '0' (Keine Klasse) f√ºr neue Eintr√§ge
¬† ¬† ¬† ¬† modeToSwitchTo = 'regular';
¬† ¬† } else {
¬† ¬† ¬† ¬† DOM.modal.querySelector('#template-class-select-container').style.display = 'none';
¬† ¬† ¬† ¬† DOM.modal.querySelector('.modal-tabs .tab-button[data-mode="substitution"]').style.display = 'block';
¬† ¬† ¬† ¬† if (clickedEntryElement) { // KORREKTUR: Verwendet die neue Variable
¬† ¬† ¬† ¬† ¬† ¬† entryId = clickedEntryElement.dataset.entryId || null;
¬† ¬† ¬† ¬† ¬† ¬† substitutionId = clickedEntryElement.dataset.substitutionId || null;
¬† ¬† ¬† ¬† ¬† ¬† blockId = clickedEntryElement.dataset.blockId || null;
¬† ¬† ¬† ¬† ¬† ¬† if (substitutionId) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† entryToEdit = (state.substitutions[cellKey] || []).find(s => s.substitution_id == substitutionId);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (entryToEdit) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const regularEntriesInCell = state.timetable[cellKey] || [];
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† regularEntryForSub = regularEntriesInCell.find(e => e.class_id == entryToEdit.class_id && e.subject_id == entryToEdit.original_subject_id);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† editingClassId = entryToEdit.class_id;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† modeToSwitchTo = 'substitution';
¬† ¬† ¬† ¬† ¬† ¬† } else if (entryId || blockId) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const entriesInCell = state.timetable[cellKey] || [];
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (blockId) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† entryToEdit = entriesInCell.find(e => e.block_id === blockId);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† entryToEdit = entriesInCell.find(e => e.entry_id == entryId);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if(entryToEdit) editingClassId = entryToEdit.class_id;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† modeToSwitchTo = 'regular';
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† modeToSwitchTo = 'regular';
¬† ¬† ¬† ¬† ¬† ¬† editingClassId = (state.currentViewMode === 'class') ? state.selectedClassId : null;
¬† ¬† ¬† ¬† }
¬† ¬† }
¬† ¬† updateState({ editingClassId: editingClassId });
¬† ¬† if (modeToSwitchTo === 'substitution') {
¬† ¬† ¬† ¬† DOM.form.querySelector('#entry_id').value = regularEntryForSub?.entry_id || '';
¬† ¬† ¬† ¬† DOM.form.querySelector('#block_id').value = regularEntryForSub?.block_id || '';
¬† ¬† ¬† ¬† DOM.form.querySelector('#substitution_id').value = entryToEdit?.substitution_id || '';
¬† ¬† } else if (modeToSwitchTo === 'regular' && entryToEdit) {
¬† ¬† ¬† ¬† DOM.form.querySelector('#entry_id').value = isTemplateEditor ? (entryToEdit.template_entry_id || '') : (entryToEdit.entry_id || '');
¬† ¬† ¬† ¬† DOM.form.querySelector('#block_id').value = isTemplateEditor ? (entryToEdit.block_ref || '') : (entryToEdit.block_id || '');
¬† ¬† ¬† ¬† DOM.form.querySelector('#substitution_id').value = '';
¬† ¬† } else {
¬† ¬† ¬† ¬† DOM.form.querySelector('#entry_id').value = '';
¬† ¬† ¬† ¬† DOM.form.querySelector('#block_id').value = '';
¬† ¬† ¬† ¬† DOM.form.querySelector('#substitution_id').value = '';
¬† ¬† }
¬† ¬† if (state.selection && (state.selection.cells.length > 1 || (state.selection.start && state.selection.start.cellData.blockId))) {
¬† ¬† ¬† ¬† const startP = Math.min(...state.selection.cells.map(c => parseInt(c.dataset.period)));
¬† ¬† ¬† ¬† const endP = Math.max(...state.selection.cells.map(c => parseInt(c.dataset.period)));
¬† ¬† ¬† ¬† DOM.modalTitle.textContent = `Block bearbeiten (${DOM.days[day-1]}, ${startP}. - ${endP}. Stunde)`;
¬† ¬† } else {
¬† ¬† ¬† ¬† DOM.modalTitle.textContent = `Eintrag bearbeiten (${DOM.days[day-1]}, ${period}. Stunde)`;
¬† ¬† }
¬† ¬† switchMode(modeToSwitchTo, isTemplateEditor);
¬† ¬† if (modeToSwitchTo === 'regular') {
¬† ¬† ¬† ¬† if(entryToEdit){
¬† ¬† ¬† ¬† ¬† ¬† DOM.form.querySelector('#subject_id').value = entryToEdit.subject_id;
¬† ¬† ¬† ¬† ¬† ¬† DOM.form.querySelector('#teacher_id').value = entryToEdit.teacher_id;
¬† ¬† ¬† ¬† ¬† ¬† DOM.form.querySelector('#room_id').value = entryToEdit.room_id;
¬† ¬† ¬† ¬† ¬† ¬† DOM.regularCommentInput.value = entryToEdit.comment || '';
¬† ¬† ¬† ¬† ¬† ¬† if (isTemplateEditor) DOM.modal.querySelector('#template_class_id').value = entryToEdit.class_id || '0';
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† DOM.regularCommentInput.value = '';
¬† ¬† ¬† ¬† ¬† ¬† if (isTemplateEditor) DOM.modal.querySelector('#template_class_id').value = editingClassId || '0';
¬† ¬† ¬† ¬† }
¬† ¬† } else if (modeToSwitchTo === 'substitution') {
¬† ¬† ¬† ¬† DOM.form.querySelector('#subject_id').value = regularEntryForSub?.subject_id || '';
¬† ¬† ¬† ¬† DOM.form.querySelector('#teacher_id').value = regularEntryForSub?.teacher_id || '';
¬† ¬† ¬† ¬† DOM.form.querySelector('#room_id').value = regularEntryForSub?.room_id || '';
¬† ¬† ¬† ¬† DOM.form.querySelector('#original_subject_id').value = regularEntryForSub?.subject_id || '';
¬† ¬† ¬† ¬† DOM.regularCommentInput.value = regularEntryForSub?.comment || '';
¬† ¬† ¬† ¬† if(entryToEdit){
¬† ¬† ¬† ¬† ¬† ¬† DOM.form.querySelector('#substitution_type').value = entryToEdit.substitution_type;
¬† ¬† ¬† ¬† ¬† ¬† DOM.form.querySelector('#new_teacher_id').value = entryToEdit.new_teacher_id || '';
¬† ¬† ¬† ¬† ¬† ¬† DOM.form.querySelector('#new_subject_id').value = entryToEdit.new_subject_id || '';
¬† ¬† ¬† ¬† ¬† ¬† DOM.form.querySelector('#new_room_id').value = entryToEdit.new_room_id || '';
¬† ¬† ¬† ¬† ¬† ¬† DOM.substitutionCommentInput.value = entryToEdit.comment || '';
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† DOM.form.querySelector('#substitution_type').value = 'Vertretung';
¬† ¬† ¬† ¬† ¬† ¬† DOM.substitutionCommentInput.value = '';
¬† ¬† ¬† ¬† ¬† ¬† DOM.form.querySelector('#new_subject_id').value = regularEntryForSub?.subject_id || '';
¬† ¬† ¬† ¬† ¬† ¬† DOM.form.querySelector('#new_room_id').value = regularEntryForSub?.room_id || '';
¬† ¬† ¬† ¬† ¬† ¬† DOM.form.querySelector('#new_teacher_id').value = '';
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† updateSubstitutionFields();
¬† ¬† }
¬† ¬† updateDeleteButtonVisibility();
¬† ¬† DOM.modal.classList.add('visible');
¬† ¬† if (!isTemplateEditor) debouncedConflictCheck();
}
export function closeModal() {
¬† ¬† clearSelectionState(getState().selection.cells);
¬† ¬† DOM.modal.classList.remove('visible');
¬† ¬† hideConflicts();
¬† ¬† updateState({ editingClassId: null });
¬† ¬† if (DOM.form) {
¬† ¬† ¬† ¬† DOM.form.querySelector('#modal_editing_template').value = 'false';
¬† ¬† ¬† ¬† const templateClassSelect = DOM.form.querySelector('#template-class-select-container');
¬† ¬† ¬† ¬† if (templateClassSelect) {
¬† ¬† ¬† ¬† ¬† ¬† templateClassSelect.style.display = 'none';
¬† ¬† ¬† ¬† }
¬† ¬† }
}
export function switchMode(mode, isTemplateEditor = false) {
¬† ¬† updateState({ activeMode: mode });
¬† ¬† DOM.modalTabs.forEach(tab => tab.classList.toggle('active', tab.dataset.mode === mode));
¬† ¬† DOM.regularFields.classList.toggle('active', mode === 'regular');
¬† ¬† DOM.substitutionFields.classList.toggle('active', mode === 'substitution');
¬† ¬† hideConflicts();
¬† ¬† if (mode === 'substitution') {
¬† ¬† ¬† ¬† const dayOfWeek = DOM.form.querySelector('#modal_day_of_week').value;
¬† ¬† ¬† ¬† if (!dayOfWeek) {
¬† ¬† ¬† ¬† ¬† ¬† showToast("Kann keine Vertretung ohne ausgew√§hlten Tag erstellen.", 'error');
¬† ¬† ¬† ¬† ¬† ¬† setTimeout(() => switchMode('regular', isTemplateEditor), 0);
¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† updateState({ selectedDate: getDateForDayInWeek(dayOfWeek, DOM.yearSelector.value, DOM.weekSelector.value) });
¬† ¬† ¬† ¬† updateSubstitutionFields();
¬† ¬† }
¬† ¬† updateDeleteButtonVisibility();
¬† ¬† if (!isTemplateEditor) debouncedConflictCheck();
}
export function updateSubstitutionFields() {
¬† ¬† const type = DOM.substitutionTypeSelect.value;
¬† ¬† DOM.modal.querySelectorAll('#substitution-details .sub-field').forEach(field => {
¬† ¬† ¬† ¬† const types = field.dataset.types ? JSON.parse(field.dataset.types) : [];
¬† ¬† ¬† ¬† field.style.display = types.includes(type) ? 'block' : 'none';
¬† ¬† });
}
export function updateDeleteButtonVisibility() {
¬† ¬† const entryId = DOM.form.querySelector('#entry_id').value;
¬† ¬† const substitutionId = DOM.form.querySelector('#substitution_id').value;
¬† ¬† const blockId = DOM.form.querySelector('#block_id').value;
¬† ¬† const isTemplateEdit = DOM.form.querySelector('#modal_editing_template').value === 'true';
¬† ¬† const canDelete = !isTemplateEdit && (
¬† ¬† ¬† ¬† (getState().activeMode === 'substitution' && substitutionId) ||
¬† ¬† ¬† ¬† (getState().activeMode === 'regular' && (entryId || blockId))
¬† ¬† );
¬† ¬† DOM.deleteBtn.style.display = canDelete ? 'block' : 'none';
}
const debouncedConflictCheck = () => {
¬† ¬† clearTimeout(getState().conflictCheckTimeout);
¬† ¬† updateState({
¬† ¬† ¬† ¬† conflictCheckTimeout: setTimeout(async () => {
¬† ¬† ¬† ¬† ¬† ¬† const state = getState();
¬† ¬† ¬† ¬† ¬† ¬† if (state.activeMode !== 'regular' || (DOM.form && DOM.form.querySelector('#modal_editing_template').value === 'true')) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† hideConflicts();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† const dayOfWeek = DOM.form.querySelector('#modal_day_of_week').value;
¬† ¬† ¬† ¬† ¬† ¬† const entryId = DOM.form.querySelector('#entry_id').value || null;
¬† ¬† ¬† ¬† ¬† ¬† const blockId = DOM.form.querySelector('#block_id').value || null;
¬† ¬† ¬† ¬† ¬† ¬† let startPeriod, endPeriod;
¬† ¬† ¬† ¬† ¬† ¬† if (state.selection && state.selection.cells.length > 0) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† startPeriod = Math.min(...state.selection.cells.map(c => parseInt(c.dataset.period)));
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† endPeriod = Math.max(...state.selection.cells.map(c => parseInt(c.dataset.period)));
¬† ¬† ¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† startPeriod = parseInt(DOM.form.querySelector('#modal_period_number').value);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† endPeriod = startPeriod;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† if (!startPeriod || !endPeriod) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† hideConflicts();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† const data = {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† year: DOM.yearSelector.value,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† calendar_week: DOM.weekSelector.value,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† day_of_week: dayOfWeek,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† start_period_number: startPeriod,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† end_period_number: endPeriod,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† teacher_id: DOM.form.querySelector('#teacher_id').value,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† room_id: DOM.form.querySelector('#room_id').value,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† class_id: state.editingClassId,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† entry_id: entryId,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† block_id: blockId,
¬† ¬† ¬† ¬† ¬† ¬† };
¬† ¬† ¬† ¬† ¬† ¬† if (!data.teacher_id || !data.room_id || !data.class_id || !data.day_of_week || !data.start_period_number) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† hideConflicts();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† await checkConflicts(data);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† hideConflicts(); // API war erfolgreich (keine Konflikte)
¬† ¬† ¬† ¬† ¬† ¬† } catch (error) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† console.error("Konfliktpr√ºfung ergab Fehler:", error);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (error.message) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showConflicts(error.message.split("\n"));
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showConflicts(["Unbekannter Fehler bei der Konfliktpr√ºfung."]);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }, 300) // 300ms Verz√∂gerung
¬† ¬† });
};
async function handleSaveEntry(e) {
¬† ¬† e.preventDefault();
¬† ¬† if (getState().conflictCheckTimeout) {
¬† ¬† ¬† ¬† await getState().lastConflictCheckPromise;
¬† ¬† }
¬† ¬† if (DOM.conflictWarningBox && DOM.conflictWarningBox.style.display !== 'none') {
¬† ¬† ¬† ¬† showToast("Speichern nicht m√∂glich: Es bestehen Konflikte.", 'error');
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬† const formData = new FormData(DOM.form);
¬† ¬† const state = getState();
¬† ¬† if (state.activeMode === 'regular') {
¬† ¬† ¬† ¬† formData.set('comment', DOM.regularCommentInput.value);
¬† ¬† ¬† ¬† formData.delete('substitution_type');
¬† ¬† ¬† ¬† formData.delete('new_teacher_id');
¬† ¬† ¬† ¬† formData.delete('new_subject_id');
¬† ¬† ¬† ¬† formData.delete('new_room_id');
¬† ¬† ¬† ¬† formData.delete('original_subject_id');
¬† ¬† } else {
¬† ¬† ¬† ¬† formData.set('comment', DOM.substitutionCommentInput.value);
¬† ¬† }
¬† ¬† const data = Object.fromEntries(formData.entries());
¬† ¬† let promise;
¬† ¬† if (state.activeMode === 'substitution') {
¬† ¬† ¬† ¬† const dayOfWeek = DOM.form.querySelector('#modal_day_of_week').value;
¬† ¬† ¬† ¬† data.date = getDateForDayInWeek(dayOfWeek, DOM.yearSelector.value, DOM.weekSelector.value);
¬† ¬† ¬† ¬† const entryId = DOM.form.querySelector('#entry_id').value;
¬† ¬† ¬† ¬† if (entryId) {
¬† ¬† ¬† ¬† ¬† ¬† const regularEntry = state.currentTimetable.find(e => e.entry_id == entryId);
¬† ¬† ¬† ¬† ¬† ¬† data.original_subject_id = regularEntry?.subject_id || null;
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† data.original_subject_id = null;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† data.class_id = state.editingClassId;
¬† ¬† ¬† ¬† if (!data.class_id) {
¬† ¬† ¬† ¬† ¬† ¬† showToast("Fehler: Klasse f√ºr Vertretung konnte nicht ermittelt werden.", 'error');
¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† promise = saveSubstitution(data);
¬† ¬† } else {
¬† ¬† ¬† ¬† const entryId = DOM.form.querySelector('#entry_id').value || null;
¬† ¬† ¬† ¬† const blockId = DOM.form.querySelector('#block_id').value || null;
¬† ¬† ¬† ¬† let startPeriod, endPeriod;
¬† ¬† ¬† ¬† if (state.selection && state.selection.cells.length > 0) {
¬† ¬† ¬† ¬† ¬† ¬† startPeriod = Math.min(...state.selection.cells.map(c => parseInt(c.dataset.period)));
¬† ¬† ¬† ¬† ¬† ¬† endPeriod = Math.max(...state.selection.cells.map(c => parseInt(c.dataset.period)));
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† startPeriod = parseInt(DOM.form.querySelector('#modal_period_number').value);
¬† ¬† ¬† ¬† ¬† ¬† endPeriod = startPeriod;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† data.start_period_number = startPeriod;
¬† ¬† ¬† ¬† data.end_period_number = endPeriod;
¬† ¬† ¬† ¬† data.year = DOM.yearSelector.value;
¬† ¬† ¬† ¬† data.calendar_week = DOM.weekSelector.value;
¬† ¬† ¬† ¬† if (DOM.form.querySelector('#modal_editing_template').value === 'true') {
¬† ¬† ¬† ¬† ¬† ¬† data.class_id = DOM.modal.querySelector('#template_class_id').value || '0';
¬† ¬† ¬† ¬† ¬† ¬† const templatePromise = new Promise((resolve) => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const updatedEntries = state.currentTemplateEditorData.filter(e => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (blockId && e.block_ref === blockId) return false;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (entryId && e.template_entry_id == entryId) return false;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return true;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const newBlockId = (startPeriod !== endPeriod) ? (blockId || `temp_block_${Date.now()}`) : null;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† for (let p = startPeriod; p <= endPeriod; p++) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† updatedEntries.push({
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† day_of_week: data.day_of_week,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† period_number: p,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† class_id: data.class_id,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† teacher_id: data.teacher_id,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† subject_id: data.subject_id,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† room_id: data.room_id,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† block_ref: newBlockId,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† comment: data.comment || null
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† updateState({ currentTemplateEditorData: updatedEntries });
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† resolve({ success: true, message: 'Template-Daten im State aktualisiert' });
¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† promise = templatePromise;
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† data.class_id = state.editingClassId;
¬† ¬† ¬† ¬† ¬† ¬† if (!data.class_id) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showToast("Fehler: Konnte Klasse nicht ermitteln.", 'error');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† promise = saveEntry(data);
¬† ¬† ¬† ¬† }
¬† ¬† }
¬† ¬† try {
¬† ¬† ¬† ¬† const response = await promise;
¬† ¬† ¬† ¬† if (response.success) {
¬† ¬† ¬† ¬† ¬† ¬† showToast("√Ñnderungen erfolgreich gespeichert.", 'success');
¬† ¬† ¬† ¬† ¬† ¬† closeModal();
¬† ¬† ¬† ¬† ¬† ¬† if (DOM.form.querySelector('#modal_editing_template').value === 'true') {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† renderTimetableGrid(getState(), true);
¬† ¬† ¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† loadPlanData();
 ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }
¬† ¬† } catch (error) {
¬† ¬† }
}
async function handleDeleteEntry() {
¬† ¬† let confirmMsg;
¬† ¬† const state = getState();
¬† ¬† const promises = [];
¬† ¬† const substitutionId = DOM.form.querySelector('#substitution_id').value;
¬† ¬† const entryId = DOM.form.querySelector('#entry_id').value;
¬† ¬† const blockId = DOM.form.querySelector('#block_id').value;
¬† ¬† if (state.activeMode === 'substitution') {
¬† ¬† ¬† ¬† if (!substitutionId) {
¬† ¬† ¬† ¬† ¬† ¬† showToast("Fehler: Keine Vertretungs-ID gefunden.", 'error');
¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† confirmMsg = 'Soll diese Vertretung gel√∂scht werden? (Die regul√§re Stunde bleibt erhalten)';
¬† ¬† ¬† ¬† if (await showConfirm("L√∂schen best√§tigen", confirmMsg)) {
¬† ¬† ¬† ¬† ¬† ¬† promises.push(deleteSubstitution(substitutionId)); // <-- RICHTIGE STELLE (NEU)
¬† ¬† ¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const responses = await Promise.all(promises);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (responses.every(r => r && r.success)) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showToast("Vertretung erfolgreich gel√∂scht.", 'success');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† closeModal();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† loadPlanData();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† throw new Error("Eintrag konnte nicht gel√∂scht werden.");
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† } catch (error) {  }
¬† ¬† ¬† ¬† }
¬† ¬† } else {
¬† ¬† ¬† ¬† let body;
¬† ¬† ¬† ¬† if (blockId) {
¬† ¬† ¬† ¬† ¬† ¬† body = { block_id: blockId };
¬† ¬† ¬† ¬† ¬† ¬† confirmMsg = 'Soll dieser gesamte Block wirklich gel√∂scht werden?';
¬† ¬† ¬† ¬† } else if (entryId) {
¬† ¬† ¬† ¬† ¬† ¬† body = { entry_id: entryId };
¬† ¬† ¬† ¬† ¬† ¬† confirmMsg = 'Soll diese regul√§re Stunde wirklich gel√∂scht werden?';
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† showToast("Kein Eintrag zum L√∂schen ausgew√§hlt.", 'error'); return;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† if (await showConfirm("L√∂schen best√§tigen", confirmMsg)) {
¬† ¬† ¬† ¬† ¬† ¬† try {
 ¬† ¬† ¬† ¬† const response = await deleteEntry(body);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (response.success) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showToast("Eintrag erfolgreich gel√∂scht.", 'success');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† closeModal();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† loadPlanData();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† } catch (error) {  }
 ¬† ¬† }
¬† ¬† }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-4.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-5.js ---
import * as DOM from './planer-dom.js';
import { getState, updateState } from './planer-state.js';
import {
¬† ¬† copyWeek, loadTemplates, createTemplate, applyTemplate, deleteTemplate,
¬† ¬† loadTemplateDetails, saveTemplate, loadPlanData
} from './planer-api.js';
import { populateYearSelector, populateWeekSelector, populateTemplateSelects, showTemplateView, populateAllModalSelects } from './planer-ui.js';
import { renderTimetableGrid } from './planer-timetable.js';
import { showToast, showConfirm } from './notifications.js';
import { getWeekAndYear, getDateOfISOWeek, escapeHtml } from './planer-utils.js';
export function initializeActionModals() {
¬† ¬† DOM.copyWeekBtn.addEventListener('click', openCopyModal);
¬† ¬† DOM.copyWeekCancelBtn.addEventListener('click', closeCopyModal);
¬† ¬† DOM.copyWeekModal.addEventListener('click', (e) => { if (e.target.id === 'copy-week-modal') closeCopyModal(); });
¬† ¬† DOM.copyWeekForm.addEventListener('submit', handleCopyWeekSubmit);
¬† ¬† DOM.createTemplateBtn.addEventListener('click', handleCreateTemplateFromWeek);
¬† ¬† DOM.applyTemplateBtn.addEventListener('click', openApplyTemplateModal);
¬† ¬† DOM.manageTemplatesBtn.addEventListener('click', openManageTemplatesModal);
¬† ¬† DOM.manageTemplatesCloseBtn.addEventListener('click', closeManageTemplatesModal);
¬† ¬† DOM.applyTemplateCancelBtn.addEventListener('click', closeApplyTemplateModal);
¬† ¬† DOM.manageTemplatesModal.addEventListener('click', (e) => { if (e.target.id === 'manage-templates-modal') closeManageTemplatesModal(); });
¬† ¬† DOM.applyTemplateModal.addEventListener('click', (e) => { if (e.target.id === 'apply-template-modal') closeApplyTemplateModal(); });
¬† ¬† DOM.manageTemplatesForm.addEventListener('submit', handleCreateTemplateSubmit);
¬† ¬† DOM.applyTemplateForm.addEventListener('submit', handleApplyTemplateSubmit);
¬† ¬† DOM.createEmptyTemplateBtn.addEventListener('click', handleCreateEmptyTemplate);
¬† ¬† DOM.backToTemplateListBtn.addEventListener('click', handleBackToTemplateList);
¬† ¬† DOM.saveTemplateEditorBtn.addEventListener('click', handleSaveTemplateEditor);
}
function openCopyModal() {
¬† ¬† const state = getState();
¬† ¬† if (!state.selectedClassId && !state.selectedTeacherId) {
¬† ¬† ¬† ¬† showToast("Bitte zuerst eine Klasse oder einen Lehrer ausw√§hlen.", 'error');
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬† DOM.copySourceDisplay.value = `KW ${DOM.weekSelector.value} / ${DOM.yearSelector.value}`;
¬† ¬† const currentMonday = getDateOfISOWeek(parseInt(DOM.weekSelector.value), parseInt(DOM.yearSelector.value));
¬† ¬† const nextWeekDate = new Date(currentMonday.getTime() + 7 * 24 * 60 * 60 * 1000);
¬† ¬† const { week: nextWeek, year: nextYear } = getWeekAndYear(nextWeekDate);
¬† ¬† populateYearSelector(DOM.copyTargetYear, nextYear);
¬† ¬† populateWeekSelector(DOM.copyTargetWeek, nextWeek);
¬† ¬† DOM.copyWeekModal.classList.add('visible');
}
function closeCopyModal() {
¬† ¬† DOM.copyWeekModal.classList.remove('visible');
}
async function handleCopyWeekSubmit(e) {
¬† ¬† e.preventDefault();
¬† ¬† const state = getState();
¬† ¬† const sourceYear = parseInt(DOM.yearSelector.value);
¬† ¬† const sourceWeek = parseInt(DOM.weekSelector.value);
¬† ¬† const targetYear = parseInt(DOM.copyTargetYear.value);
¬† ¬† const targetWeek = parseInt(DOM.copyTargetWeek.value);
¬† ¬† if (sourceYear === targetYear && sourceWeek === targetWeek) {
¬† ¬† ¬† ¬† showToast("Fehler: Quell- und Zielwoche d√ºrfen nicht identisch sein.", 'error');
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬† const entityName = state.currentViewMode === 'class'
¬† ¬† ¬† ¬† ? `Klasse ${state.selectedClassId}`
¬† ¬† ¬† ¬† : `Lehrer ${DOM.teacherSelector.options[DOM.teacherSelector.selectedIndex]?.text || state.selectedTeacherId}`;
¬† ¬† if (await showConfirm("Kopieren best√§tigen", `Sind Sie sicher, dass Sie den Plan f√ºr '${escapeHtml(entityName)}' von KW ${sourceWeek}/${sourceYear} nach KW ${targetWeek}/${targetYear} kopieren m√∂chten? Alle Eintr√§ge in der Zielwoche werden √ºberschrieben.`)) {
¬† ¬† ¬† ¬† const body = { sourceYear, sourceWeek, targetYear, targetWeek, classId: state.selectedClassId, teacherId: state.selectedTeacherId };
¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† const response = await copyWeek(body);
¬† ¬† ¬† ¬† ¬† ¬† if (response.success) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showToast(response.message, 'success');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† closeCopyModal();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† DOM.yearSelector.value = targetYear;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† DOM.weekSelector.value = targetWeek;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† loadPlanData();
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† } catch (error) {  }
¬† ¬† }
}
async function openManageTemplatesModal() {
¬† ¬† DOM.manageTemplatesForm.reset();
¬† ¬† const templates = await loadTemplates(); // L√§dt Vorlagen und f√ºllt Selects
¬† ¬† renderTemplatesList(templates); // Rendert die Liste im "Verwalten"-Modal
¬† ¬† showTemplateView('list'); // Zeigt die Listenansicht
¬† ¬† DOM.manageTemplatesModal.classList.add('visible');
}
function closeManageTemplatesModal() {
¬† ¬† DOM.manageTemplatesModal.classList.remove('visible');
}
async function openApplyTemplateModal() {
¬† ¬† const state = getState();
¬† ¬† if (!state.selectedClassId && !state.selectedTeacherId) {
¬† ¬† ¬† ¬† showToast("Bitte zuerst eine Klasse oder einen Lehrer ausw√§hlen.", 'error');
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬† await loadTemplates(); // F√ºllt automatisch das Select-Feld
¬† ¬† DOM.applyTemplateForm.reset();
¬† ¬† DOM.applyTemplateModal.classList.add('visible');
}
function closeApplyTemplateModal() {
¬† ¬† DOM.applyTemplateModal.classList.remove('visible');
}
function handleCreateTemplateFromWeek() {
¬† ¬† const state = getState();
¬† ¬† if (!state.selectedClassId && !state.selectedTeacherId) {
¬† ¬† ¬† ¬† showToast("Bitte zuerst eine Klasse oder einen Lehrer ausw√§hlen, um eine Vorlage zu erstellen.", 'error');
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬† if (state.currentTimetable.length === 0) {
¬† ¬† ¬† ¬† showToast("Die aktuelle Woche enth√§lt keine Eintr√§ge zum Speichern als Vorlage.", 'info');
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬† openManageTemplatesModal();
}
async function handleCreateTemplateSubmit(e) {
¬† ¬† e.preventDefault();
¬† ¬† const templateNameInput = DOM.manageTemplatesForm.querySelector('#template-name');
¬† ¬† const templateDescriptionInput = DOM.manageTemplatesForm.querySelector('#template-description');
¬† ¬† const templateName = templateNameInput ? templateNameInput.value.trim() : '';
¬† ¬† const templateDescription = templateDescriptionInput ? templateDescriptionInput.value.trim() : '';
¬† ¬† if (!templateName) {
¬† ¬† ¬† ¬† showToast("Bitte geben Sie einen Namen f√ºr die Vorlage ein.", 'error');
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬† const state = getState();
¬† ¬† const body = {
¬† ¬† ¬† ¬† name: templateName,
¬† ¬† ¬† ¬† description: templateDescription || null,
¬† ¬† ¬† ¬† sourceYear: DOM.yearSelector.value,
¬† ¬† ¬† ¬† sourceWeek: DOM.weekSelector.value,
¬† ¬† ¬† ¬† sourceClassId: state.selectedClassId,
¬† ¬† ¬† ¬† sourceTeacherId: state.selectedTeacherId
¬† ¬† };
¬† ¬† try {
¬† ¬† ¬† ¬† const response = await createTemplate(body);
¬† ¬† ¬† ¬† if (response.success) {
¬† ¬† ¬† ¬† ¬† ¬† showToast(response.message, 'success');
¬† ¬† ¬† ¬† ¬† ¬† DOM.manageTemplatesForm.reset();
¬† ¬† ¬† ¬† ¬† ¬† const templates = await loadTemplates(); // L√§dt neu und aktualisiert alle Selects
¬† ¬† ¬† ¬† ¬† ¬† renderTemplatesList(templates); // Rendert die Liste im Modal neu
¬† ¬† ¬† ¬† }
¬† ¬† } catch (error) {  }
}
async function handleApplyTemplateSubmit(e) {
¬† ¬† e.preventDefault();
¬† ¬† const templateId = DOM.applyTemplateSelect.value;
¬† ¬† if (!templateId) {
¬† ¬† ¬† ¬† showToast("Bitte w√§hlen Sie eine Vorlage aus.", 'error');
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬† const targetYear = DOM.yearSelector.value;
¬† ¬† const targetWeek = DOM.weekSelector.value;
¬† ¬† if (!targetYear || !targetWeek) return;¬†
¬† ¬† const state = getState();
¬† ¬† if (await showConfirm("Vorlage anwenden", "Sind Sie sicher? Alle Eintr√§ge f√ºr die aktuelle Auswahl in dieser Woche werden durch die Vorlage √ºberschrieben.")) {
¬† ¬† ¬† ¬† const body = {
¬† ¬† ¬† ¬† ¬† ¬† templateId: templateId,
¬† ¬† ¬† ¬† ¬† ¬† targetYear: targetYear,
¬† ¬† ¬† ¬† ¬† ¬† targetWeek: targetWeek,
¬† ¬† ¬† ¬† ¬† ¬† targetClassId: state.selectedClassId,
¬† ¬† ¬† ¬† ¬† ¬† targetTeacherId: state.selectedTeacherId
¬† ¬† ¬† ¬† };
¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† const response = await applyTemplate(body);
¬† ¬† ¬† ¬† ¬† ¬† if (response.success) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showToast(response.message, 'success');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† closeApplyTemplateModal();
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† loadPlanData();¬†
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† } catch (error) {  }
¬† ¬† }
}
function handleCreateEmptyTemplate() {
¬† ¬† updateState({¬†
¬† ¬† ¬† ¬† currentTemplateEditorData: [], // Leere Daten
¬† ¬† ¬† ¬† currentEditingTemplateId: null // Keine ID
¬† ¬† });¬†
¬† ¬† DOM.templateEditorTitle.textContent = 'Neue leere Vorlage erstellen';
¬† ¬† const nameInput = DOM.manageTemplatesModal.querySelector('#template-editor-name');
¬† ¬† const descInput = DOM.manageTemplatesModal.querySelector('#template-editor-description');
¬† ¬† if(nameInput) nameInput.value = '';
¬† ¬† if(descInput) descInput.value = '';
¬† ¬† populateAllModalSelects(getState().stammdaten);
¬† ¬† renderTimetableGrid(getState(), true); // true = Template-Editor-Modus
¬† ¬† showTemplateView('editor');
}
function handleBackToTemplateList() {
¬† ¬† showTemplateView('list');
¬† ¬† updateState({¬†
¬† ¬† ¬† ¬† currentTemplateEditorData: null,¬†
¬† ¬† ¬† ¬† currentEditingTemplateId: null¬†
¬† ¬† });¬†
}
async function handleSaveTemplateEditor() {
¬† ¬† const state = getState();
¬† ¬† const name = DOM.manageTemplatesModal.querySelector('#template-editor-name').value.trim();
¬† ¬† const description = DOM.manageTemplatesModal.querySelector('#template-editor-description').value.trim();
¬† ¬† const templateId = state.currentEditingTemplateId; // Kann null sein (f√ºr neue Vorlage)
¬† ¬† const entries = state.currentTemplateEditorData || [];
¬† ¬† if (!name) {
¬† ¬† ¬† ¬† showToast("Bitte einen Vorlagennamen eingeben.", 'error');
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬† const templateData = {
¬† ¬† ¬† ¬† template_id: templateId,
¬† ¬† ¬† ¬† name: name,
¬† ¬† ¬† ¬† description: description || null,
¬† ¬† ¬† ¬† entries: entries
¬† ¬† };
¬† ¬† try {
¬† ¬† ¬† ¬† const response = await saveTemplate(templateData);
¬† ¬† ¬† ¬† if (response.success) {
¬† ¬† ¬† ¬† ¬† ¬† showToast(response.message, 'success');
¬† ¬† ¬† ¬† ¬† ¬† updateState({ currentTemplateEditorData: null, currentEditingTemplateId: null });
¬† ¬† ¬† ¬† ¬† ¬† const templates = await loadTemplates();
¬† ¬† ¬† ¬† ¬† ¬† renderTemplatesList(templates);
¬† ¬† ¬† ¬† ¬† ¬† showTemplateView('list');
¬† ¬† ¬† ¬† }
¬† ¬† } catch (error) {  }
}
export function renderTemplatesList(templates) {
¬† ¬† if (!DOM.manageTemplatesList) return;
¬† ¬† if (!Array.isArray(templates)) {
¬† ¬† ¬† ¬† console.error("renderTemplatesList: Input 'templates' ist kein Array.", templates);
¬† ¬† ¬† ¬† DOM.manageTemplatesList.innerHTML = '<p class="message error">Fehler beim Anzeigen der Vorlagen.</p>';
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬† if (templates.length === 0) {
¬† ¬† ¬† ¬† DOM.manageTemplatesList.innerHTML = '<p>Keine Vorlagen vorhanden.</p>';
¬† ¬† ¬† ¬† return;
¬† ¬† }
¬† ¬† DOM.manageTemplatesList.innerHTML = `
¬† ¬† ¬† ¬† <table class="data-table templates-list-table">
¬† ¬† ¬† ¬† ¬† ¬† <thead><tr><th>Name</th><th>Beschreibung</th><th>Aktion</th></tr></thead>
¬† ¬† ¬† ¬† ¬† ¬† <tbody>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ${templates.map(t => `
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <tr data-id="${t.template_id}">
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <td>${escapeHtml(t.name)}</td>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <td>${escapeHtml(t.description) || '-'}</td>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <td class="actions">
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <button class="btn btn-warning btn-small edit-template" data-id="${t.template_id}">Bearbeiten</button>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <button class="btn btn-danger btn-small delete-template" data-name="${escapeHtml(t.name)}">L√∂schen</button>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† </td>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† </tr>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† `).join('')}
¬† ¬† ¬† ¬† ¬† ¬† </tbody>
¬† ¬† ¬† ¬† </table>
¬† ¬† `;
¬† ¬† DOM.manageTemplatesList.querySelectorAll('.delete-template').forEach(button => {
¬† ¬† ¬† ¬† button.addEventListener('click', handleDeleteTemplateClick);
¬† ¬† });
¬† ¬† DOM.manageTemplatesList.querySelectorAll('.edit-template').forEach(button => {
¬† ¬† ¬† ¬† button.addEventListener('click', handleEditTemplateClick);
¬† ¬† });
}
async function handleEditTemplateClick(e) {
¬† ¬† const button = e.target;
¬† ¬† const templateId = button.dataset.id;
¬† ¬† if (!templateId) return;
¬† ¬† try {
¬† ¬† ¬† ¬† const response = await loadTemplateDetails(templateId);
¬† ¬† ¬† ¬† if (response.success && response.data) {
¬† ¬† ¬† ¬† ¬† ¬† const { template, entries } = response.data;
¬† ¬† ¬† ¬† ¬† ¬† updateState({
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† currentTemplateEditorData: entries || [],
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† currentEditingTemplateId: template.template_id
¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† DOM.templateEditorTitle.textContent = `Vorlage bearbeiten: ${escapeHtml(template.name)}`;
¬† ¬† ¬† ¬† ¬† ¬† const nameInput = DOM.manageTemplatesModal.querySelector('#template-editor-name');
¬† ¬† ¬† ¬† ¬† ¬† const descInput = DOM.manageTemplatesModal.querySelector('#template-editor-description');
¬† ¬† ¬† ¬† ¬† ¬† if (nameInput) nameInput.value = template.name;
¬† ¬† ¬† ¬† ¬† ¬† if (descInput) descInput.value = template.description || '';
¬† ¬† ¬† ¬† ¬† ¬† renderTimetableGrid(getState(), true); // true = Template-Editor-Modus
¬† ¬† ¬† ¬† ¬† ¬† showTemplateView('editor');
¬† ¬† ¬† ¬† }
¬† ¬† } catch (error) {  }
}
async function handleDeleteTemplateClick(e) {
¬† ¬† const button = e.target;
¬† ¬† const row = button.closest('tr');
¬† ¬† if (!row) return;¬†
¬† ¬† const templateId = row.dataset.id;
¬† ¬† const templateName = button.dataset.name;
¬† ¬† if (await showConfirm("Vorlage l√∂schen", `Sind Sie sicher, dass Sie die Vorlage "${templateName}" endg√ºltig l√∂schen m√∂chten?`)) {
¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† const response = await deleteTemplate(templateId);
¬† ¬† ¬† ¬† ¬† ¬† if (response.success) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† showToast(response.message, 'success');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const updatedTemplates = await loadTemplates(); // L√§dt neu und aktualisiert Selects
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† renderTemplatesList(updatedTemplates); // Rendert Liste im Modal neu
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† } catch (error) {  }
¬† ¬† }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-5.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-state.js ---
import { timeSlots, days } from './planer-dom.js';
const state = {
¬† ¬† stammdaten: {
¬† ¬† ¬† ¬† classes: [],
¬† ¬† ¬† ¬† teachers: [],
¬† ¬† ¬† ¬† subjects: [],
¬† ¬† ¬† ¬† rooms: [],
¬† ¬† ¬† ¬† absences: [], // Wird mit Plandaten geladen
¬† ¬† ¬† ¬† templates: [] // Wird bei Bedarf geladen
¬† ¬† },
¬† ¬† currentViewMode: 'class', // 'class' oder 'teacher'
¬† ¬† selectedClassId: null,
¬† ¬† selectedTeacherId: null,
¬† ¬† selectedYear: null,
¬† ¬† selectedWeek: null,
¬† ¬† selectedDate: null, // YYYY-MM-DD (f√ºr Vertretungen)
¬† ¬† timetable: {}, // Map[cellKey] -> [] (Regul√§re Eintr√§ge)
¬† ¬† substitutions: {}, // Map[cellKey] -> [] (Vertretungen)
¬† ¬† currentTimetable: [], // Array aller regul√§ren Eintr√§ge
¬† ¬† currentSubstitutions: [], // Array aller Vertretungen
¬† ¬† publishStatus: { student: false, teacher: false },
¬† ¬† isLoading: false,
¬† ¬† currentModalData: null, // Daten f√ºr das ge√∂ffnete Modal
¬† ¬† activeMode: 'regular', // 'regular' oder 'substitution' im Modal
¬† ¬† conflictCheckTimeout: null, // Timeout-ID f√ºr debouncing
¬† ¬† lastConflictCheckPromise: null, // Speichert das Promise der letzten Pr√ºfung
¬† ¬† selection: {
¬† ¬† ¬† ¬† start: null, // { day, period, cell, cellData }
¬† ¬† ¬† ¬† end: null, // { day, period }
¬† ¬† ¬† ¬† cells: [], // Array der ausgew√§hlten HTMLElements
¬† ¬† },
¬† ¬† dragData: null, // Daten des gezogenen Elements
¬† ¬† lastDragOverCell: null, // Letzte Zelle, √ºber der geschwebt wurde
¬† ¬† editingClassId: null, // Welche Klassen-ID wird im Modal bearbeitet
¬† ¬† currentTemplateEditorData: null, // Array der Eintr√§ge der Vorlage
¬† ¬† currentEditingTemplateId: null, // ID der Vorlage, die bearbeitet wird
};
export function getState() {
¬† ¬† return state;
}
export function updateState(newState) {
¬† ¬† Object.assign(state, newState);
}
export function setSelectionState(selection) {
¬† ¬† state.selection = selection;
}
export function clearSelectionState(selectedCells = []) {
¬† ¬† selectedCells.forEach(cell => cell.classList.remove('selected'));
¬† ¬† state.selection = { start: null, end: null, cells: [] };
}
export function processTimetableData(data) {
¬† ¬† const newTimetableMap = {};
¬† ¬† const newSubstitutionMap = {};
¬† ¬† const numPeriods = timeSlots.length; // z.B. 10
¬† ¬† const numDays = days.length; // z.B. 5
¬† ¬† for (let day = 1; day <= numDays; day++) {
¬† ¬† ¬† ¬† for (let period = 1; period <= numPeriods; period++) {
¬† ¬† ¬† ¬† ¬† ¬† const cellKey = `${day}-${period}`;
¬† ¬† ¬† ¬† ¬† ¬† newTimetableMap[cellKey] = [];
¬† ¬† ¬† ¬† ¬† ¬† newSubstitutionMap[cellKey] = [];
¬† ¬† ¬† ¬† }
¬† ¬† }
¬† ¬† if (data.timetable && Array.isArray(data.timetable)) {
¬† ¬† ¬† ¬† data.timetable.forEach(entry => {
¬† ¬† ¬† ¬† ¬† ¬† const cellKey = `${entry.day_of_week}-${entry.period_number}`;
¬† ¬† ¬† ¬† ¬† ¬† if (newTimetableMap[cellKey]) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† newTimetableMap[cellKey].push(entry);
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† });
¬† ¬† }
¬† ¬† if (data.substitutions && Array.isArray(data.substitutions)) {
¬† ¬† ¬† ¬† data.substitutions.forEach(sub => {
¬† ¬† ¬† ¬† ¬† ¬† if (sub.day_of_week) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const cellKey = `${sub.day_of_week}-${sub.period_number}`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (newSubstitutionMap[cellKey]) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† newSubstitutionMap[cellKey].push(sub);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† });
¬† ¬† }
¬† ¬† updateState({
¬† ¬† ¬† ¬† timetable: newTimetableMap,
¬† ¬† ¬† ¬† substitutions: newSubstitutionMap,
¬† ¬† ¬† ¬† currentTimetable: data.timetable || [], // Rohdaten f√ºr Drag & Drop
¬† ¬† ¬† ¬† currentSubstitutions: data.substitutions || [], // Rohdaten f√ºr Drag & Drop
¬† ¬† ¬† ¬† publishStatus: data.publishStatus || { student: false, teacher: false },
¬† ¬† ¬† ¬† stammdaten: {
¬† ¬† ¬† ¬† ¬† ¬† ...state.stammdaten,
¬† ¬† ¬† ¬† ¬† ¬† absences: data.absences || state.stammdaten.absences || []
¬† ¬† ¬† ¬† },
¬† ¬† ¬† ¬† isLoading: false
¬† ¬† });
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-state.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-timetable.js ---
import { getState } from './planer-state.js';
import { days, timeSlots, timetableContainer } from './planer-dom.js';
import { escapeHtml } from './planer-utils.js'; 
export function renderTimetableGrid(overrideState = null, isTemplateEditor = false) {
¬† ¬† const container = isTemplateEditor ? document.getElementById('template-editor-grid-container') : timetableContainer;
¬† ¬† if (!container) return;
¬† ¬† const state = overrideState || getState();
¬† ¬† const stammdaten = state.stammdaten || {};
¬† ¬† const settings = (stammdaten && stammdaten.settings) ? stammdaten.settings : (window.APP_CONFIG.settings || {});
¬† ¬† const startHour = parseInt(settings.default_start_hour, 10) || 1;
¬† ¬† const endHour = parseInt(settings.default_end_hour, 10) || 10;
¬† ¬† const grid = document.createElement('div');
¬† ¬† grid.className = 'timetable-grid'; 
¬† ¬† if (isTemplateEditor) {
¬† ¬† ¬† ¬† grid.classList.add('template-editor-grid');
¬† ¬† } else {
¬† ¬† ¬† ¬† grid.id = 'timetable-grid'; 
¬† ¬† }
¬† ¬† let gridHTML = '';
¬† ¬† gridHTML += '<div class="grid-header period-header">Zeit</div>';
¬† ¬† days.forEach(dayName => { 
¬† ¬† ¬† ¬† gridHTML += `<div class="grid-header">${dayName}</div>`;
¬† ¬† });
¬† ¬† for (let period = 1; period <= timeSlots.length; period++) {
¬† ¬† ¬† ¬† if (isTemplateEditor && (period < startHour || period > endHour)) {
¬† ¬† ¬† ¬† ¬† ¬† continue;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† gridHTML += `<div class="grid-header period-header" style="grid-row: ${period + 1};">
¬† ¬† ¬† ¬† ¬† ¬† <div class="time-slot-period">${period}. Std</div>
¬† ¬† ¬† ¬† ¬† ¬† <div class="time-slot-time">${timeSlots[period - 1]}</div>
¬† ¬† ¬† ¬† </div>`;
¬† ¬† }
¬† ¬† const processedCellKeys = new Set();
¬† ¬† const blockSpans = new Map();
¬† ¬† const dataToRender = isTemplateEditor ? (state.currentTemplateEditorData || []) : (state.currentTimetable || []);
¬† ¬† const subsToRender = isTemplateEditor ? [] : (state.currentSubstitutions || []);
¬† ¬† const stateTimetableMap = isTemplateEditor ? null : (state.timetable || {}); 
¬† ¬† const stateSubMap = isTemplateEditor ? null : (state.substitutions || {}); 
¬† ¬† if (dataToRender.length > 0) {
¬† ¬† ¬† ¬† const blocks = new Map();
¬† ¬† ¬† ¬† dataToRender.forEach(entry => {
¬† ¬† ¬† ¬† ¬† ¬† const blockKey = isTemplateEditor ? entry.block_ref : entry.block_id;
¬† ¬† ¬† ¬† ¬† ¬† if (blockKey) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (!blocks.has(blockKey)) blocks.set(blockKey, []);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† blocks.get(blockKey).push(entry);
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† blocks.forEach(entries => {
¬† ¬† ¬† ¬† ¬† ¬† if (entries.length === 0) return;
¬† ¬† ¬† ¬† ¬† ¬† entries.sort((a, b) => a.period_number - b.period_number);
¬† ¬† ¬† ¬† ¬† ¬† const startEntry = entries[0];
¬† ¬† ¬† ¬† ¬† ¬† const span = parseInt(entries[entries.length - 1].period_number) - parseInt(startEntry.period_number) + 1;
¬† ¬† ¬† ¬† ¬† ¬† blockSpans.set(`${startEntry.day_of_week}-${startEntry.period_number}`, span);
¬† ¬† ¬† ¬† ¬† ¬† for (let i = 1; i < span; i++) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† processedCellKeys.add(`${startEntry.day_of_week}-${parseInt(startEntry.period_number) + i}`);
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† });
¬† ¬† }
¬† ¬† if (subsToRender.length > 0) {
¬† ¬† ¬† ¬† const substitutionBlocks = new Map();
¬† ¬† ¬† ¬† subsToRender.forEach(sub => {
¬† ¬† ¬† ¬† ¬† ¬† if (!sub.day_of_week) return;
¬† ¬† ¬† ¬† ¬† ¬† const key = `${sub.date}-${sub.class_id}-${sub.substitution_type}-${sub.comment || ''}-${sub.new_room_id || ''}-${sub.new_teacher_id || ''}-${sub.new_subject_id || ''}`;
¬† ¬† ¬† ¬† ¬† ¬† if (!substitutionBlocks.has(key)) substitutionBlocks.set(key, []);
¬† ¬† ¬† ¬† ¬† ¬† substitutionBlocks.get(key).push(sub);
¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† substitutionBlocks.forEach(subs => {
¬† ¬† ¬† ¬† ¬† ¬† if (subs.length > 1) {¬†
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† subs.sort((a, b) => a.period_number - b.period_number);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† let isConsecutive = true;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† for (let i = 0; i < subs.length - 1; i++) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (parseInt(subs[i + 1].period_number) !== parseInt(subs[i].period_number) + 1) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† isConsecutive = false; break;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (isConsecutive) {¬†
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const startSub = subs[0];
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const span = subs.length;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const dayNum = startSub.day_of_week;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (dayNum) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† blockSpans.set(`${dayNum}-${startSub.period_number}`, span);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† for (let i = 1; i < span; i++) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† processedCellKeys.add(`${dayNum}-${parseInt(startSub.period_number) + i}`);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† });
¬† ¬† }
¬† ¬† for (let period = 1; period <= timeSlots.length; period++) {
¬† ¬† ¬† ¬† if (isTemplateEditor && (period < startHour || period > endHour)) {
¬† ¬† ¬† ¬† ¬† ¬† continue;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† for (let day = 1; day <= days.length; day++) {
¬† ¬† ¬† ¬† ¬† ¬† const cellKey = `${day}-${period}`;
¬† ¬† ¬† ¬† ¬† ¬† if (processedCellKeys.has(cellKey)) continue;
¬† ¬† ¬† ¬† ¬† ¬† const entries = isTemplateEditor ? dataToRender.filter(e => e.day_of_week == day && e.period_number == period) : (stateTimetableMap[cellKey] || []);
¬† ¬† ¬† ¬† ¬† ¬† const subs = isTemplateEditor ? [] : (stateSubMap[cellKey] || []);
¬† ¬† ¬† ¬† ¬† ¬† let cellClass = 'grid-cell';
¬† ¬† ¬† ¬† ¬† ¬† if (isTemplateEditor) cellClass += ' template-cell';
¬† ¬† ¬† ¬† ¬† ¬† let cellContent = '';
¬† ¬† ¬† ¬† ¬† ¬† let dataAttrs = `data-day="${day}" data-period="${period}" data-cell-key="${cellKey}"`;
¬† ¬† ¬† ¬† ¬† ¬† let style = `grid-row: ${period + 1}; grid-column: ${day + 1};`;
¬† ¬† ¬† ¬† ¬† ¬† const span = blockSpans.get(cellKey);
¬† ¬† ¬† ¬† ¬† ¬† if (span) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† style += `grid-row: ${period + 1} / span ${span};`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† cellClass += ' block-start';
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† if (subs.length > 0) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† cellClass += ' has-substitution';
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† dataAttrs += ` draggable="true"`; 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† subs.forEach(sub => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (!dataAttrs.includes('data-substitution-id')) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† dataAttrs += ` data-substitution-id="${sub.substitution_id}"`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const typeClass = `substitution-${sub.substitution_type.toLowerCase()}`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (!cellClass.includes(typeClass)) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† cellClass += ` ${typeClass}`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† cellContent += createSubstitutionElement(sub, state).outerHTML;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† } else if (entries.length > 0) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† cellClass += ' has-entry';
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† dataAttrs += ` draggable="true"`; 
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† entries.forEach(entry => {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (isTemplateEditor) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (!dataAttrs.includes('data-template-entry-id')) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† dataAttrs += ` data-template-entry-id="${entry.template_entry_id}"`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (entry.block_ref) dataAttrs += ` data-block-id="${entry.block_ref}"`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (!dataAttrs.includes('data-entry-id')) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† dataAttrs += ` data-entry-id="${entry.entry_id}"`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (entry.block_id) dataAttrs += ` data-block-id="${entry.block_id}"`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† cellContent += createTimetableElement(entry, isTemplateEditor, state).outerHTML;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† cellClass += ' is-empty';
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (!isTemplateEditor && (period === startHour || period === endHour)) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† cellClass += ' default-entry';
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† cellContent = `<div class="planner-entry default-entry" style="pointer-events: none;"><strong>FU</strong></div>`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† cellContent = `<span class="sr-only">Kein Eintrag f√ºr ${days[day-1]}, ${period}. Stunde</span>`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† gridHTML += `<div class="${cellClass}" ${dataAttrs} style="${style}">
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <div class="cell-entries-container">${cellContent}</div>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† </div>`;
¬† ¬† ¬† ¬† }
¬† ¬† }
¬† ¬† grid.innerHTML = gridHTML;
¬† ¬† container.innerHTML = '';
¬† ¬† container.appendChild(grid);
}
function createTimetableElement(entry, isTemplateEditor = false, state) {
¬† ¬† const entryElement = document.createElement('div');
¬† ¬† entryElement.className = 'planner-entry timetable-entry';
¬† ¬† if (isTemplateEditor) {
¬† ¬† ¬† ¬† entryElement.dataset.templateEntryId = entry.template_entry_id; 
¬† ¬† ¬† ¬† if (entry.block_ref) {
¬† ¬† ¬† ¬† ¬† ¬† entryElement.dataset.blockId = entry.block_ref; 
¬† ¬† ¬† ¬† }
¬† ¬† } else {
¬† ¬† ¬† ¬† entryElement.dataset.entryId = entry.entry_id;
¬† ¬† ¬† ¬† if (entry.block_id) {
¬† ¬† ¬† ¬† ¬† ¬† entryElement.dataset.blockId = entry.block_id;
¬† ¬† ¬† ¬† }
¬† ¬† }
¬† ¬† const isTeacherView = state.currentViewMode === 'teacher';
¬† ¬† const stammdaten = state.stammdaten || {};
¬† ¬† let subjectShortcut, teacherShortcut, roomName, className;
¬† ¬† if (isTemplateEditor) {
¬† ¬† ¬† ¬† subjectShortcut = (stammdaten.subjects?.find(s => s.subject_id == entry.subject_id) || {}).subject_shortcut || 'F?';
¬† ¬† ¬† ¬† teacherShortcut = (stammdaten.teachers?.find(t => t.teacher_id == entry.teacher_id) || {}).teacher_shortcut || 'L?';
¬† ¬† ¬† ¬† roomName = (stammdaten.rooms?.find(r => r.room_id == entry.room_id) || {}).room_name || 'R?';
¬† ¬† ¬† ¬† className = (stammdaten.classes?.find(c => c.class_id == entry.class_id) || {}).class_name || 'K?';
¬† ¬† ¬† ¬† if (entry.class_id == 0) className = 'Alle'; 
¬† ¬† } else {
¬† ¬† ¬† ¬† subjectShortcut = entry.subject_shortcut || '---';
¬† ¬† ¬† ¬† teacherShortcut = entry.teacher_shortcut || '---';
¬† ¬† ¬† ¬† roomName = entry.room_name || '---';
¬† ¬† ¬† ¬† className = entry.class_name || 'N/A';
¬† ¬† }
¬† ¬† let mainHtml = '';
¬† ¬† if (isTeacherView) {
¬† ¬† ¬† ¬† const classDisplay = escapeHtml(className);
¬† ¬† ¬† ¬† if (entry.class_id && entry.class_id != 0) {
¬† ¬† ¬† ¬† ¬† ¬† mainHtml = `<div class="entry-line entry-main">${classDisplay} (ID: ${escapeHtml(entry.class_id)})</div>`;
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† mainHtml = `<div class="entry-line entry-main">${classDisplay}</div>`;
¬† ¬† ¬† ¬† }
¬† ¬† } else {
¬† ¬† ¬† ¬† mainHtml = `<div class="entry-line entry-main">${escapeHtml(teacherShortcut)}</div>`;
¬† ¬† }
¬† ¬† entryElement.innerHTML = `
¬† ¬† ¬† ¬† <div class="entry-line entry-subject">${escapeHtml(subjectShortcut)}</div>
¬† ¬† ¬† ¬† ${mainHtml}
¬† ¬† ¬† ¬† <div class="entry-line entry-room">${escapeHtml(roomName)}</div>
¬† ¬† `;
¬† ¬† if (entry.comment) {
¬† ¬† ¬† ¬† entryElement.classList.add('has-comment');
¬† ¬† ¬† ¬† entryElement.title = `Kommentar: ${escapeHtml(entry.comment)}`;
¬† ¬† }
¬† ¬† if (!isTemplateEditor && entry.teacher_id && state.stammdaten.absences && state.stammdaten.absences.length > 0) {
¬† ¬† ¬† ¬† let entryDate;
¬† ¬† ¬† ¬† try {
¬† ¬† ¬† ¬† ¬† ¬† const dto = new Date();
¬† ¬† ¬† ¬† ¬† ¬† dto.setUTCFullYear(state.selectedYear);
¬† ¬† ¬† ¬† ¬† ¬† dto.setUTCMonth(0); 
¬† ¬† ¬† ¬† ¬† ¬† dto.setUTCDate(1); 
¬† ¬† ¬† ¬† ¬† ¬† let dayOfWeek = dto.getUTCDay();
¬† ¬† ¬† ¬† ¬† ¬† let firstMonday = (dayOfWeek <= 1) ? (2 - dayOfWeek) : (9 - dayOfWeek);
¬† ¬† ¬† ¬† ¬† ¬† dto.setUTCDate(firstMonday);
¬† ¬† ¬† ¬† ¬† ¬† dto.setUTCDate(dto.getUTCDate() + (state.selectedWeek - 1) * 7);
¬† ¬† ¬† ¬† ¬† ¬† dto.setUTCDate(dto.getUTCDate() + (entry.day_of_week - 1));
¬† ¬† ¬† ¬† ¬† ¬† entryDate = dto.toISOString().split('T')[0];
¬† ¬† ¬† ¬† } catch(e) {
¬† ¬† ¬† ¬† ¬† ¬† console.error("Datumsberechnung fehlgeschlagen", e);
¬† ¬† ¬† ¬† ¬† ¬† entryDate = null;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† if(entryDate) {
¬† ¬† ¬† ¬† ¬† ¬† const absence = isTeacherAbsent(entry.teacher_id, entryDate, state); 
¬† ¬† ¬† ¬† ¬† ¬† if (absence) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† entryElement.classList.add('is-absent');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const warning = document.createElement('small');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† warning.className = 'absence-warning';
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† warning.textContent = `(Lehrer abwesend: ${escapeHtml(absence.reason)})`;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† entryElement.appendChild(warning);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† entryElement.title = `Lehrer abwesend: ${escapeHtml(absence.reason)}`;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }
¬† ¬† }
¬† ¬† return entryElement;
}
function createSubstitutionElement(sub, state) {
¬† ¬† const entryElement = document.createElement('div');
¬† ¬† entryElement.className = `planner-entry substitution-entry ${sub.substitution_type.toLowerCase()}`;
¬† ¬† entryElement.dataset.substitutionId = sub.substitution_id;
¬† ¬† entryElement.dataset.day = sub.day_of_week;
¬† ¬† entryElement.dataset.period = sub.period_number;
¬† ¬† entryElement.dataset.date = sub.date;
¬† ¬† const originalEntry = getOriginalEntry(sub, state); 
¬† ¬† if (originalEntry) {
¬† ¬† ¬† ¬† entryElement.dataset.entryId = originalEntry.entry_id;
¬† ¬† ¬† ¬† if(originalEntry.block_id) entryElement.dataset.blockId = originalEntry.block_id;
¬† ¬† }
¬† ¬† const isTeacherView = state.currentViewMode === 'teacher';
¬† ¬† let subjectText = '---';
¬† ¬† let mainText = '---';
¬† ¬† let roomText = '---';
¬† ¬† let typeText = sub.substitution_type;
¬† ¬† let classDisplay = escapeHtml(sub.class_name || 'N/A');
¬† ¬† if (sub.class_id && sub.class_id != 0) {
¬† ¬† ¬† ¬† classDisplay += ` (ID: ${escapeHtml(sub.class_id)})`;
¬† ¬† }
¬† ¬† switch (sub.substitution_type) {
¬† ¬† ¬† ¬† case 'Vertretung':
¬† ¬† ¬† ¬† ¬† ¬† subjectText = sub.new_subject_shortcut || sub.original_subject_shortcut || '---';
¬† ¬† ¬† ¬† ¬† ¬† mainText = isTeacherView ? classDisplay : (sub.new_teacher_shortcut || '!!!');
¬† ¬† ¬† ¬† ¬† ¬† roomText = sub.new_room_name || '---';
¬† ¬† ¬† ¬† ¬† ¬† break;
¬† ¬† ¬† ¬† case 'Raum√§nderung':
¬† ¬† ¬† ¬† ¬† ¬† typeText = 'Raum'; 
¬† ¬† ¬† ¬† ¬† ¬† subjectText = sub.original_subject_shortcut || '---';
¬† ¬† ¬† ¬† ¬† ¬† mainText = isTeacherView ? classDisplay : (getOriginalTeacher(sub, state) || '---'); 
¬† ¬† ¬† ¬† ¬† ¬† roomText = sub.new_room_name || '!!!';
¬† ¬† ¬† ¬† ¬† ¬† break;
¬† ¬† ¬† ¬† case 'Entfall':
¬† ¬† ¬† ¬† ¬† ¬† subjectText = sub.original_subject_shortcut || '---';
¬† ¬† ¬† ¬† ¬† ¬† mainText = `(${isTeacherView ? classDisplay : (getOriginalTeacher(sub, state) || '---')})`; 
¬† ¬† ¬† ¬† ¬† ¬† roomText = '---';
¬† ¬† ¬† ¬† ¬† ¬† break;
¬† ¬† ¬† ¬† case 'Sonderevent':
¬† ¬† ¬† ¬† ¬† ¬† typeText = 'Event'; 
¬† ¬† ¬† ¬† ¬† ¬† subjectText = sub.new_subject_shortcut || 'EVENT';
¬† ¬† ¬† ¬† ¬† ¬† mainText = sub.comment ? (sub.comment.substring(0, 10) + '...') : 'Info';
¬† ¬† ¬† ¬† ¬† ¬† roomText = sub.new_room_name || '---';
¬† ¬† ¬† ¬† ¬† ¬† break;
¬† ¬† }
¬† ¬† entryElement.innerHTML = `
¬† ¬† ¬† ¬† <div class="entry-line sub-type">${escapeHtml(typeText)}</div>
¬† ¬† ¬† ¬† <div class="entry-line entry-subject">${escapeHtml(subjectText)}</div>
¬† ¬† ¬† ¬† <div class="entry-line entry-main">${mainText}</div> 
¬† ¬† ¬† ¬† <div class="entry-line entry-room">${escapeHtml(roomText)}</div>
¬† ¬† `;
¬† ¬† if (sub.comment && sub.substitution_type !== 'Sonderevent') {
¬† ¬† ¬† ¬† ¬†entryElement.title = `Kommentar: ${escapeHtml(sub.comment)}`;
¬† ¬† }
¬† ¬† return entryElement;
}
function isTeacherAbsent(teacherId, dateString, state) {
¬† ¬† if (!teacherId || !dateString) return null;
¬† ¬† const absences = (state.stammdaten && state.stammdaten.absences) ? state.stammdaten.absences : [];
¬† ¬† if (absences.length === 0) return null;
¬† ¬† try {
¬† ¬† ¬† ¬† const checkDate = new Date(dateString + 'T00:00:00Z');
¬† ¬† ¬† ¬† if (isNaN(checkDate.getTime())) {
¬† ¬† ¬† ¬† ¬† ¬† console.warn(`isTeacherAbsent: Ung√ºltiges Datum ${dateString}`);
¬† ¬† ¬† ¬† ¬† ¬† return null;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† for (const absence of absences) {
¬† ¬† ¬† ¬† ¬† ¬† if (absence.teacher_id == teacherId) {¬†
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const startDate = new Date(absence.start_date + 'T00:00:00Z');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const endDate = new Date(absence.end_date + 'T00:00:00Z');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† if (checkDate >= startDate && checkDate <= endDate) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return absence;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }
¬† ¬† } catch (e) {
¬† ¬† ¬† ¬† console.error("Fehler beim Pr√ºfen der Abwesenheit:", e);
¬† ¬† }
¬† ¬† return null;
}
function getOriginalEntry(sub, state) {
¬† ¬† const cellKey = `${sub.day_of_week}-${sub.period_number}`;
¬† ¬† const entries = state.timetable[cellKey] || [];
¬† ¬† const originalEntry = entries.find(e =>¬†
¬† ¬† ¬† ¬† e.class_id == sub.class_id &&¬†
¬† ¬† ¬† ¬† e.subject_id == sub.original_subject_id
¬† ¬† );
¬† ¬† return originalEntry || null;
}
function getOriginalTeacher(sub, state) {
¬† ¬† const originalEntry = getOriginalEntry(sub, state);
¬† ¬† if (originalEntry) {
¬† ¬† ¬† ¬† if (originalEntry.teacher_shortcut) {
¬† ¬† ¬† ¬† ¬† ¬† return originalEntry.teacher_shortcut;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† const teacher = (state.stammdaten.teachers || []).find(t => t.teacher_id == originalEntry.teacher_id);
¬† ¬† ¬† ¬† if (teacher) {
¬† ¬† ¬† ¬† ¬† ¬† return teacher.teacher_shortcut;
¬† ¬† ¬† ¬† }
¬† ¬† }
¬† ¬† return null; 
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-timetable.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-ui.js ---
import * as DOM from './planer-dom.js';
import { getState } from './planer-state.js';
import { escapeHtml } from './planer-utils.js';
export const populateYearSelector = (selectorElement, defaultYear) => {
¬† ¬† if (!selectorElement) return; 
¬† ¬† const currentYear = new Date().getFullYear();
¬† ¬† let options = '';
¬† ¬† for (let i = currentYear - 2; i <= currentYear + 2; i++) {
¬† ¬† ¬† ¬† options += `<option value="${i}">${i}</option>`;
¬† ¬† }
¬† ¬† selectorElement.innerHTML = options;
¬† ¬† selectorElement.value = defaultYear;
};
export const populateWeekSelector = (selectorElement, defaultWeek) => {
¬† ¬† ¬†if (!selectorElement) return; 
¬† ¬† let options = '';
¬† ¬† for (let i = 1; i <= 53; i++) {
¬† ¬† ¬† ¬† options += `<option value="${i}">KW ${i}</option>`;
¬† ¬† }
¬† ¬† selectorElement.innerHTML = options;
¬† ¬† selectorElement.value = defaultWeek;
};
export const populateClassSelector = (classes = []) => { 
¬† ¬† if (!DOM.classSelector) return; 
¬† ¬† console.log(`planer-ui: Populating class selector with ${classes.length} classes...`); 
¬† ¬† DOM.classSelector.innerHTML = '<option value="">Bitte w√§hlen...</option>' +
¬† ¬† ¬† ¬† classes.map(c => `<option value="${c.class_id}">${c.class_id} - ${escapeHtml(c.class_name)}</option>`).join(''); 
};
export const populateTeacherSelector = (teachers = []) => { 
¬† ¬† ¬†if (!DOM.teacherSelector) return; 
¬† ¬† const filteredTeachers = teachers.filter(t => t.teacher_shortcut !== 'SGL'); 
¬† ¬† console.log(`planer-ui: Populating teacher selector with ${filteredTeachers.length} teachers...`); 
¬† ¬† DOM.teacherSelector.innerHTML = '<option value="">Bitte w√§hlen...</option>' +
¬† ¬† ¬† ¬† filteredTeachers.map(t => `<option value="${t.teacher_id}">${escapeHtml(t.last_name)}, ${escapeHtml(t.first_name)} (${escapeHtml(t.teacher_shortcut)})</option>`).join(''); 
};
export const populateAllModalSelects = (stammdaten) => {
¬† ¬† ¬†if (!DOM.modal) return; 
¬† ¬† console.log("planer-ui: Populating modal selects..."); 
¬† ¬† const { subjects = [], teachers = [], rooms = [], classes = [] } = stammdaten || {}; 
¬† ¬† const subjectSelect = DOM.modal.querySelector('#subject_id');
¬† ¬† const newSubjectSelect = DOM.modal.querySelector('#new_subject_id');
¬† ¬† const teacherSelect = DOM.modal.querySelector('#teacher_id');
¬† ¬† const newTeacherSelect = DOM.modal.querySelector('#new_teacher_id');
¬† ¬† const roomSelect = DOM.modal.querySelector('#room_id');
¬† ¬† const newRoomSelect = DOM.modal.querySelector('#new_room_id');
¬† ¬† const templateClassSelect = DOM.modal.querySelector('#template_class_id');
¬† ¬† if (subjectSelect) {
¬† ¬† ¬† ¬† subjectSelect.innerHTML = subjects.map(s => `<option value="${s.subject_id}">${escapeHtml(s.subject_name)} (${escapeHtml(s.subject_shortcut)})</option>`).join('');
¬† ¬† }
¬† ¬† if (newSubjectSelect) {
¬† ¬† ¬† ¬† newSubjectSelect.innerHTML = '<option value="">(wie Original)</option>' + subjects.map(s => `<option value="${s.subject_id}">${escapeHtml(s.subject_name)} (${escapeHtml(s.subject_shortcut)})</option>`).join('');
¬† ¬† }
¬† ¬† const filteredTeachers = teachers.filter(t => t.teacher_shortcut !== 'SGL');
¬† ¬† const teacherOptions = filteredTeachers.map(t => `<option value="${t.teacher_id}">${escapeHtml(t.first_name)} ${escapeHtml(t.last_name)}</option>`).join('');
¬† ¬† if (teacherSelect) {
¬† ¬† ¬† ¬† teacherSelect.innerHTML = teacherOptions;
¬† ¬† }
¬† ¬† if (newTeacherSelect) {
¬† ¬† ¬† ¬† newTeacherSelect.innerHTML = '<option value="">(kein Lehrer)</option>' + teacherOptions;
¬† ¬† }
¬† ¬† const roomOptions = rooms.map(r => `<option value="${r.room_id}">${escapeHtml(r.room_name)}</option>`).join('');
¬† ¬† if (roomSelect) {
¬† ¬† ¬† ¬† roomSelect.innerHTML = roomOptions;
¬† ¬† }
¬† ¬† if (newRoomSelect) {
¬† ¬† ¬† ¬† newRoomSelect.innerHTML = '<option value="">(kein Raum)</option>' + roomOptions;
¬† ¬† }
¬† ¬† if (templateClassSelect) {
¬† ¬† ¬† ¬† templateClassSelect.innerHTML = '<option value="0">(Keine Klasse)</option>' + classes.map(c => `<option value="${c.class_id}">${escapeHtml(c.class_name)}</option>`).join('');
¬† ¬† }
};
export const populateTemplateSelects = (templates = []) => { 
¬† ¬† ¬†if (!DOM.applyTemplateSelect) return; 
¬† ¬† ¬†console.log(`planer-ui: Populating template select with ${templates.length} templates...`); 
¬† ¬† DOM.applyTemplateSelect.innerHTML = templates.length > 0
¬† ¬† ¬† ¬† ? '<option value="">-- Vorlage w√§hlen --</option>' + templates.map(t => `<option value="${t.template_id}">${escapeHtml(t.name)}</option>`).join('')
¬† ¬† ¬† ¬† : '<option value="">Keine Vorlagen verf√ºgbar</option>';
};
export const updatePublishControls = (status = { student: false, teacher: false }) => { 
¬† ¬† if (DOM.publishWeekLabel) DOM.publishWeekLabel.textContent = DOM.weekSelector?.value || '--'; 
¬† ¬† if (DOM.publishStatusStudent) {
¬† ¬† ¬† ¬† DOM.publishStatusStudent.textContent = status.student ? 'Sch√ºler: Ver√∂ffentlicht' : 'Sch√ºler: Nicht ver√∂ffentlicht';
¬† ¬† ¬† ¬† DOM.publishStatusStudent.classList.toggle('published', !!status.student);
¬† ¬† ¬† ¬† DOM.publishStatusStudent.classList.toggle('not-published', !status.student);
¬† ¬† }
¬† ¬† ¬†if (DOM.publishStudentBtn) DOM.publishStudentBtn.classList.toggle('hidden', !!status.student);
¬† ¬† ¬†if (DOM.unpublishStudentBtn) DOM.unpublishStudentBtn.classList.toggle('hidden', !status.student);
¬† ¬† if (DOM.publishStatusTeacher) {
¬† ¬† ¬† ¬† DOM.publishStatusTeacher.textContent = status.teacher ? 'Lehrer: Ver√∂ffentlicht' : 'Lehrer: Nicht ver√∂ffentlicht';
¬† ¬† ¬† ¬† DOM.publishStatusTeacher.classList.toggle('published', !!status.teacher);
¬† ¬† ¬† ¬† DOM.publishStatusTeacher.classList.toggle('not-published', !status.teacher);
¬† ¬† }
¬† ¬† ¬†if (DOM.publishTeacherBtn) DOM.publishTeacherBtn.classList.toggle('hidden', !!status.teacher);
¬† ¬† ¬†if (DOM.unpublishTeacherBtn) DOM.unpublishTeacherBtn.classList.toggle('hidden', !status.teacher);
¬† ¬† const isValidWeek = DOM.yearSelector?.value && DOM.weekSelector?.value;
¬† ¬† ¬†if (DOM.publishStudentBtn) DOM.publishStudentBtn.disabled = !isValidWeek;
¬† ¬† ¬†if (DOM.publishTeacherBtn) DOM.publishTeacherBtn.disabled = !isValidWeek;
¬† ¬† ¬†if (DOM.unpublishStudentBtn) DOM.unpublishStudentBtn.disabled = !isValidWeek;
¬† ¬† ¬†if (DOM.unpublishTeacherBtn) DOM.unpublishTeacherBtn.disabled = !isValidWeek;
};
export const showConflicts = (conflictMessages = []) => { 
¬† ¬† if (DOM.conflictWarningBox) {
¬† ¬† ¬† ¬† DOM.conflictWarningBox.innerHTML = conflictMessages.map(msg => `<div>${escapeHtml(msg)}</div>`).join('');
¬† ¬† ¬† ¬† DOM.conflictWarningBox.style.display = 'block';
¬† ¬† }
¬† ¬† if (DOM.saveButton) {
¬† ¬† ¬† ¬† DOM.saveButton.disabled = true;
¬† ¬† ¬† ¬† DOM.saveButton.style.opacity = '0.5';
¬† ¬† ¬† ¬† DOM.saveButton.style.cursor = 'not-allowed';
¬† ¬† }
};
export const hideConflicts = () => {
¬† ¬† if (DOM.conflictWarningBox) {
¬† ¬† ¬† ¬† DOM.conflictWarningBox.innerHTML = '';
¬† ¬† ¬† ¬† DOM.conflictWarningBox.style.display = 'none';
¬† ¬† }
¬† ¬† if (DOM.saveButton) {
¬† ¬† ¬† ¬† DOM.saveButton.disabled = false;
¬† ¬† ¬† ¬† DOM.saveButton.style.opacity = '1';
¬† ¬† ¬† ¬† DOM.saveButton.style.cursor = 'pointer';
¬† ¬† }
};
export const showTemplateView = (viewType) => {
¬† ¬† ¬†if (!DOM.templateListView || !DOM.templateEditorView || !DOM.manageTemplatesModal) return;
¬† ¬† if (viewType === 'editor') {
¬† ¬† ¬† ¬† DOM.templateListView.style.display = 'none';
¬† ¬† ¬† ¬† DOM.templateEditorView.style.display = 'flex'; 
¬† ¬† ¬† ¬† if (DOM.templateEditorTitle) DOM.templateEditorTitle.textContent = "Neue leere Vorlage erstellen"; 
¬† ¬† ¬† ¬† const nameInput = DOM.manageTemplatesModal.querySelector('#template-editor-name');
¬† ¬† ¬† ¬† if (nameInput) nameInput.focus(); 
¬† ¬† } else { 
¬† ¬† ¬† ¬† DOM.templateListView.style.display = 'flex'; 
¬† ¬† ¬† ¬† DOM.templateEditorView.style.display = 'none';
¬† ¬† }
};
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-ui.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-utils.js ---
export function getWeekAndYear(date) {
¬† ¬† const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
¬† ¬† d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
¬† ¬† const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
¬† ¬† const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
¬† ¬† return { week: weekNo, year: d.getUTCFullYear() };
}
export function getDateOfISOWeek(week, year) {
¬† ¬† const simple = new Date(Date.UTC(year, 0, 1 + (week - 1) * 7));
¬† ¬† const dow = simple.getUTCDay(); 
¬† ¬† const ISOweekStart = simple;
¬† ¬† ISOweekStart.setUTCDate(simple.getUTCDate() - (dow || 7) + 1);
¬† ¬† return new Date(ISOweekStart.getFullYear(), ISOweekStart.getMonth(), ISOweekStart.getDate());
}
export function getDateForDayInWeek(dayNum, year, week) {
¬† ¬† const monday = getDateOfISOWeek(week, year);
¬† ¬† const targetDate = new Date(monday.getTime() + (dayNum - 1) * 24 * 60 * 60 * 1000);
¬† ¬† const yyyy = targetDate.getFullYear();
¬† ¬† const mm = String(targetDate.getMonth() + 1).padStart(2, '0');
¬† ¬† const dd = String(targetDate.getDate()).padStart(2, '0');
¬† ¬† return `${yyyy}-${mm}-${dd}`;
}
export function escapeHtml(unsafe) {
¬† ¬† if (!unsafe) return '';
¬† ¬† return String(unsafe)
¬† ¬† ¬† ¬† ¬†.replace(/&/g, "&amp;")
¬† ¬† ¬† ¬† ¬†.replace(/</g, "&lt;")
¬† ¬† ¬† ¬† ¬†.replace(/>/g, "&gt;")
¬† ¬† ¬† ¬† ¬†.replace(/"/g, "&quot;")
¬† ¬† ¬† ¬† ¬†.replace(/'/g, "&#039;");
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-utils.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\teacher-cockpit.js ---
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js';

function escapeHtml(unsafe) {
    if (!unsafe) return '';
    return String(unsafe)
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}

function formatShortTime(timeString) {
    if (!timeString) return '';
    const parts = timeString.split(':');
    if (parts.length >= 2) {
        return `${parts[0]}:${parts[1]}`;
    }
    return timeString; 
}

function formatDayOfWeek(dayNum) {
    const days = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag'];
    const index = parseInt(dayNum, 10) - 1;
    return days[index] || 'Unbekannt';
}

function formatGermanDate(dateString) {
    if (!dateString) return '';
    try {
        const parts = dateString.split('-');
        if (parts.length === 3) {
            return `${parts[2]}.${parts[1]}.${parts[0]}`;
        }
        return dateString;
    } catch(e) {
        return dateString;
    }
}

let attendanceController = null;

export function initializeTeacherCockpit() {
    const cockpit = document.getElementById('teacher-cockpit');
    if (!cockpit || window.APP_CONFIG.userRole !== 'lehrer') {
        return; 
    }

    // --- Kollegensuche ---
    const searchInput = document.getElementById('colleague-search-input');
    const searchResults = document.getElementById('colleague-search-results');
    const resultDisplay = document.getElementById('colleague-result-display');
    const resultSpinner = resultDisplay.querySelector('.loading-spinner');
    const resultParagraph = resultDisplay.querySelector('p');
    const findColleagueFeature = document.getElementById('find-colleague-feature');
    
    let searchTimeout;
    let selectedTeacherId = null;

    const handleSearchInput = () => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(async () => {
            const query = searchInput.value.trim();
            if (query.length < 2) {
                searchResults.innerHTML = '';
                searchResults.classList.remove('visible');
                return;
            }
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/search-colleagues?query=${encodeURIComponent(query)}`);
                if (response.success && response.data) {
                    const filteredTeachers = response.data.filter(t => t.teacher_shortcut !== 'SGL');
                    if (filteredTeachers.length > 0) {
                        searchResults.innerHTML = filteredTeachers.map(teacher => `
                            <div class="search-result-item" data-id="${teacher.teacher_id}" data-name="${escapeHtml(teacher.first_name)} ${escapeHtml(teacher.last_name)} (${escapeHtml(teacher.teacher_shortcut)})">
                                <strong>${escapeHtml(teacher.last_name)}, ${escapeHtml(teacher.first_name)}</strong> (${escapeHtml(teacher.teacher_shortcut)})
                            </div>
                        `).join('');
                        searchResults.classList.add('visible');
                    } else {
                        searchResults.innerHTML = '<div class="search-result-item none">Keine Treffer</div>';
                        searchResults.classList.add('visible');
                    }
                } else {
                    searchResults.innerHTML = '<div class="search-result-item none">Keine Treffer</div>';
                    searchResults.classList.add('visible');
                }
            } catch (error) {
                console.error("Fehler bei Lehrersuche:", error);
                searchResults.innerHTML = `<div class="search-result-item none">Fehler: ${escapeHtml(error.message)}</div>`;
                searchResults.classList.add('visible');
            }
        }, 300); 
    };

    const handleResultClick = async (e) => {
        const item = e.target.closest('.search-result-item');
        if (!item || !item.dataset.id) return;
        
        selectedTeacherId = item.dataset.id;
        const selectedName = item.dataset.name;
        
        searchInput.value = selectedName; 
        searchResults.innerHTML = ''; 
        searchResults.classList.remove('visible');

        resultDisplay.style.display = 'flex';
        if(resultSpinner) resultSpinner.style.display = 'block';
        if(resultParagraph) resultParagraph.innerHTML = `Suche nach ${escapeHtml(selectedName)}...`;

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/find-colleague?teacher_id=${selectedTeacherId}`);
            if (response.success) {
                if(resultParagraph) resultParagraph.innerHTML = `
                    <strong>${escapeHtml(selectedName)}:</strong><br>
                    ${escapeHtml(response.data.message)}
                `;
            } else {
                throw new Error(response.message);
            }
        } catch (error) {
            console.error("Fehler bei Standortabfrage:", error);
            if(resultParagraph) resultParagraph.innerHTML = `<span class="text-danger">Fehler: ${escapeHtml(error.message)}</span>`;
        } finally {
            if(resultSpinner) resultSpinner.style.display = 'none';
        }
    };

    if (searchInput && searchResults && resultDisplay && findColleagueFeature) {
        searchInput.addEventListener('input', handleSearchInput);
        searchResults.addEventListener('click', handleResultClick);
        
        document.addEventListener('click', (e) => {
            if (!findColleagueFeature.contains(e.target)) {
                searchResults.classList.remove('visible');
            }
        });
    }

    // --- Anwesenheit ---
    const attendanceContainer = document.getElementById('attendance-feature');
    if (attendanceContainer) {
        attendanceController = new AttendanceController(attendanceContainer);
        attendanceController.loadCurrentLesson();
    }

    // --- Aufgaben & Klausuren ---
    const eventsContainer = document.getElementById('academic-events-feature');
    if (eventsContainer) {
        const eventsController = new AcademicEventsController(eventsContainer);
        eventsController.initialize();
    }
    
    // --- Sprechzeiten ---
    const officeHoursContainer = document.getElementById('office-hours-feature');
    if (officeHoursContainer) {
        const officeHoursController = new OfficeHoursController(officeHoursContainer);
        officeHoursController.initialize();
    }
}

class AttendanceController {
    constructor(containerElement) {
        this.container = containerElement;
        this.lessonDisplay = document.getElementById('attendance-current-lesson');
        this.listContainer = document.getElementById('attendance-list-container');
        this.studentList = document.getElementById('attendance-student-list');
        this.saveButton = document.getElementById('save-attendance-btn');
        this.saveSpinner = document.getElementById('attendance-save-spinner');
        this.saveContext = null; 
        this.bindEvents();
    }

    bindEvents() {
        if (this.saveButton) {
            this.saveButton.addEventListener('click', () => this.handleSaveAttendance());
        }
        if (this.studentList) {
            this.studentList.addEventListener('click', (e) => {
                const button = e.target.closest('.btn-toggle');
                if (!button) return;
                const li = button.closest('.student-row');
                if (!li) return;

                const newStatus = button.dataset.status;
                li.dataset.status = newStatus;
                
                li.querySelectorAll('.btn-toggle').forEach(btn => {
                    btn.classList.remove('active');
                });
                button.classList.add('active');
            });
        }
    }

    async loadCurrentLesson() {
        if (!this.lessonDisplay || !this.listContainer) return;
        this.lessonDisplay.innerHTML = '<div class="loading-spinner small"></div><p>Pr√ºfe aktuelle Stunde...</p>';
        this.listContainer.style.display = 'none';

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/current-lesson`);
            if (!response.success) throw new Error(response.message);

            const { status, lesson, students, attendance, context } = response.data;
            
            if (status === 'Unterricht' || status === 'Vertretung') {
                this.lessonDisplay.innerHTML = `
                    <p class="lesson-info">
                        Aktuelle Stunde: <strong>${escapeHtml(lesson.class_name)} (${escapeHtml(lesson.subject_shortcut || lesson.new_subject_shortcut || '?')})</strong>
                        in Raum <strong>${escapeHtml(lesson.room_name || lesson.new_room_name || '?')}</strong>
                        (${status === 'Vertretung' ? 'Vertretung' : 'Regul√§r'})
                    </p>
                `;
                this.renderStudentList(students, attendance);
                this.listContainer.style.display = 'block';
                this.saveContext = {
                    class_id: lesson.class_id,
                    date: context.date,
                    period_number: context.period
                };
            } else if (status === 'Freistunde') {
                this.lessonDisplay.innerHTML = '<p class="message info" style="margin: 0; padding: 0; background: transparent; border: none;">Sie haben jetzt eine Freistunde.</p>';
            } else {
                this.lessonDisplay.innerHTML = '<p class="message info" style="margin: 0; padding: 0; background: transparent; border: none;">Aktuell findet kein Unterricht statt.</p>';
            }

        } catch (error) {
            console.error("Fehler beim Laden der aktuellen Stunde:", error);
            this.lessonDisplay.innerHTML = `<p class="message error">Fehler: ${escapeHtml(error.message)}</p>`;
        }
    }

    renderStudentList(students, attendance) {
        if (!students || students.length === 0) {
            this.studentList.innerHTML = '<li>Keine Sch√ºler f√ºr diese Klasse gefunden.</li>';
            this.saveButton.disabled = true;
            return;
        }

        this.studentList.innerHTML = students.map(student => {
            const currentStatus = attendance[student.user_id] || 'anwesend'; 
            return `
                <li class="student-row" data-student-id="${student.user_id}" data-status="${currentStatus}">
                    <span class="student-name">${escapeHtml(student.last_name)}, ${escapeHtml(student.first_name)}</span>
                    <div class="attendance-toggles">
                        <button class="btn-toggle status-anwesend ${currentStatus === 'anwesend' ? 'active' : ''}" data-status="anwesend">A</button>
                        <button class="btn-toggle status-abwesend ${currentStatus === 'abwesend' ? 'active' : ''}" data-status="abwesend">F</button>
                        <button class="btn-toggle status-verspaetet ${currentStatus === 'verspaetet' ? 'active' : ''}" data-status="verspaetet">V</button>
                    </div>
                </li>
            `;
        }).join('');
        this.saveButton.disabled = false;
    }

    async handleSaveAttendance() {
        if (!this.saveContext) {
            showToast("Fehler: Keine Stundendaten zum Speichern vorhanden.", "error");
            return;
        }

        this.saveButton.disabled = true;
        this.saveSpinner.style.display = 'block';

        const studentsStatus = [];
        this.studentList.querySelectorAll('.student-row').forEach(row => {
            studentsStatus.push({
                student_id: row.dataset.studentId,
                status: row.dataset.status
            });
        });

        const body = {
            ...this.saveContext,
            students: studentsStatus
        };

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/attendance/save`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            if (response.success) {
                showToast(response.message, 'success');
            }
        } catch (error) {
            console.error("Fehler beim Speichern der Anwesenheit:", error);
        } finally {
            this.saveButton.disabled = false;
            this.saveSpinner.style.display = 'none';
        }
    }
}

class AcademicEventsController {
    constructor(containerElement) {
        this.container = containerElement;
        this.form = document.getElementById('academic-event-form');
        this.classSelect = document.getElementById('event-class-id');
        this.subjectSelect = document.getElementById('event-subject-id');
        this.eventList = document.getElementById('teacher-event-list');
        this.saveButton = document.getElementById('save-event-btn');
        this.saveSpinner = document.getElementById('event-save-spinner');
        this.teacherClasses = [];
        this.allSubjects = [];
    }

    async initialize() {
        if (!this.form) return;
        this.bindEvents();
        await this.loadPrerequisites();
        await this.loadTeacherEvents();
    }

    bindEvents() {
        this.form.addEventListener('submit', (e) => this.handleSaveEvent(e));
        this.eventList.addEventListener('click', (e) => {
            const deleteButton = e.target.closest('.delete-event-btn');
            if (deleteButton) {
                const eventId = deleteButton.dataset.eventId;
                const eventTitle = deleteButton.dataset.eventTitle;
                this.handleDeleteEvent(eventId, eventTitle);
            }
        });
    }

    async loadPrerequisites() {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/prerequisites`);
            if (response.success && response.data) {
                this.allSubjects = response.data.subjects || [];
                this.teacherClasses = response.data.classes || [];

                this.subjectSelect.innerHTML = '<option value="">Kein Fach</option>' + 
                    this.allSubjects.map(s => 
                        `<option value="${s.subject_id}">${escapeHtml(s.subject_name)} (${escapeHtml(s.subject_shortcut)})</option>`
                    ).join('');

                if (this.teacherClasses.length > 0) {
                    this.classSelect.innerHTML = '<option value="">-- Klasse w√§hlen --</option>' + 
                        this.teacherClasses.map(c => 
                            `<option value="${c.class_id}">${escapeHtml(c.class_name)} (ID: ${c.class_id})</option>`
                        ).join('');
                } else {
                    this.classSelect.innerHTML = '<option value="">Keine Klassen gefunden</option>';
                    this.form.querySelector('button[type="submit"]').disabled = true;
                    showToast("Es wurden keine Klassen gefunden, die Sie unterrichten.", "info", 5000);
                }
            } else {
                throw new Error(response.message || "Stammdaten konnten nicht geladen werden.");
            }
        } catch (error) {
            console.error("Fehler beim Laden der Voraussetzungen f√ºr Events:", error);
            this.classSelect.innerHTML = '<option value="">Fehler</option>';
            this.subjectSelect.innerHTML = '<option value="">Fehler</option>';
            showToast(`Fehler beim Laden der Klassen/F√§cher: ${error.message}`, 'error');
        }
    }

    async loadTeacherEvents() {
        this.eventList.innerHTML = '<div class="loading-spinner small"></div>';
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/events`);
            if (response.success && response.data) {
                this.renderEventList(response.data);
            } else {
                throw new Error(response.message || "Events konnten nicht geladen werden.");
            }
        } catch (error) {
            console.error("Fehler beim Laden der Lehrer-Events:", error);
            this.eventList.innerHTML = `<p class="message error small">${escapeHtml(error.message)}</p>`;
        }
    }

    renderEventList(events) {
        if (events.length === 0) {
            this.eventList.innerHTML = '<p class="message info small" style="margin: 10px;">Keine Eintr√§ge f√ºr die n√§chsten 14 Tage gefunden.</p>';
            return;
        }

        const groups = events.reduce((acc, event) => {
            const date = event.due_date;
            if (!acc[date]) {
                acc[date] = [];
            }
            acc[date].push(event);
            return acc;
        }, {});

        let html = '';
        const sortedDates = Object.keys(groups).sort();
        
        for (const date of sortedDates) {
            html += `<div class="event-group">
                        <div class="event-group-date">${escapeHtml(formatGermanDate(date))}</div>
                        <ul class="event-list-items">`;
            
            groups[date].forEach(event => {
                let icon = '‚ÑπÔ∏è'; 
                if (event.event_type === 'klausur') icon = 'üéì'; 
                if (event.event_type === 'aufgabe') icon = 'üìö'; 
                html += `
                    <li class="event-list-item type-${escapeHtml(event.event_type)}" data-event-id="${event.event_id}">
                        <span class="event-icon">${icon}</span>
                        <div class="event-details">
                            <strong>${escapeHtml(event.title)}</strong>
                            <span>
                                ${escapeHtml(event.class_name)} 
                                ${event.subject_shortcut ? `(${escapeHtml(event.subject_shortcut)})` : ''}
                            </span>
                            ${event.description ? `<small>${escapeHtml(event.description)}</small>` : ''}
                        </div>
                        <button class="btn btn-danger btn-small delete-event-btn" 
                                title="Eintrag l√∂schen"
                                data-event-id="${event.event_id}" 
                                data-event-title="${escapeHtml(event.title)}">
                            &times;
                        </button>
                    </li>
                `;
            });
            html += `</ul></div>`;
        }
        this.eventList.innerHTML = html;
    }

    async handleSaveEvent(e) {
        e.preventDefault();
        this.saveButton.disabled = true;
        this.saveSpinner.style.display = 'block';
        
        const formData = new FormData(this.form);
        const data = Object.fromEntries(formData.entries());

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/events/create`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            
            if (response.success) {
                showToast(response.message, 'success');
                this.form.reset();
                this.loadTeacherEvents();
            }
        } catch (error) {
            console.error("Fehler beim Speichern des Events:", error);
        } finally {
            this.saveButton.disabled = false;
            this.saveSpinner.style.display = 'none';
        }
    }

    async handleDeleteEvent(eventId, eventTitle) {
        if (!eventId) return;

        if (await showConfirm("Eintrag l√∂schen", `M√∂chten Sie den Eintrag "${eventTitle}" wirklich l√∂schen?`)) {
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/events/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ event_id: eventId })
                });

                if (response.success) {
                    showToast(response.message, 'success');
                    this.loadTeacherEvents();
                }
            } catch (error) {
                console.error("Fehler beim L√∂schen des Events:", error);
            }
        }
    }
}

class OfficeHoursController {
    constructor(containerElement) {
        this.container = containerElement;
        this.form = document.getElementById('office-hours-form');
        this.listContainer = document.getElementById('teacher-office-hours-list');
        this.saveButton = document.getElementById('save-office-hours-btn');
        this.saveSpinner = document.getElementById('office-hours-save-spinner');
        
        // NEU: Elemente f√ºr den "Gebucht"-Tab
        this.innerTabButtons = this.container.querySelectorAll('.inner-tabs .tab-button');
        this.innerTabContents = this.container.querySelectorAll('.inner-tab-content .dashboard-section');
        this.bookedListContainer = document.getElementById('booked-appointments-list-container');
        this.bookedCountSpan = document.getElementById('booked-appointments-count');
        this.bookedListLoaded = false;
    }

    async initialize() {
        if (!this.form) return;
        this.bindEvents();
        await this.loadOfficeHours();
    }

    bindEvents() {
        this.form.addEventListener('submit', (e) => this.handleSave(e));
        
        this.listContainer.addEventListener('click', (e) => {
            const deleteButton = e.target.closest('.delete-office-hour-btn');
            if (deleteButton) {
                const availabilityId = deleteButton.dataset.id;
                this.handleDelete(availabilityId);
            }
        });

        // NEU: Tab-Logik binden
        this.innerTabButtons.forEach(button => {
            button.addEventListener('click', () => this.handleInnerTabClick(button));
        });

        // NEU: Klick-Handler f√ºr Stornieren-Buttons in der "Gebucht"-Liste
        this.bookedListContainer.addEventListener('click', (e) => {
            const cancelButton = e.target.closest('.cancel-appointment-btn');
            if (cancelButton) {
                const appointmentId = cancelButton.dataset.id;
                const item = cancelButton.closest('.booked-appointment-item');
                const title = item ? item.querySelector('.appointment-student-name').textContent : 'diesen Termin';
                this.handleCancelBookedAppointment(appointmentId, title, item);
            }
        });
    }

    // NEU: Logik zum Umschalten der inneren Tabs
    handleInnerTabClick(button) {
        this.innerTabButtons.forEach(btn => btn.classList.remove('active'));
        this.innerTabContents.forEach(content => content.classList.remove('active'));
        
        button.classList.add('active');
        const targetId = button.dataset.target;
        const targetContent = document.getElementById(targetId);
        
        if (targetContent) {
            targetContent.classList.add('active');
        }

        // Lade die gebuchten Termine, wenn der Tab zum ersten Mal aktiviert wird
        if (targetId === 'office-hours-booked-view' && !this.bookedListLoaded) {
            this.loadBookedAppointments();
        }
    }

    async loadOfficeHours() {
        this.listContainer.innerHTML = '<div class="loading-spinner small"></div>';
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/office-hours`);
            if (response.success && response.data) {
                this.renderList(response.data);
            } else {
                throw new Error(response.message || "Sprechzeiten konnten nicht geladen werden.");
            }
        } catch (error) {
            console.error("Fehler beim Laden der Sprechzeiten:", error);
            this.listContainer.innerHTML = `<p class="message error small">${escapeHtml(error.message)}</p>`;
        }
    }

    // NEU: L√§dt die gebuchten Termine
    async loadBookedAppointments() {
        if (this.bookedListLoaded) return; 
        this.bookedListLoaded = true; // Verhindert doppeltes Laden
        this.bookedListContainer.innerHTML = '<div class="loading-spinner"></div>';
        
        try {
            // API-Endpunkt (sortiert nach 'ASC' f√ºr Zukunft)
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/all-appointments?sort=ASC`);
            
            if (response.success && response.data) {
                // Die API gibt 'future' und 'past' zur√ºck. Wir wollen nur 'future'.
                const futureAppointments = response.data.future || [];
                this.renderBookedAppointmentsList(futureAppointments);
            } else {
                throw new Error(response.message || "Gebuchte Termine konnten nicht geladen werden.");
            }
        } catch (error) {
            console.error("Fehler beim Laden der gebuchten Termine:", error);
            this.bookedListContainer.innerHTML = `<p class="message error">${escapeHtml(error.message)}</p>`;
            this.bookedListLoaded = false; // Erlaube erneuten Ladeversuch
        }
    }

    renderList(availabilities) {
        if (availabilities.length === 0) {
            this.listContainer.innerHTML = '<p class="message info small" style="margin: 0; text-align: center;">Keine Sprechzeitenfenster definiert.</p>';
            return;
        }

        this.listContainer.innerHTML = availabilities.map(av => `
            <div class="office-hour-item" data-id="${av.availability_id}">
                <div class="office-hour-details">
                    <span class="office-hour-day-badge">${escapeHtml(formatDayOfWeek(av.day_of_week).substring(0, 2))}</span>
                    <div class="office-hour-time-info">
                        <strong>${escapeHtml(formatShortTime(av.start_time))} - ${escapeHtml(formatShortTime(av.end_time))} Uhr</strong>
                        <span>${escapeHtml(av.location)} ‚Ä¢ (${escapeHtml(av.slot_duration)} Min. Slots)</span>
                    </div>
                </div>
                <button class="btn btn-danger btn-small delete-office-hour-btn" 
                        title="Fenster l√∂schen" 
                        data-id="${av.availability_id}">
                    &times;
                </button>
            </div>
        `).join('');
    }

    // NEU: Rendert die Liste der gebuchten Termine
    renderBookedAppointmentsList(appointments) {
        if (this.bookedCountSpan) {
            this.bookedCountSpan.textContent = `(${appointments.length})`;
        }

        if (appointments.length === 0) {
            this.bookedListContainer.innerHTML = '<p class="message info" style="margin: 0; text-align: center;">Keine zuk√ºnftigen Termine gebucht.</p>';
            return;
        }

        // Wir zeigen nur zuk√ºnftige Termine an. Die API liefert bereits vorsortiert (ASC).
        const now = new Date();
        // Setzt die Zeit auf Mitternacht, um heutige Termine einzuschlie√üen
        now.setHours(0, 0, 0, 0); 
        
        const futureAppointments = appointments.filter(app => {
            const appDate = new Date(app.appointment_date);
            return appDate >= now;
        });

        if (this.bookedCountSpan) {
             this.bookedCountSpan.textContent = `(${futureAppointments.length})`;
        }

        if (futureAppointments.length === 0) {
             this.bookedListContainer.innerHTML = '<p class="message info" style="margin: 0; text-align: center;">Keine zuk√ºnftigen Termine gebucht.</p>';
             return;
        }

        this.bookedListContainer.innerHTML = futureAppointments.map(app => {
            const date = formatGermanDate(app.appointment_date);
            const time = formatShortTime(app.appointment_time);
            const student = escapeHtml(app.student_name);
            const className = escapeHtml(app.class_name) || 'N/A';
            const classId = escapeHtml(app.class_id) || 'N/A';
            const location = escapeHtml(app.location) || 'N/A';
            const notes = app.notes ? escapeHtml(app.notes) : 'Keine Notizen';

            return `
            <div class="booked-appointment-item" data-id="${app.appointment_id}">
                <div class="appointment-time-info">
                    <span class="appointment-date">${date}</span>
                    <span class="appointment-time">${time} Uhr</span>
                </div>
                <div class="appointment-details">
                    <strong class="appointment-student-name">${student}</strong>
                    <span class="appointment-class">Klasse: ${className} (ID: ${classId})</span>
                    <span class="appointment-location">Ort: ${location}</span>
                </div>
                <div class="appointment-notes">
                    <strong>Notiz des Sch√ºlers:</strong>
                    <p>${notes}</p>
                </div>
                <div class="appointment-actions">
                    <button class="btn btn-danger btn-small cancel-appointment-btn" data-id="${app.appointment_id}" title="Termin stornieren">
                        Stornieren
                    </button>
                </div>
            </div>
            `;
        }).join('');
    }

    async handleSave(e) {
        e.preventDefault();
        this.saveButton.disabled = true;
        this.saveSpinner.style.display = 'block';

        const formData = new FormData(this.form);
        const data = Object.fromEntries(formData.entries());

        try {
            if (data.start_time >= data.end_time) {
                throw new Error("Startzeit muss vor der Endzeit liegen.");
            }
            
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/office-hours/save`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            
            if (response.success) {
                showToast(response.message, 'success');
                this.form.reset();
                // Set default slot duration back
                this.form.querySelector('#office-slot-duration').value = 15;
                this.loadOfficeHours(); 
            }
        } catch (error) {
            console.error("Fehler beim Speichern der Sprechzeit:", error);
            showToast(error.message, 'error'); 
        } finally {
            this.saveButton.disabled = false;
            this.saveSpinner.style.display = 'none';
        }
    }

    async handleDelete(availabilityId) {
        if (!availabilityId) return;

        if (await showConfirm("Sprechzeit l√∂schen", `M√∂chten Sie dieses Zeitfenster wirklich l√∂schen? Zuk√ºnftige Termine in diesem Fenster werden ebenfalls entfernt.`)) {
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/office-hours/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ availability_id: availabilityId })
                });

                if (response.success) {
                    showToast(response.message, 'success');
                    this.loadOfficeHours(); 
                }
            } catch (error) {
                console.error("Fehler beim L√∂schen der Sprechzeit:", error);
            }
        }
    }
    
    // NEU: Storniert einen gebuchten Termin
    async handleCancelBookedAppointment(appointmentId, title, itemElement) {
        if (await showConfirm("Termin stornieren", `M√∂chten Sie den Termin mit "${escapeHtml(title)}" wirklich stornieren?`)) {
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/appointment/cancel`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ appointment_id: appointmentId })
                });
                if (response.success) {
                    showToast(response.message, 'success');
                    // Element aus der Liste entfernen
                    if (itemElement) {
                        itemElement.style.transition = 'opacity 0.3s ease, height 0.3s ease, margin 0.3s ease, padding 0.3s ease';
                        itemElement.style.opacity = '0';
                        itemElement.style.height = '0px';
                        itemElement.style.paddingTop = '0';
                        itemElement.style.paddingBottom = '0';
                        itemElement.style.margin = '0';
                        setTimeout(() => {
                            itemElement.remove();
                            // "Mein Tag" Tab neu laden, falls der Termin dort angezeigt wurde
                            if(window.dashboardApp && typeof window.dashboardApp.loadAndRenderWeeklyData === 'function') {
                                // Wir rufen die Haupt-Datenladefunktion auf, da diese "Mein Tag" aktualisiert
                                window.dashboardApp.loadAndRenderWeeklyData(false); // false = Ansicht nicht zur√ºcksetzen
                            }
                            // Z√§hler aktualisieren
                            const remaining = this.bookedListContainer.querySelectorAll('.booked-appointment-item').length;
                            if (this.bookedCountSpan) this.bookedCountSpan.textContent = `(${remaining})`;
                            if (remaining === 0) {
                                this.renderBookedAppointmentsList([]); // "Leer"-Nachricht anzeigen
                            }
                        }, 300);
                    } else {
                         this.loadBookedAppointments(); // Fallback: Liste neu laden
                    }
                }
            } catch (error) {
                console.error("Fehler beim Stornieren:", error);
            }
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\teacher-cockpit.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\index.php ---
<?php
require_once __DIR__ . '/../init.php';
require_once __DIR__ . '/../index.php';
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\index.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\index.php ---
<?php
require_once __DIR__ . '/init.php';
if (defined('MAINTENANCE_MODE_ACTIVE') && MAINTENANCE_MODE_ACTIVE === true) {
    http_response_code(503); 
    $settings = \App\Core\Utils::getSettings();
    $page_title = $settings['site_title'] . ' - Wartung';
    $maintenance_message = $settings['maintenance_message']; 
    include_once __DIR__ . '/pages/partials/header.php'; 
    include_once __DIR__ . '/pages/errors/503.php';      
    include_once __DIR__ . '/pages/partials/footer.php'; 
    exit(); 
}
$router = new \App\Core\Router();
$routes = require __DIR__ . '/config/routes.php';
foreach ($routes as $pattern => $handler) {
    $router->add($pattern, $handler);
}
$request_uri = $_GET['url'] ?? '/';
$request_path = trim(parse_url($request_uri, PHP_URL_PATH), '/');
$routeInfo = $router->resolve($request_path);
if ($routeInfo) {
    $handler = $routeInfo['handler'];
    $matches = $routeInfo['matches'];
    if (is_array($handler) && class_exists($handler[0]) && method_exists($handler[0], $handler[1])) {
        $controllerClass = $handler[0];
        $method = $handler[1];
        $controller = new $controllerClass();
        call_user_func_array([$controller, $method], $matches);
    }
    elseif (is_string($handler) && file_exists(__DIR__ . '/' . $handler)) {
        include __DIR__ . '/' . $handler;
    }
    else {
        http_response_code(500);
        echo "Fehler: Route-Handler f√ºr '{$request_path}' ist ung√ºltig konfiguriert.";
    }
} else {
    http_response_code(404);
    $page_title = '404 - Seite nicht gefunden';
    include_once __DIR__ . '/pages/partials/header.php';
    include_once __DIR__ . '/pages/errors/404.php';
    include_once __DIR__ . '/pages/partials/footer.php';
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\index.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\init.php ---
<?php
require_once __DIR__ . '/libs/Parsedown.php';
ini_set('session.cookie_httponly', 1);
ini_set('session.use_only_cookies', 1);
if (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on') {
    ini_set('session.cookie_secure', 1);
}
if (session_status() === PHP_SESSION_NONE) {
    session_start();
}
spl_autoload_register(function ($class) {
    $prefix = 'App\\';
    $base_dir = __DIR__ . '/app/'; 
    $len = strlen($prefix);
    if (strncmp($prefix, $class, $len) !== 0) {
        return;
    }
    $relative_class = substr($class, $len);
    $file = $base_dir . str_replace('\\', '/', $relative_class) . '.php';
    if (file_exists($file)) {
        require $file;
    }
});
if (session_status() === PHP_SESSION_ACTIVE) {
    \App\Core\Security::getCsrfToken();
} else {
    error_log("Session not active when trying to get CSRF token in init.php");
}
global $config;
try {
    $config = App\Core\Database::getConfig();
    $pdo = App\Core\Database::getInstance();
} catch (RuntimeException $e) {
    http_response_code(503); 
    error_log("Schwerwiegender DB-Fehler in init.php: " . $e->getMessage());
    $maintenance_message = "Fehler: Die Datenbankverbindung konnte nicht hergestellt werden. \nBitte versuchen Sie es zu einem sp√§teren Zeitpunkt erneut.";
    require_once __DIR__ . '/pages/partials/header.php';
    require_once __DIR__ . '/pages/errors/503.php';
    require_once __DIR__ . '/pages/partials/footer.php';
    exit;
} catch (Exception $e) { 
    http_response_code(500);
    die("Ein kritischer Initialisierungsfehler ist aufgetreten: " . $e->getMessage());
}
try {
    $settings = \App\Core\Utils::getSettings();
    if ($settings['maintenance_mode'] === true) {
        $userRole = $_SESSION['user_role'] ?? 'guest';
        $allowedRoles = ['admin', 'planer']; 
        $userIsAllowed = in_array($userRole, $allowedRoles);
        $userIP = $_SERVER['REMOTE_ADDR'] ?? 'UNKNOWN';
        $ipWhitelistString = $settings['maintenance_whitelist_ips'] ?? '';
        $ipWhitelist = array_map('trim', explode(',', $ipWhitelistString));
        $ipWhitelist = array_filter($ipWhitelist); 
        $ipIsAllowed = in_array($userIP, $ipWhitelist);
        if (!$userIsAllowed && !$ipIsAllowed) {
            $request_uri = $_GET['url'] ?? '/';
            $request_path = trim(parse_url($request_uri, PHP_URL_PATH), '/');
            $allowedPaths = ['login', 'login/process']; 
            if (!in_array($request_path, $allowedPaths)) {
                define('MAINTENANCE_MODE_ACTIVE', true);
            }
        }
    }
} catch (Exception $e) {
    http_response_code(500);
    die("Fehler beim Pr√ºfen des Wartungsstatus: " . $e->getMessage());
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\init.php ---

