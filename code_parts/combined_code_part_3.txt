grid-cell ersetzt) } */


/* Container für mehrere Einträge pro Zelle */
.cell-entries-container {
    display: flex;
    flex-direction: column;
    gap: 2px; /* Kleiner Abstand zwischen parallelen Einträgen */
    height: 100%;
    width: 100%;
    padding: 2px; /* Etwas Innenabstand in der Zelle */
    box-sizing: border-box;
}

/* Anpassung der Zellen (TD), damit der Container die volle Höhe nutzt */
.timetable-grid .grid-cell {
    /* (Dieser Stil wird jetzt vom Dashboard übernommen) */
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: stretch;
    gap: 3px; /* Abstand zwischen parallelen Einträgen */
    padding: 3px;
    position: relative;
    background-color: var(--color-surface);
    cursor: pointer;
    transition: background-color 0.2s ease, transform 0.2s ease;
    min-height: 70px; /* Synchronisiert mit grid-auto-rows */
}
.dark-mode .timetable-grid .grid-cell {
    background-color: var(--color-surface);
}

/* Weist Zellen den korrekten Spalten zu (CSS-Grid-Logik) */
.grid-cell[data-day="1"] { grid-column: 2; }
.grid-cell[data-day="2"] { grid-column: 3; }
.grid-cell[data-day="3"] { grid-column: 4; }
.grid-cell[data-day="4"] { grid-column: 5; }
.grid-cell[data-day="5"] { grid-column: 6; }


.timetable-grid .grid-cell:hover {
    background-color: #f1f5f9;
    z-index: 5;
}
.dark-mode .timetable-grid .grid-cell:hover {
    background-color: #ffffff1a;
}

.timetable-grid .grid-cell.selected {
    background-color: rgba(57, 0, 153, 0.1);
    outline: 2px solid var(--color-primary);
    outline-offset: -2px;
    z-index: 10;
}

/* KORREKTUR: Drag-Stile auf .grid-cell (TD) anwenden */
.timetable-grid .grid-cell.dragging {
    opacity: 0.4;
    transform: scale(0.95);
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}
.timetable-grid.is-dragging .grid-cell {
    transition: background-color 0.3s ease;
}
.grid-cell.drop-target {
    background-color: rgba(57, 0, 153, 0.1);
    transform: scale(1.03);
    z-index: 15;
}
.grid-cell.drop-target-valid {
    background-color: rgba(40, 167, 69, 0.15);
    outline: 2px dashed var(--color-success);
    outline-offset: -2px;
}
.grid-cell.drop-target-invalid {
    background-color: rgba(255, 0, 84, 0.15);
    outline: 2px dashed var(--color-danger);
    outline-offset: -2px;
}
/* Ende Drag-Stile */


/* (Dieser Stil ist jetzt obsolet, da .planner-entry das Styling übernimmt) */
.cell-entry {
    /* KORREKTUR: pointer-events: none; (damit die Zelle das Drag-Event empfängt) */
    pointer-events: none;
}

/* KORREKTUR: .grid-cell strong/span/small (Globale Zellenschriftarten) */
.grid-cell strong { font-size: 0.9rem; font-weight: 700; }
.grid-cell span { font-size: 0.75rem; color: var(--color-text-muted); }
.grid-cell small { font-size: 0.7rem; color: var(--color-text-muted); }
.grid-cell small.entry-room { color: #555; }
.dark-mode .grid-cell small.entry-room { color: #bbb; }
.grid-cell small.entry-comment { display: block; font-style: italic; color: var(--color-secondary); margin-top: 2px; line-height: 1.2; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 90%; }
/* --- Ende Grid-Stile --- */


/* Styling für die einzelnen Eintrag-Divs (Planner-Entry) */
.planner-entry {
    border-radius: 4px;
    padding: 4px;
    font-size: 0.8rem;
    cursor: pointer;
    border: 1px solid var(--color-border);
    transition: all 0.2s ease;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    flex-shrink: 0;
    line-height: 1.3;
    /* KORREKTUR: Stile aus .cell-entry übernommen */
    background: rgba(255, 255, 255, 0.9);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    word-break: break-word;
}
.dark-mode .planner-entry {
    background: rgba(40, 48, 54, 0.9);
    border-color: #444c56;
}


.planner-entry:hover {
    transform: translateY(-1px) scale(1.03); /* Leichter Hover-Effekt auf dem Eintrag selbst */
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    z-index: 10;
    position: relative; /* Für z-index */
}

/* Styling für reguläre Einträge (timetable-entry) */
.timetable-entry {
    background-color: var(--color-surface-alt);
    border-left: 3px solid var(--color-primary);
}
.dark-mode .timetable-entry {
    background-color: var(--color-surface);
}

.planner-entry .entry-line {
    text-align: left; /* Linksbündig für bessere Lesbarkeit */
    padding: 0 2px; /* Kleiner horizontaler Abstand */
    pointer-events: none; /* Stellt sicher, dass Klicks/Drag zur Zelle durchgehen */
}

.planner-entry .entry-subject {
    font-weight: 600;
    color: var(--color-text);
    font-size: 0.9rem; /* War .grid-cell strong */
}
.planner-entry .entry-main {
    color: var(--color-text-muted);
    font-size: 0.75rem; /* War .grid-cell span */
}
.planner-entry .entry-room {
    font-size: 0.75rem; /* Angepasst */
    color: var(--color-secondary);
}
.planner-entry .sub-type {
    font-weight: 700;
    font-size: 0.7rem;
    text-transform: uppercase;
    margin-bottom: 2px;
}


/* Styling für Vertretungen (substitution-entry) */
.substitution-entry {
    background-color: var(--color-surface-alt);
}
.dark-mode .substitution-entry {
    background-color: var(--color-surface);
}

.planner-entry.vertretung {
    border-left: 3px solid var(--color-danger);
    background-color: #fff0f1;
}
.planner-entry.vertretung .sub-type {
    color: var(--color-danger);
}
.dark-mode .planner-entry.vertretung {
    background-color: rgba(255, 0, 84, 0.1);
}

.planner-entry.raumänderung {
    border-left: 3px solid var(--color-warning);
    background-color: #fff9e6;
}
.planner-entry.raumänderung .sub-type {
    color: var(--color-warning);
}
.dark-mode .planner-entry.raumänderung {
    background-color: rgba(255, 189, 0, 0.1);
}

.planner-entry.entfall {
    border-left: 3px solid var(--color-text-muted);
    background-color: var(--color-surface-alt);
    opacity: 0.7;
    text-decoration: line-through;
}
.planner-entry.entfall .sub-type {
    color: var(--color-text-muted);
}
.dark-mode .planner-entry.entfall {
    background-color: var(--color-surface);
}


.planner-entry.sonderevent {
    border-left: 3px solid var(--color-primary);
    background-color: #e7f5ff; /* Hellblau von Dashboard */
}
.planner-entry.sonderevent .sub-type {
    color: var(--color-primary);
}
.dark-mode .planner-entry.sonderevent {
    background-color: rgba(0, 123, 255, 0.1);
}

/* KORREKTUR: Styling für Abwesenheits-Warnung (zielt auf .planner-entry) */
.planner-entry.is-absent {
    background-color: rgba(255, 0, 84, 0.05);
    outline: 1px dashed var(--color-danger);
    outline-offset: -1px;
}
.dark-mode .planner-entry.is-absent {
    background-color: rgba(255, 0, 84, 0.1);
}
.planner-entry.is-absent .entry-main { /* Zielt auf Lehrer/Klasse */
    color: var(--color-danger);
    font-weight: 700;
    background-color: rgba(255, 0, 84, 0.1);
    padding: 0 4px;
    border-radius: 3px;
}
.dark-mode .planner-entry.is-absent .entry-main {
    background-color: rgba(255, 0, 84, 0.2);
    color: #ff8984;
}
.planner-entry .absence-warning { /* .absence-warning ist jetzt ein Kind von .planner-entry */
    font-size: 0.7rem !important;
    font-weight: 700;
    color: var(--color-danger) !important;
    display: block;
}


/* KORREKTUR: Leere Zellen (TDs) und FU-Zellen */
.timetable-grid .grid-cell.is-empty {
    background-color: var(--color-surface-alt);
    cursor: cell;
}
.dark-mode .timetable-grid .grid-cell.is-empty {
    background-color: var(--color-background); /* Dunkler für leer */
}

/* FU-Stil (Zelle, die einen default-entry enthält) */
.timetable-grid .grid-cell.default-entry {
    background-color: #f8f9fa;
    color: #6c757d;
    justify-content: center;
    align-items: center;
    cursor: default;
}
.dark-mode .timetable-grid .grid-cell.default-entry {
    background-color: #21262d;
    color: var(--color-text-muted);
}
/* Der .planner-entry div innerhalb einer FU-Zelle */
.grid-cell.default-entry .planner-entry {
    background: transparent;
    border: none;
    flex-grow: 0;
    height: auto;
    min-height: 0;
    pointer-events: none;
}
.grid-cell.default-entry .planner-entry .entry-subject {
    color: inherit;
    font-size: 0.9rem;
}


.timetable-grid .grid-cell.is-empty:hover {
    background-color: #f1f5f9;
    transform: none;
}
.dark-mode .timetable-grid .grid-cell.is-empty:hover {
    background-color: #ffffff1a;
}
/* KORREKTUR: Hover für FU-Zellen */
.timetable-grid .grid-cell.default-entry:hover {
    background-color: #f8f9fa;
    transform: none;
}
.dark-mode .timetable-grid .grid-cell.default-entry:hover {
    background-color: #21262d;
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\css\pages\_planer.css ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\css\main.css ---
/* Basis-Stile */
@import url('base/_variables.css');
@import url('base/_globals.css');
@import url('base/_print.css'); /* ADDED */

/* Layout */
@import url('layout/_general.css');
@import url('layout/_header.css');
/*  @import url('layout/_header_new.css'); dd new header base */
@import url('layout/_footer.css');

/* Komponenten */
@import url('components/_buttons.css');
@import url('components/_form-elements.css');
@import url('components/_messages.css');
@import url('components/_mobile_menu.css'); /* Add mobile menu styles */
@import url('components/_user_menu.css'); /* Add user menu styles */
@import url('components/_theme_toggle.css'); /* Add theme toggle styles */


/*Seiten*/
@import url('pages/_admin.css');
@import url('pages/_planer.css');
@import url('pages/_dashboard.css');
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\css\main.css ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-announcements.js ---
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js'; // Import notification functions

/**
 * Escapes HTML special characters to prevent XSS.
 * @param {string} unsafe - The string to escape.
 * @returns {string} The escaped string.
 */
function escapeHtml(unsafe) {
    if (unsafe === null || typeof unsafe === 'undefined') return '';
  	 return String(unsafe)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
}


export function initializeAdminAnnouncements() {
    const managementContainer = document.getElementById('announcements-management');
    if (!managementContainer) return;

    const tableBody = managementContainer.querySelector('#announcements-table tbody');
    const form = managementContainer.querySelector('#announcement-form');
    const formTitle = managementContainer.querySelector('#announcement-form-title');
    const announcementIdInput = managementContainer.querySelector('#announcement_id');
    const targetClassSelect = managementContainer.querySelector('#target_class_id');
    const targetCheckboxes = managementContainer.querySelectorAll('.checkbox-group input[type="checkbox"]');
    const targetGlobalCheckbox = managementContainer.querySelector('#target_global');
    const targetTeacherCheckbox = managementContainer.querySelector('#target_teacher');
    const targetPlanerCheckbox = managementContainer.querySelector('#target_planer');
    const targetErrorHint = managementContainer.querySelector('#target-error');
    const cancelBtn = managementContainer.querySelector('#cancel-edit-announcement');
    const attachmentInput = managementContainer.querySelector('#attachment');
    const currentAttachmentInfo = managementContainer.querySelector('#current-attachment-info');
    const currentAttachmentLink = managementContainer.querySelector('#current-attachment-link');
    const removeAttachmentCheckbox = managementContainer.querySelector('#remove_attachment');
    const csrfTokenInput = managementContainer.querySelector('input[name="_csrf_token"]'); // Corrected name

    const userRole = window.APP_CONFIG.userRole;

    const resetForm = () => {
        form.dataset.mode = 'create';
        form.reset();
        announcementIdInput.value = '';
        formTitle.textContent = 'Neue Ankündigung erstellen';
        cancelBtn.style.display = 'none';

        // Reset targeting fields specifically for admin/planer
        if (targetClassSelect) targetClassSelect.disabled = false;
        if (targetCheckboxes) targetCheckboxes.forEach(cb => { cb.checked = false; cb.disabled = false; });
        if (targetErrorHint) targetErrorHint.style.display = 'none';

        // Lehrer view specific reset
        if (userRole === 'lehrer' && targetClassSelect) {
             targetClassSelect.required = true;
        }

        // Reset attachment fields
        if (currentAttachmentInfo) currentAttachmentInfo.style.display = 'none';
        if (currentAttachmentLink) {
            currentAttachmentLink.href = '#';
            currentAttachmentLink.textContent = '';
        }
        if (removeAttachmentCheckbox) removeAttachmentCheckbox.checked = false;
        if (attachmentInput) attachmentInput.value = ''; // Clear file input
    };

    // --- Targeting Logic ---
    const handleTargetSelectionChange = (event) => {
        if (!targetClassSelect || !targetCheckboxes.length) return; // Only run for admin/planer

        const isCheckboxEvent = event && event.target.type === 'checkbox';
        const isSelectEvent = event && event.target === targetClassSelect;

        let checkedCount = 0;
        targetCheckboxes.forEach(cb => { if (cb.checked) checkedCount++; });

        if (isCheckboxEvent) {
             // If a checkbox is checked, ensure only one is checked and clear/disable class select
             if (event.target.checked) {
                 targetCheckboxes.forEach(cb => {
                     if (cb !== event.target) cb.checked = false;
                 });
                 targetClassSelect.value = ''; // Clear class selection
                 targetClassSelect.disabled = true;
                 checkedCount = 1; // We just checked one
             } else {
                 // If the last checkbox was unchecked, re-enable class select
                 if (checkedCount === 0) {
                     targetClassSelect.disabled = false;
                 }
             }
        } else if (isSelectEvent) {
             // If a class is selected, uncheck and disable all checkboxes
             if (targetClassSelect.value !== '') {
                 targetCheckboxes.forEach(cb => {
                     cb.checked = false;
                     cb.disabled = true; // Disable checkboxes if class is chosen
                 });
                 checkedCount = 0;
             } else {
                 // If '-- Klasse wählen --' is selected, re-enable checkboxes
                 targetCheckboxes.forEach(cb => cb.disabled = false);
             }
        } else {
             // Initial load or reset: Sync state
             if (checkedCount > 0) {
                 targetClassSelect.value = '';
                 targetClassSelect.disabled = true;
                 if (checkedCount > 1) { // Ensure only one is checked on load (shouldn't happen)
                     targetCheckboxes[0].checked = true;
                     for(let i=1; i<targetCheckboxes.length; i++) targetCheckboxes[i].checked = false;
                 }
             } else if (targetClassSelect.value !== '') {
                 targetCheckboxes.forEach(cb => { cb.checked = false; cb.disabled = true; });
             } else {
                 targetClassSelect.disabled = false;
                 targetCheckboxes.forEach(cb => cb.disabled = false);
             }
        }
        // Validation Hint (Show if nothing is selected)
        if (targetErrorHint) {
            targetErrorHint.style.display = (targetClassSelect.value === '' && checkedCount === 0) ? 'block' : 'none';
        }

    };

    if (targetClassSelect && targetCheckboxes.length) {
        targetClassSelect.addEventListener('change', handleTargetSelectionChange);
        targetCheckboxes.forEach(cb => cb.addEventListener('change', handleTargetSelectionChange));
        handleTargetSelectionChange(); // Initial check
    }
     // --- End Targeting Logic ---


    const renderTable = (announcements) => {
         // This function needs to be updated based on the new table structure in the PHP file
         // It's less critical now as the initial render happens server-side.
         // You might want to update rows dynamically after create/update/delete instead of full re-render.
         // For now, leave it empty or log a message, as initial load is SSR.
         console.log("Rendering table (client-side update - currently basic)");
         // Basic example if needed later:
         /*
         tableBody.innerHTML = announcements.length > 0 ? announcements.map(item => {
              // ... generate row HTML based on item data and new columns ...
              return `<tr>...</tr>`;
         }).join('') : `<tr><td colspan="6">Keine Ankündigungen gefunden.</td></tr>`;
         */
    };


    // Load function might not be needed if initial load is always server-side
    // const loadAnnouncements = async () => { ... };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const mode = form.dataset.mode;
        const formData = new FormData(form);

        // --- Target Validation (for Admin/Planer) ---
        if (userRole === 'admin' || userRole === 'planer') {
            const classSelected = formData.get('target_class_id') && formData.get('target_class_id') !== '';
            const globalChecked = formData.get('target_global') === '1';
            const teacherChecked = formData.get('target_teacher') === '1';
            const planerChecked = formData.get('target_planer') === '1';
            const checkedCount = [globalChecked, teacherChecked, planerChecked].filter(Boolean).length;

            if (!classSelected && checkedCount !== 1) {
                if (targetErrorHint) targetErrorHint.style.display = 'block';
                // Use imported function directly
                showToast('Bitte eine Klasse ODER genau eine Zielgruppe (Global, Lehrer, Planer) auswählen.', 'error');
                return; // Stop submission
            } else {
                 if (targetErrorHint) targetErrorHint.style.display = 'none';
            }
             // Clear unchecked checkboxes from form data if needed (usually not necessary)
             if (!globalChecked) formData.delete('target_global');
             if (!teacherChecked) formData.delete('target_teacher');
             if (!planerChecked) formData.delete('target_planer');
             if (checkedCount > 0) formData.delete('target_class_id'); // Don't send class_id if a checkbox is checked
        }
        // --- End Target Validation ---

        // Lehrer specific handling (already done via hidden input + required on select)

        const url = mode === 'create'
            ? `${window.APP_CONFIG.baseUrl}/api/announcements/create`
            : `${window.APP_CONFIG.baseUrl}/api/announcements/update`; // Update endpoint needs implementation

         // Add CSRF token manually if not already added by apiFetch for FormData
         if (!formData.has('_csrf_token') && csrfTokenInput) {
             formData.append('_csrf_token', csrfTokenInput.value);
         }


        try {
             // apiFetch should handle FormData correctly including CSRF in body
            const response = await apiFetch(url, { method: 'POST', body: formData });
            if(response.success) {
                // Use imported function directly
                showToast(response.message, 'success');
                resetForm();
                // Instead of loadAnnouncements(), maybe just add/update the row in the table?
                // For simplicity, reload the page to see changes
                window.location.reload();
            }
            // Error handled by apiFetch
        } catch(error) {
             console.error("Form submission error:", error);
             // Maybe refresh CSRF token if it failed due to token mismatch
        }
    });

    tableBody.addEventListener('click', async (e) => {
        const target = e.target;
        const row = target.closest('tr');
        if (!row) return;

        const id = row.dataset.id;
        // Get data from data attributes
        const announcementData = {
            announcement_id: id,
            title: row.dataset.title,
            content: row.dataset.content,
            is_global: row.dataset.isGlobal === '1',
            class_id: row.dataset.classId || null,
            file_path: row.dataset.filePath || null,
            user_id: row.dataset.userId
        };

        if (target.classList.contains('edit-announcement')) {
            // Edit is disabled for now, but logic would go here
             // Use imported function directly
             showToast('Bearbeiten ist derzeit nicht implementiert.', 'info');

             /* // Logic if Edit were enabled:
             form.dataset.mode = 'update';
             formTitle.textContent = 'Ankündigung bearbeiten';
             cancelBtn.style.display = 'inline-block';

             announcementIdInput.value = announcementData.announcement_id;
             form.querySelector('#title').value = announcementData.title;
             form.querySelector('#content').value = announcementData.content;

            // Reset and set targeting based on loaded data (for admin/planer)
             if (userRole === 'admin' || userRole === 'planer') {
                 targetClassSelect.value = '';
                 targetCheckboxes.forEach(cb => cb.checked = false);

                 if (announcementData.is_global) {
                     // We can't know if it was originally 'lehrer' or 'planer' vs 'all'
                     targetGlobalCheckbox.checked = true;
                 } else if (announcementData.class_id) {
                     targetClassSelect.value = announcementData.class_id;
                 }
                 handleTargetSelectionChange(); // Update UI based on loaded data
             } else if (userRole === 'lehrer') {
                  targetClassSelect.value = announcementData.class_id || '';
Dienstag
             }


            // Handle attachment display
            if (attachmentInput) {
                 attachmentInput.value = '';
Dienstag
                 if (announcementData.file_path) {
                     const fileUrl = `${window.APP_CONFIG.baseUrl}/${announcementData.file_path.startsWith('/') ? announcementData.file_path.substring(1) : announcementData.file_path}`;
                     currentAttachmentInfo.style.display = 'block';
                     currentAttachmentLink.href = fileUrl;
                     currentAttachmentLink.textContent = announcementData.file_path.split('/').pop(); // Show filename
                tuesday
                     removeAttachmentCheckbox.checked = false;
                 } else {
                     currentAttachmentInfo.style.display = 'none';
                 }
            }


             form.querySelector('#title').focus();
             */

        }

        if (target.classList.contains('delete-announcement')) {
            // Permission check already done in PHP for button visibility, but double-check here if needed
            const canModify = in_array(userRole, ['admin', 'planer']) || (userRole === 'lehrer' && announcementData.user_id == window.APP_CONFIG.userId); // Assuming userId is available globally
Dienstag
             if (!canModify) return;

            // Use imported function directly
            if (await showConfirm('Ankündigung löschen', `Sind Sie sicher, dass Sie "${escapeHtml(announcementData.title)}" löschen möchten? Zugehörige Dateien werden ebenfalls entfernt.`)) {
                const deleteFormData = new FormData();
                deleteFormData.append('announcement_id', id);
Dienstag
                 // Add CSRF token manually if not already added by apiFetch for FormData
                 if (!deleteFormData.has('_csrf_token') && csrfTokenInput) {
                     deleteFormData.append('_csrf_token', csrfTokenInput.value);
                 }


                try {
                    const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/announcements/delete`, { method: 'POST', body: deleteFormData });
Dienstag
                    if(response.success) {
                        // Use imported function directly
                        showToast(response.message, 'success');
                        row.remove(); // Remove row directly
          tuesday
                         // Optionally check if table is now empty
                        if (tableBody.rows.length === 0) {
                            // Display a message or reload
                             window.location.reload(); // Reload if empty for simplicity
A
                        }
                    }
                     // Error handled by apiFetch
d
                } catch(error) {
                     console.error("Delete error:", error);
                     // Maybe refresh CSRF token
                }
            }
        }
    });

    cancelBtn.addEventListener('click', resetForm);

    // Initial load is handled by PHP SSR, no need for loadAnnouncements() on init
    // Initial setup for targeting fields
    handleTargetSelectionChange();
}

// Helper function to check if an element is in an array
function in_array(needle, haystack) {
    return haystack.indexOf(needle) > -1;
}

// Ensure APP_CONFIG includes userId if needed for client-side permission checks
// Example: Add this to pages/partials/header.php within the script tag
// userId: <?php echo $_SESSION['user_id'] ?? 'null'; ?>,

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-announcements.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-audit-log.js ---
import { apiFetch } from './api-client.js';
import { showToast } from './notifications.js';

/**
 * Escapes HTML special characters to prevent XSS.
 * @param {string|null|undefined} unsafe - The string to escape.
 * @returns {string} The escaped string.
 */
function escapeHtml(unsafe) {
    if (unsafe === null || typeof unsafe === 'undefined') return '';
    return String(unsafe)
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}

/**
 * Formatiert ein Datumsobjekt oder einen String in das deutsche Format.
 * KORRIGIERT: Ersetzt Leerzeichen durch 'T' für bessere new Date() Kompatibilität.
 * @param {string|Date} dateInput - Der Datumsstring (erwartet YYYY-MM-DD HH:MM:SS).
 * @returns {string} Formatiertes Datum (TT.MM.YYYY HH:MM:SS) oder 'Ungültig'.
 */
function formatDateTime(dateInput) {
    if (!dateInput) return 'N/A'; // Handle empty input

    try {
        let dateString = String(dateInput);
        // Ersetze das erste Leerzeichen durch 'T', um ISO-Nähe herzustellen
        dateString = dateString.replace(' ', 'T');

        const date = new Date(dateString);

        if (isNaN(date.getTime())) {
            console.warn("formatDateTime: Ungültiges Datum nach Konvertierung:", dateString, "Original:", dateInput);
            return 'Ungültig';
        }

        return date.toLocaleString('de-DE', {
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit', second: '2-digit'
        });
    } catch (e) {
        console.error("formatDateTime Fehler:", e, "Input:", dateInput);
        return 'Fehler'; // Gibt einen anderen Fehlertext zurück
    }
}


/**
 * Initialisiert die Logik für die Audit-Log-Seite.
 */
export function initializeAdminAuditLogs() {
    const managementContainer = document.getElementById('audit-log-management');
    if (!managementContainer) return;

    const filterForm = document.getElementById('audit-filter-form');
    const tableBody = document.getElementById('audit-logs-tbody');
    const paginationContainer = document.getElementById('pagination-controls');
    const paginationSummary = document.getElementById('pagination-summary');

    let currentFilters = {};
    let currentPage = 1;

    /**
     * Erstellt das HTML für eine einzelne Log-Zeile.
     * @param {object} log - Das Log-Objekt aus der API.
     * @returns {string} HTML-String für die <tr>.
     */
    const createLogRowHtml = (log) => {
        const userName = log.user_id
            ? `${escapeHtml(log.last_name)}, ${escapeHtml(log.first_name)} (${escapeHtml(log.username)})`
            : '<em style="color: var(--color-text-muted);">System/Gast</em>';

        let detailsHtml = '';
        if (log.details) {
            try {
                const detailsObj = JSON.parse(log.details);
                // Zeigt JSON als aufklappbares Detail an
                detailsHtml = `
                    <details class="log-details">
                        <summary>Details anzeigen</summary>
                        <pre>${escapeHtml(JSON.stringify(detailsObj, null, 2))}</pre>
                    </details>
                `;
            } catch (e) {
                detailsHtml = escapeHtml(log.details); // Fallback für kein JSON
            }
        }

        return `
            <tr data-log-id="${log.log_id}">
                <td data-label="Zeitstempel">${formatDateTime(log.timestamp)}</td> <td data-label="Benutzer">${userName}</td>
                <td data-label="Aktion">${escapeHtml(log.action)}</td>
                <td data-label="Ziel-Typ">${escapeHtml(log.target_type)}</td>
                <td data-label="Ziel-ID">${escapeHtml(log.target_id)}</td>
                <td data-label="Details" class="log-details-cell">${detailsHtml}</td>
                <td data-label="IP-Adresse">${escapeHtml(log.ip_address)}</td>
            </tr>
        `;
    };

    /**
     * Erstellt die Paginierungs-Buttons.
     * @param {number} currentPage
     * @param {number} totalPages
     */
    const renderPagination = (currentPage, totalPages) => {
        paginationContainer.innerHTML = '';
        if (totalPages <= 1) return;

        // "Zurück"-Button
        const prevBtn = document.createElement('button');
        prevBtn.className = 'btn btn-secondary btn-small pagination-btn';
        prevBtn.textContent = '« Zurück';
        prevBtn.disabled = currentPage <= 1;
        prevBtn.dataset.page = currentPage - 1;
        paginationContainer.appendChild(prevBtn);

        // Seiteninfo
        const pageInfo = document.createElement('span');
        pageInfo.className = 'pagination-info';
        pageInfo.textContent = `Seite ${currentPage} / ${totalPages}`;
        paginationContainer.appendChild(pageInfo);

        // "Weiter"-Button
        const nextBtn = document.createElement('button');
        nextBtn.className = 'btn btn-secondary btn-small pagination-btn';
        nextBtn.textContent = 'Weiter »';
        nextBtn.disabled = currentPage >= totalPages;
        nextBtn.dataset.page = currentPage + 1;
        paginationContainer.appendChild(nextBtn);
    };

    /**
     * Hauptfunktion zum Laden und Rendern der Logs.
     * @param {number} page - Die zu ladende Seite.
     * @param {object} filters - Die anzuwendenden Filter.
     */
    const loadLogs = async (page = 1, filters = {}) => {
        currentPage = page;
        currentFilters = filters;

        tableBody.innerHTML = `<tr><td colspan="7" style="text-align: center; padding: 40px;"><div class="loading-spinner"></div></td></tr>`;
        paginationContainer.innerHTML = '';
        paginationSummary.textContent = 'Lade Einträge...';

        const params = new URLSearchParams();
        params.append('page', page);
        for (const [key, value] of Object.entries(filters)) {
            if (value) { // Nur hinzufügen, wenn Wert vorhanden
                params.append(key, value);
            }
        }

        try {
            const url = `${window.APP_CONFIG.baseUrl}/api/admin/audit-logs?${params.toString()}`;
            const response = await apiFetch(url); // GET-Anfrage

            if (response.success) {
                // Logs rendern
                if (response.logs && response.logs.length > 0) {
                    tableBody.innerHTML = response.logs.map(createLogRowHtml).join('');
                } else {
                    tableBody.innerHTML = `<tr><td colspan="7" style="text-align: center; padding: 20px;">Keine Protokolleinträge für diese Filter gefunden.</td></tr>`;
                }

                // Paginierung rendern
                const { currentPage, totalPages, totalCount, limit } = response.pagination;
                renderPagination(currentPage, totalPages);

                // Zusammenfassung aktualisieren
                const startEntry = (currentPage - 1) * limit + 1;
                const endEntry = Math.min(currentPage * limit, totalCount);
                paginationSummary.textContent = totalCount > 0
                    ? `Zeige Einträge ${startEntry} - ${endEntry} von ${totalCount}`
                    : 'Keine Einträge gefunden';

            } else {
                throw new Error(response.message || 'Unbekannter Fehler');
            }

        } catch (error) {
            console.error("Fehler beim Laden der Audit-Logs:", error);
            showToast(error.message, 'error');
            tableBody.innerHTML = `<tr><td colspan="7" class="message error">Fehler: ${error.message}</td></tr>`;
            paginationSummary.textContent = 'Fehler beim Laden';
        }
    };

    // --- Event Listeners ---

    // Filter-Formular absenden
    filterForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const formData = new FormData(filterForm);
        const filters = Object.fromEntries(formData.entries());
        loadLogs(1, filters); // Starte immer auf Seite 1, wenn gefiltert wird
    });

    // Filter zurücksetzen
    filterForm.addEventListener('reset', (e) => {
        // Verzögere das Neuladen leicht, damit das Formular zuerst zurückgesetzt wird
        setTimeout(() => {
            loadLogs(1, {}); // Lade Seite 1 ohne Filter
        }, 0);
    });

    // Klicks auf Paginierungs-Buttons
    paginationContainer.addEventListener('click', (e) => {
        const target = e.target.closest('.pagination-btn');
        if (target && !target.disabled) {
            const page = parseInt(target.dataset.page, 10);
            if (page) {
                loadLogs(page, currentFilters);
            }
        }
    });

    // Initiales Laden
    loadLogs(1, {});
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-audit-log.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-community.js ---
// public/assets/js/admin-community.js
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js';

/**
 * Initialisiert die Moderationsseite für das Schwarze Brett.
 * NEU: Fügt Tab-Switching-Logik hinzu.
 */
export function initializeAdminCommunity() {
    const container = document.getElementById('community-moderation');
    if (!container) return;

    // --- NEU: Tab-Logik ---
    const tabContainer = container.querySelector('.tab-navigation');
    const contentContainer = container.querySelector('.tab-content');

    if (tabContainer && contentContainer) {
        const tabButtons = tabContainer.querySelectorAll('.tab-button');
        const tabContents = contentContainer.querySelectorAll('.dashboard-section');

        const handleTabClick = (button) => {
            const targetId = button.dataset.target;
            if (!targetId) return;

            tabButtons.forEach(btn => btn.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));

            button.classList.add('active');
            const targetContent = document.getElementById(targetId);
            if (targetContent) {
                targetContent.classList.add('active');
            }
        };

        tabButtons.forEach(button => {
            button.addEventListener('click', () => handleTabClick(button));
        });

        // KORREKTUR: Die Initialisierungs-Logik wird entfernt.
        // Das HTML (PHP) rendert bereits den korrekten Start-Zustand
        // (erster Tab aktiv, erstes Panel aktiv).
        // Wir müssen nur die Klick-Listener hinzufügen.
        /*
        const initiallyActiveButton = tabContainer.querySelector('.tab-button.active');
        if (initiallyActiveButton) {
             handleTabClick(initiallyActiveButton);
        } else if (tabButtons.length > 0) {
             handleTabClick(tabButtons[0]); // Fallback: Ersten Tab aktivieren
        }
        */
    }
    // --- ENDE Tab-Logik ---


    // Event-Listener auf den Hauptcontainer legen (Event Delegation)
    container.addEventListener('click', handleModerationClick);
}

/**
 * Behandelt Klicks auf alle Moderations-Buttons (Freigeben, Ablehnen, Löschen)
 * @param {Event} e
 */
async function handleModerationClick(e) {
    const approveBtn = e.target.closest('.approve-post-btn');
    const rejectBtn = e.target.closest('.reject-post-btn');
    const deleteBtn = e.target.closest('.delete-approved-btn'); // NEU

    const button = approveBtn || rejectBtn || deleteBtn;
    if (!button) return;

    e.preventDefault();
    
    const postItem = button.closest('.moderation-item');
    const postId = postItem?.dataset.id;
    const postTitle = postItem?.querySelector('.post-title')?.textContent || 'dieser Beitrag';

    if (!postId) {
        showToast('Konnte Beitrags-ID nicht finden.', 'error');
        return;
    }

    let actionText, url, confirmTitle, confirmMessage, logAction;

    if (approveBtn) {
        actionText = 'Freigeben';
        url = `${window.APP_CONFIG.baseUrl}/api/admin/community/approve`;
        logAction = 'approve';
        confirmTitle = 'Beitrag freigeben';
        confirmMessage = `Möchten Sie "${postTitle}" wirklich freigeben?`;
    } else if (rejectBtn) {
        actionText = 'Ablehnen & Löschen';
        url = `${window.APP_CONFIG.baseUrl}/api/admin/community/reject`;
        logAction = 'reject';
        confirmTitle = 'Beitrag ablehnen';
        confirmMessage = `Möchten Sie "${postTitle}" wirklich ablehnen und löschen?`;
    } else if (deleteBtn) { // NEU
        actionText = 'Endgültig Löschen';
        url = `${window.APP_CONFIG.baseUrl}/api/admin/community/delete-approved`;
        logAction = 'delete';
        confirmTitle = 'Beitrag löschen';
        confirmMessage = `Möchten Sie den freigegebenen Beitrag "${postTitle}" wirklich endgültig löschen?`;
    }

    // Bestätigung einholen
    if (await showConfirm(confirmTitle, confirmMessage)) {
        button.disabled = true;
        const spinner = document.createElement('span');
        spinner.className = 'loading-spinner small';
        button.insertAdjacentElement('afterend', spinner);

        try {
            const response = await apiFetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ post_id: postId })
            });

            if (response.success) {
                showToast(response.message, 'success');
                // Beitrag aus der Liste entfernen
                postItem.style.transition = 'opacity 0.3s ease, height 0.3s ease, margin 0.3s ease, padding 0.3s ease';
                postItem.style.opacity = '0';
                postItem.style.height = '0px';
                postItem.style.paddingTop = '0';
                postItem.style.paddingBottom = '0';
                postItem.style.margin = '0';
                
                setTimeout(() => {
                    const listContainer = postItem.parentElement;
                    postItem.remove();
                    // Prüfen, ob die Liste jetzt leer ist
                    if (listContainer && listContainer.childElementCount === 0) {
                        const messageType = (logAction === 'approve' || logAction === 'reject') ? 'ausstehende' : 'freigegebene';
                        listContainer.innerHTML = `<p class="message info">Aktuell gibt es keine ${messageType} Beiträge.</p>`;
                    }
                }, 300);
            }
            // Fehler wird von apiFetch als Toast angezeigt
        } catch (error) {
            console.error(`Fehler bei Aktion '${logAction}':`, error);
            // Button wieder aktivieren, falls der Request fehlschlägt
            button.disabled = false;
        } finally {
            spinner.remove();
        }
    }
}



--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-community.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-settings.js ---
import { apiFetch } from './api-client.js';
import { showToast } from './notifications.js';

export function initializeAdminSettings() {
    const settingsForm = document.getElementById('settings-form');
    if (!settingsForm) return;

    const saveButton = document.getElementById('save-settings-btn');
    const statusSpinner = document.getElementById('save-settings-spinner');
    
    // Toggle-Schalter
    const maintenanceToggle = document.getElementById('maintenance_mode');
    const maintenanceStatus = document.getElementById('maintenance-status');
    const icalToggle = document.getElementById('ical_enabled');
    const icalStatus = document.getElementById('ical-status');
    // NEU: Community Board Toggle
    const communityToggle = document.getElementById('community_board_enabled');
    const communityStatus = document.getElementById('community-board-status');
    
    // Datei-Upload-Vorschau-Handler
    const logoInput = document.getElementById('site_logo');
    const logoPreviewContainer = document.getElementById('logo-preview-container');
    const logoRemoveCheckbox = document.querySelector('input[name="remove_site_logo"]');
    const faviconInput = document.getElementById('site_favicon');
    const faviconPreviewContainer = document.getElementById('favicon-preview-container');
    const faviconRemoveCheckbox = document.querySelector('input[name="remove_site_favicon"]');

    // NEU: Cache-Management-Elemente
    const clearCacheBtn = document.getElementById('clear-cache-btn');
    const cacheStatusText = document.getElementById('cache-clear-status');
    const cacheCsrfTokenInput = document.getElementById('cache_csrf_token');


    // NEU: Hilfsfunktion für Toggles
    const setupToggle = (toggleElement, statusElement, activeText = 'Aktiviert', inactiveText = 'Deaktiviert') => {
        if (!toggleElement || !statusElement) return;
        
        const updateStatus = () => {
             if (toggleElement.checked) {
                statusElement.textContent = activeText;
                statusElement.style.color = 'var(--color-success)';
            } else {
                statusElement.textContent = inactiveText;
                statusElement.style.color = 'var(--color-text-muted)';
            }
        };
        
        toggleElement.addEventListener('change', updateStatus);
        updateStatus(); // Initialen Status beim Laden setzen
    };

    // Live-Aktualisierung der Status-Texte
    setupToggle(maintenanceToggle, maintenanceStatus, 'Aktiviert', 'Deaktiviert');
    setupToggle(icalToggle, icalStatus, 'Aktiviert', 'Deaktiviert');
    setupToggle(communityToggle, communityStatus, 'Aktiviert', 'Deaktiviert'); // NEU


    // Funktion zur Aktualisierung der Datei-Vorschau
    const updatePreview = (input, container, removeCheckbox, isLogo = true) => {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = (e) => {
                container.innerHTML = `
                    <img src="${e.target.result}" alt="Vorschau" class="${isLogo ? 'logo-preview' : 'favicon-preview'}">
                    <label class="remove-file-label" style="display: block;">
                        <input type="checkbox" name="${removeCheckbox.name}" value="1"> Entfernen
                    </label>
                `;
                // Re-binde den "Entfernen"-Checkbox-Listener für das *neue* Element
                const newRemoveCheckbox = container.querySelector(`input[name="${removeCheckbox.name}"]`);
                if (newRemoveCheckbox) {
                     newRemoveCheckbox.addEventListener('change', () => handleRemoveCheck(newRemoveCheckbox, input, container, isLogo ? 'Logo' : 'Favicon'));
                }
            };
            reader.readAsDataURL(input.files[0]);
            if (removeCheckbox) removeCheckbox.checked = false; // Deaktiviere "Entfernen", wenn neue Datei gewählt
        }
    };
    
    // Funktion, die das "Entfernen" behandelt
    const handleRemoveCheck = (checkbox, input, container, altText) => {
         if (checkbox.checked) {
            if (input) input.value = ''; // Clear file input
            container.querySelector('img')?.remove(); // Remove preview image
            container.querySelector('.no-file')?.remove();
            
            const noFileSpan = document.createElement('span');
            noFileSpan.className = 'no-file';
            noFileSpan.textContent = `${altText} wird entfernt.`;
            container.prepend(noFileSpan);
            // Verstecke die Checkbox selbst, da sie ihre Aufgabe erfüllt hat
            if (checkbox.parentElement) checkbox.parentElement.style.display = 'none';
        }
    };

    // Event Listener für Datei-Vorschau
    if (logoInput) logoInput.addEventListener('change', () => updatePreview(logoInput, logoPreviewContainer, logoRemoveCheckbox, true));
    if (faviconInput) faviconInput.addEventListener('change', () => updatePreview(faviconInput, faviconPreviewContainer, faviconRemoveCheckbox, false));
    
    // Logik für "Entfernen"-Checkbox (für bereits geladene Bilder)
    if (logoRemoveCheckbox) {
        logoRemoveCheckbox.addEventListener('change', () => handleRemoveCheck(logoRemoveCheckbox, logoInput, logoPreviewContainer, 'Logo'));
    }
     if (faviconRemoveCheckbox) {
        faviconRemoveCheckbox.addEventListener('change', () => handleRemoveCheck(faviconRemoveCheckbox, faviconInput, faviconPreviewContainer, 'Favicon'));
    }

    // ====== NEUER EVENT LISTENER FÜR CACHE-LÖSCHUNG ======
    if (clearCacheBtn && cacheStatusText && cacheCsrfTokenInput) {
        clearCacheBtn.addEventListener('click', async () => {
            if (confirm('Sind Sie sicher, dass Sie den gesamten Anwendungs-Cache leeren möchten?')) {
                
                clearCacheBtn.disabled = true;
                clearCacheBtn.textContent = 'Leere...';
                cacheStatusText.textContent = '';
                cacheStatusText.classList.remove('text-success', 'text-danger');
    
                // Wir erstellen FormData, um konsistent mit dem apiFetch-Aufruf
                // des Hauptformulars zu sein.
                const formData = new FormData();
                formData.append('csrf_token', cacheCsrfTokenInput.value);
    
                try {
                    const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/cache/clear`, {
                        method: 'POST',
                        body: formData
                    });
    
                    if (response.success) {
                        showToast(response.message || 'Cache erfolgreich geleert.', 'success');
                        cacheStatusText.textContent = response.message;
                        cacheStatusText.classList.add('text-success');
                    } else {
                        // apiFetch sollte bei HTTP-Fehlern werfen, aber fangen wir auch 'success: false' ab
                        throw new Error(response.message || 'Ein unbekannter Fehler ist aufgetreten.');
                    }
    
                } catch (error) {
                    console.error('Fehler beim Leeren des Caches:', error);
                    const errorMessage = error.message || 'Fehler beim Leeren des Caches.';
                    showToast(errorMessage, 'error');
                    cacheStatusText.textContent = `Fehler: ${errorMessage}`;
                    cacheStatusText.classList.add('text-danger');
                } finally {
                    clearCacheBtn.disabled = false;
                    clearCacheBtn.textContent = 'Cache jetzt leeren';
                }
            }
        });
    }
    // ====== ENDE CACHE-LOGIK ======


    settingsForm.addEventListener('submit', async (e) => {
        e.preventDefault();

        if (saveButton) saveButton.disabled = true;
        if (statusSpinner) statusSpinner.style.display = 'inline-block';

        const formData = new FormData(settingsForm);

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/settings/save`, {
                method: 'POST',
                body: formData // Sende als FormData (inkl. Dateien)
            });

            if (response.success) {
                showToast('Einstellungen erfolgreich gespeichert.', 'success');
                
                const cacheBuster = `?v=${new Date().getTime()}`;

                // Update site title in header if changed
                const newTitle = formData.get('site_title');
                const logoContainer = document.querySelector('.site-logo');
                
                if (logoContainer) {
                    if (response.data.site_logo_path) {
                        // Neues Logo wurde gesetzt
                        logoContainer.innerHTML = `<img src="${window.APP_CONFIG.baseUrl}/${response.data.site_logo_path}${cacheBuster}" alt="${escapeHtml(newTitle)} Logo" class="site-logo-image" id="header-logo-img">`;
                    } else {
                        // Logo wurde entfernt oder war nie da, zeige Titel
                        logoContainer.innerHTML = `<span id="header-logo-text">${escapeHtml(newTitle)}</span>`;
                    }
                }
                // Update document title
                document.title = escapeHtml(newTitle);
                
                // Update Favicon
                let faviconElement = document.querySelector('link[rel="icon"]');
                if (response.data.site_favicon_path) {
                    const newFaviconUrl = `${window.APP_CONFIG.baseUrl}/${response.data.site_favicon_path}${cacheBuster}`;
                    if (faviconElement) {
                        faviconElement.href = newFaviconUrl;
                    } else {
                        // Erstelle Favicon-Link, falls er nicht existiert
                        const newLink = document.createElement('link');
                        newLink.rel = 'icon';
                        newLink.href = newFaviconUrl;
                        document.head.appendChild(newLink);
                    }
                } else if (!response.data.site_favicon_path && faviconElement) {
                    // Favicon wurde entfernt
                    faviconElement.remove();
                }

                // Aktualisiere die Vorschau-Container in der Einstellungs-Seite selbst
                updatePreviewContainer(logoPreviewContainer, response.data.site_logo_path, 'remove_site_logo', 'Logo', true);
                updatePreviewContainer(faviconPreviewContainer, response.data.site_favicon_path, 'remove_site_favicon', 'Favicon', false);
                // Setze File-Inputs zurück
                if (logoInput) logoInput.value = '';
                if (faviconInput) faviconInput.value = '';

                 // Aktualisiere globalen Config-Cache
                 window.APP_CONFIG.settings.site_title = newTitle;
                 window.APP_CONFIG.settings.site_logo_path = response.data.site_logo_path;
                 window.APP_CONFIG.settings.site_favicon_path = response.data.site_favicon_path;
                 window.APP_CONFIG.settings.default_theme = response.data.default_theme;
                 window.APP_CONFIG.settings.ical_enabled = formData.get('ical_enabled') === '1';
                 window.APP_CONFIG.settings.ical_weeks_future = parseInt(formData.get('ical_weeks_future'), 10);
                 window.APP_CONFIG.settings.maintenance_whitelist_ips = formData.get('maintenance_whitelist_ips'); // NEU
                 window.APP_CONFIG.settings.community_board_enabled = formData.get('community_board_enabled') === '1'; // NEU
            }
             // Errors are handled by apiFetch and showToast
        } catch (error) {
            console.error('Fehler beim Speichern der Einstellungen:', error);
            // Error toast is already shown by apiFetch
        } finally {
            if (saveButton) saveButton.disabled = false;
            if (statusSpinner) statusSpinner.style.display = 'none';
        }
    });

    /**
     * NEU: Hilfsfunktion zum Aktualisieren des Vorschau-Containers nach dem Speichern.
     */
    function updatePreviewContainer(container, newPath, checkboxName, altText, isLogo) {
        if (!container) return;
        
        // Cache-Buster für das neue Bild
        const cacheBuster = `?v=${new Date().getTime()}`;
        
        if (newPath) {
             container.innerHTML = `
                <img src="${window.APP_CONFIG.baseUrl}/${newPath}${cacheBuster}" alt="${altText} Vorschau" class="${isLogo ? 'logo-preview' : 'favicon-preview'}">
                <label class="remove-file-label">
                    <input type="checkbox" name="${checkboxName}" value="1"> ${altText} entfernen
                </label>
            `;
            // Re-binde den Event Listener für die neue Checkbox
             const newCheckbox = container.querySelector(`input[name="${checkboxName}"]`);
             if (newCheckbox) {
                 const inputEl = document.getElementById(isLogo ? 'site_logo' : 'site_favicon');
                 newCheckbox.addEventListener('change', () => handleRemoveCheck(newCheckbox, inputEl, container, altText));
             }

        } else {
             container.innerHTML = `<span class="no-file">Kein ${altText} festgelegt.</span>`;
        }
    }
    
    // Hilfsfunktion zum Escapen von HTML
    function escapeHtml(unsafe) {
         if (!unsafe) return '';
         return String(unsafe)
              .replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&#039;");
    }

}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-settings.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-stammdaten.js ---
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js'; // Import notification functions

/**
 * Steuert die Tab-Navigation und das "Lazy Loading" der Inhalte.
 */
function initializeTabbedInterface() {
    const stammdatenManagement = document.getElementById('stammdaten-management');
    if (!stammdatenManagement) return;

    const tabButtons = stammdatenManagement.querySelectorAll('.tab-button');
    const tabContents = stammdatenManagement.querySelectorAll('.dashboard-section');

    const initializers = {
        'subjects-section': initializeSubjectManagement,
        'rooms-section': initializeRoomManagement,
        'teachers-section': initializeTeacherManagement,
        'classes-section': initializeClassManagement,
    };

    const handleTabClick = (button) => {
        tabButtons.forEach(btn => btn.classList.remove('active'));
        tabContents.forEach(content => content.classList.remove('active'));

        button.classList.add('active');
        const targetId = button.dataset.target;
        const targetContent = document.getElementById(targetId);

        if (targetContent) {
            targetContent.classList.add('active');

            // Initialize content only once
            if (!targetContent.dataset.initialized) {
                const initFunc = initializers[targetId];
                if (typeof initFunc === 'function') {
                    initFunc(); // Call the specific initializer for this tab
                    targetContent.dataset.initialized = 'true';
                }
            }

            // Focus first input in the form for better UX
            const firstInput = targetContent.querySelector('form input[type="text"], form input[type="email"], form input[type="number"]');
            if (firstInput) {
                setTimeout(() => firstInput.focus(), 50); // Small delay might be needed
            }
        }
    };

    tabButtons.forEach(button => {
        button.addEventListener('click', () => handleTabClick(button));
    });

    // Initialize the initially active tab (defined by 'active' class in HTML)
    const initiallyActiveButton = stammdatenManagement.querySelector('.tab-button.active');
    if (initiallyActiveButton) {
        handleTabClick(initiallyActiveButton);
    }
}


function initializeSubjectManagement() {
    const section = document.getElementById('subjects-section');
    if (!section) return;

    const tableBody = section.querySelector('#subjects-table tbody');
    const form = section.querySelector('#subject-form');
    const formTitle = section.querySelector('#subject-form-container h4');
    const subjectIdInput = section.querySelector('#subject_id');
    const subjectNameInput = section.querySelector('#subject_name');
    const subjectShortcutInput = section.querySelector('#subject_shortcut');
    const cancelBtn = section.querySelector('#cancel-edit-subject');

    const resetForm = () => {
        form.dataset.mode = 'create';
        form.reset();
        subjectIdInput.value = '';
        formTitle.textContent = 'Neues Fach anlegen';
        cancelBtn.style.display = 'none';
    };

    const renderTable = (subjects) => {
        tableBody.innerHTML = subjects.length > 0 ? subjects.map(subject => `
            <tr data-id="${subject.subject_id}">
                <td>${subject.subject_id}</td>
                <td>${subject.subject_name}</td>
                <td>${subject.subject_shortcut}</td>
                <td class="actions">
                    <button class="btn btn-warning btn-small edit-subject" data-name="${subject.subject_name}" data-shortcut="${subject.subject_shortcut}">Bearbeiten</button>
                    <button class="btn btn-danger btn-small delete-subject">Löschen</button>
                </td>
            </tr>
        `).join('') : '<tr><td colspan="4">Keine Fächer gefunden.</td></tr>';
    };

    const loadSubjects = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/subjects`);
            if (response.success) {
                renderTable(response.data);
            }
            // Error handled by apiFetch
        } catch (error) {
            tableBody.innerHTML = '<tr><td colspan="4" class="message error">Fehler beim Laden der Fächer.</td></tr>';
        }
    };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const mode = form.dataset.mode;
        const formData = new FormData(form);
        const url = mode === 'create'
            ? `${window.APP_CONFIG.baseUrl}/api/admin/subjects/create`
            : `${window.APP_CONFIG.baseUrl}/api/admin/subjects/update`;

        try {
            const response = await apiFetch(url, { method: 'POST', body: formData });
            if(response.success) {
                // Use imported function directly
                showToast(response.message, 'success');
                resetForm();
                loadSubjects(); // Reload table
            }
             // Error handled by apiFetch
        } catch(error) {}
    });

    tableBody.addEventListener('click', async (e) => {
        const target = e.target;
        const row = target.closest('tr');
        if (!row) return;

        const id = row.dataset.id;

        if (target.classList.contains('edit-subject')) {
            form.dataset.mode = 'update';
            subjectIdInput.value = id;
            subjectNameInput.value = target.dataset.name;
            subjectShortcutInput.value = target.dataset.shortcut;
            formTitle.textContent = 'Fach bearbeiten';
            cancelBtn.style.display = 'inline-block';
            subjectNameInput.focus();
        }

        if (target.classList.contains('delete-subject')) {
            // Use imported function directly
            if (await showConfirm('Fach löschen', 'Sind Sie sicher, dass Sie dieses Fach endgültig löschen möchten?')) {
                const formData = new FormData();
                formData.append('subject_id', id);
                try {
                    const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/subjects/delete`, { method: 'POST', body: formData });
                     if(response.success) {
                         // Use imported function directly
                         showToast(response.message, 'success');
                         loadSubjects(); // Reload table
                     }
                      // Error handled by apiFetch
                } catch(error) {}
            }
        }
    });

    cancelBtn.addEventListener('click', resetForm);
    loadSubjects(); // Initial load
}

function initializeRoomManagement() {
    const section = document.getElementById('rooms-section');
    if (!section) return;

    const tableBody = section.querySelector('#rooms-table tbody');
    const form = section.querySelector('#room-form');
    const formTitle = section.querySelector('#room-form-container h4');
    const roomIdInput = section.querySelector('#room_id');
    const roomNameInput = section.querySelector('#room_name');
    const cancelBtn = section.querySelector('#cancel-edit-room');

    const resetForm = () => {
        form.dataset.mode = 'create';
        form.reset();
        roomIdInput.value = '';
        formTitle.textContent = 'Neuen Raum anlegen';
        cancelBtn.style.display = 'none';
    };

    const renderTable = (rooms) => {
        tableBody.innerHTML = rooms.length > 0 ? rooms.map(room => `
            <tr data-id="${room.room_id}">
                <td>${room.room_id}</td>
                <td>${room.room_name}</td>
                <td class="actions">
                    <button class="btn btn-warning btn-small edit-room" data-name="${room.room_name}">Bearbeiten</button>
                    <button class="btn btn-danger btn-small delete-room">Löschen</button>
                </td>
            </tr>
        `).join('') : '<tr><td colspan="3">Keine Räume gefunden.</td></tr>';
    };

    const loadRooms = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/rooms`);
            if (response.success) {
                renderTable(response.data);
            }
            // Error handled by apiFetch
        } catch (error) {
             tableBody.innerHTML = '<tr><td colspan="3" class="message error">Fehler beim Laden der Räume.</td></tr>';
        }
    };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const mode = form.dataset.mode;
        const formData = new FormData(form);
        const url = mode === 'create'
            ? `${window.APP_CONFIG.baseUrl}/api/admin/rooms/create`
            : `${window.APP_CONFIG.baseUrl}/api/admin/rooms/update`;

        try {
            const response = await apiFetch(url, { method: 'POST', body: formData });
            if(response.success) {
                 // Use imported function directly
                 showToast(response.message, 'success');
                 resetForm();
                 loadRooms(); // Reload table
            }
             // Error handled by apiFetch
        } catch(error) {}
    });

    tableBody.addEventListener('click', async (e) => {
        const target = e.target;
        const row = target.closest('tr');
        if (!row) return;

        const id = row.dataset.id;

        if (target.classList.contains('edit-room')) {
            form.dataset.mode = 'update';
            roomIdInput.value = id;
            roomNameInput.value = target.dataset.name;
            formTitle.textContent = 'Raum bearbeiten';
            cancelBtn.style.display = 'inline-block';
            roomNameInput.focus();
        }

        if (target.classList.contains('delete-room')) {
             // Use imported function directly
            if (await showConfirm('Raum löschen', 'Sind Sie sicher, dass Sie diesen Raum endgültig löschen möchten?')) {
                const formData = new FormData();
                formData.append('room_id', id);
                try {
                    const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/rooms/delete`, { method: 'POST', body: formData });
                     if(response.success) {
                         // Use imported function directly
                         showToast(response.message, 'success');
                         loadRooms(); // Reload table
                     }
                      // Error handled by apiFetch
                } catch(error) {}
            }
        }
    });

    cancelBtn.addEventListener('click', resetForm);
    loadRooms(); // Initial load
}

function initializeTeacherManagement() {
    const section = document.getElementById('teachers-section');
    if (!section) return;

    const tableBody = section.querySelector('#teachers-table tbody');
    const form = section.querySelector('#teacher-form');
    const formTitle = section.querySelector('#teacher-form-container h4');
    const teacherIdInput = section.querySelector('#teacher_id');
    const cancelBtn = section.querySelector('#cancel-edit-teacher');

    const resetForm = () => {
        form.dataset.mode = 'create';
        form.reset();
        teacherIdInput.value = '';
        formTitle.textContent = 'Lehrer anlegen/bearbeiten';
        cancelBtn.style.display = 'none';
    };

    const renderTable = (teachers) => {
        tableBody.innerHTML = teachers.length > 0 ? teachers.map(t => `
            <tr data-id="${t.teacher_id}">
                <td>${t.teacher_id}</td>
                <td>${t.teacher_shortcut}</td>
                <td>${t.first_name}</td>
                <td>${t.last_name}</td>
                <td>${t.email || ''}</td>
                <td class="actions">
                    <button class="btn btn-warning btn-small edit-teacher">Bearbeiten</button>
                    <button class="btn btn-danger btn-small delete-teacher">Löschen</button>
                </td>
            </tr>
        `).join('') : '<tr><td colspan="6">Keine Lehrer gefunden.</td></tr>';
    };

    const loadTeachers = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/teachers`);
            if (response.success) {
                renderTable(response.data);
            }
            // Error handled by apiFetch
        } catch (error) {
            tableBody.innerHTML = '<tr><td colspan="6" class="message error">Fehler beim Laden der Lehrer.</td></tr>';
        }
    };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const mode = form.dataset.mode;
        const formData = new FormData(form);
        const url = mode === 'create'
            ? `${window.APP_CONFIG.baseUrl}/api/admin/teachers/create`
            : `${window.APP_CONFIG.baseUrl}/api/admin/teachers/update`;

        try {
            const response = await apiFetch(url, { method: 'POST', body: formData });
            if(response.success) {
                 // Use imported function directly
                 showToast(response.message, 'success');
                 resetForm();
                 loadTeachers(); // Reload table
            }
             // Error handled by apiFetch
        } catch(error) {}
    });

    tableBody.addEventListener('click', async (e) => {
        const target = e.target;
        const row = target.closest('tr');
        if (!row) return;

        const id = row.dataset.id;

        if (target.classList.contains('edit-teacher')) {
            form.dataset.mode = 'update';
            teacherIdInput.value = id;
            form.querySelector('#teacher_shortcut').value = row.cells[1].textContent;
            form.querySelector('#first_name').value = row.cells[2].textContent;
            form.querySelector('#last_name').value = row.cells[3].textContent;
            form.querySelector('#email').value = row.cells[4].textContent;
            formTitle.textContent = 'Lehrer bearbeiten';
            cancelBtn.style.display = 'inline-block';
        }

        if (target.classList.contains('delete-teacher')) {
             // Use imported function directly
            if (await showConfirm('Lehrer löschen', 'Sind Sie sicher? Dies kann Stundenpläne beeinflussen.')) {
                const formData = new FormData();
                formData.append('teacher_id', id);
                try {
                    const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/teachers/delete`, { method: 'POST', body: formData });
                     if(response.success) {
                         // Use imported function directly
                         showToast(response.message, 'success');
                         loadTeachers(); // Reload table
                     }
                      // Error handled by apiFetch
                } catch(error) {}
            }
        }
    });

    cancelBtn.addEventListener('click', resetForm);
    loadTeachers(); // Initial load
}

function initializeClassManagement() {
    const section = document.getElementById('classes-section');
    if (!section) return;

    const tableBody = section.querySelector('#classes-table tbody');
    const form = section.querySelector('#class-form');
    const formTitle = section.querySelector('#class-form-container h4');
    const classIdInput = section.querySelector('#class_id_input'); // Input for ID (readonly in edit mode)
    const classIdHiddenInput = section.querySelector('#class_id_hidden'); // Hidden input for submit
    const classNameInput = section.querySelector('#class_name');
    const teacherSelect = section.querySelector('#class_teacher_id');
    const cancelBtn = section.querySelector('#cancel-edit-class');

    const resetForm = () => {
        form.dataset.mode = 'create';
        form.reset();
        classIdHiddenInput.value = '';
        formTitle.textContent = 'Neue Klasse anlegen';
        cancelBtn.style.display = 'none';
        classIdInput.readOnly = false; // Allow editing ID when creating
        classIdInput.disabled = false;
    };

    const renderTable = (classes) => {
        tableBody.innerHTML = classes.length > 0 ? classes.map(c => `
            <tr data-id="${c.class_id}" data-teacher-id="${c.class_teacher_id || ''}">
                <td>${c.class_id}</td>
                <td>${c.class_name}</td>
                <td>${c.teacher_name || 'Kein Klassenlehrer'}</td>
                <td class="actions">
                    <button class="btn btn-warning btn-small edit-class" data-name="${c.class_name}">Bearbeiten</button>
                    <button class="btn btn-danger btn-small delete-class">Löschen</button>
                </td>
            </tr>
        `).join('') : '<tr><td colspan="4">Keine Klassen gefunden.</td></tr>';
    };

    const loadTeachersForSelect = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/teachers`);
            if (response.success) {
                teacherSelect.innerHTML = '<option value="">Kein Klassenlehrer</option>' + response.data.map(t =>
                    `<option value="${t.teacher_id}">${t.first_name} ${t.last_name} (${t.teacher_shortcut})</option>`
                ).join('');
            }
             // Error handled by apiFetch
        } catch (error) {
            teacherSelect.innerHTML = '<option value="">Lehrer konnten nicht geladen werden</option>';
        }
    };

    const loadClasses = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/classes`);
            if (response.success) {
                renderTable(response.data);
            }
            // Error handled by apiFetch
        } catch (error) {
            tableBody.innerHTML = '<tr><td colspan="4" class="message error">Fehler beim Laden der Klassen.</td></tr>';
        }
    };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const mode = form.dataset.mode;
        const formData = new FormData(form);
        // Ensure the correct class_id is submitted (from hidden input in update mode)
        if (mode === 'update') {
            formData.set('class_id', classIdHiddenInput.value); // Use hidden input value
             formData.delete('class_id_input'); // Remove the potentially disabled input value
        } else {
             formData.set('class_id', classIdInput.value); // Use visible input value for create
             formData.delete('class_id_input'); // Remove the input field with suffix
             formData.delete('class_id_hidden'); // Remove hidden field for create
        }

        const url = mode === 'create'
            ? `${window.APP_CONFIG.baseUrl}/api/admin/classes/create`
            : `${window.APP_CONFIG.baseUrl}/api/admin/classes/update`;

        try {
            const response = await apiFetch(url, { method: 'POST', body: formData });
            if(response.success) {
                 // Use imported function directly
                 showToast(response.message, 'success');
                 resetForm();
                 loadClasses(); // Reload table
            }
            // Error (like duplicate ID) handled by apiFetch
        } catch(error) {}
    });

    tableBody.addEventListener('click', async (e) => {
        const target = e.target;
        const row = target.closest('tr');
        if (!row) return;

        const id = row.dataset.id;

        if (target.classList.contains('edit-class')) {
            form.dataset.mode = 'update';
            classIdInput.value = id; // Show ID in input
            classIdInput.readOnly = true; // Make ID readonly
            classIdInput.disabled = true; // Disable ID input visually
            classIdHiddenInput.value = id; // Set hidden input for submission
            classNameInput.value = target.dataset.name;
            teacherSelect.value = row.dataset.teacherId;
            formTitle.textContent = 'Klasse bearbeiten';
            cancelBtn.style.display = 'inline-block';
            classNameInput.focus();
        }

        if (target.classList.contains('delete-class')) {
            // Use imported function directly
            if (await showConfirm('Klasse löschen', 'Sind Sie sicher? Dies kann Stundenpläne und Benutzerzuweisungen beeinflussen.')) {
                const formData = new FormData();
                formData.append('class_id', id);
                try {
                    const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/classes/delete`, { method: 'POST', body: formData });
                     if(response.success) {
                         // Use imported function directly
                         showToast(response.message, 'success');
                         loadClasses(); // Reload table
                     }
                      // Error handled by apiFetch
                } catch(error) {}
            }
        }
    });

    cancelBtn.addEventListener('click', resetForm);
    loadTeachersForSelect(); // Load teachers for the dropdown
    loadClasses(); // Initial load
}

export function initializeAdminStammdaten() {
    initializeTabbedInterface();
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-stammdaten.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-users.js ---
// public/assets/js/admin-users.js
// KORRIGIERT: Fehlendes 'export' in Zeile 4 hinzugefügt.

import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js'; // Import notification functions

export function initializeAdminUsers() { // <-- DIESES 'export' HAT GEFEHLT
    const userManagement = document.getElementById('user-management');
    if (!userManagement) return;

    const tableBody = userManagement.querySelector('#users-table tbody');
    const form = userManagement.querySelector('#user-form');
    const formTitle = userManagement.querySelector('#user-form-title');
    const userIdInput = userManagement.querySelector('#user_id');
    const passwordInput = userManagement.querySelector('#password');
    const cancelBtn = userManagement.querySelector('#cancel-edit-user');

    // Role specific fields
    const roleSelect = userManagement.querySelector('#role');
    const classSelectContainer = userManagement.querySelector('#class-select-container');
    const classSelect = userManagement.querySelector('#class_id');
    const teacherSelectContainer = userManagement.querySelector('#teacher-select-container');
    const teacherSelect = userManagement.querySelector('#teacher_id');
    // NEU: Community Ban Checkbox
    const communityBanContainer = userManagement.querySelector('#community-ban-container');
    const communityBanCheckbox = userManagement.querySelector('#is_community_banned');


    let allData = {}; // To store roles, classes, teachers

    const resetForm = () => {
        form.dataset.mode = 'create';
        form.reset();
        userIdInput.value = '';
        formTitle.textContent = 'Neuen Benutzer anlegen';
        passwordInput.setAttribute('required', 'required');
        passwordInput.parentElement.querySelector('label').textContent = 'Passwort*';
        cancelBtn.style.display = 'none';
        toggleRoleSpecificFields(); // Reset visibility
    };

    const toggleRoleSpecificFields = () => {
        const selectedRole = roleSelect.value;
        classSelectContainer.style.display = selectedRole === 'schueler' ? 'block' : 'none';
        teacherSelectContainer.style.display = selectedRole === 'lehrer' ? 'block' : 'none';
        // NEU: Zeige Ban-Checkbox nur für Schüler
        communityBanContainer.style.display = selectedRole === 'schueler' ? 'block' : 'none';


        // Reset selections when role changes
        if (selectedRole !== 'schueler') {
            classSelect.value = '';
            communityBanCheckbox.checked = false; // NEU
        }
        if (selectedRole !== 'lehrer') {
            teacherSelect.value = '';
        }
    };

    const renderTable = (users) => {
        const currentAdminId = window.APP_CONFIG.userId; // Holt die ID des Admins

        // KORREKTUR: HTML für die neue Spalte "Community" hinzugefügt
        tableBody.innerHTML = users.length > 0 ? users.map(user => {
            let details = '';
            if (user.role === 'schueler' && user.class_name) {
                details = `Klasse: ${user.class_name}`;
            } else if (user.role === 'lehrer' && user.teacher_name) {
                details = `Lehrerprofil: ${user.teacher_name}`;
            }

            // NEU: Community-Status
            let communityStatus = '-';
            if (user.role === 'schueler') {
                communityStatus = user.is_community_banned == 1 
                    ? '<span style="color: var(--color-danger); font-weight: 600;">Gesperrt</span>' 
                    : '<span style="color: var(--color-success);">Aktiv</span>';
            }

            // NEU: Logik für Impersonate-Button
            const canImpersonate = (user.user_id != currentAdminId); // Admin kann sich nicht selbst imitieren
            const impersonateButton = canImpersonate
                ? `<button class="btn btn-secondary btn-small impersonate-user-btn" data-id="${user.user_id}" data-username="${escapeHtml(user.username)}" data-role="${escapeHtml(user.role)}" title="Anmelden als ${escapeHtml(user.username)}">
                       Anmelden als
                   </button>`
                : ``; // Zeige keinen Button an, wenn man es selbst ist

            return `
                <tr data-id="${user.user_id}" data-user='${JSON.stringify(user)}'>
                    <td>${user.user_id}</td>
                    <td><strong>${escapeHtml(user.first_name)} ${escapeHtml(user.last_name)}</strong><br><small>${escapeHtml(user.username)}</small></td>
                    <td>${user.role}</td>
                    <td>${details}</td>
                    <td>${communityStatus}</td>
                    <td class="actions">
                        ${impersonateButton}
                        <button class="btn btn-warning btn-small edit-user">Bearbeiten</button>
                        <button class="btn btn-danger btn-small delete-user">Löschen</button>
                    </td>
                </tr>
            `;
        }).join('') : '<tr><td colspan="6">Keine Benutzer gefunden.</td></tr>'; // KORREKTUR: colspan="6"
    };

    const populateSelects = (data) => {
        allData = data; // Store for later use
        roleSelect.innerHTML = data.roles.map(r => `<option value="${r}">${r.charAt(0).toUpperCase() + r.slice(1)}</option>`).join('');
        
        // KORRIGIERT: Zeigt jetzt ID und Name an (und nutzt escapeHtml)
        classSelect.innerHTML = '<option value="">Keine Klasse</option>' + data.classes.map(c => 
            `<option value="${c.class_id}">${c.class_id} - ${escapeHtml(c.class_name)}</option>`
        ).join('');
        
        // KORRIGIERT: Zeigt jetzt Name und Kürzel an (und nutzt escapeHtml)
        teacherSelect.innerHTML = '<option value="">Kein Lehrerprofil</option>' + data.teachers.map(t => 
            `<option value="${t.teacher_id}">${escapeHtml(t.first_name)} ${escapeHtml(t.last_name)} (${escapeHtml(t.teacher_shortcut)})</option>`
        ).join('');
    };

    const loadUsers = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/users`);
            if (response.success) {
                renderTable(response.data.users);
                populateSelects(response.data);
                // After populating, ensure the correct fields are shown based on the initial role value (might be pre-selected)
                toggleRoleSpecificFields();
            }
             // Error handled by apiFetch
        } catch (error) {
            tableBody.innerHTML = '<tr><td colspan="6" class="message error">Fehler beim Laden der Benutzer.</td></tr>'; // KORREKTUR: colspan="6"
        }
    };

    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const mode = form.dataset.mode;
        const formData = new FormData(form);
        const url = mode === 'create'
            ? `${window.APP_CONFIG.baseUrl}/api/admin/users/create`
            : `${window.APP_CONFIG.baseUrl}/api/admin/users/update`;

        try {
            // KORREKTUR: admin-users.js sendet FormData, NICHT JSON.
            // Der Controller MUSS $_POST lesen.
            const response = await apiFetch(url, { method: 'POST', body: formData });
            if (response.success) {
                // Use imported function directly
                showToast(response.message, 'success');
                resetForm();
                loadUsers(); // Reload table and selects
            }
             // Error handled by apiFetch
        } catch (error) { /* Handled by apiFetch */ }
    });

    tableBody.addEventListener('click', async (e) => {
        const target = e.target;
        const row = target.closest('tr');
        if (!row) return;

        const id = row.dataset.id;
        let user;
        try {
            user = JSON.parse(row.dataset.user);
        } catch(e) {
            console.error("Could not parse user data from row:", row.dataset.user);
            return;
        }


        if (target.classList.contains('edit-user')) {
            form.dataset.mode = 'update';
            formTitle.textContent = 'Benutzer bearbeiten';
            cancelBtn.style.display = 'inline-block';
            passwordInput.removeAttribute('required');
            passwordInput.parentElement.querySelector('label').textContent = 'Neues Passwort';


            // Populate form
            userIdInput.value = user.user_id;
            form.querySelector('#username').value = user.username;
            form.querySelector('#email').value = user.email;
            form.querySelector('#first_name').value = user.first_name;
            form.querySelector('#last_name').value = user.last_name;
            form.querySelector('#birth_date').value = user.birth_date;
            roleSelect.value = user.role;
            // Ensure selects are populated before setting value
            if (allData.classes) classSelect.value = user.class_id || '';
            if (allData.teachers) teacherSelect.value = user.teacher_id || '';
            
            // NEU: Setze den Status der Ban-Checkbox
            if (communityBanCheckbox) {
                communityBanCheckbox.checked = (user.is_community_banned == 1);
            }

            toggleRoleSpecificFields(); // Show/hide fields based on populated role
            form.querySelector('#username').focus(); // Focus first editable field
        }

        if (target.classList.contains('delete-user')) {
            // Use imported function directly
            if (await showConfirm('Benutzer löschen', `Sind Sie sicher, dass Sie ${escapeHtml(user.first_name)} ${escapeHtml(user.last_name)} löschen möchten?`)) {
                // KORREKTUR: Muss FormData senden, da handleApiRequest im Controller $_POST erwartet
                const formData = new FormData();
                formData.append('user_id', id);
                try {
                    const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/users/delete`, { method: 'POST', body: formData });
                    if (response.success) {
                        // Use imported function directly
                        showToast(response.message, 'success');
                        loadUsers(); // Reload table
                    }
                     // Error handled by apiFetch
                } catch (error) { /* Handled by apiFetch */ }
            }
        }
        
        // NEU: Event-Listener für Impersonate-Button
        if (target.classList.contains('impersonate-user-btn')) {
            // Holt Daten aus dem Button/Row, da 'user' veraltet sein könnte
            const username = target.closest('tr').dataset.user ? JSON.parse(target.closest('tr').dataset.user).username : 'Benutzer';
            const role = target.closest('tr').dataset.user ? JSON.parse(target.closest('tr').dataset.user).role : 'unbekannt';
            await handleImpersonateUser(id, username, role);
        }
    });

    roleSelect.addEventListener('change', toggleRoleSpecificFields);
    cancelBtn.addEventListener('click', resetForm);

    loadUsers(); // Initial load
}

/**
 * NEU: Startet die Impersonation für einen Benutzer.
 * Diese Funktion sendet JSON, daher muss der Controller (impersonateUserApi) JSON erwarten.
 */
async function handleImpersonateUser(userId, username, role) {
    if (!await showConfirm(
        'Als Benutzer anmelden?', 
        `Möchten Sie sich wirklich als <strong>${escapeHtml(username)}</strong> (Rolle: ${escapeHtml(role)}) anmelden? Sie werden vom Admin-Konto abgemeldet.`
    )) {
        return;
    }

    try {
        const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/admin/users/impersonate`, {
            method: 'POST',
            // WICHTIG: Diese Route erwartet JSON, basierend auf unserem Controller-Setup
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ user_id: userId }) // Sende die ID als JSON
        });

        if (response.success && response.redirectUrl) {
            showToast(`Sie sind jetzt als ${escapeHtml(username)} angemeldet.`, 'success');
            // Weiterleitung zum Dashboard des Benutzers
            window.location.href = response.redirectUrl;
        }
    } catch (error) {
        console.error('Impersonation failed:', error);
        // Fehler wird bereits von apiFetch als Toast angezeigt
    }
}

// Helper-Funktion (falls nicht global verfügbar)
function escapeHtml(str) {
    if (str === null || typeof str === 'undefined') return '';
    return str.toString()
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\admin-users.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\api-client.js ---
import { showToast } from './notifications.js'; // Import showToast

/**
 * Zentraler API-Client zum Senden von Anfragen an das Backend.
 * @param {string} url - Der API-Endpunkt (z.B. '/api/admin/users').
 * @param {object} options - Die Konfigurationsoptionen für den Fetch-Aufruf (z.B. method, body).
 * @returns {Promise<any>} - Ein Promise, das die JSON-Antwort des Servers zurückgibt.
 * @throws {Error} - Wirft einen Fehler bei Netzwerkproblemen oder wenn die API 'success: false' zurückgibt.
 */
export async function apiFetch(url, options = {}) {
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');

    const defaultHeaders = {
        'X-Requested-With': 'XMLHttpRequest',
    };

    // Füge das CSRF-Token zu allen POST-Anfragen hinzu, wenn es nicht FormData ist.
    // Bei FormData wird es im Body hinzugefügt.
    if (csrfToken && options.method === 'POST' && !(options.body instanceof FormData)) {
        defaultHeaders['X-CSRF-TOKEN'] = csrfToken;
    }
    // Für GET oder andere Methoden (falls CSRF im Header benötigt wird)
    // else if (csrfToken && options.method !== 'POST') { // Beispiel, anpassen falls nötig
    //     defaultHeaders['X-CSRF-TOKEN'] = csrfToken;
    // }


    // Content-Type nur setzen, wenn es kein FormData ist und einer vorhanden ist
    if (!(options.body instanceof FormData) && options.headers && options.headers['Content-Type']) {
         defaultHeaders['Content-Type'] = options.headers['Content-Type'];
    } else if (!(options.body instanceof FormData) && options.body && typeof options.body === 'string') {
        // Default auf application/json wenn body ein String ist (wahrscheinlich JSON.stringify)
         defaultHeaders['Content-Type'] = 'application/json';
    }


    const config = {
        ...options,
        headers: {
            ...defaultHeaders,
            // Überschreibe mit spezifischen Headern, außer Content-Type bei FormData
            ...(options.headers && !(options.body instanceof FormData) ? options.headers : {}),
        },
    };

    // Füge CSRF-Token zum FormData Body hinzu, falls nötig.
    if (config.body instanceof FormData && csrfToken && options.method === 'POST') {
        if (!config.body.has('_csrf_token')) {
            config.body.append('_csrf_token', csrfToken);
        }
    }


    try {
        const response = await fetch(url, config);

        // Zuerst den Text der Antwort abrufen
        const responseText = await response.text();

        if (!response.ok) {
            // Server hat einen HTTP-Fehlerstatus zurückgegeben (z.B. 400, 403, 500)
            let errorMessage = `Serverfehler: ${response.status}`;
            // Versuchen, eine JSON-Fehlermeldung aus dem Text zu parsen
            try {
                const errorData = JSON.parse(responseText);
                errorMessage = errorData.message || errorMessage;
            } catch (e) {
                // Der Text war kein JSON (z.B. eine HTML-Fehlerseite), verwende den Status-Text
                errorMessage = `Serverfehler: ${response.status} (${response.statusText})`;
                // Bei 404 eine spezifischere Meldung
                if (response.status === 404) {
                    errorMessage = `API-Endpunkt nicht gefunden (404): ${url}`;
                }
            }
            
            // Spezifische Behandlung für 403 CSRF Fehler
            if (response.status === 403 && (errorMessage.includes('CSRF') || errorMessage.includes('Sicherheit') || responseText.includes('CSRF'))) {
                throw new Error("Sicherheitsüberprüfung fehlgeschlagen. Bitte laden Sie die Seite neu und versuchen Sie es erneut.");
            }
            throw new Error(errorMessage);
        }

        // Response war OK (2xx), jetzt versuchen wir zu parsen
        let data;
        try {
            data = JSON.parse(responseText);
        } catch (e) {
            // Response war 200 OK, aber der Body war KEIN JSON
            // (Sehr wahrscheinlich ein PHP-Notice/Warning)
            console.error("API-Antwort war kein gültiges JSON:", responseText);
            throw new Error(`Ungültige JSON-Antwort vom Server erhalten. (Möglicherweise ein PHP-Fehler). Antwort-Anfang: ${responseText.substring(0, 100)}...`);
        }


        if (data.success === false) {
            // Die API meldet einen Anwendungsfehler (z.B. ungültige Eingabe)
            throw new Error(data.message || 'Ein unbekannter Anwendungsfehler ist aufgetreten.');
        }

        return data;

    } catch (error) {
        // Zeigt dem Benutzer eine Fehlermeldung an und leitet den Fehler weiter
        console.error('API Fehler:', error);
        // Verwende die importierte Funktion direkt
        showToast(error.message, 'error');

        // Wirft den Fehler erneut, damit aufrufende try/catch-Blöcke darauf reagieren können
        throw error;
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\api-client.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard-community.js ---
// public/assets/js/dashboard-community.js
import { apiFetch } from './api-client.js';
import { showToast } from './notifications.js';
import { escapeHtml } from './planer-utils.js';

/**
 * Initialisiert die Funktionen des Schwarzen Bretts im Dashboard.
 */
export function initializeDashboardCommunity() {
    const section = document.getElementById('section-community-board');
    if (!section) return;

    const form = document.getElementById('community-post-form');
    const titleInput = document.getElementById('post-title');
    const contentInput = document.getElementById('post-content');
    const createButton = document.getElementById('create-post-btn');
    const postSpinner = document.getElementById('post-create-spinner');
    const postListContainer = document.getElementById('community-posts-list');
    
    let hasLoaded = false; // Status-Flag, ob Daten schon geladen wurden

    // 1. Beiträge laden
    const loadCommunityPosts = async () => {
        // KORREKTUR: Nur laden, wenn noch nicht geladen
        if (hasLoaded) return; 
        
        hasLoaded = true; // Sofort als "Ladevorgang gestartet" markieren
        postListContainer.innerHTML = '<div class="loading-spinner"></div>';
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/posts`);
            if (response.success && response.data) {
                renderPosts(response.data);
            } else {
                throw new Error(response.message || 'Beiträge konnten nicht geladen werden.');
            }
        } catch (error) {
            console.error("Fehler beim Laden der Community-Beiträge:", error);
            postListContainer.innerHTML = `<p class="message error">${escapeHtml(error.message)}</p>`;
            hasLoaded = false; // Laden erneut erlauben, wenn es fehlgeschlagen ist
        }
    };

    // 2. Beiträge rendern
    const renderPosts = (posts) => {
        if (posts.length === 0) {
            postListContainer.innerHTML = '<p class="message info" style="margin: 0;">Keine Beiträge am Schwarzen Brett vorhanden.</p>';
            return;
        }

        postListContainer.innerHTML = posts.map(post => {
            const contentHtml = post.content_html || '<p><em>Kein Inhalt.</em></p>'; // Verwende vorgerendertes HTML
            const postDate = new Date(post.created_at).toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
            
            const authorName = `${escapeHtml(post.first_name)} ${escapeHtml(post.last_name[0])}.`;
            const emailLink = post.email 
                ? `(<a href="mailto:${escapeHtml(post.email)}" title="E-Mail an ${escapeHtml(post.first_name)}">${escapeHtml(post.username)}</a>)`
                : `(${escapeHtml(post.username)})`;

            return `
            <div class="community-post-item" data-id="${post.post_id}">
                <div class="post-header">
                    <strong class="post-title">${escapeHtml(post.title)}</strong>
                    <span class="post-meta">
                        Von: ${authorName} ${emailLink}
                        <br>
                        Am: ${postDate} Uhr
                    </span>
                </div>
                <div class="post-content-preview">
                    ${contentHtml}
                </div>
            </div>
            `;
        }).join('');
    };

    // 3. Formular-Handler
    if (form) {
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const title = titleInput.value.trim();
            const content = contentInput.value.trim();

            if (!title || !content) {
                showToast("Titel und Inhalt dürfen nicht leer sein.", "error");
                return;
            }

            createButton.disabled = true;
            postSpinner.style.display = 'block';

            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/posts/create`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title, content })
                });

                if (response.success) {
                    showToast(response.message, 'success');
                    form.reset(); // Formular leeren
                    // Wenn der Beitrag sofort freigeschaltet wurde, Liste neu laden
                    if (response.status === 'approved') {
                        hasLoaded = false; // Erzwinge Neuladen der Liste
                        loadCommunityPosts();
                    }
                }
                // Fehler werden von apiFetch als Toast angezeigt
            } catch (error) {
                console.error("Fehler beim Erstellen des Beitrags:", error);
            } finally {
                createButton.disabled = false;
                postSpinner.style.display = 'none';
            }
        });
    }

    // 4. KORRIGIERTES Laden (Lazy Loading)
    const tabButton = document.querySelector('.tab-button[data-target="section-community-board"]');
    
    if (tabButton) {
        // Diese Funktion wird aufgerufen, wenn der Tab geklickt wird (von dashboard.js)
        const loadOnVisible = () => {
            // Prüft, ob der Tab aktiv ist (von dashboard.js gesetzt) UND ob noch nicht geladen wurde
            if (section.classList.contains('active') && !hasLoaded) {
                loadCommunityPosts();
            }
        };

        // Fügt einen Listener hinzu, falls der Tab später erneut geklickt wird
        tabButton.addEventListener('click', loadOnVisible);

        // KORREKTUR: Prüfe sofort, ob der Tab bereits aktiv ist.
        // (Die dashboard.js-Tablogik setzt 'active' *bevor* sie initializeDashboardCommunity aufruft)
        if (section.classList.contains('active')) {
            loadOnVisible();
        }
        
    } else {
        // Fallback, falls die Tab-Logik fehlschlägt
        loadCommunityPosts();
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard-community.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard-my-posts.js ---
// public/assets/js/dashboard-my-posts.js
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js';
import { escapeHtml } from './planer-utils.js'; // Stellt sicher, dass diese Hilfsfunktion existiert

/**
 * Initialisiert die "Meine Beiträge"-Sektion im Dashboard.
 */
export function initializeMyCommunityPosts() {
    const section = document.getElementById('section-my-posts');
    if (!section) return;

    const postListContainer = document.getElementById('my-posts-list');
    const postModal = document.getElementById('my-post-edit-modal');
    const postForm = document.getElementById('my-post-edit-form');
    const postTitleInput = document.getElementById('edit-post-title');
    const postContentInput = document.getElementById('edit-post-content');
    const postIdInput = document.getElementById('edit-post-id');
    const postSpinner = document.getElementById('edit-post-spinner');
    const cancelEditBtn = document.getElementById('my-post-modal-cancel-btn');
    const closeEditBtn = document.getElementById('my-post-modal-close-btn');

    let hasLoaded = false;
    let isSaving = false;

    /**
     * Lädt die Beiträge des Benutzers.
     */
    const loadMyPosts = async () => {
        if (hasLoaded) return; // Nur einmal laden, es sei denn, es wird explizit neu geladen
        hasLoaded = true;

        if (!postListContainer) return;
        postListContainer.innerHTML = '<div class="loading-spinner"></div>';

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/my-posts`);
            if (response.success && response.data) {
                renderMyPosts(response.data);
            } else {
                throw new Error(response.message || 'Beiträge konnten nicht geladen werden.');
            }
        } catch (error) {
            console.error("Fehler beim Laden meiner Beiträge:", error);
            if (postListContainer) {
                postListContainer.innerHTML = `<p class="message error">${escapeHtml(error.message)}</p>`;
            }
            hasLoaded = false; // Erlaube erneutes Laden bei Fehler
        }
    };

    /**
     * Rendert die Liste der Beiträge.
     * @param {Array} posts - Array von Post-Objekten.
     */
    const renderMyPosts = (posts) => {
        if (!postListContainer) return;
        if (posts.length === 0) {
            postListContainer.innerHTML = '<p class="message info" style="margin: 0;">Du hast noch keine Beiträge erstellt.</p>';
            return;
        }

        // KORRIGIERTES STYLING (flexibel)
        postListContainer.innerHTML = posts.map(post => {
            const postDate = new Date(post.created_at).toLocaleString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' }) + ' Uhr';
            const contentHtml = post.content_html || '<p><em>Kein Inhalt.</em></p>';
            
            let statusClass = '';
            let statusText = '';
            switch (post.status) {
                case 'pending':
                    statusClass = 'status-pending';
                    statusText = 'Ausstehend';
                    break;
                case 'approved':
                    statusClass = 'status-approved';
                    statusText = 'Genehmigt';
                    break;
                case 'rejected':
                    statusClass = 'status-rejected';
                    statusText = 'Abgelehnt';
                    break;
            }

            return `
                <div class="community-post-item my-post-item" data-id="${post.post_id}" data-title="${escapeHtml(post.title)}" data-content="${escapeHtml(post.content)}">
                    <div class="post-content-preview">
                        <strong class="post-title">${escapeHtml(post.title)}</strong>
                        ${contentHtml}
                    </div>
                    <div class="my-post-meta">
                        <div class="post-status">
                            <span>Erstellt am: ${postDate}</span>
                            <span class="status-badge ${statusClass}">${statusText}</span>
                        </div>
                        <div class="post-actions">
                            <button class="btn btn-secondary btn-small edit-my-post-btn">Bearbeiten</button>
                            <button class="btn btn-danger btn-small delete-my-post-btn">Löschen</button>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    };

    /**
     * Öffnet das Bearbeiten-Modal und füllt es.
     * @param {HTMLElement} postItem - Das angeklickte Beitrags-Element.
     */
    const openEditModal = (postItem) => {
        if (!postModal) return;
        
        // Daten aus data-Attributen holen (sicherer gegen XSS als innerHTML)
        const id = postItem.dataset.id;
        const title = postItem.dataset.title;
        const content = postItem.dataset.content; // Roh-Markdown holen

        postIdInput.value = id;
        postTitleInput.value = title;
        postContentInput.value = content;
        
        postModal.classList.add('visible');
        postTitleInput.focus();
    };

    /**
     * Schließt das Bearbeiten-Modal.
     */
    const closeEditModal = () => {
        if (postModal) {
            postModal.classList.remove('visible');
            postForm.reset();
            postIdInput.value = '';
            postSpinner.style.display = 'none';
            postForm.querySelector('button[type="submit"]').disabled = false;
        }
    };

    /**
     * Behandelt das Speichern (Aktualisieren) eines Beitrags.
     * @param {Event} e - Das Submit-Event.
     */
    const handleUpdatePost = async (e) => {
        e.preventDefault();
        if (isSaving) return;

        const id = postIdInput.value;
        const title = postTitleInput.value.trim();
        const content = postContentInput.value.trim();

        if (!id || !title || !content) {
            showToast("Titel und Inhalt dürfen nicht leer sein.", "error");
            return;
        }

        isSaving = true;
        postSpinner.style.display = 'block';
        postForm.querySelector('button[type="submit"]').disabled = true;

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/post/update`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ post_id: id, title: title, content: content })
            });

            if (response.success) {
                showToast(response.message, 'success');
                closeEditModal();
                hasLoaded = false; // Erzwinge Neuladen der Liste, um Status zu aktualisieren
                loadMyPosts();
            }
            // Fehler wird von apiFetch als Toast angezeigt
        } catch (error) {
            console.error("Fehler beim Aktualisieren des Beitrags:", error);
            // Fehler-Toast wird bereits von apiFetch angezeigt
        } finally {
            isSaving = false;
            postSpinner.style.display = 'none';
            // Button wird im closeEditModal() wieder aktiviert
        }
    };

    /**
     * Behandelt das Löschen eines Beitrags.
     * @param {HTMLElement} postItem - Das Beitrags-Element.
     */
    const handleDeletePost = async (postItem) => {
        const id = postItem.dataset.id;
        const title = postItem.dataset.title;

        if (await showConfirm("Beitrag löschen", `Möchtest du deinen Beitrag "${escapeHtml(title)}" wirklich endgültig löschen?`)) {
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/community/post/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ post_id: id })
                });

                if (response.success) {
                    showToast(response.message, 'success');
                    // Beitrag aus der Liste entfernen
                    postItem.style.transition = 'opacity 0.3s ease, height 0.3s ease, margin 0.3s ease, padding 0.3s ease';
                    postItem.style.opacity = '0';
                    postItem.style.height = '0px';
                    postItem.style.paddingTop = '0';
                    postItem.style.paddingBottom = '0';
                    postItem.style.margin = '0';
                    setTimeout(() => {
                        postItem.remove();
                        if (postListContainer.childElementCount === 0) {
                            renderMyPosts([]);
                        }
                    }, 300);
                }
                // Fehler wird von apiFetch angezeigt
            } catch (error) {
                console.error("Fehler beim Löschen des Beitrags:", error);
            }
        }
    };

    // --- Event Listeners ---

    // Event Delegation für Bearbeiten- und Löschen-Buttons
    postListContainer.addEventListener('click', (e) => {
        const editButton = e.target.closest('.edit-my-post-btn');
        const deleteButton = e.target.closest('.delete-my-post-btn');
        
        if (editButton) {
            const postItem = editButton.closest('.my-post-item');
            if (postItem) openEditModal(postItem);
            return;
        }
        
        if (deleteButton) {
            const postItem = deleteButton.closest('.my-post-item');
            if (postItem) handleDeletePost(postItem);
            return;
        }
    });

    // Formular-Speichern
    if (postForm) {
        postForm.addEventListener('submit', handleUpdatePost);
    }

    // Modal schließen
    if (cancelEditBtn) {
        cancelEditBtn.addEventListener('click', closeEditModal);
    }
    if (closeEditBtn) {
        closeEditBtn.addEventListener('click', closeEditModal);
    }
    if (postModal) {
        postModal.addEventListener('click', (e) => {
            if (e.target.id === 'my-post-edit-modal') {
                closeEditModal();
            }
        });
    }

    // Tab-Lazy-Loading (wird von dashboard.js gesteuert)
    const tabButton = document.querySelector('.tab-button[data-target="section-my-posts"]');
    if (tabButton) {
        const loadOnVisible = () => {
            if (section.classList.contains('active') && !hasLoaded) {
                loadMyPosts();
            }
        };
        // Beim Klick auf den Tab (wird von dashboard.js gehandhabt)
        tabButton.addEventListener('click', loadOnVisible);
        // Beim Initial-Load (falls der Tab bereits aktiv ist, obwohl das nicht der Standard sein sollte)
        if (section.classList.contains('active')) {
            loadOnVisible();
        }
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard-my-posts.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard.js ---
// public/assets/js/dashboard.js
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js';
import { escapeHtml } from './planer-utils.js';
// NEU: Importiere die Lazy-Loading-Funktion für "Meine Beiträge"
import { initializeMyCommunityPosts } from './dashboard-my-posts.js';


/**
 * Helper function to get week and year for a date according to ISO 8601.
 * @param {Date} date - The date object.
 * @returns {{week: number, year: number}} - Calendar week and year.
 */
function getWeekAndYear(date) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    return { week: weekNo, year: d.getUTCFullYear() };
}

/**
 * Gets the date of the Monday of a given calendar week and year.
 * @param {number} week - The calendar week.
 * @param {number} year - The year.
 * @returns {Date} The Date object for Monday (local time).
*/
function getDateOfISOWeek(week, year) {
    const simple = new Date(Date.UTC(year, 0, 1 + (week - 1) * 7));
    const dow = simple.getUTCDay();
    const ISOweekStart = simple;
    ISOweekStart.setUTCDate(simple.getUTCDate() - (dow || 7) + 1);
    return new Date(ISOweekStart.getUTCFullYear(), ISOweekStart.getUTCMonth(), ISOweekStart.getUTCDate());
}

/**
 * Formats a time slot index (1-based) into HH:MM (start time).
 * @param {number} period - The period number (1 to 10).
 * @returns {string} Formatted time string like "08:00".
 */
function formatTimeSlot(period) {
    const times = [
        "08:00", "08:55", "09:40", "10:35", "11:20",
        "13:05", "13:50", "14:45", "15:30", "16:25"
    ];
    return times[period - 1] || '??:??';
}

/**
 * Formats a YYYY-MM-DD Datum in ein lesbares deutsches Format.
 * @param {string} dateString - YYYY-MM-DD
 * @returns {string} TT.MM.YYYY
 */
function formatGermanDate(dateString) {
    if (!dateString) return '';
    try {
        const parts = dateString.split('-');
        if (parts.length === 3) {
            return `${parts[2]}.${parts[1]}.${parts[0]}`;
        }
        return dateString;
    } catch(e) {
        return dateString;
    }
}
/**
 * Formatiert HH:MM:SS zu HH:MM.
 * @param {string} timeString - HH:MM:SS
 * @returns {string} HH:MM
 */
function formatShortTime(timeString) {
    if (!timeString) return '';
    const parts = timeString.split(':');
    if (parts.length >= 2) {
        return `${parts[0]}:${parts[1]}`;
    }
    return timeString;
}

// NEU: Globaler State für Dashboard-Daten (Stammdaten, Pläne)
const dashboardState = {
    stammdaten: null,
    currentTimetable: [],
    currentSubstitutions: [],
    studentNotes: {}, // NEU: Objekt für Notizen
    currentPublishStatus: { student: false, teacher: false }
    // currentViewMode, selectedClassId, etc. werden in planer-state.js verwaltet,
    // aber wir brauchen sie hier nicht, da das Dashboard seine eigene Logik hat.
};

// --- Module-Level Constants (MOVED HERE) ---
const days = ["Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag"];
const timeSlotsDisplay = [
     "08:00 - 08:45", "08:55 - 09:40", "09:40 - 10:25", "10:35 - 11:20",
     "11:20 - 12:05", "13:05 - 13:50", "13:50 - 14:35", "14:45 - 15:30",
     "15:30 - 16:15", "16:25 - 17:10"
];
// --- Module-Level DOM Elements & Constants (MOVED HERE) ---
const userRole = window.APP_CONFIG.userRole;
const today = new Date();
const todayDateString = today.toISOString().split('T')[0];
const todayDayOfWeek = (today.getDay() === 0) ? 7 : today.getDay(); // 1=Mo

// --- DOM Elements (defined at module scope) ---
const yearSelector = document.getElementById('year-selector');
const weekSelector = document.getElementById('week-selector');
const planHeaderInfo = document.getElementById('plan-header-info');
const timetableContainer = document.getElementById('timetable-container');
const announcementsList = document.getElementById('announcements-list');
const todayScheduleContainer = document.getElementById('today-schedule-container');
const icalUrlInput = document.getElementById('ical-url');
const copyIcalUrlButton = document.getElementById('copy-ical-url');
const pdfButton = document.getElementById('export-pdf-btn');
const printableSection = document.getElementById('weekly-timetable-section-printable');
const detailModal = document.getElementById('plan-detail-modal');
const detailCloseBtn = document.getElementById('plan-detail-close-btn');
const noteRow = document.getElementById('detail-notes-row');
const noteInput = document.getElementById('detail-notes-input');
const noteSaveBtn = document.getElementById('plan-detail-save-note-btn');
const noteSpinner = document.getElementById('note-save-spinner');

/**
 * Loads and renders announcements into the sidebar, now using content_html.
 */
const loadAnnouncements = async () => {
    if (!announcementsList) return;
    announcementsList.innerHTML = '<div class="loading-spinner"></div>';
    try {
        const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/announcements`);
        if (response.success && response.data) {
            if (response.data.length === 0) {
                announcementsList.innerHTML = '<p class="message info" style="padding: 20px; margin: 0; text-align: center;">Keine aktuellen Ankündigungen.</p>';
                return;
            }
            announcementsList.style.padding = '0';
            announcementsList.innerHTML = response.data.map(item => {
                let targetInfo = '';
                let visibilityText = item.is_global ? 'Global' : 'Klasse';
                let badgeClass = item.is_global ? 'global' : 'class';
                if (!item.is_global && item.target_class_name) {
                    targetInfo = ` (Klasse: ${escapeHtml(item.target_class_name)})`;
                }

                const attachmentLink = item.file_url
                    ? `<p class="announcement-attachment"><a href="${escapeHtml(item.file_url)}" target="_blank" download>📎 Anhang herunterladen</a></p>`
                    : '';

                const contentHtml = item.content_html || '<p><em>Kein Inhalt.</em></p>';

                return `
                <div class="announcement-item">
                    <div class="announcement-header">
                        <div class="announcement-title-meta">
                            <strong>${escapeHtml(item.title)}</strong> <small>Von ${escapeHtml(item.author_name)}${targetInfo} • ${new Date(item.created_at).toLocaleDateString('de-DE')}</small>
                        </div>
                        <span class="announcement-badge ${badgeClass}">${visibilityText}</span>
                    </div>
                    <div class="announcement-content"> ${contentHtml} </div>
                    ${attachmentLink}
                </div>
                `;
            }).join('');
        } else {
            throw new Error(response.message || "Ankündigungen konnten nicht geladen werden.");
        }
    } catch (error) {
        console.error("Announcement loading error:", error);
        announcementsList.innerHTML = `<p class="message error" style="margin: 20px;">${error.message || 'Ankündigungen konnten nicht geladen werden.'}</p>`;
    }
};

/**
 * Populates year and week selector dropdowns.
 */
const populateSelectors = () => {
    if (!yearSelector || !weekSelector) return; 
    const currentYear = new Date().getFullYear();
    let yearOptions = '';
    for (let i = currentYear - 1; i <= currentYear + 1; i++) {
        yearOptions += `<option value="${i}">${i}</option>`;
    }
    yearSelector.innerHTML = yearOptions;

    let weekOptions = '';
    for (let i = 1; i <= 53; i++) {
        weekOptions += `<option value="${i}">KW ${i}</option>`;
    }
    weekSelector.innerHTML = weekOptions;

    const { week, year } = getWeekAndYear(today);
    yearSelector.value = year;
    weekSelector.value = week;
};

/**
 * Loads all data for the selected week and renders both weekly and daily views.
 */
const loadAndRenderWeeklyData = async () => {
    if (!yearSelector || !weekSelector) return; 
    
    const year = yearSelector.value;
    const week = weekSelector.value;

    timetableContainer.innerHTML = '<div class="loading-spinner"></div>';
    if (todayScheduleContainer) {
        todayScheduleContainer.innerHTML = '<div class="loading-spinner small"></div>';
    }

    const monday = getDateOfISOWeek(Number(week), Number(year));
    const friday = new Date(monday.getTime() + 4 * 24 * 60 * 60 * 1000);
    planHeaderInfo.textContent = `Stundenplan für die ${week}. Kalenderwoche (${monday.toLocaleDateString('de-DE')} - ${friday.toLocaleDateString('de-DE')})`;

    let timetable = [];
    let substitutions = [];
    let academicEvents = [];
    let appointments = [];
    let studentNotes = {}; // NEU: Notizen hier empfangen

    try {
        // --- Schritt 1: Plandaten & Termine (Kritisch) ---
        const planUrl = `${window.APP_CONFIG.baseUrl}/api/dashboard/weekly-data?year=${year}&week=${week}`;
        const planResponse = await apiFetch(planUrl);
        
        if (!planResponse.success || !planResponse.data) {
            throw new Error(planResponse.message || "Plandaten konnten nicht geladen werden.");
        }

        timetable = planResponse.data.timetable || [];
        substitutions = planResponse.data.substitutions || [];
        appointments = planResponse.data.appointments || [];
        studentNotes = (userRole === 'schueler') ? (planResponse.data.studentNotes || {}) : {}; // NEU

        
        // NEU: Daten im globalen State speichern
        dashboardState.currentTimetable = timetable;
        dashboardState.currentSubstitutions = substitutions;
        dashboardState.studentNotes = studentNotes; // NEU

        // --- Schritt 2: Wochenplan sofort rendern ---
        renderWeeklyTimetable(timetable, substitutions, studentNotes); // NEU: Notizen übergeben

        // --- Schritt 3: Events (Zusätzlich, nur für Schüler) ---
        if (userRole === 'schueler') {
            try {
                const eventsUrl = `${window.APP_CONFIG.baseUrl}/api/student/events?year=${year}&week=${week}`;
                const eventsResponse = await apiFetch(eventsUrl);
                if (eventsResponse.success && eventsResponse.data) {
                    academicEvents = eventsResponse.data;
                } else {
                    console.warn("Zusatz-Events (Aufgaben/Klausuren) konnten nicht geladen werden:", eventsResponse.message || "Unbekannter Fehler");
                }
            } catch (eventError) {
                console.error("Fehler beim Laden der Events:", eventError);
            }
        }

        // --- Schritt 4: "Mein Tag" rendern (mit Plandaten, Events UND Terminen) ---
        renderTodaySchedule(timetable, substitutions, academicEvents, appointments, studentNotes); // NEU: Notizen übergeben

    } catch (error) { 
        console.error("Fehler beim Laden der Wochendaten (kritisch):", error);
        timetableContainer.innerHTML = `<p class="message error">${error.message || 'Der Wochenplan konnte nicht geladen werden.'}</p>`;
        if (todayScheduleContainer) {
            todayScheduleContainer.innerHTML = `<p class="message error small">Heutiger Plan nicht verfügbar.</p>`;
        }
    }
};

/**
 * Extracts and renders today's schedule into the "Mein Tag" container.
 */
const renderTodaySchedule = (weeklyTimetable, weeklySubstitutions, academicEvents, appointments, studentNotes) => {
    if (!todayScheduleContainer) return;

    const currentDayNum = todayDayOfWeek;
    if (currentDayNum < 1 || currentDayNum > 5) {
        todayScheduleContainer.innerHTML = '<p class="message info" style="padding: 10px; margin: 0;">Heute ist kein Schultag. Genieße die freie Zeit! 🎉</p>';
        return;
    }

    // A. Ermittle die aktuelle Zeit in HHMM (z.B. 1030 für 10:30)
    const PERIOD_END_TIMES = [
        845, 940, 1025, 1120, 1205, // Vormittag
        1350, 1435, 1530, 1615, 1710  // Nachmittag (basierend auf Standard-Definition)
    ];
    const now = new Date();
    // Hole die Zeit in der korrekten Zeitzone (Europe/Berlin)
    const timeFormatter = new Intl.DateTimeFormat('de-DE', {
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'Europe/Berlin', 
        hour12: false
    });
    const parts = timeFormatter.format(now).split(':'); // z.B. ["11", "21"]
    const currentHHMM = parseInt(parts[0], 10) * 100 + parseInt(parts[1], 10); // z.B. 1121


    const todaysEntries = weeklyTimetable.filter(entry => entry.day_of_week == currentDayNum);
    const todaysSubstitutions = weeklySubstitutions.filter(sub => sub.date === todayDateString);
    const todaysEvents = (academicEvents || []).filter(event => event.due_date === todayDateString);
    const todaysAppointments = (appointments || []).filter(app => app.appointment_date === todayDateString);

    let combinedSchedule = [];

    // 1. Reguläre Einträge und Vertretungen
    for (let period = 1; period <= timeSlotsDisplay.length; period++) {
        const periodEndTime = PERIOD_END_TIMES[period - 1]; // z.B. 845

        // *** NEUE FILTERLOGIK: Überspringe, wenn die Stunde vorbei ist ***
        if (currentHHMM > periodEndTime) {
            continue; 
        }
        // *** ENDE NEUE LOGIK ***

        const substitution = todaysSubstitutions.find(sub => sub.period_number === period);
        const regularEntry = todaysEntries.find(entry => entry.period_number === period);
        const noteKey = `${todayDayOfWeek}-${period}`; // NEU
        const note = studentNotes[noteKey] || ''; // NEU

        if (substitution) {
            combinedSchedule.push({
                sortKey: period * 10,
                period: period,
                time: formatTimeSlot(period),
                type: substitution.substitution_type,
                id: substitution.substitution_id, // ID für ICS-Link (Sonderevent)
                class_id: substitution.class_id, // HINZUGEFÜGT
                subject: substitution.new_subject_shortcut || regularEntry?.subject_shortcut || (substitution.substitution_type === 'Sonderevent' ? 'EVENT' : '---'),
                mainText: substitution.substitution_type === 'Vertretung'
                    ? (userRole === 'teacher' ? (substitution.class_name || regularEntry?.class_name) : substitution.new_teacher_shortcut)
                    : (substitution.substitution_type === 'Entfall' ? '' : (regularEntry ? (userRole === 'schueler' ? regularEntry.teacher_shortcut : regularEntry.class_name) : '')),
                room: substitution.new_room_name || regularEntry?.room_name || '',
                comment: substitution.comment || '',
                note: note, // NEU
                icsType: (substitution.substitution_type === 'Sonderevent') ? 'sub' : null // ICS-Typ für Sonderevent
            });
        } else if (regularEntry) {
            combinedSchedule.push({
                sortKey: period * 10,
                period: period,
                time: formatTimeSlot(period),
                type: 'regular',
                id: regularEntry.entry_id,
                class_id: regularEntry.class_id, // HINZUGEFÜGT
                subject: regularEntry.subject_shortcut || '---',
                mainText: userRole === 'schueler' ? regularEntry.teacher_shortcut : regularEntry.class_name,
                room: regularEntry.room_name || '---',
                comment: regularEntry.comment || '',
                note: note, // NEU
                icsType: null
            });
        }
    }
    
    // 2. Klausuren/Aufgaben (Ganztägig - werden immer angezeigt)
    todaysEvents.forEach(event => {
        combinedSchedule.push({
            sortKey: 1, // Ganztägig, an den Anfang
            time: 'Ganztägig',
            type: event.event_type,
            subject: event.title,
            mainText: event.subject_shortcut || (userRole === 'schueler' ? `${event.teacher_first_name} ${event.teacher_last_name}` : ''),
            room: '',
            comment: event.description || '',
            note: '', // NEU (Keine Notizen für Events)
            id: event.event_id, // ID für ICS-Link
            icsType: 'acad' // Typ für ICS-Link
        });
    });

    // 3. Sprechstunden (Termine)
    todaysAppointments.forEach(app => {
        const appTime = formatShortTime(app.appointment_time);
        const sortKeyTime = parseInt(appTime.replace(':', ''), 10); // z.B. 1400

        // *** NEUE FILTERLOGIK für Termine (Sprechstunden) ***
        const timeParts = app.appointment_time.split(':'); // "14:00:00"
        const duration = parseInt(app.duration, 10) || 15; // z.B. 15
        
        if (timeParts.length >= 2) {
            const startH = parseInt(timeParts[0], 10);
            const startM = parseInt(timeParts[1], 10);
            
            // Simuliere das Enddatum
            const endM = startM + duration; // z.B. 0 + 15 = 15
            const endH = startH + Math.floor(endM / 60); // z.B. 14 + 0 = 14
            const finalEndM = endM % 60; // z.B. 15
            
            const endHHMM = (endH * 100) + finalEndM; // z.B. 1400 + 15 = 1415

            if (currentHHMM > endHHMM) {
                return; // Dieser Termin ist vorbei, überspringe ihn
            }
        }
        // *** ENDE NEUE LOGIK ***

        // NEU: mainText mit ID für Lehrer
        let mainText = '';
        if (userRole === 'lehrer') {
            mainText = app.class_name 
                ? `Klasse: ${escapeHtml(app.class_name)} (ID: ${escapeHtml(app.class_id)})` 
                : 'Schüler';
        }

        combinedSchedule.push({
            sortKey: sortKeyTime,
            time: appTime,
            type: 'appointment',
            class_id: app.class_id, // HINZUGEFÜGT
            subject: userRole === 'schueler' ? `Sprechstunde (${escapeHtml(app.teacher_shortcut || app.teacher_name)})` : `Sprechstunde (${escapeHtml(app.student_name)})`,
            mainText: mainText, // Verwendet die neue Variable
            room: 'Sprechzimmer',
            comment: app.notes || '',
            note: '', // NEU (Keine Notizen für Termine)
            id: app.appointment_id,
            icsType: null 
        });
    });

    combinedSchedule.sort((a, b) => a.sortKey - b.sortKey);

    if (combinedSchedule.length === 0) {
        todayScheduleContainer.innerHTML = '<p class="message info" style="padding: 10px; margin: 0;">Für heute sind keine Einträge (mehr) vorhanden.</p>';
        return;
    }

    // SVG-Icon für den Kalender-Download
    const icsIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M14 0H2a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2M2 1a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v1H2zM14 15H2a1 1 0 0 1-1-1V5h14v9a1 1 0 0 1-1 1M9 7.5a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5zM6.5 9a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5m-3 2a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-1a.5.5 0 0 1-.5-.5z"/></svg>`;
    // NEU: SVG-Icon für Notiz
    const noteIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 0A1.5 1.5 0 0 0 0 1.5V13a1 1 0 0 0 1 1V1.5a.5.5 0 0 1 .5-.5H14a1 1 0 0 0-1-1zM3.5 2A1.5 1.5 0 0 0 2 3.5v11A1.5 1.5 0 0 0 3.5 16h9a1.5 1.5 0 0 0 1.5-1.5v-11A1.5 1.5 0 0 0 12.5 2zM3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5z"/></svg>`;


    todayScheduleContainer.innerHTML = combinedSchedule.map(item => {
        const typeClass = `type-${item.type.replace(' ', '')}`;
        
        // NEU: Kombiniere Kommentar und Notiz
        let commentHtml = '';
        if (item.comment) {
            commentHtml += `<small class="entry-comment" title="${escapeHtml(item.comment)}">📝 ${escapeHtml(item.comment)}</small>`;
        }
        if (item.note) {
            commentHtml += `<small class="entry-note" title="${escapeHtml(item.note)}">${noteIcon} ${escapeHtml(item.note)}</small>`;
        }

        
        let detailsHtml = `<strong>${escapeHtml(item.subject)}</strong>`;
        if(item.mainText && item.type !== 'Entfall') {
            // ▼▼▼ HIER IST DIE ÄNDERUNG FÜR "MEIN TAG" ▼▼▼
            if (userRole === 'lehrer' && item.type !== 'appointment' && item.class_id) {
                detailsHtml += `<span>${escapeHtml(item.mainText)} (ID: ${escapeHtml(item.class_id)})</span>`;
            } else {
                detailsHtml += `<span>${escapeHtml(item.mainText)}</span>`;
            }
            // ▲▲▲ ENDE DER ÄNDERUNG ▲▲▲
        }
        if(item.room && item.type !== 'Entfall') detailsHtml += `<span>${escapeHtml(item.room)}</span>`;

        let actionButton = '';
        if (item.type === 'appointment') {
            actionButton = `<button class="btn btn-danger btn-small cancel-appointment-btn" data-id="${item.id}" title="Termin stornieren">&times;</button>`;
        }

        let icsButtonHtml = '';
        if (item.icsType === 'acad') { // Für Aufgaben, Klausuren, Infos
            const icsUrl = `${window.APP_CONFIG.baseUrl}/ics/event/acad/${item.id}`;
            icsButtonHtml = `<a href="${icsUrl}" class="btn-ics" title="Zum Kalender hinzufügen">${icsIcon}</a>`;
        } else if (item.icsType === 'sub') { // Für Sonderevents
            const icsUrl = `${window.APP_CONFIG.baseUrl}/ics/event/sub/${item.id}`;
            icsButtonHtml = `<a href="${icsUrl}" class="btn-ics" title="Zum Kalender hinzufügen">${icsIcon}</a>`;
        }

        return `
        <div class="today-entry ${typeClass}">
            <div class="time">${escapeHtml(item.time)}</div>
            <div class="details">
                ${detailsHtml}
                ${commentHtml}
            </div>
            <div class="entry-actions">
                <span class="type-badge ${typeClass}">${item.type === 'regular' ? 'Plan' : (item.type === 'klausur' ? 'Klausur' : (item.type === 'aufgabe' ? 'Aufgabe' : (item.type === 'info' ? 'Info' : (item.type === 'appointment' ? 'Termin' : item.type))))}</span>
                ${icsButtonHtml}
                ${actionButton}
            </div>
        </div>
        `;
    }).join('');

    todayScheduleContainer.querySelectorAll('.cancel-appointment-btn').forEach(btn => {
        btn.addEventListener('click', handleCancelAppointment);
    });
};

/**
 * Renders the weekly timetable grid.
 */
const renderWeeklyTimetable = (weeklyTimetableData, allWeeklySubstitutions, studentNotes) => {
    const processedCellKeys = new Set();
    const blockSpans = new Map();

    // 1. Reguläre Blöcke
    const blocks = new Map();
    weeklyTimetableData.forEach(entry => {
        if (entry.block_id) {
            if (!blocks.has(entry.block_id)) blocks.set(entry.block_id, []);
            blocks.get(entry.block_id).push(entry);
        }
    });
    blocks.forEach(entries => {
        if (entries.length === 0) return;
        entries.sort((a, b) => a.period_number - b.period_number);
        const startEntry = entries[0];
        const span = entries[entries.length - 1].period_number - startEntry.period_number + 1;
        blockSpans.set(`${startEntry.day_of_week}-${startEntry.period_number}`, span);
        for (let i = 1; i < span; i++) {
            processedCellKeys.add(`${startEntry.day_of_week}-${startEntry.period_number + i}`);
        }
    });

    // 2. Vertretungs-Blöcke
    const substitutionBlocks = new Map();
    allWeeklySubstitutions.forEach(sub => {
        if (!sub.day_of_week) return;
        const key = `${sub.date}-${sub.class_id}-${sub.substitution_type}-${sub.comment || ''}-${sub.new_room_id || ''}-${sub.new_teacher_id || ''}-${sub.new_subject_id || ''}`;
        if (!substitutionBlocks.has(key)) substitutionBlocks.set(key, []);
        substitutionBlocks.get(key).push(sub);
    });
    substitutionBlocks.forEach(subs => {
        if (subs.length > 1) { 
            subs.sort((a, b) => a.period_number - b.period_number);
            let isConsecutive = true;
            for (let i = 0; i < subs.length - 1; i++) {
                if (subs[i + 1].period_number !== subs[i].period_number + 1) {
                    isConsecutive = false; break;
                }
            }
            if (isConsecutive) { 
                const startSub = subs[0];
                const span = subs.length;
                const dayNum = startSub.day_of_week;
                if (dayNum) {
                    blockSpans.set(`${dayNum}-${startSub.period_number}`, span);
                    for (let i = 1; i < span; i++) {
                        processedCellKeys.add(`${dayNum}-${startSub.period_number + i}`);
                    }
                }
            }
        }
    });

    // 3. Grid HTML rendern
    let gridHTML = '<div class="timetable-grid">';
    gridHTML += '<div class="grid-header">Zeit</div>';
    days.forEach(day => gridHTML += `<div class="grid-header">${day}</div>`);

    const settings = window.APP_CONFIG.settings || {};
    const startHour = parseInt(settings.default_start_hour, 10) || 1;
    const endHour = parseInt(settings.default_end_hour, 10) || 10;

    timeSlotsDisplay.forEach((slot, index) => {
        const period = index + 1;
        gridHTML += `<div class="grid-header period-header">${slot}</div>`;

        days.forEach((day, dayIndex) => {
            const dayNum = dayIndex + 1; // 1=Mon, ..., 5=Fri
            const cellKey = `${dayNum}-${period}`;
            const noteKey = cellKey; // NEU

            if (processedCellKeys.has(cellKey)) { return; }

            let cellContent = '', cellClass = 'empty', dataAttrs = `data-day="${dayNum}" data-period="${period}"`, style = '';
            const span = blockSpans.get(cellKey);
            if (span) {
                style = `grid-row: span ${span};`;
                cellClass += ' block-start';
            }

            const substitution = allWeeklySubstitutions.find(s => s.day_of_week == dayNum && s.period_number == period);
            const entryToRender = weeklyTimetableData.find(e => e.day_of_week == dayNum && e.period_number == period);
            const note = (userRole === 'schueler' && studentNotes[noteKey]) ? studentNotes[noteKey] : null; // NEU

            dataAttrs = `data-day="${dayNum}" data-period="${period}"`; // Basis-Attribute

            if (substitution) {
                cellClass = `has-entry substitution-${substitution.substitution_type}`;
                dataAttrs += ` data-substitution-id="${substitution.substitution_id}"`;
                if (substitution.comment) dataAttrs += ` data-comment="${escapeHtml(substitution.comment)}"`;
                const regularEntry = entryToRender; 
                if(regularEntry) { // Füge reguläre IDs hinzu, falls vorhanden
                    dataAttrs += ` data-entry-id="${regularEntry.entry_id}"`;
                    if (regularEntry.block_id) dataAttrs += ` data-block-id="${regularEntry.block_id}"`;
                }
                dataAttrs += ` data-class-id="${substitution.class_id}"`; 
                cellContent = createCellEntryHtml(
                    substitution.substitution_type === 'Vertretung'
                        ? (substitution.new_subject_shortcut || regularEntry?.subject_shortcut)
                        : (substitution.substitution_type === 'Sonderevent' ? 'EVENT' : regularEntry?.subject_shortcut),
                    substitution.substitution_type === 'Vertretung'
                        ? (userRole === 'teacher' ? (substitution.class_name || regularEntry?.class_name) : substitution.new_teacher_shortcut)
                        : (substitution.substitution_type === 'Entfall' ? 'Entfällt' : (regularEntry ? (userRole === 'schueler' ? regularEntry.teacher_shortcut : regularEntry.class_name) : '---')),
                    substitution.new_room_name || regularEntry?.room_name,
                    substitution.comment, 
                    substitution.substitution_type,
                    note, // NEU
                    substitution.class_id // HINZUGEFÜGT
                );
            } else if (entryToRender) {
                cellClass = 'has-entry';
                dataAttrs += ` data-entry-id="${entryToRender.entry_id}"`;
                dataAttrs += ` data-class-id="${entryToRender.class_id}"`;
                if (entryToRender.block_id) dataAttrs += ` data-block-id="${entryToRender.block_id}"`;
                const mainText = userRole === 'schueler' ? entryToRender.teacher_shortcut : entryToRender.class_name;
                cellContent += createCellEntryHtml(entryToRender.subject_shortcut, mainText, entryToRender.room_name, entryToRender.comment, null, note, entryToRender.class_id); // NEU + class_id
            } else if (period >= startHour && period <= endHour) {
                // KORREKTUR: Logik für FU
                if (period === startHour || period === endHour) {
                    cellClass = 'default-entry';
                    cellContent = createCellEntryHtml('FU', 'Förderunterricht', '', '', null, null, null); // FU anzeigen
                } else {
                    // Bleibt leer (cellClass = 'empty')
                }
            } else {
                // Außerhalb des Rasters (z.B. Stunde 11, 12)
                // Bleibt leer (cellClass = 'empty')
            }
            
            // NEU: Füge Notiz-Indikator hinzu, wenn Notiz vorhanden ist
            if (note) {
                cellClass += ' has-note';
            }

            gridHTML += `<div class="grid-cell ${cellClass}" ${dataAttrs} style="${style}">${cellContent}</div>`;
        });
    });

    gridHTML += '</div>';
    timetableContainer.innerHTML = gridHTML;
};

/**
 * Helper to create HTML content for a single cell entry.
 */
// ▼▼▼ HIER IST DIE ZWEITE ÄNDERUNG (createCellEntryHtml) ▼▼▼
const createCellEntryHtml = (subject, mainText, room, comment = null, substitutionType = null, note = null, class_id = null) => {
    let commentHtml = comment ? `<small class="entry-comment" title="${escapeHtml(comment)}">📝 ${escapeHtml(comment.substring(0, 15))}${comment.length > 15 ? '...' : ''}</small>` : '';
    let roomHtml = room ? `<small class="entry-room">${escapeHtml(room)}</small>` : '';
    
    // ALT: let mainHtml = mainText ? `<span>${escapeHtml(mainText)}</span>` : '';
    let mainHtml = ''; // NEU
    if (mainText) {
        if (userRole === 'lehrer' && class_id) { // userRole ist global in dashboard.js
            mainHtml = `<span>${escapeHtml(mainText)} (ID: ${escapeHtml(class_id)})</span>`;
        } else {
            mainHtml = `<span>${escapeHtml(mainText)}</span>`;
        }
    }
    
    let subjectHtml = subject ? `<strong>${escapeHtml(subject)}</strong>` : '';
    // NEU: Notiz-Icon (SVG)
    const noteIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M1.5 0A1.5 1.5 0 0 0 0 1.5V13a1 1 0 0 0 1 1V1.5a.5.5 0 0 1 .5-.5H14a1 1 0 0 0-1-1zM3.5 2A1.5 1.5 0 0 0 2 3.5v11A1.5 1.5 0 0 0 3.5 16h9a1.5 1.5 0 0 0 1.5-1.5v-11A1.5 1.5 0 0 0 12.5 2zM3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5z"/></svg>`;
    let noteHtml = (note && userRole === 'schueler') ? `<small class="entry-note" title="${escapeHtml(note)}">${noteIcon}</small>` : '';


    if (substitutionType === 'Entfall') {
        subjectHtml = `<strong>${escapeHtml(subject)}</strong>`;
        mainHtml = `<span>Entfällt</span>`;
        roomHtml = '';
        commentHtml = comment ? `<small class="entry-comment" title="${escapeHtml(comment)}">📝 ${escapeHtml(comment.substring(0, 15))}${comment.length > 15 ? '...' : ''}</small>` : '';
    }
    if (substitutionType === 'Raumänderung') {
        roomHtml = room ? `<small class="entry-room" style="font-weight:bold; color: var(--color-warning);">${escapeHtml(room)}</small>` : '';
    }
    if (substitutionType === 'Sonderevent') {
        subjectHtml = `<strong>EVENT</strong>`;
        const safeComment = escapeHtml(comment);
        mainHtml = safeComment ? `<span title="${safeComment}">${safeComment.substring(0, 20)}${safeComment.length > 20 ? '...' : ''}</span>` : `<span>Sonderveranst.</span>`;
        commentHtml = '';
    }
    
    // KORREKTUR: noteHtml hinzugefügt
    return `<div class="cell-entry">${noteHtml}${subjectHtml}${mainHtml}${roomHtml}${commentHtml}</div>`;
};
// ▲▲▲ ENDE DER ÄNDERUNG (createCellEntryHtml) ▲▲▲

/** Function to handle PDF export by redirecting to server */
const handlePdfExport = () => {
    const year = yearSelector.value;
    const week = weekSelector.value;
    if (!year || !week) {
        showToast("Bitte Jahr und KW auswählen.", 'error');
        return;
    }
    const pdfUrl = `${window.APP_CONFIG.baseUrl}/pdf/timetable/${year}/${week}`;
    window.open(pdfUrl, '_blank');
};

/** Storniert einen Termin */
const handleCancelAppointment = async (e) => {
    const button = e.target.closest('.cancel-appointment-btn');
    if (!button) return;
    
    const appointmentId = button.dataset.id;
    const entryElement = button.closest('.today-entry');
    const title = entryElement.querySelector('.details strong').textContent;

    if (await showConfirm("Termin stornieren", `Möchten Sie den Termin "${escapeHtml(title)}" wirklich stornieren?`)) {
        button.disabled = true;
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/appointment/cancel`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ appointment_id: appointmentId })
            });

            if (response.success) {
                showToast(response.message, 'success');
                entryElement.style.transition = 'opacity 0.3s ease, height 0.3s ease, margin 0.3s ease, padding 0.3s ease';
                entryElement.style.opacity = '0';
                entryElement.style.height = '0px';
                entryElement.style.paddingTop = '0';
                entryElement.style.paddingBottom = '0';
                entryElement.style.margin = '0';
                setTimeout(() => {
                    entryElement.remove();
                    if (todayScheduleContainer && todayScheduleContainer.childElementCount === 0) {
                        renderTodaySchedule([], [], [], [], {});
                    }
                }, 300);
            }
        } catch (error) {
            console.error("Fehler beim Stornieren:", error);
            button.disabled = false;
        }
    }
};


export function initializeDashboard() {
    const container = document.querySelector('.dashboard-wrapper');
    if (!container) return;
    
    // Lade Stammdaten sofort
    dashboardState.stammdaten = window.APP_CONFIG.settings.stammdaten || {
        subjects: [], teachers: [], rooms: [], classes: []
    };

    // --- Event Listeners ---
    if (yearSelector) yearSelector.addEventListener('change', loadAndRenderWeeklyData);
    if (weekSelector) weekSelector.addEventListener('change', loadAndRenderWeeklyData);
    if (pdfButton) pdfButton.addEventListener('click', handlePdfExport);

    if (copyIcalUrlButton && icalUrlInput) {
        copyIcalUrlButton.addEventListener('click', async () => {
            try {
                icalUrlInput.select();
                icalUrlInput.setSelectionRange(0, 99999);
                let copied = false;
                try { copied = document.execCommand('copy'); } catch(err) { copied = false; }
                if (copied) {
                    showToast('iCal URL in Zwischenablage kopiert!', 'success', 2000);
                } else if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(icalUrlInput.value);
                    showToast('iCal URL in Zwischenablage kopiert!', 'success', 2000);
                } else {
                    throw new Error('Copy command failed and Clipboard API not available.');
                }
            } catch (err) {
                console.error('Fehler beim Kopieren der iCal URL: ', err);
                showToast('Kopieren fehlgeschlagen. Bitte manuell kopieren.', 'error');
            }
            if (window.getSelection) { window.getSelection().removeAllRanges(); }
            else if (document.selection) { document.selection.empty(); }
            icalUrlInput.blur();
        });
    }

    // --- Tab-Interface Initialisierung ---
    initializeTabbedInterface();

    // --- Initialisierung des Sprechstunden-Widgets (nur für Schüler) ---
    if (userRole === 'schueler') {
        initializeAppointmentBooking();
    }
    
    // --- NEU: Event-Listener für Wochenplan-Detail-Modal ---
    initializePlanDetailModal(timetableContainer, detailModal, detailCloseBtn, noteRow, noteInput, noteSaveBtn, noteSpinner);

    // --- Initialization ---
    populateSelectors();
    loadAndRenderWeeklyData(); // Lädt "Mein Tag" und "Wochenplan"
    loadAnnouncements(); // Lädt Ankündigungen

    // Hide elements for admin if applicable
    if(userRole === 'admin') {
        const printExportActions = document.querySelector('.print-export-actions');
        if(printExportActions) printExportActions.style.display = 'none';
        const icalBox = document.querySelector('.ical-subscription-box');
        if(icalBox) icalBox.style.display = 'none';
    }
}


/**
 * Initialisiert das Sprechstunden-Buchungs-Widget für Schüler.
 */
function initializeAppointmentBooking() {
    const widget = document.getElementById('appointment-booking-widget');
    if (!widget) return;

    const form = document.getElementById('appointment-booking-form');
    const teacherSearchInput = document.getElementById('teacher-search-input');
    const teacherSearchResults = document.getElementById('teacher-search-results');
    const selectedTeacherIdInput = document.getElementById('selected-teacher-id');
    const datePicker = document.getElementById('appointment-date-picker');
    const slotsContainer = document.getElementById('available-slots-container');
    const notesContainer = document.getElementById('appointment-notes-container');
    const notesInput = document.getElementById('appointment-notes');
    const bookButton = document.getElementById('book-appointment-btn');
    const bookSpinner = document.getElementById('appointment-book-spinner');

    let searchTimeout;
    let selectedSlot = null; 

    datePicker.min = new Date().toISOString().split('T')[0];

    // --- 1. Lehrer-Suche ---
    teacherSearchInput.addEventListener('input', () => {
        clearTimeout(searchTimeout);
        resetSlotSelection();
        datePicker.disabled = true;
        datePicker.value = '';
        selectedTeacherIdInput.value = '';

        const query = teacherSearchInput.value.trim();
        if (query.length < 2) {
            teacherSearchResults.innerHTML = '';
            teacherSearchResults.classList.remove('visible');
            return;
        }

        searchTimeout = setTimeout(async () => {
            try {
                // KORREKTUR: API-Endpunkt angepasst (search-colleagues statt -teachers)
                // KORREKTUR: Sende die Stammdaten-ID (teacher_id), nicht die user_id
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/search-colleagues?query=${encodeURIComponent(query)}`);
                if (response.success && response.data) {
                    const filteredTeachers = response.data.filter(t => t.teacher_shortcut !== 'SGL');
                    if (filteredTeachers.length > 0) {
                        teacherSearchResults.innerHTML = filteredTeachers.map(teacher => {
                            // KORREKTUR: Verwende teacher.teacher_id (Stammdaten-ID)
                            return `
                                <div class="search-result-item" data-id="${teacher.teacher_id}" data-name="${escapeHtml(teacher.first_name)} ${escapeHtml(teacher.last_name)} (${escapeHtml(teacher.teacher_shortcut)})">
                                    <strong>${escapeHtml(teacher.last_name)}, ${escapeHtml(teacher.first_name)}</strong> (${escapeHtml(teacher.teacher_shortcut)})
                                </div>
                            `;
                        }).join('');
                        teacherSearchResults.classList.add('visible');
                    } else {
                        teacherSearchResults.innerHTML = '<div class="search-result-item none">Keine Treffer</div>';
                        teacherSearchResults.classList.add('visible');
                    }
                } else {
                    teacherSearchResults.innerHTML = '<div class="search-result-item none">Keine Treffer</div>';
                    teacherSearchResults.classList.add('visible');
                }
            } catch (error) {
                console.error("Fehler bei Lehrersuche:", error);
                teacherSearchResults.innerHTML = `<div class="search-result-item none">Fehler: ${escapeHtml(error.message)}</div>`;
                teacherSearchResults.classList.add('visible');
            }
        }, 300);
    });

    // --- 2. Lehrer-Auswahl ---
    teacherSearchResults.addEventListener('click', (e) => {
        const item = e.target.closest('.search-result-item');
        if (!item || !item.dataset.id) return;

        selectedTeacherIdInput.value = item.dataset.id; // Speichert die teacher_id (Stammdaten)
        teacherSearchInput.value = item.dataset.name;
        teacherSearchResults.innerHTML = '';
        teacherSearchResults.classList.remove('visible');
        
        datePicker.disabled = false;
        datePicker.focus();
    });

    // --- 3. Datums-Auswahl (lädt Slots) ---
    datePicker.addEventListener('change', async () => {
        resetSlotSelection();
        const teacherId = selectedTeacherIdInput.value; // Dies ist die teacher_id (Stammdaten)
        const date = datePicker.value;

        if (!teacherId || !date) return;
        
        const dayOfWeek = new Date(date + 'T00:00:00').getDay();
        if (dayOfWeek === 0 || dayOfWeek === 6) {
            slotsContainer.innerHTML = '<small class="form-hint error-hint">Sprechstunden finden nur Mo-Fr statt.</small>';
            return;
        }

        slotsContainer.innerHTML = '<div class="loading-spinner small"></div>';
        
        try {
            // KORREKTUR: Sendet teacher_id (Stammdaten-ID)
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/student/available-slots?teacher_id=${teacherId}&date=${date}`);
            if (response.success && response.data) {
                if (response.data.length > 0) {
                    slotsContainer.innerHTML = response.data.map(slot => `
                        <button type="button" class="btn-slot" data-time="${slot.time}" data-duration="${slot.duration}">
                            ${escapeHtml(slot.display)}
                        </button>
                    `).join('');
                } else {
                    slotsContainer.innerHTML = '<small class="form-hint">Keine freien Termine an diesem Tag.</small>';
                }
            } else {
                throw new Error(response.message || 'Fehler beim Laden der Slots.');
            }
        } catch (error) {
            slotsContainer.innerHTML = `<small class="form-hint error-hint">${escapeHtml(error.message)}</small>`;
        }
    });

    // --- 4. Slot-Auswahl ---
    slotsContainer.addEventListener('click', (e) => {
        const button = e.target.closest('.btn-slot');
        if (!button) return;

        slotsContainer.querySelectorAll('.btn-slot').forEach(btn => btn.classList.remove('selected'));
        
        button.classList.add('selected');
        selectedSlot = {
            time: button.dataset.time,
            duration: button.dataset.duration
        };
        
        notesContainer.style.display = 'block';
        bookButton.disabled = false;
    });
    
    const resetSlotSelection = () => {
        selectedSlot = null;
        slotsContainer.innerHTML = '<small class="form-hint">Bitte Lehrer und Datum wählen.</small>';
        notesContainer.style.display = 'none';
        if (notesInput) notesInput.value = '';
        if (bookButton) bookButton.disabled = true;
    };

    // --- 5. Buchen ---
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (!selectedSlot || !selectedTeacherIdInput.value || !datePicker.value) {
            showToast("Bitte Lehrer, Datum und einen Slot auswählen.", "error");
            return;
        }

        bookButton.disabled = true;
        bookSpinner.style.display = 'block';

        const body = {
            // KORREKTUR: Sendet teacher_id (Stammdaten-ID)
            teacher_id: selectedTeacherIdInput.value,
            date: datePicker.value,
            time: selectedSlot.time,
            duration: selectedSlot.duration,
            notes: notesInput.value.trim() || null
        };
        
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/student/book-appointment`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            if (response.success) {
                showToast(response.message, 'success');
                form.reset();
                selectedTeacherIdInput.value = '';
                datePicker.disabled = true;
                resetSlotSelection();
                loadAndRenderWeeklyData(); // Lädt "Mein Tag" neu
            }
        } catch (error) {
             console.error("Fehler beim Buchen:", error);
             if (error.message.includes('gebu')) {
                 datePicker.dispatchEvent(new Event('change')); // Löst Neuladen der Slots aus
             }
        } finally {
            bookButton.disabled = false;
            bookSpinner.style.display = 'none';
        }
    });

    document.addEventListener('click', (e) => {
        if (widget && !widget.contains(e.target)) {
            teacherSearchResults.classList.remove('visible');
        }
    });
}

/**
 * NEU: Initialisiert das Tab-Interface.
 */
function initializeTabbedInterface() {
    const wrapper = document.querySelector('.dashboard-wrapper');
    if (!wrapper) return;
    const tabContainer = wrapper.querySelector('.tab-navigation');
    const contentContainer = wrapper.querySelector('.tab-content');
    if (!tabContainer || !contentContainer) return;

    const tabButtons = tabContainer.querySelectorAll('.tab-button');
    const tabContents = contentContainer.querySelectorAll('.dashboard-section');

    // Tabs, die bereits initial geladen werden
    const loadedTabs = {
        'section-my-day': true,
        'section-weekly-plan': true,
        'section-announcements': true,
    };


    tabContainer.addEventListener('click', (e) => {
        const clickedButton = e.target.closest('.tab-button');
        if (!clickedButton || clickedButton.classList.contains('active')) return;
        
        tabButtons.forEach(btn => btn.classList.remove('active'));
        tabContents.forEach(content => content.classList.remove('active'));

        clickedButton.classList.add('active');
        const targetId = clickedButton.dataset.target;
        const targetContent = document.getElementById(targetId);

        if (targetContent) {
            targetContent.classList.add('active');
            
            // Prüfen, ob der Tab-Inhalt "lazy loaded" werden muss
            if (!loadedTabs[targetId]) {
                // Lazy loading für Community Board (Schüler)
                if (targetId === 'section-community-board') {
                    if (window.initializeDashboardCommunity) {
                        window.initializeDashboardCommunity();
                    }
                }
                // NEU: Lazy loading für "Meine Beiträge" (Schüler)
                else if (targetId === 'section-my-posts') {
                    if (initializeMyCommunityPosts) { // Verwende die importierte Funktion
                        initializeMyCommunityPosts();
                    }
                }
                // Lazy loading für Lehrer-Tabs
                else if (targetId === 'section-attendance' || targetId === 'section-events' || targetId === 'section-office-hours' || targetId === 'section-colleague-search') {
                     if (window.initializeTeacherCockpit) {
                         // Diese Funktion initialisiert ALLE Lehrer-Tabs beim ersten Klick auf einen von ihnen
                         window.initializeTeacherCockpit(); 
                         // Markiere alle Lehrer-Tabs als geladen, um Mehrfach-Initialisierung zu vermeiden
                         loadedTabs['section-attendance'] = true;
                         loadedTabs['section-events'] = true;
                         loadedTabs['section-office-hours'] = true;
                         loadedTabs['section-colleague-search'] = true;
                     }
                }
                
                loadedTabs[targetId] = true; // Markiere diesen Tab als geladen
            }
        }
    });
}

/**
 * NEU: Initialisiert das Modal für die Stundendetails.
 */
function initializePlanDetailModal(timetableContainer, modal, closeBtn, noteRow, noteInput, noteSaveBtn, noteSpinner) {
    if (!timetableContainer || !modal || !closeBtn) {
        console.warn("Detail-Modal-Initialisierung übersprungen: Elemente fehlen.", {timetableContainer, modal, closeBtn});
        return;
    }

    const state = {
        currentSlotKey: null, // z.B. "1-2" (day-period)
        isSaving: false
    };

    const close = () => modal.classList.remove('visible');

    closeBtn.addEventListener('click', close);
    modal.addEventListener('click', (e) => {
        if (e.target.id === 'plan-detail-modal') {
            close();
        }
    });

    // Event-Listener am Haupt-Grid-Container (nur für den Wochenplan-Tab)
    timetableContainer.addEventListener('click', (e) => {
        const cell = e.target.closest('.grid-cell.has-entry');
        if (!cell || e.target.closest('a') || cell.classList.contains('dragging')) {
            return;
        }
        
        // Daten aus dem globalen State holen
        const { stammdaten, currentTimetable, currentSubstitutions, studentNotes } = dashboardState;
        
        // IDs aus der Zelle extrahieren
        const day = cell.dataset.day;
        const period = cell.dataset.period;
        const entryId = cell.dataset.entryId;
        const blockId = cell.dataset.blockId;
        const substitutionId = cell.dataset.substitutionId;

        state.currentSlotKey = `${day}-${period}`; // Speichere den Slot für das Speichern der Notiz

        let data = {}; // Hier sammeln wir die Infos
        let status = "Regulär";
        let statusClass = "status-regular";

        let entry = null;
        if (blockId) {
            entry = currentTimetable.find(e => e.block_id === blockId && e.day_of_week == day);
        } else if (entryId) {
            entry = currentTimetable.find(e => e.entry_id == entryId);
        }
        
        let substitution = substitutionId ? currentSubstitutions.find(s => s.substitution_id == substitutionId) : null;

        if (substitution) {
            const regularEntry = entry; 
            status = substitution.substitution_type;
            statusClass = `status-${substitution.substitution_type.toLowerCase()}`;
            
            data.subject = substitution.new_subject_shortcut || regularEntry?.subject_shortcut || 'N/A';
            data.teacher = substitution.new_teacher_shortcut || (userRole === 'schueler' ? regularEntry?.teacher_shortcut : null) || 'N/A';
            data.room = substitution.new_room_name || regularEntry?.room_name || 'N/A';
            data.class = substitution.class_name || regularEntry?.class_name || 'N/A';
            data.comment = substitution.comment || regularEntry?.comment || '';
        
        } else if (entry) { // Regulärer Eintrag
            status = "Regulär";
            statusClass = "status-regular";
            data.subject = entry.subject_shortcut;
            data.teacher = entry.teacher_shortcut;
            data.room = entry.room_name;
            data.class = entry.class_name;
            data.comment = entry.comment || '';
        } else {
            return; // Nichts zu anzeigen (FU oder leer)
        }

        // Fülle das Modal
        document.getElementById('detail-status').textContent = status;
        document.getElementById('detail-status').className = `detail-value ${statusClass}`;
        
        // Zeit-Logik (prüft auf Block)
        // KORREKTUR: Verwende die globale Variable 'timeSlotsDisplay'
        const span = blockId ? (currentTimetable.filter(e => e.block_id === blockId).length) : 1;
        let timeText;
        if (span > 1) {
            const startPeriod = parseInt(period);
            const endPeriod = startPeriod + span - 1;
            const startTime = formatTimeSlot(startPeriod);
            const endTime = timeSlotsDisplay[endPeriod - 1]?.split(' - ')[1] || '??:??'; // KORRIGIERT
            timeText = `${days[day-1]}, ${startPeriod}. - ${endPeriod}. Stunde (${startTime} - ${endTime})`; // KORRIGIERT
        } else {
            timeText = `${days[day-1]}, ${period}. Stunde (${timeSlotsDisplay[period-1]})`; // KORRIGIERT
        }
        document.getElementById('detail-time').textContent = timeText;
        
        // Volle Namen aus Stammdaten holen (falls vorhanden)
        const subjectFull = stammdaten.subjects?.find(s => s.subject_shortcut === data.subject)?.subject_name || data.subject;
        const teacherFull = stammdaten.teachers?.find(t => t.teacher_shortcut === data.teacher);
        const teacherName = teacherFull ? `${teacherFull.first_name} ${teacherFull.last_name} (${teacherFull.teacher_shortcut})` : (data.teacher || 'N/A');
        
        document.getElementById('detail-subject').textContent = subjectFull || 'N/A';
        
        const teacherRow = document.getElementById('detail-teacher');
        const classRow = document.getElementById('detail-class');
        
        if (userRole === 'schueler' && teacherRow) {
            teacherRow.textContent = teacherName;
        } else if (userRole === 'lehrer' && classRow) {
            classRow.textContent = data.class || 'N/A';
        }
        document.getElementById('detail-room').textContent = data.room || 'N/A';

        const commentRow = document.getElementById('detail-comment-row');
        if (data.comment) {
            document.getElementById('detail-comment').textContent = data.comment;
            commentRow.style.display = 'flex';
        } else {
            commentRow.style.display = 'none';
        }

        // NEU: Notiz-Logik für Schüler
        if (userRole === 'schueler' && noteRow && noteInput) {
            const noteKey = state.currentSlotKey;
            const currentNote = studentNotes[noteKey] || '';
            noteInput.value = currentNote;
            noteRow.style.display = 'flex'; // Mache die Notiz-Sektion sichtbar
            if(noteSaveBtn) noteSaveBtn.disabled = false;
            if(noteSpinner) noteSpinner.style.display = 'none';
        }

        modal.classList.add('visible');
    });

    // NEU: Event-Listener für Notiz-Speichern (nur für Schüler)
    if (userRole === 'schueler' && noteSaveBtn && noteInput && noteSpinner) {
        noteSaveBtn.addEventListener('click', async () => {
            if (state.isSaving || !state.currentSlotKey) return;
            state.isSaving = true;
            noteSaveBtn.disabled = true;
            noteSpinner.style.display = 'inline-block';

            const [day, period] = state.currentSlotKey.split('-');
            const year = yearSelector.value;
            const week = weekSelector.value;
            const content = noteInput.value.trim();

            const body = {
                year: parseInt(year),
                calendar_week: parseInt(week),
                day_of_week: parseInt(day),
                period_number: parseInt(period),
                note_content: content
            };

            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/student/note/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                if (response.success) {
                    showToast('Notiz gespeichert!', 'success');
                    // Aktualisiere den globalen Notiz-State
                    if (content) {
                        dashboardState.studentNotes[state.currentSlotKey] = content;
                    } else {
                        delete dashboardState.studentNotes[state.currentSlotKey];
                    }
                    // Rendere die Grids neu, um Notiz-Indikatoren zu aktualisieren
                    renderWeeklyTimetable(dashboardState.currentTimetable, dashboardState.currentSubstitutions, dashboardState.studentNotes);
                    renderTodaySchedule(dashboardState.currentTimetable, dashboardState.currentSubstitutions, [], [], dashboardState.studentNotes); // TODO: Events/Appointments müssten hier neu geladen oder übergeben werden
                    close(); // Schließe das Modal nach dem Speichern
                }
                // Fehler wird von apiFetch als Toast angezeigt
            } catch (error) {
                console.error("Fehler beim Speichern der Notiz:", error);
            } finally {
                state.isSaving = false;
                noteSaveBtn.disabled = false;
                noteSpinner.style.display = 'none';
            }
        });
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\dashboard.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\footer-ui.js ---
// public/assets/js/footer-ui.js

/**
 * Initializes footer UI interactions: Imprint toggle.
 */
export function initializeFooterUi() {
    const imprintToggle = document.getElementById('imprint-toggle');
    const imprintDetails = document.getElementById('imprint-details');
    const imprintClose = document.getElementById('imprint-close');

    if (imprintToggle && imprintDetails && imprintClose) {
        const toggleImprint = (show) => {
            if (show) {
                imprintDetails.classList.add('visible');
                imprintToggle.setAttribute('aria-expanded', 'true');
            } else {
                imprintDetails.classList.remove('visible');
                imprintToggle.setAttribute('aria-expanded', 'false');
            }
        };

        imprintToggle.addEventListener('click', () => {
            const isVisible = imprintDetails.classList.contains('visible');
            toggleImprint(!isVisible);
        });

        imprintClose.addEventListener('click', () => {
            toggleImprint(false);
        });

        // Optional: Close imprint when clicking outside of it
        document.addEventListener('click', (event) => {
            if (imprintDetails.classList.contains('visible') &&
                !imprintDetails.contains(event.target) &&
                event.target !== imprintToggle) {
                toggleImprint(false);
            }
        });

         // Optional: Close imprint with Escape key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && imprintDetails.classList.contains('visible')) {
                toggleImprint(false);
            }
        });
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\footer-ui.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\header-ui.js ---
// public/assets/js/header-ui.js

/**
 * Applies the selected theme (light/dark) to the document.
 * @param {string} theme - 'light' or 'dark'.
 */
function applyTheme(theme) {
    if (theme === 'dark') {
        document.documentElement.classList.add('dark-mode');
        // Update toggle button if it exists (might run before button is ready)
        const toggle = document.getElementById('theme-toggle');
        if (toggle) {
             toggle.setAttribute('aria-pressed', 'true'); // Indicate dark mode is active
        }
    } else {
        document.documentElement.classList.remove('dark-mode');
        // Update toggle button if it exists
        const toggle = document.getElementById('theme-toggle');
         if (toggle) {
             toggle.setAttribute('aria-pressed', 'false'); // Indicate light mode is active
        }
    }
}


/**
 * Initializes header UI interactions: mobile menu toggle, user dropdown, and theme toggle.
 */
export function initializeHeaderUi() {
    const header = document.querySelector('.page-header');
    if (!header) return;

    // --- Theme Toggle Handling ---
    const themeToggle = document.getElementById('theme-toggle');
    if (themeToggle) {
        // Set initial state of the button based on current theme (already applied by inline script)
        const currentTheme = document.documentElement.classList.contains('dark-mode') ? 'dark' : 'light';
        themeToggle.setAttribute('aria-pressed', currentTheme === 'dark');


        themeToggle.addEventListener('click', () => {
            const currentIsDark = document.documentElement.classList.contains('dark-mode');
            const newTheme = currentIsDark ? 'light' : 'dark';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
             // Update aria-pressed state after applying theme
             themeToggle.setAttribute('aria-pressed', newTheme === 'dark');
        });
    }


    // --- Mobile Menu Handling ---
    const mobileToggle = document.getElementById('mobile-menu-toggle');
    const headerNav = document.getElementById('header-nav');

    if (mobileToggle && headerNav) {

        const closeMobileMenu = () => {
            mobileToggle.classList.remove('is-open');
            headerNav.classList.remove('is-open');
            document.body.classList.remove('menu-open'); // Allow scrolling again
            mobileToggle.setAttribute('aria-expanded', 'false');
        };

        mobileToggle.addEventListener('click', () => {
            const isOpen = headerNav.classList.contains('is-open');
            if (isOpen) {
                closeMobileMenu();
            } else {
                mobileToggle.classList.add('is-open');
                headerNav.classList.add('is-open');
                document.body.classList.add('menu-open'); // Prevent scrolling
                mobileToggle.setAttribute('aria-expanded', 'true');
            }
        });

        // Close mobile menu when a navigation link inside it is clicked
        headerNav.addEventListener('click', (e) => {
            // Check if the clicked element or its parent is a link within the nav
            if (e.target.closest('a')) {
                // Check if the screen width is mobile (where the overlay is active)
                if (window.innerWidth < 769) {
                     closeMobileMenu();
                }
            }
        });
    }

    // --- User Dropdown Handling (Desktop) ---
    const userMenu = header.querySelector('.user-menu');
    // Add a check to prevent re-initializing if script runs multiple times
    if (userMenu && !userMenu.dataset.menuInitialized) {
        const toggleButton = userMenu.querySelector('.user-menu-toggle');
        const dropdown = userMenu.querySelector('.user-menu-dropdown');

        if (toggleButton && dropdown) {
            toggleButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent document click listener from closing it immediately
                const isOpen = dropdown.classList.toggle('is-open');
                toggleButton.setAttribute('aria-expanded', isOpen);
            });

            // Close dropdown if clicking outside of it
            document.addEventListener('click', (e) => {
                // Check if the click was outside the user menu and the dropdown is open
                if (!userMenu.contains(e.target) && dropdown.classList.contains('is-open')) {
                    dropdown.classList.remove('is-open');
                    toggleButton.setAttribute('aria-expanded', 'false');
                }
            });

            // Close dropdown if a link inside it is clicked
            dropdown.addEventListener('click', (e) => {
                if (e.target.closest('a')) {
                     dropdown.classList.remove('is-open');
                     toggleButton.setAttribute('aria-expanded', 'false');
                }
            });

            userMenu.dataset.menuInitialized = 'true'; // Mark as initialized
        }
    }
}

// Apply initial theme on script load (redundant with inline script but safe)
// const initialTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
// applyTheme(initialTheme);
// Removed this as the inline script in header.php handles the initial, flash-preventing application.
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\header-ui.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\main.js ---
// public/assets/js/main.js

// Importiere globale UI-Handler
import { showToast, showConfirm } from './notifications.js'; // Stellt sicher, dass showToast/showConfirm global registriert werden
import { initializeHeaderUi } from './header-ui.js';
import { initializeFooterUi } from './footer-ui.js'; // Import footer UI

// Importiere seiten-spezifische Initialisierer
import { initializeAdminStammdaten } from './admin-stammdaten.js';
import { initializeAdminUsers } from './admin-users.js';
import { initializeAdminAnnouncements } from './admin-announcements.js';
import { initializePlanerDashboard } from './planer-dashboard.js';
import { initializeDashboard } from './dashboard.js';
import { initializeAdminAuditLogs } from './admin-audit-log.js'; 
import { initializeAdminSettings } from './admin-settings.js'; 
import { initializeTeacherCockpit } from './teacher-cockpit.js';
import { initializeAdminCommunity } from './admin-community.js';
import { initializeDashboardCommunity } from './dashboard-community.js';
// NEU: Import für "Meine Beiträge"
import { initializeMyCommunityPosts } from './dashboard-my-posts.js';
// NEU: Import für "Abwesenheiten"
import { initializePlanerAbsences } from './planer-absences.js';


console.log("main.js: Skript gestartet.");

/**
 * Führt alle seiten-spezifischen JavaScript-Module aus.
 * Prüft anhand von IDs im DOM, welche Module geladen werden sollen.
 */
function runContentInitializers() {
    console.log("main.js: Führe Inhalts-Initialisierer aus...");

    // Admin: Stammdaten
    if(document.getElementById('stammdaten-management')) {
        console.log("main.js: Initialisiere Admin Stammdaten...");
        initializeAdminStammdaten();
    }
    // Admin: Benutzerverwaltung
    if(document.getElementById('user-management')) {
        console.log("main.js: Initialisiere Admin Benutzer...");
        initializeAdminUsers();
    }
    // Admin: Ankündigungen
    if(document.getElementById('announcements-management')) {
        console.log("main.js: Initialisiere Admin Ankündigungen...");
        initializeAdminAnnouncements();
    }
    // Planer: Dashboard
    if(document.querySelector('.planer-dashboard-wrapper') && document.getElementById('timetable-container')) { // Spezifischer auf Dashboard
        console.log("main.js: Initialisiere Planer Dashboard...");
        initializePlanerDashboard();
    }
    // NEU: Planer: Abwesenheiten
    if(document.getElementById('absence-management')) {
        console.log("main.js: Initialisiere Planer Abwesenheiten...");
        initializePlanerAbsences();
    }
    // Schüler/Lehrer: Dashboard
    if(document.querySelector('.dashboard-wrapper')) {
        console.log("main.js: Initialisiere (Schüler/Lehrer) Dashboard...");
        initializeDashboard();
    }
    // Admin: Audit Logs
    if(document.getElementById('audit-log-management')) {
        console.log("main.js: Initialisiere Admin Audit Logs...");
        initializeAdminAuditLogs();
    }
    // Admin: Settings
    if(document.getElementById('settings-management')) {
        console.log("main.js: Initialisiere Admin Einstellungen...");
        initializeAdminSettings();
    }
    
    // Lehrer-Cockpit (wird auf der Dashboard-Seite geladen)
    // Die Logik in dashboard.js (initializeTabbedInterface) ruft dies verzögert auf
    // if(document.getElementById('teacher-cockpit')) {
    //     console.log("main.js: Initialisiere Lehrer-Cockpit...");
    //     initializeTeacherCockpit();
    // }

    // Admin Community Moderation
    if(document.getElementById('community-moderation')) {
        console.log("main.js: Initialisiere Admin Community Moderation...");
        initializeAdminCommunity();
    }
    
    // Dashboard Community Board (Schüler)
    // Wird verzögert von dashboard.js -> initializeTabbedInterface aufgerufen
    // if(document.getElementById('section-community-board')) {
    //     console.log("main.js: Initialisiere Dashboard Community Board...");
    //     initializeDashboardCommunity();
    // }

    // NEU: Dashboard "Meine Beiträge" (Schüler)
    // Wird verzögert von dashboard.js -> initializeTabbedInterface aufgerufen
    // if(document.getElementById('section-my-posts')) {
    //     console.log("main.js: Initialisiere Dashboard Meine Beiträge...");
    //     initializeMyCommunityPosts();
    // }


    console.log("main.js: Inhalts-Initialisierer abgeschlossen.");
}

/**
 * Führt globale UI-Initialisierer aus (Header, Footer, etc.)
 */
function runGlobalInitializers() {
    console.log("main.js: Führe globale Initialisierer aus...");
    initializeHeaderUi(); // Initialize the header interactions
    initializeFooterUi(); // Initialize the footer interactions
    // Future global initializers will go here
    console.log("main.js: Globale Initialisierer abgeschlossen.");
}


// Startet die Anwendung, sobald das DOM geladen ist.
document.addEventListener('DOMContentLoaded', () => {
    console.log("main.js: DOMContentLoaded Event ausgelöst.");
    runGlobalInitializers();
    runContentInitializers();
    console.log("main.js: Alle Initialisierungen nach DOMContentLoaded abgeschlossen.");
});

// NEU: Mache die Lazy-Loading-Funktionen global verfügbar,
// damit sie von dashboard.js aufgerufen werden können.
// (Bessere Methode wäre, dashboard.js auch modular zu importieren, aber das würde dashboard.js ändern)
window.initializeDashboardCommunity = initializeDashboardCommunity;
window.initializeMyCommunityPosts = initializeMyCommunityPosts;
window.initializeTeacherCockpit = initializeTeacherCockpit;


console.log("main.js: Skript-Ende erreicht.");


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\main.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\notifications.js ---
/**
 * Erstellt und zeigt eine Toast-Benachrichtigung an.
 * @param {string} message - Die anzuzeigende Nachricht.
 * @param {'success'|'error'|'info'} type - Der Typ der Benachrichtigung.
 * @param {number} duration - Wie lange der Toast sichtbar bleibt (in ms).
 */
export function showToast(message, type = 'info', duration = 3000) {
    // Alten Toast entfernen, falls vorhanden
    const oldToast = document.querySelector('.toast-notification');
    if (oldToast) {
        oldToast.remove();
    }

    const toast = document.createElement('div');
    toast.className = `toast-notification toast-${type}`;
    toast.textContent = message;

    document.body.appendChild(toast);

    // Animation starten
    setTimeout(() => {
        toast.classList.add('visible');
    }, 10); // Kleiner Delay, damit CSS Transition greift

    // Toast nach der angegebenen Dauer ausblenden und entfernen
    setTimeout(() => {
        toast.classList.remove('visible');
        // Entferne das Element erst, nachdem die Ausblend-Animation abgeschlossen ist
        toast.addEventListener('transitionend', () => toast.remove());
    }, duration);
}

/**
 * Zeigt einen Bestätigungsdialog (Modal) an.
 * @param {string} title - Der Titel des Dialogs.
 * @param {string} message - Die Frage oder Nachricht im Dialog.
 * @returns {Promise<boolean>} - Ein Promise, das `true` bei Bestätigung und `false` bei Abbruch zurückgibt.
 */
export function showConfirm(title, message) {
    return new Promise((resolve) => {
        // Alten Dialog entfernen, falls einer existiert
        const oldOverlay = document.querySelector('.confirm-overlay');
        if (oldOverlay) {
            oldOverlay.remove();
        }

        const confirmOverlay = document.createElement('div');
        confirmOverlay.className = 'confirm-overlay';

        const confirmBox = document.createElement('div');
        confirmBox.className = 'confirm-box';

        // Verwende textContent für Sicherheit gegen XSS in title/message
        confirmBox.innerHTML = `
            <h2></h2>
            <p></p>
            <div class="confirm-actions">
                <button class="btn btn-secondary" id="confirm-cancel">Abbrechen</button>
                <button class="btn btn-danger" id="confirm-ok">Bestätigen</button>
            </div>
        `;
        confirmBox.querySelector('h2').textContent = title;
        confirmBox.querySelector('p').textContent = message;


        confirmOverlay.appendChild(confirmBox);
        document.body.appendChild(confirmOverlay);

        // Animation starten
        setTimeout(() => confirmOverlay.classList.add('visible'), 10);

        const close = (value) => {
            confirmOverlay.classList.remove('visible');
            confirmOverlay.addEventListener('transitionend', () => {
                confirmOverlay.remove();
                resolve(value);
            }, { once: true }); // Ensure listener is removed after execution
        };

        document.getElementById('confirm-ok').onclick = () => close(true);
        document.getElementById('confirm-cancel').onclick = () => close(false);

        // Schließen bei Klick außerhalb (optional)
        confirmOverlay.addEventListener('click', (e) => {
            if (e.target === confirmOverlay) {
                close(false);
            }
        });
         // Schließen bei Escape-Taste (optional)
        const escapeListener = (e) => {
             if (e.key === 'Escape') {
                 close(false);
                 document.removeEventListener('keydown', escapeListener); // Listener entfernen
             }
         };
         document.addEventListener('keydown', escapeListener);
         // Sicherstellen, dass der Listener entfernt wird, wenn das Modal anders geschlossen wird
         confirmOverlay.addEventListener('transitionend', () => {
             if (!confirmOverlay.classList.contains('visible')) {
                 document.removeEventListener('keydown', escapeListener);
             }
         }, { once: true });
    });
}

// Global assignments removed
// window.showToast = showToast;
// window.showConfirm = showConfirm;

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\notifications.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-absences.js ---
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js';
import { escapeHtml, getWeekAndYear, getDateOfISOWeek } from './planer-utils.js';
// KORREKTUR: FullCalendar wird als globales Objekt (aus header.php) verwendet, nicht als ES-Modul importiert.
// import { FullCalendar } from './fullcalendar-index.js'; // ENTFERNT

/**
 * Escapes HTML special characters.
 * @param {string} unsafe
 * @returns {string}
 */
// function escapeHtml(unsafe) { ... } // Duplikate Funktion, da sie schon in planer-utils ist. Besser aus planer-utils importieren.

/**
 * Formatiert HH:MM:SS zu HH:MM.
 * @param {string} timeString - HH:MM:SS
 * @returns {string} HH:MM
 */
function formatShortTime(timeString) {
    if (!timeString) return '';
    const parts = timeString.split(':');
    if (parts.length >= 2) {
        return `${parts[0]}:${parts[1]}`;
    }
    return timeString; // Fallback
}

/**
 * Wandelt 1-5 in Wochentage um.
 * @param {string|number} dayNum
 * @returns {string}
 */
function formatDayOfWeek(dayNum) {
    const days = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag'];
    const index = parseInt(dayNum, 10) - 1;
    return days[index] || 'Unbekannt';
}

/**
 * Hauptinitialisierungsfunktion, die jetzt exportiert wird.
 */
export function initializePlanerAbsences() {
    const container = document.getElementById('absence-management');
    if (!container) return;

    // KORREKTUR: Suche Elemente innerhalb des 'container'-Elements statt 'document'
    const calendarEl = container.querySelector('#absence-calendar');
    const form = container.querySelector('#absence-form');
    const formTitle = container.querySelector('#absence-form-title');
    const teacherSelect = container.querySelector('#absence-teacher-id');
    const reasonSelect = container.querySelector('#absence-reason');
    const startDateInput = container.querySelector('#absence-start-date');
    const endDateInput = container.querySelector('#absence-end-date');
    const absenceIdInput = container.querySelector('#absence-id');
    const saveButton = container.querySelector('#absence-save-btn');
    const cancelEditButton = container.querySelector('#absence-cancel-edit-btn');
    const deleteButton = container.querySelector('#absence-delete-btn');
    const saveSpinner = container.querySelector('#absence-save-spinner');

    let calendarInstance = null;

    // KORREKTUR: Prüfe, ob das globale FullCalendar-Objekt existiert.
    if (typeof FullCalendar === 'undefined' || typeof FullCalendar.Calendar === 'undefined') {
        console.error("FullCalendar ist nicht geladen. Stellen Sie sicher, dass es in header.php eingebunden ist.");
        if (calendarEl) {
            calendarEl.innerHTML = '<p class="message error">Kalender-Bibliothek konnte nicht geladen werden.</p>';
        }
        return;
    }

    // --- NEUE DEBUGGING-LOGS ---
    console.log("planer-absences.js: Initialisierung läuft...");
    console.log("container:", container); // Zeigt den gefundenen Container
    console.log("calendarEl (gesucht in container):", calendarEl);
    console.log("form (gesucht in container):", form);
    console.log("teacherSelect (gesucht in container):", teacherSelect);
    // --- ENDE DEBUGGING-LOGS ---

    if (!calendarEl || !form || !teacherSelect) {
        console.error("Erforderliche Elemente für das Abwesenheits-Management fehlen.");
        // --- NEUE DEBUGGING-LOGS ---
        if (!calendarEl) console.error("Element '#absence-calendar' nicht gefunden.");
        if (!form) console.error("Element '#absence-form' nicht gefunden.");
        if (!teacherSelect) console.error("Element '#absence-teacher-id' nicht gefunden.");
        // --- ENDE DEBUGGING-LOGS ---
        return;
    }

    /**
     * Setzt das Formular in den "Erstellen"-Modus zurück.
     */
    const resetForm = () => {
        form.reset();
        absenceIdInput.value = '';
        formTitle.textContent = 'Neue Abwesenheit eintragen';
        saveButton.textContent = 'Speichern';
        deleteButton.style.display = 'none';
        cancelEditButton.style.display = 'none';
        
        // Setze Start- und Enddatum zurück (falls sie durch Kalenderauswahl gesetzt wurden)
        startDateInput.value = '';
        endDateInput.value = '';
    };

    /**
     * Lädt die Abwesenheiten und zeigt sie im Kalender an.
     */
    const loadAbsences = async () => {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/absences`);
            if (response.success && response.data) {
                const events = response.data.map(abs => ({
                    id: abs.absence_id,
                    title: `${abs.teacher_shortcut}: ${abs.reason}`,
                    start: abs.start_date,
                    end: new Date(new Date(abs.end_date).getTime() + 86400000).toISOString().split('T')[0], // Enddatum ist exklusiv in FullCalendar
                    allDay: true,
                    classNames: [`absence-${abs.reason.toLowerCase()}`],
                    extendedProps: {
                        teacher_id: abs.teacher_id,
                        reason: abs.reason
                    }
                }));
                
                if (calendarInstance) {
                    calendarInstance.removeAllEvents();
                    calendarInstance.addEventSource(events);
                }
            } else {
                throw new Error(response.message || "Abwesenheiten konnten nicht geladen werden.");
            }
        } catch (error) {
            console.error("Fehler beim Laden der Abwesenheiten:", error);
            showToast(error.message, 'error');
        }
    };

    /**
     * Initialisiert den FullCalendar.
     */
    const initializeCalendar = () => {
        // KORREKTUR: Verwende das globale FullCalendar-Objekt
        calendarInstance = new FullCalendar.Calendar(calendarEl, {
            locale: 'de', // Deutsches Sprachpaket
            initialView: 'dayGridMonth',
            headerToolbar: {
                left: 'prev,next today',
                center: 'title',
                right: 'dayGridMonth,listWeek'
            },
            buttonText: {
                today: 'Heute',
                month: 'Monat',
                list: 'Liste'
            },
            selectable: true, // Erlaube das Auswählen von Tagen
            select: (selectionInfo) => {
                // Bei Auswahl eines Zeitraums, fülle das Formular
                resetForm();
                startDateInput.value = selectionInfo.startStr;
                // FullCalendar's Enddatum ist exklusiv. Wir müssen einen Tag abziehen.
                const endDate = new Date(new Date(selectionInfo.endStr).getTime() - 86400000);
                endDateInput.value = endDate.toISOString().split('T')[0];
                formTitle.textContent = 'Neue Abwesenheit eintragen';
                teacherSelect.focus();
            },
            eventClick: (clickInfo) => {
                // Bei Klick auf ein Event, fülle das Formular zum Bearbeiten
                const event = clickInfo.event;
                formTitle.textContent = 'Abwesenheit bearbeiten';
                absenceIdInput.value = event.id;
                teacherSelect.value = event.extendedProps.teacher_id;
                reasonSelect.value = event.extendedProps.reason;
                startDateInput.value = event.startStr;
                
                // Enddatum ist exklusiv, ziehe einen Tag ab für die Anzeige
                const endDate = new Date(new Date(event.endStr).getTime() - 86400000);
                endDateInput.value = endDate.toISOString().split('T')[0];

                saveButton.textContent = 'Aktualisieren';
                deleteButton.style.display = 'inline-block';
                cancelEditButton.style.display = 'inline-block';
            }
        });
        calendarInstance.render();
        loadAbsences(); // Lade Events nach der Initialisierung
    };

    /**
     * Behandelt das Speichern (Erstellen/Aktualisieren) einer Abwesenheit.
     */
    form.addEventListener('submit', async (e) => {
        e.preventDefault();
        saveButton.disabled = true;
        saveSpinner.style.display = 'inline-block';

        const formData = new FormData(form);
        const data = Object.fromEntries(formData.entries());
        const url = `${window.APP_CONFIG.baseUrl}/api/planer/absences/save`;

        try {
            // KORREKTUR: Validierung Start-/Enddatum
            if (data.start_date > data.end_date) {
                throw new Error("Das Startdatum darf nicht nach dem Enddatum liegen.");
            }
            
            const response = await apiFetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (response.success) {
                showToast(response.message, 'success');
                resetForm();
                loadAbsences(); // Kalender neu laden
            }
            // Fehler wird von apiFetch als Toast angezeigt
        } catch (error) {
            console.error("Fehler beim Speichern der Abwesenheit:", error);
            // Fehler-Toast wird bereits von apiFetch angezeigt (oder hier, falls Validierung fehlschlägt)
            if (!error.message.includes('API')) { // Zeige Validierungsfehler
                 showToast(error.message, 'error');
            }
        } finally {
            saveButton.disabled = false;
            saveSpinner.style.display = 'none';
        }
    });

    /**
     * Behandelt das Löschen einer Abwesenheit.
     */
    deleteButton.addEventListener('click', async () => {
        const absenceId = absenceIdInput.value;
        if (!absenceId) return;

        if (await showConfirm("Löschen bestätigen", "Möchten Sie diese Abwesenheit wirklich löschen?")) {
            saveButton.disabled = true;
            deleteButton.disabled = true;
            saveSpinner.style.display = 'inline-block';

            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/absences/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ absence_id: absenceId })
                });

                if (response.success) {
                    showToast(response.message, 'success');
                    resetForm();
                    loadAbsences(); // Kalender neu laden
                }
            } catch (error) {
                console.error("Fehler beim Löschen:", error);
            } finally {
                saveButton.disabled = false;
                deleteButton.disabled = false;
                saveSpinner.style.display = 'none';
            }
        }
    });

    /**
     * Behandelt das Abbrechen des Bearbeitungsmodus.
     */
    cancelEditButton.addEventListener('click', () => {
        resetForm();
    });

    // --- Initialisierung ---
    // (Lehrer-Select wurde bereits durch PHP/Stammdaten geladen)
    initializeCalendar();
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-absences.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-api.js ---
import { apiFetch } from './api-client.js';
 import * as DOM from './planer-dom.js';
 // KORRIGIERT: processTimetableData importiert
 import { updateState, getState, processTimetableData } from './planer-state.js';
 import { populateAllModalSelects, populateClassSelector, populateTeacherSelector, populateTemplateSelects, updatePublishControls } from './planer-ui.js';
 // KORREKTUR 1: Import auf 'renderTimetableGrid' geändert
 import { renderTimetableGrid } from './planer-timetable.js';
 // renderTemplatesList wird in planer-interactions-2.js importiert und dort nach dem API-Aufruf verwendet.
 // import { renderTemplatesList } from './planer-interactions-2.js';
 
 /** Lädt Stammdaten (Klassen, Lehrer, etc.) UND VORLAGEN */
 export const loadInitialData = async () => {
     console.log("planer-api: Lade initiale Stammdaten..."); // Logging
     try {
         // Fetch base data including templates
         // The initial call to /api/planer/data without class_id/teacher_id should return base data
         // KORREKTUR: API-Aufruf, um sicherzustellen, dass 'absences' enthalten sind
         const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/data`);
         console.log("planer-api: Antwort für Initialdaten:", response); // Logging
         if (response.success && response.data) {
             console.log("planer-api: Initialdaten erfolgreich geladen:", response.data); // Logging
             updateState({
                 // Ensure stammdaten contains the base data (classes, teachers etc.)
                 stammdaten: response.data, // Speichere ALLE Stammdaten, inkl. 'absences'
                 templates: response.data.templates || [] // Ensure templates array exists
             });
             // UI-Updates
             // Pass the specific arrays to the populating functions
             populateClassSelector(response.data.classes);
             populateTeacherSelector(response.data.teachers);
             populateAllModalSelects(response.data); // Populates modal selects using the full data object
             populateTemplateSelects(response.data.templates || []); // Populates template selects in modals
 
             // Setzt die Vorauswahl und lädt den ersten Plan
             if (DOM.classSelector && DOM.classSelector.options.length > 1) { // Check if classes were loaded and selector exists
                 console.log("planer-api: Setze Standardauswahl auf erste Klasse."); // Logging
                 DOM.classSelector.selectedIndex = 1; // Select the first actual class
                 updateState({ selectedClassId: DOM.classSelector.value });
                 await loadPlanData(); // Load plan for the initially selected class
             } else {
                  console.log("planer-api: Keine Klassen zum Auswählen gefunden, lade leeren Plan."); // Logging
                  await loadPlanData(); // Attempt to load plan data even if no class selected (will show message)
             }
         } else {
             // Throw error if API call failed or data format is unexpected
             throw new Error(response.message || "Stammdaten konnten nicht geladen werden oder haben ein unerwartetes Format.");
         }
     } catch (error) {
         console.error("planer-api: Fehler beim Laden der Initialdaten:", error);
         if (DOM.timetableContainer) { // Check if container exists before updating
             DOM.timetableContainer.innerHTML = `<p class="message error">${error.message || 'Stammdaten konnten nicht geladen werden.'}</p>`;
         }
         // Optionally disable UI elements if initial load fails
     }
 };
 
 
 /** Lädt die Plandaten für die ausgewählte Ansicht/Woche */
 export const loadPlanData = async () => {
     console.log("planer-api: Lade Plandaten..."); // Logging hinzugefügt
     let { currentViewMode, selectedClassId, selectedTeacherId } = getState();
     // Re-read selected values directly from DOM elements as they are the source of truth
     selectedClassId = DOM.classSelector ? DOM.classSelector.value : null;
     selectedTeacherId = DOM.teacherSelector ? DOM.teacherSelector.value : null;
 
     const selectedYear = DOM.yearSelector ? DOM.yearSelector.value : null;
     const selectedWeek = DOM.weekSelector ? DOM.weekSelector.value : null;
 
     // Check if selectors exist and have values before proceeding
      if (!selectedYear || !selectedWeek) {
          console.warn("planer-api: Jahr oder Woche nicht ausgewählt.");
          if(DOM.timetableContainer) DOM.timetableContainer.innerHTML = '<p class="message info">Bitte Jahr und Kalenderwoche auswählen.</p>';
          updatePublishControls({ student: false, teacher: false });
          return;
      }
 
     // Base URL for the API endpoint
     let url = `${window.APP_CONFIG.baseUrl}/api/planer/data?year=${selectedYear}&week=${selectedWeek}`;
 
     // Append class_id or teacher_id based on the current view mode
     if (currentViewMode === 'class') {
         if (!selectedClassId) {
             console.log("planer-api: Keine Klasse ausgewählt, breche Plandaten-Ladevorgang ab."); // Logging hinzugefügt
             // KORREKTUR 3: Generische Meldung
             if (DOM.timetableContainer) DOM.timetableContainer.innerHTML = '<p class="message info">Bitte einen Lehrer oder eine Klasse auswählen.</p>';
             updatePublishControls({ student: false, teacher: false }); // Reset publish status display
             // Clear relevant state parts but keep stammdaten
             // KORRIGIERT: timetable und substitutions auf leere OBJEKTE setzen
             updateState({ selectedClassId: null, selectedTeacherId: null, currentTimetable: {}, currentSubstitutions: {}, currentPublishStatus: { student: false, teacher: false } });
             return;
         }
         // Update state and URL for class view
         updateState({ selectedClassId: selectedClassId, selectedTeacherId: null });
         url += `&class_id=${selectedClassId}`;
     } else { // Teacher view
         if (!selectedTeacherId) {
              console.log("planer-api: Kein Lehrer ausgewählt, breche Plandaten-Ladevorgang ab."); // Logging hinzugefügt
             // KORREKTUR 3: Generische Meldung
             if (DOM.timetableContainer) DOM.timetableContainer.innerHTML = '<p class="message info">Bitte einen Lehrer oder eine Klasse auswählen.</p>';
             updatePublishControls({ student: false, teacher: false });
              // Clear relevant state parts but keep stammdaten
              // KORRIGIERT: timetable und substitutions auf leere OBJEKTE setzen
             updateState({ selectedClassId: null, selectedTeacherId: null, currentTimetable: {}, currentSubstitutions: {}, currentPublishStatus: { student: false, teacher: false } });
             return;
         }
         // Update state and URL for teacher view
         updateState({ selectedClassId: null, selectedTeacherId: selectedTeacherId });
         url += `&teacher_id=${selectedTeacherId}`;
     }
 
     // Show loading spinner while fetching data
     if (DOM.timetableContainer) DOM.timetableContainer.innerHTML = '<div class="loading-spinner"></div>';
     try {
         // Fetch timetable data from the API
         const response = await apiFetch(url);
         console.log("planer-api: Antwort für Plandaten:", response); // Logging hinzugefügt
         if (response.success && response.data) {
              console.log("planer-api: Plandaten erfolgreich geladen, rufe processTimetableData auf...", response.data); // Logging hinzugefügt
 
              // *** KORREKTUR: Rufe processTimetableData auf, um Maps zu erstellen ***
              processTimetableData(response.data);
              // *** ENDE KORREKTUR ***
 
             // Render the timetable grid with the new data
             // KORREKTUR 1: Aufruf an 'renderTimetableGrid' geändert
             renderTimetableGrid(); // <--- HIER WIRD GERENDERT (getState() wird intern geholt)
             // Update the publish control buttons based on the fetched status
             updatePublishControls(getState().currentPublishStatus);
         } else {
             // If API call was not successful, throw an error
             throw new Error(response.message || "Plandaten konnten nicht geladen werden.");
         }
     } catch (error) {
         // Log error and display an error message in the timetable container
         console.error("planer-api: Fehler beim Laden der Plandaten:", error);
          if (DOM.timetableContainer) { // Check if container exists
              DOM.timetableContainer.innerHTML = `<p class="message error">${error.message || 'Stundenplan konnte nicht geladen werden.'}</p>`;
          }
         // Reset publish controls in case of error
         updatePublishControls({ student: false, teacher: false });
     }
 };
 
 /** API-Aufruf zum Veröffentlichen/Zurückziehen */
 export const publishWeek = async (target, publish = true) => {
     // const { year, week } = getState(); // Get current year/week from state // This might be wrong if selectors changed
     const currentYear = DOM.yearSelector.value; // Get selected year from DOM
     const currentWeek = DOM.weekSelector.value; // Get selected week from DOM
     if (!currentYear || !currentWeek) {
         window.showToast("Bitte Jahr und KW auswählen.", 'error');
         throw new Error("Jahr oder Woche nicht ausgewählt."); // Prevent API call
     }
     const url = publish ? `${window.APP_CONFIG.baseUrl}/api/planer/publish` : `${window.APP_CONFIG.baseUrl}/api/planer/unpublish`;
     const body = JSON.stringify({ year: currentYear, week: currentWeek, target });
     // Make the API call using apiFetch
     return await apiFetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body });
 };
 
 /** API-Aufruf zur Konfliktprüfung */
 export const checkConflicts = async (data) => {
      // Make the API call to check for conflicts
     return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/check-conflicts`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(data)
     });
 };
 
 /** API-Aufruf zum Speichern eines Eintrags */
 export const saveEntry = async (data) => {
       // Make the API call to save a regular timetable entry or block
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/entry/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
      });
 };
 
 /** API-Aufruf zum Löschen eines Eintrags/Blocks */
 export const deleteEntry = async (body) => {
     // Body should contain { entry_id: id } or { block_id: id }
     const url = `${window.APP_CONFIG.baseUrl}/api/planer/entry/delete`;
     // Make the API call to delete an entry or block
     return await apiFetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
 };
 
 /** API-Aufruf zum Speichern einer Vertretung */
 export const saveSubstitution = async (data) => {
       // Make the API call to save a substitution entry
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/substitution/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
      });
 };
 
 /** API-Aufruf zum Löschen einer Vertretung */
 export const deleteSubstitution = async (id) => {
     const url = `${window.APP_CONFIG.baseUrl}/api/planer/substitution/delete`;
      // Make the API call to delete a substitution entry
      return await apiFetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ substitution_id: id }) });
 };
 
 /** API-Aufruf zum Kopieren einer Woche */
 export const copyWeek = async (body) => {
       // Make the API call to copy timetable data from one week to another
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/copy-week`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
      });
 };
 
 /** API-Aufruf zum Laden aller Vorlagen - returns data instead of calling render */
 export const loadTemplates = async () => {
     try {
         // Fetch the list of available templates
         const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates`);
         if (response.success) {
             const templates = response.data || [];
             // Update state and UI selects
             updateState({ templates: templates });
             populateTemplateSelects(templates); // Update selects in modals
             // Return the data for the caller to handle rendering the list
             return templates;
         } else {
             throw new Error(response.message || "Vorlagen konnten nicht geladen werden.");
         }
     } catch (error) {
         // Handle errors during template loading
         updateState({ templates: [] }); // Clear templates in state
         console.error("Fehler beim Laden der Vorlagen:", error);
         // Display error messages in relevant UI elements
         if (DOM.applyTemplateSelect) DOM.applyTemplateSelect.innerHTML = '<option value="">Fehler beim Laden</option>';
         if (DOM.manageTemplatesList) DOM.manageTemplatesList.innerHTML = '<p class="message error">Fehler beim Laden.</p>';
         return []; // Return empty array on error
     }
 };
 
 
 /** API-Aufruf zum Erstellen einer Vorlage */
 export const createTemplate = async (body) => {
       // Make the API call to create a new template
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/create`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
      });
 };
 
 /** API-Aufruf zum Anwenden einer Vorlage */
 export const applyTemplate = async (body) => {
       // Make the API call to apply a template to a specific week
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/apply`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
      });
 };
 
 /** API-Aufruf zum Löschen einer Vorlage */
 export const deleteTemplate = async (templateId) => {
       // Make the API call to delete a template
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/delete`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ templateId: templateId })
      });
 };
 
 // --- NEUE API-FUNKTIONEN (HINZUGEFÜGT) ---
 
 /** API-Aufruf zum Laden der Details einer einzelnen Vorlage */
 export const loadTemplateDetails = async (templateId) => {
       // Dieser Endpunkt muss noch in routes.php und PlanController.php erstellt werden
       // Annahme: GET-Anfrage, gibt { success: true, data: { template: {...}, entries: [...] } } zurück
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/${templateId}`);
 };
 
 /** API-Aufruf zum Speichern/Aktualisieren einer Vorlage aus dem Editor */
 export const saveTemplate = async (templateData) => {
       // Dieser Endpunkt muss noch in routes.php und PlanController.php erstellt werden
       // Annahme: POST-Anfrage, sendet { template_id (optional), name, description, entries: [...] }
      return await apiFetch(`${window.APP_CONFIG.baseUrl}/api/planer/templates/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(templateData)
      });
 };

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-api.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-dashboard.js ---
// public/assets/js/planer-dashboard.js
import { initializePlanerInteractions } from './planer-interactions-2.js'; // Importiere Teil 2
import { loadInitialData } from './planer-api.js';

/**
 * Initialisiert das Planer-Dashboard.
 */
export function initializePlanerDashboard() {
    console.log("planer-dashboard: Initialisiere Planer Interaktionen..."); // Log hinzugefügt
    // 1. Alle Event-Listener und Interaktionslogik initialisieren (jetzt in Teil 2)
    initializePlanerInteractions();

    console.log("planer-dashboard: Lade initiale Daten..."); // Log hinzugefügt
    // 2. Die initialen Stammdaten laden (was wiederum das Laden des Plans auslöst)
    loadInitialData(); // Aufruf wieder aktiviert
}

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-dashboard.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-dom.js ---
 // --- DOM Referenzen ---
 export const viewModeSelector = document.getElementById('view-mode-selector');
 export const classSelectorContainer = document.getElementById('class-selector-container');
 export const classSelector = document.getElementById('class-selector');
 export const teacherSelectorContainer = document.getElementById('teacher-selector-container');
 export const teacherSelector = document.getElementById('teacher-selector');
 export const yearSelector = document.getElementById('year-selector');
 export const weekSelector = document.getElementById('week-selector');
 export const dateSelector = document.getElementById('date-selector');
 export const timetableContainer = document.getElementById('timetable-container');
 export const modal = document.getElementById('timetable-modal');
 // Verhindere Fehler, wenn das Modal (z.B. auf anderen Seiten) nicht existiert
 export const modalTitle = document.getElementById('modal-title');
 export const form = document.getElementById('timetable-entry-form');
 export const deleteBtn = document.getElementById('delete-entry-btn');
 export const modalTabs = modal ? modal.querySelectorAll('.modal-tabs .tab-button') : [];
 export const regularFields = document.getElementById('regular-fields');
 export const substitutionFields = document.getElementById('substitution-fields');
 export const substitutionTypeSelect = document.getElementById('substitution_type');
 export const publishWeekLabel = document.getElementById('publish-week-label');
 export const publishStatusStudent = document.getElementById('publish-status-student');
 export const publishStatusTeacher = document.getElementById('publish-status-teacher');
 export const publishStudentBtn = document.getElementById('publish-student-btn');
 export const publishTeacherBtn = document.getElementById('publish-teacher-btn');
 export const unpublishStudentBtn = document.getElementById('unpublish-student-btn');
 export const unpublishTeacherBtn = document.getElementById('unpublish-teacher-btn');
 export const regularCommentInput = document.getElementById('regular_comment');
 export const substitutionCommentInput = document.getElementById('substitution_comment');
 
 // *** Konflikt-Warnung ***
 export const conflictWarningBox = document.getElementById('modal-conflict-warning');
 export const saveButton = document.getElementById('modal-save-btn');
 // Füge eine Prüfung hinzu, ob 'modal' existiert
 export const conflictCheckFields = modal ? modal.querySelectorAll('.conflict-check') : []; // Alle Felder, die Prüfung auslösen
 
 // *** DOM Referenzen für Kopiermodal ***
 export const copyWeekBtn = document.getElementById('copy-week-btn');
 export const copyWeekModal = document.getElementById('copy-week-modal');
 export const copyWeekForm = document.getElementById('copy-week-form');
 export const copySourceDisplay = document.getElementById('copy-source-display');
 export const copyTargetYear = document.getElementById('copy-target-year');
 export const copyTargetWeek = document.getElementById('copy-target-week');
 export const copyWeekConfirmBtn = document.getElementById('copy-week-confirm-btn');
 export const copyWeekCancelBtn = document.getElementById('copy-week-cancel-btn');
 
 // *** NEUE DOM Referenzen für Vorlagen ***
 export const createTemplateBtn = document.getElementById('create-template-btn');
 export const applyTemplateBtn = document.getElementById('apply-template-btn');
 export const manageTemplatesBtn = document.getElementById('manage-templates-btn');
 export const manageTemplatesModal = document.getElementById('manage-templates-modal');
 export const manageTemplatesViewContainer = document.getElementById('manage-templates-view-container'); // Container für Ansichten
 export const templateListView = document.getElementById('template-list-view'); // Ansicht: Liste
 export const templateEditorView = document.getElementById('template-editor-view'); // Ansicht: Editor
 export const manageTemplatesForm = document.getElementById('create-template-form'); // Form zum Erstellen aus Woche
 export const createEmptyTemplateBtn = document.getElementById('create-empty-template-btn'); // Button für leere Vorlage
 export const manageTemplatesList = document.getElementById('templates-list-container');
 export const manageTemplatesCloseBtn = document.getElementById('manage-templates-close-btn');
 export const templateEditorTitle = document.getElementById('template-editor-title');
 export const templateEditorGridContainer = document.getElementById('template-editor-grid-container'); // Grid-Container
 export const backToTemplateListBtn = document.getElementById('back-to-template-list-btn'); // Zurück zur Liste
 export const saveTemplateEditorBtn = document.getElementById('save-template-editor-btn'); // Speichern im Editor
 export const applyTemplateModal = document.getElementById('apply-template-modal');
 export const applyTemplateForm = document.getElementById('apply-template-form');
 export const applyTemplateSelect = document.getElementById('apply-template-select');
 export const applyTemplateConfirmBtn = document.getElementById('apply-template-confirm-btn');
 export const applyTemplateCancelBtn = document.getElementById('apply-template-cancel-btn');
 
 // *** Konstanten für Grid-Rendering ***
 export const days = ["Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag"];
 export const timeSlots = [
     "08:00 - 08:45", "08:55 - 09:40", "09:40 - 10:25", "10:35 - 11:20",
     "11:20 - 12:05", "13:05 - 13:50", "13:50 - 14:35", "14:45 - 15:30",
     "15:30 - 16:15", "16:25 - 17:10"
 ];


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-dom.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-1.js ---
// public/assets/js/planer-interactions-1.js
// MODIFIZIERT: Logik in openModal, debouncedConflictCheck und initializeEntryModal (handleSubmit)
// korrigiert, um mit den neuen Datenstrukturen (Maps von Arrays) und parallelen Einträgen
// korrekt umzugehen.
// KORRIGIERT: Syntaktische Fehler (eingestreute Zeichen wie 'm', 's', 'Maus') entfernt.

import * as DOM from './planer-dom.js';
import { getState, updateState, clearSelectionState, setSelectionState } from './planer-state.js';
import { getWeekAndYear, getDateOfISOWeek, getDateForDayInWeek, escapeHtml } from './planer-utils.js';
// Import API functions used locally
// KORREKTUR: loadPlanData hinzugefügt
import { checkConflicts, saveEntry, deleteEntry, saveSubstitution, deleteSubstitution, loadPlanData } from './planer-api.js';
// KORRIGIERTER IMPORT: populateYearSelector und populateWeekSelector hinzugefügt
import { showConflicts, hideConflicts, populateYearSelector, populateWeekSelector } from './planer-ui.js';
// Import notifications
import { showToast, showConfirm } from './notifications.js';

// --- Interaktionen Teil 1: Modal-Logik ---

/**
 * Definiert die debounced Conflict Check Funktion auf Modulebene,
 * damit sie von openModal, switchMode und initializeEntryModal aufgerufen werden kann.
 * KORRIGIERT: Liest Daten aus dem Formular und dem State, nicht mehr nur aus state.selection.
 */
const debouncedConflictCheck = () => {
    clearTimeout(getState().conflictCheckTimeout);
    updateState({
        conflictCheckTimeout: setTimeout(async () => {
            const state = getState();
            // Konfliktprüfung nur im 'regular' Modus und NICHT im Template-Editor
            if (state.activeMode !== 'regular' || (DOM.form && DOM.form.querySelector('#modal_editing_template').value === 'true')) {
                hideConflicts();
                return;
            }

            // *** KORRIGIERT: Daten direkt aus dem Formular und state.selection lesen ***
            
            const dayOfWeek = DOM.form.querySelector('#modal_day_of_week').value;
            const entryId = DOM.form.querySelector('#entry_id').value || null;
            const blockId = DOM.form.querySelector('#block_id').value || null;

            let startPeriod, endPeriod;
            
            if (blockId && !entryId) {
                // Bearbeite einen Block (basierend auf der Auswahl)
                if (state.selection && state.selection.cells.length > 0) {
                    startPeriod = Math.min(...state.selection.cells.map(c => parseInt(c.dataset.period)));
                    endPeriod = Math.max(...state.selection.cells.map(c => parseInt(c.dataset.period)));
                } else {
                    // Fallback (sollte nicht passieren, wenn openModal korrekt funktioniert)
                    startPeriod = parseInt(DOM.form.querySelector('#modal_period_number').value);
                    endPeriod = startPeriod;
                }
            } else {
                // Einzelner Eintrag (neu oder Bearbeitung)
                // (Die Perioden-Auswahl wird für einzelne parallele Einträge nicht unterstützt)
                startPeriod = parseInt(DOM.form.querySelector('#modal_period_number').value);
                endPeriod = startPeriod;
            }

            if (!startPeriod || !endPeriod) {
                // console.warn("Konfliktprüfung übersprungen: Periode nicht ermittelbar.");
                hideConflicts();
                return;
            }
            
            const data = {
                year: DOM.yearSelector.value,
                calendar_week: DOM.weekSelector.value,
                day_of_week: dayOfWeek,
                start_period_number: startPeriod,
                end_period_number: endPeriod,
                teacher_id: DOM.form.querySelector('#teacher_id').value,
                room_id: DOM.form.querySelector('#room_id').value,
                class_id: state.editingClassId, // Holt die ID der Klasse, die bearbeitet wird
                entry_id: entryId,
                block_id: blockId,
            };

            // Don't check if essential data is missing
            if (!data.teacher_id || !data.room_id || !data.class_id || !data.day_of_week || !data.start_period_number) {
                hideConflicts();
                return;
            }

            try {
                // This will throw an error if conflicts exist, handled by apiFetch and catch block
                await checkConflicts(data);
                // If checkConflicts didn't throw, hide any previous warnings
                hideConflicts();
            } catch (error) {
                // Error is already handled by apiFetch (shows toast)
                // We need to show the conflict details in the modal
                console.error("Fehler bei Konfliktprüfung (gefangen):", error);
                if (error.message) {
                    showConflicts(error.message.split("\n"));
                } else {
                    showConflicts(["Unbekannter Fehler bei der Konfliktprüfung."]);
                }
            }
        }, 300) // 300ms debounce time
    });
};

/** Setzt die Haupt-Selektoren auf die aktuelle Woche */
export function setDefaultSelectors() {
    const today = new Date();
    const { week, year } = getWeekAndYear(today);
    populateYearSelector(DOM.yearSelector, year);
    populateWeekSelector(DOM.weekSelector, week);

    const dayOfWeek = today.getDay();
    if (dayOfWeek >= 1 && dayOfWeek <= 5) {
        DOM.dateSelector.value = today.toISOString().split('T')[0];
    } else {
        DOM.dateSelector.value = '';
    }
}

/** * Behandelt Klicks auf Zellen im Grid (Single Click für Selektion)
 * @param {HTMLElement} cell - Die angeklickte Zelle (TD)
 * @param {HTMLElement} container - Der Grid-Container (timetableContainer oder templateEditorGridContainer)
 */
export function handleCellClick(cell, container) {
    if (!container) { // Fallback, falls Container nicht übergeben wird
        container = DOM.timetableContainer;
    }
    const clickedDay = cell.dataset.day;
    const clickedPeriod = parseInt(cell.dataset.period);
    const state = getState();

    // *** KORREKTUR: Die Klick-Logik MUSS das .planner-entry (den Div) berücksichtigen ***
    // (Annahme: Der Event-Listener in interactions-2.js wurde noch nicht angepasst und übergibt 'cell' (das TD))
    
    // HINWEIS: Die bestehende `handleCellClick`-Logik ist für Multi-Zellen-Auswahl (Block-Erstellung)
    // durch Ziehen oder Klicken. Sie ist NICHT für die Auswahl *einzelner* paralleler Einträge gedacht.
    
    // Wir behalten die Block-Auswahl-Logik (Klick auf <td>), da sie für das Erstellen neuer Blöcke 
    // und das Bearbeiten von Vorlagen-Blöcken (Template-Editor) benötigt wird.
    
    // Die Auswahl eines *spezifischen* parallelen Eintrags erfolgt über DBLCLICK,
    // was direkt `openModal` auslöst (siehe Anpassung in Teil 2).

    // --- Bisherige Block-Auswahl-Logik (leicht angepasst) ---
    
    // Finde Daten des *ersten* Eintrags in der Zelle (falls vorhanden), um die Gruppe zu bestimmen
    const firstEntryInCell = cell.querySelector('.planner-entry');
    const cellData = firstEntryInCell ? firstEntryInCell.dataset : {}; // Verwende .dataset des Eintrags, nicht der Zelle

    const startCellData = state.selection.start ? state.selection.start.cellData : {};
    
    const isSameGroupAsStart = (startCellData.blockId && cellData.blockId === startCellData.blockId) ||
                             (startCellData.entryId && cellData.entryId === startCellData.entryId) ||
                             (startCellData.substitutionId && cellData.substitutionId === startCellData.substitutionId);

    const startIsEmpty = !startCellData.entryId && !startCellData.blockId && !startCellData.substitutionId;
    const currentIsEmpty = !cellData.entryId && !cellData.blockId && !cellData.substitutionId;

    if (
        !state.selection.start ||
        clickedDay !== state.selection.start.day ||
        cell.classList.contains('default-entry') || // Prevent selecting FU cells
        (!isSameGroupAsStart && !(startIsEmpty && currentIsEmpty))
    ) {
        clearSelectionState(state.selection.cells); // Clear previous visual selection
        setSelectionState({ start: { day: clickedDay, period: clickedPeriod, cell: cell, cellData: cellData }, end: null, cells: [cell] });
        cell.classList.add('selected');
        return;
    }

    // --- Extend selection ---
    state.selection.end = { day: clickedDay, period: clickedPeriod };
    const startPeriod = Math.min(state.selection.start.period, state.selection.end.period);
    const endPeriod = Math.max(state.selection.start.period, state.selection.end.period);

    state.selection.cells.forEach(c => c.classList.remove('selected'));
    const newSelectionCells = [];

    for (let p = startPeriod; p <= endPeriod; p++) {
        const cellToSelect = container.querySelector(`.grid-cell[data-day='${clickedDay}'][data-period='${p}']`);
        if (cellToSelect) {
            const firstEntryInCellToSelect = cellToSelect.querySelector('.planner-entry');
            const currentCellData = firstEntryInCellToSelect ? firstEntryInCellToSelect.dataset : {};

            const isCurrentSameGroup = (startCellData.blockId && currentCellData.blockId === startCellData.blockId) ||
                                     (startCellData.entryId && currentCellData.entryId === startCellData.entryId) ||
                                     (startCellData.substitutionId && currentCellData.substitutionId === startCellData.substitutionId);
            const isCurrentEmpty = !currentCellData.entryId && !currentCellData.blockId && !currentCellData.substitutionId;

            if ((startIsEmpty && !isCurrentEmpty) || (!startIsEmpty && !isCurrentSameGroup)) {
                clearSelectionState(state.selection.cells.concat(newSelectionCells));
                setSelectionState({ start: { day: clickedDay, period: clickedPeriod, cell: cell, cellData: cellData }, end: null, cells: [cell] });
                cell.classList.add('selected');
                return; 
            }

            cellToSelect.classList.add('selected');
            newSelectionCells.push(cellToSelect);
        }
    }
    state.selection.cells = newSelectionCells;
    state.selection.start.cell = newSelectionCells[0];
    state.selection.start.period = parseInt(newSelectionCells[0].dataset.period);
    setSelectionState(state.selection); // Update the global state
}


/** Logik für das Haupt-Eintragsmodal */
export function initializeEntryModal() {
    // --- Konfliktprüfung ---
    // Die Funktion debouncedConflictCheck ist jetzt auf Modulebene definiert.
    // Wir fügen hier nur die Event-Listener hinzu.

    DOM.conflictCheckFields.forEach(field => {
        field.addEventListener('change', debouncedConflictCheck);
    });
    // --- Ende Konfliktprüfung ---


    DOM.modalTabs.forEach(tab => tab.addEventListener('click', () => switchMode(tab.dataset.mode)));
    DOM.substitutionTypeSelect.addEventListener('change', () => {
        updateSubstitutionFields();
        hideConflicts(); // Hide conflicts when switching substitution type
    });

    // --- Form Submit ---
    DOM.form.addEventListener('submit', async (e) => {
        e.preventDefault();
        // Prevent saving if conflict warning is visible
        if (DOM.conflictWarningBox && DOM.conflictWarningBox.style.display !== 'none') {
            showToast("Speichern nicht möglich: Es bestehen Konflikte.", 'error');
            return;
        }

        const formData = new FormData(DOM.form);
        const state = getState();

        // Clean up form data based on mode
        if (state.activeMode === 'regular') {
            formData.set('comment', DOM.regularCommentInput.value); // Ensure correct comment is set
            // Remove substitution-specific fields
            formData.delete('substitution_type');
            formData.delete('new_teacher_id');
            formData.delete('new_subject_id');
            formData.delete('new_room_id');
            formData.delete('original_subject_id'); // Make sure this is not sent
        } else { // Substitution mode
            formData.set('comment', DOM.substitutionCommentInput.value); // Ensure correct comment is set
        }

        const data = Object.fromEntries(formData.entries());
        let promise;

        if (state.activeMode === 'substitution') {
            // Add date and potentially original subject ID for substitution save
            const dayOfWeek = DOM.form.querySelector('#modal_day_of_week').value;
            data.date = getDateForDayInWeek(dayOfWeek, DOM.yearSelector.value, DOM.weekSelector.value);

            // Find original subject ID from the (potentially hidden) regular entry ID
            const entryId = DOM.form.querySelector('#entry_id').value; // ID des regulären Eintrags
            if (entryId) {
                 // KORREKTUR: Finde den regulären Eintrag im flachen Array
                 const regularEntry = state.currentTimetable.find(e => e.entry_id == entryId);
                 data.original_subject_id = regularEntry?.subject_id || null;
            } else {
                 data.original_subject_id = null; // Kein zugrundeliegender Eintrag (z.B. Sonderevent in Lücke)
            }
            
            data.class_id = state.editingClassId; // Ensure class_id is set for substitution
            if (!data.class_id) {
                showToast("Fehler: Klasse für Vertretung konnte nicht ermittelt werden.", 'error');
                return; // Stop if class ID is missing
            }
            promise = saveSubstitution(data);
        } else { // Regulärer Modus
            // *** KORREKTUR: Verwende die IDs aus dem Formular UND state.selection für Spannen ***
            const entryId = DOM.form.querySelector('#entry_id').value || null;
            const blockId = DOM.form.querySelector('#block_id').value || null;

            let startPeriod, endPeriod;
            
            // KORRIGIERTE LOGIK:
            // Wenn wir eine Auswahl haben (state.selection), hat der Benutzer geklickt/gezogen.
            // Nutze diese Auswahl für die Perioden.
            if (state.selection && state.selection.cells && state.selection.cells.length > 0) {
                startPeriod = Math.min(...state.selection.cells.map(c => parseInt(c.dataset.period)));
                endPeriod = Math.max(...state.selection.cells.map(c => parseInt(c.dataset.period)));
            } else {
                // Fallback (z.B. wenn Modal ohne Klick geöffnet wurde? sollte nicht passieren)
                startPeriod = parseInt(DOM.form.querySelector('#modal_period_number').value);
                endPeriod = startPeriod;
            }

            data.start_period_number = startPeriod;
            data.end_period_number = endPeriod;
            data.year = DOM.yearSelector.value;
            data.calendar_week = DOM.weekSelector.value;
            
            // KORREKTUR: class_id muss explizit gesetzt werden
            if (DOM.form.querySelector('#modal_editing_template').value === 'true') {
                 data.class_id = DOM.modal.querySelector('#template_class_id').value || '0';
            } else {
                 data.class_id = state.editingClassId;
            }

            if (!data.class_id && data.class_id !== '0') {
                showToast("Fehler: Konnte Klasse nicht ermitteln.", 'error');
                return;
            }

            promise = saveEntry(data);
        }

        // Execute save and handle response
        try {
            const response = await promise;
            if (response.success) {
                showToast("Änderungen erfolgreich gespeichert.", 'success');
                closeModal();
                loadPlanData(); // Reload data after saving
            }
            // Errors are handled by apiFetch
        } catch (error) { /* Error already shown by apiFetch */ }
    });
    // --- Delete Button ---
    DOM.deleteBtn.addEventListener('click', async () => {
        let confirmMsg;
        const state = getState();
        const promises = []; // Array für mehrere Lösch-Promises
        
        // *** KORREKTUR: Daten direkt aus dem Formular statt aus state.selection holen ***
        const substitutionId = DOM.form.querySelector('#substitution_id').value;
        const entryId = DOM.form.querySelector('#entry_id').value;
        const blockId = DOM.form.querySelector('#block_id').value;

        if (state.activeMode === 'substitution') {
            if (!substitutionId) {
                showToast("Fehler: Keine Vertretungs-ID gefunden.", 'error');
                return;
            }
            
            confirmMsg = 'Soll diese Vertretung gelöscht werden? (Die reguläre Stunde bleibt erhalten)';
            
            // Nur Vertretung löschen
            promises.push(deleteSubstitution(substitutionId));

            // Optional: Wenn der Benutzer auch die reguläre Stunde löschen will (komplexer)
            // if (await showConfirm("Zusatzfrage", "Soll die zugrundeliegende reguläre Stunde auch gelöscht werden?")) { ... }
            
            if (await showConfirm("Löschen bestätigen", confirmMsg)) {
                try {
                    const responses = await Promise.all(promises);
                    if (responses.every(r => r && r.success)) {
                        showToast("Vertretung erfolgreich gelöscht.", 'success');
                        closeModal();
                        loadPlanData();
                    } else {
                        throw new Error("Eintrag konnte nicht gelöscht werden.");
                    }
                } catch (error) { /* Fehler wird von apiFetch behandelt */ }
            }

        } else { // Regular mode
            let body;
            if (blockId) {
                body = { block_id: blockId };
                confirmMsg = 'Soll dieser gesamte Block wirklich gelöscht werden?';
            } else if (entryId) {
                body = { entry_id: entryId };
                confirmMsg = 'Soll diese reguläre Stunde wirklich gelöscht werden?';
            } else {
                showToast("Kein Eintrag zum Löschen ausgewählt.", 'error'); return;
            }
            
            if (await showConfirm("Löschen bestätigen", confirmMsg)) {
                try {
                    const response = await deleteEntry(body);
                    if (response.success) {
                        showToast("Eintrag erfolgreich gelöscht.", 'success');
                        closeModal();
                        loadPlanData(); // Reload data after deleting
                    }
                } catch (error) { /* Error already shown */ }
            }
        }
    });

    // --- Cancel / Close Modal ---
    DOM.modal.addEventListener('click', (e) => {
        // Close if clicking outside the modal box or on the cancel button
        if (e.target.id === 'timetable-modal' || e.target.id === 'modal-cancel-btn') {
            closeModal();
        }
    });
}


/** * Öffnet das Eintragsmodal und füllt es basierend auf dem Klick-Ereignis.
* KORRIGIERT: Akzeptiert das Event 'e' anstelle von 'isTemplateEdit'.
 * KORRIGIERT: Findet den korrekten Eintrag in den State-Arrays.
 * KORRIGIERT: Setzt editingClassId korrekt.
 */
export function openModal(event, isTemplateEdit = false) {
    const state = getState();
    DOM.form.reset(); // Clear previous data
    hideConflicts(); // Clear old conflicts

    // *** KORREKTUR: Ermittle das Klick-Ziel ***
    const target = event.target;
    const clickedEntryElement = target.closest('.planner-entry');
    const clickedCellElement = target.closest('.grid-cell');

    if (!clickedCellElement) return; // Klick außerhalb des Grids

    const day = clickedCellElement.dataset.day;
    const period = clickedCellElement.dataset.period;
    const cellKey = clickedCellElement.dataset.cellKey; // "day-period"
    let entryId = null;
    let substitutionId = null;
    let blockId = null;
    let entryToEdit = null;
    let regularEntryForSub = null;
    let modeToSwitchTo = 'regular';
    let editingClassId = null;

    // Setze versteckte Felder (Tag/Stunde)
    DOM.form.querySelector('#modal_day_of_week').value = day;
    DOM.form.querySelector('#modal_period_number').value = period;
    DOM.form.querySelector('#modal_editing_template').value = isTemplateEdit ? 'true' : 'false';

    // *** KORREKTUR: Logik basierend auf Klick-Ziel (Eintrag vs. Zelle) ***
    
    if (isTemplateEdit) {
        // --- Template-Editor-Logik ---
        DOM.modal.querySelector('#template-class-select-container').style.display = 'block';
        DOM.modal.querySelector('.modal-tabs .tab-button[data-mode="substitution"]').style.display = 'none';
        
        const templateData = state.currentTemplateEditorData || [];
        if (clickedEntryElement) {
            entryId = clickedEntryElement.dataset.templateEntryId || null;
            blockId = clickedEntryElement.dataset.blockId || null; // (ist block_ref)
            if (blockId) entryToEdit = templateData.find(e => e.block_ref === blockId);
            else if (entryId) entryToEdit = templateData.find(e => e.template_entry_id == entryId);
        }
        editingClassId = entryToEdit ? entryToEdit.class_id : '0'; // Default '0'
        modeToSwitchTo = 'regular';

    } else {
        // --- Normale Planer-Logik ---
        DOM.modal.querySelector('#template-class-select-container').style.display = 'none';
        DOM.modal.querySelector('.modal-tabs .tab-button[data-mode="substitution"]').style.display = 'block';

        if (clickedEntryElement) {
            // A. Klick auf einen vorhandenen Eintrag
            entryId = clickedEntryElement.dataset.entryId || null;
            substitutionId = clickedEntryElement.dataset.substitutionId || null;
            blockId = clickedEntryElement.dataset.blockId || null;

            if (substitutionId) {
                // A1. Vertretung angeklickt
                // KORREKTUR: Finde in der Map (Array)
                entryToEdit = (state.substitutions[cellKey] || []).find(s => s.substitution_id == substitutionId);
                if (entryToEdit) {
                    // Finde den regulären Eintrag für diese Zelle (falls vorhanden)
                    const regularEntriesInCell = state.timetable[cellKey] || [];
                    // KORREKTUR: Finde basierend auf class_id UND original_subject_id
                    regularEntryForSub = regularEntriesInCell.find(e => e.class_id == entryToEdit.class_id && e.subject_id == entryToEdit.original_subject_id);
                    editingClassId = entryToEdit.class_id;
                }
                modeToSwitchTo = 'substitution';
            } else if (entryId || blockId) {
                // A2. Regulären Eintrag angeklickt
                // KORREKTUR: Finde in der Map (Array)
                const entriesInCell = state.timetable[cellKey] || [];
                if (blockId) {
                    entryToEdit = entriesInCell.find(e => e.block_id === blockId);
                } else {
                    entryToEdit = entriesInCell.find(e => e.entry_id == entryId);
                }
                if(entryToEdit) editingClassId = entryToEdit.class_id;
                modeToSwitchTo = 'regular';
            }
        } else {
            // B. Klick auf leere Zelle (neuer Eintrag)
            modeToSwitchTo = 'regular';
            // KORREKTUR: Setze editingClassId korrekt für Klassen- vs. Lehreransicht
            editingClassId = (state.currentViewMode === 'class') ? state.selectedClassId : '0';
        }
    }
    
    updateState({ editingClassId: editingClassId }); // Speichere die Klasse des Eintrags

    // --- Versteckte Felder setzen ---
    if (regularEntryForSub) {
        // Bearbeite Vertretung, speichere IDs des regulären Eintrags
        DOM.form.querySelector('#entry_id').value = regularEntryForSub.entry_id || '';
        DOM.form.querySelector('#block_id').value = regularEntryForSub.block_id || '';
        DOM.form.querySelector('#substitution_id').value = entryToEdit?.substitution_id || '';
    } else if (entryToEdit && modeToSwitchTo === 'regular') {
        // Bearbeite regulären Eintrag
        DOM.form.querySelector('#entry_id').value = isTemplateEdit ? (entryToEdit.template_entry_id || '') : (entryToEdit.entry_id || '');
        DOM.form.querySelector('#block_id').value = isTemplateEdit ? (entryToEdit.block_ref || '') : (entryToEdit.block_id || '');
        DOM.form.querySelector('#substitution_id').value = '';
    } else {
        // Neuer Eintrag
        DOM.form.querySelector('#entry_id').value = '';
        DOM.form.querySelector('#block_id').value = '';
        DOM.form.querySelector('#substitution_id').value = '';
    }

    // --- Modal-Titel setzen ---
    // KORREKTUR: Verwende state.selection (das im Klick-Event in interactions-2.js gesetzt wurde)
    if (state.selection && (state.selection.cells.length > 1 || (state.selection.start && state.selection.start.cellData.blockId))) {
        const startP = Math.min(...state.selection.cells.map(c => parseInt(c.dataset.period)));
        const endP = Math.max(...state.selection.cells.map(c => parseInt(c.dataset.period)));
        DOM.modalTitle.textContent = `Block bearbeiten (${DOM.days[day-1]}, ${startP}. - ${endP}. Stunde)`;
    } else {
        DOM.modalTitle.textContent = `Eintrag bearbeiten (${DOM.days[day-1]}, ${period}. Stunde)`;
    }


    // --- Formular füllen ---
    switchMode(modeToSwitchTo, isTemplateEdit); // Tabs umschalten

    if (modeToSwitchTo === 'regular') {
        if(entryToEdit){ // Bearbeite regulären Eintrag
            DOM.form.querySelector('#subject_id').value = entryToEdit.subject_id;
            DOM.form.querySelector('#teacher_id').value = entryToEdit.teacher_id;
            DOM.form.querySelector('#room_id').value = entryToEdit.room_id;
            DOM.regularCommentInput.value = entryToEdit.comment || '';
            if (isTemplateEdit) DOM.modal.querySelector('#template_class_id').value = entryToEdit.class_id || '0';
        } else { // Neuer regulärer Eintrag
            DOM.regularCommentInput.value = '';
            // (Standardwerte werden nicht mehr vorausgefüllt, um parallele Einträge zu erleichtern)
            if (isTemplateEdit) DOM.modal.querySelector('#template_class_id').value = editingClassId || '0';
        }
    } else if (modeToSwitchTo === 'substitution') {
        // Fülle reguläre Felder (deaktiviert) mit Originaldaten
        DOM.form.querySelector('#subject_id').value = regularEntryForSub?.subject_id || '';
        DOM.form.querySelector('#teacher_id').value = regularEntryForSub?.teacher_id || '';
        DOM.form.querySelector('#room_id').value = regularEntryForSub?.room_id || '';
        DOM.form.querySelector('#original_subject_id').value = regularEntryForSub?.subject_id || ''; // Hidden field
        DOM.regularCommentInput.value = regularEntryForSub?.comment || ''; 

        if(entryToEdit){ // Bearbeite bestehende Vertretung
            DOM.form.querySelector('#substitution_type').value = entryToEdit.substitution_type;
            DOM.form.querySelector('#new_teacher_id').value = entryToEdit.new_teacher_id || '';
            DOM.form.querySelector('#new_subject_id').value = entryToEdit.new_subject_id || '';
            DOM.form.querySelector('#new_room_id').value = entryToEdit.new_room_id || '';
            DOM.substitutionCommentInput.value = entryToEdit.comment || '';
        } else { // Neue Vertretung erstellen
            DOM.form.querySelector('#substitution_type').value = 'Vertretung';
            DOM.substitutionCommentInput.value = '';
            DOM.form.querySelector('#new_subject_id').value = regularEntryForSub?.subject_id || '';
            DOM.form.querySelector('#new_room_id').value = regularEntryForSub?.room_id || '';
            DOM.form.querySelector('#new_teacher_id').value = '';
        }
        updateSubstitutionFields(); // Zeige korrekte Felder
    }

    updateDeleteButtonVisibility();
    DOM.modal.classList.add('visible');
    if (!isTemplateEdit) debouncedConflictCheck(); // Initiale Konfliktprüfung
}


/** Schließt das Eintragsmodal */
export function closeModal() {
    clearSelectionState(getState().selection.cells); // Clear visual selection in grid
    DOM.modal.classList.remove('visible'); // Hide modal
    hideConflicts(); // Clear conflict messages
    updateState({ editingClassId: null }); // Clear editing class ID
    // Reset template editor flag and class select visibility
    if (DOM.form) { // Add check if DOM.form exists
        DOM.form.querySelector('#modal_editing_template').value = 'false';
        const templateClassSelect = DOM.form.querySelector('#template-class-select-container');
        if (templateClassSelect) {
            templateClassSelect.style.display = 'none';
        }
    }
}


/** Wechselt den Modus (Tab) im Eintragsmodal */
export function switchMode(mode, isTemplateEditor = false) {
    updateState({ activeMode: mode }); // Update global state

    // Toggle active classes for tabs and content panes
    DOM.modalTabs.forEach(tab => tab.classList.toggle('active', tab.dataset.mode === mode));
    DOM.regularFields.classList.toggle('active', mode === 'regular');
    DOM.substitutionFields.classList.toggle('active', mode === 'substitution');

    hideConflicts(); // Hide conflicts when switching mode

    if (mode === 'substitution') {
        const dayOfWeek = DOM.form.querySelector('#modal_day_of_week').value;
        if (!dayOfWeek) { 
            showToast("Kann keine Vertretung ohne ausgewählten Tag erstellen.", 'error');
            setTimeout(() => switchMode('regular', isTemplateEditor), 0);
            return;
        }
        updateState({ selectedDate: getDateForDayInWeek(dayOfWeek, DOM.yearSelector.value, DOM.weekSelector.value) });

        // (Vor-Befüllung der Felder wurde bereits in openModal() erledigt)
        
        updateSubstitutionFields(); // Show/hide fields based on the selected substitution type

    }
    updateDeleteButtonVisibility(); // Update delete button visibility based on mode/IDs
    if (!isTemplateEditor) debouncedConflictCheck(); // Check conflicts unless in template editor
}


/** Zeigt/Versteckt Felder im Vertretungs-Tab basierend auf dem Typ */
export function updateSubstitutionFields() {
    const type = DOM.substitutionTypeSelect.value;
    DOM.modal.querySelectorAll('#substitution-details .sub-field').forEach(field => {
        const types = field.dataset.types ? JSON.parse(field.dataset.types) : [];
        field.style.display = types.includes(type) ? 'block' : 'none';
    });
}

/** Zeigt/Versteckt den Löschen-Button im Modal */
export function updateDeleteButtonVisibility() {
    const entryId = DOM.form.querySelector('#entry_id').value;
    const substitutionId = DOM.form.querySelector('#substitution_id').value;
    const blockId = DOM.form.querySelector('#block_id').value;
    const isTemplateEdit = DOM.form.querySelector('#modal_editing_template').value === 'true';

    const canDelete = !isTemplateEdit && (
        (getState().activeMode === 'substitution' && substitutionId) ||
        (getState().activeMode === 'regular' && (entryId || blockId))
    );
    
    // KORREKTUR: Tippfehler 'SO' zu 'DOM' (bereits im Original-Code korrekt)
    DOM.deleteBtn.style.display = canDelete ? 'block' : 'none';
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-1.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-2.js ---
// public/assets/js/planer-interactions-2.js
// KORRIGIERT: Drag-Start (dragstart) Logik. Berechnet Span/IDs jetzt korrekt aus dem State.

import * as DOM from './planer-dom.js';
import { getState, updateState, clearSelectionState, setSelectionState } from './planer-state.js';
import { getWeekAndYear, getDateOfISOWeek, getDateForDayInWeek, escapeHtml } from './planer-utils.js';
// KORREKTUR: Import 'renderTimetableGrid'
import { loadPlanData, publishWeek, checkConflicts, saveEntry, deleteEntry, saveSubstitution, deleteSubstitution, copyWeek, loadTemplates, createTemplate, applyTemplate, deleteTemplate, loadTemplateDetails, saveTemplate } from './planer-api.js';
// KORREKTUR: Import 'renderTimetableGrid'
import { renderTimetableGrid } from './planer-timetable.js';
import { populateYearSelector, populateWeekSelector, populateTemplateSelects, showTemplateView, showConflicts, hideConflicts, populateAllModalSelects } from './planer-ui.js';
// Import notifications
import { showToast, showConfirm } from './notifications.js';
// Import functions from part 1
import { setDefaultSelectors, handleCellClick, initializeEntryModal, openModal, closeModal, switchMode, updateSubstitutionFields, updateDeleteButtonVisibility } from './planer-interactions-1.js';

/**
 * Initialisiert alle Event-Listener und Hauptinteraktionen für die Planer-Oberfläche.
 */
export function initializePlanerInteractions() {

    // Setze Standard-Selektoren
    setDefaultSelectors();
    // Initialisiere Modal-Logik
    initializeEntryModal(); // From part 1

    // UI-Handler
    const handleDateOrWeekChange = () => {
        const dateVal = DOM.dateSelector.value;
        if (dateVal) {
            const dateObj = new Date(dateVal + 'T00:00:00'); // Ensure local time interpretation
            const { week, year } = getWeekAndYear(dateObj);
            // If date change resulted in a new week/year, update selectors and reload
            if (DOM.yearSelector.value != year || DOM.weekSelector.value != week) {
                DOM.yearSelector.value = year;
                DOM.weekSelector.value = week;
                loadPlanData(); // Reload plan for the new week/year
                return; // Prevent double loading
            }
        }
        // If only week/year changed, or date didn't change the week/year, just reload
        loadPlanData();
    };
    const handleViewModeChange = () => {
        updateState({ currentViewMode: DOM.viewModeSelector.value });
        if (getState().currentViewMode === 'class') {
            DOM.classSelectorContainer.classList.remove('hidden');
            DOM.teacherSelectorContainer.classList.add('hidden');
            DOM.teacherSelector.value = ''; // Reset teacher selection
        } else {
            DOM.classSelectorContainer.classList.add('hidden');
            DOM.teacherSelectorContainer.classList.remove('hidden');
            DOM.classSelector.value = ''; // Reset class selection
        }
        loadPlanData(); // Load data for the new view mode
    };
    const handlePublishAction = async (target, publish = true) => {
        const year = DOM.yearSelector.value;
        const week = DOM.weekSelector.value;
        if (!year || !week) {
            showToast("Bitte Jahr und KW auswählen.", 'error');
            return;
        }
        try {
            const response = await publishWeek(target, publish); // API call from planer-api.js
            if (response.success) {
                showToast(response.message, 'success');
                loadPlanData(); // Reload data to reflect new publish status
            }
            // Errors handled by apiFetch
        } catch(error) {}
    };

    // Event Listeners
    DOM.viewModeSelector.addEventListener('change', handleViewModeChange);
    // Wrapper für loadPlanData()
    DOM.classSelector.addEventListener('change', () => loadPlanData());
    DOM.teacherSelector.addEventListener('change', () => loadPlanData());
    DOM.yearSelector.addEventListener('change', handleDateOrWeekChange);
    DOM.weekSelector.addEventListener('change', handleDateOrWeekChange);
    DOM.dateSelector.addEventListener('change', handleDateOrWeekChange);

    DOM.publishStudentBtn.addEventListener('click', () => handlePublishAction('student', true));
    DOM.unpublishStudentBtn.addEventListener('click', () => handlePublishAction('student', false));
    DOM.publishTeacherBtn.addEventListener('click', () => handlePublishAction('teacher', true));
    DOM.unpublishTeacherBtn.addEventListener('click', () => handlePublishAction('teacher', false));

    // Grid Interaktionen (Click/DblClick)
    DOM.timetableContainer.addEventListener('click', (e) => {
        const cell = e.target.closest('.grid-cell');
        const state = getState();
        // Ignore clicks outside cells or if no class/teacher is selected
        if (!cell || !(state.selectedClassId || state.selectedTeacherId)) {
            clearSelectionState(state.selection.cells); // Clear selection if clicking outside valid area
            return;
        }
        handleCellClick(cell, DOM.timetableContainer);

        // Modal bei Doppelklick
        if (e.detail === 2) {
            openModal(e, false);
        }
    });


    // --- Drag & Drop ---
    DOM.timetableContainer.addEventListener('dragstart', (e) => {
        // Ziele auf .planner-entry
        const entryElement = e.target.closest('.planner-entry');
        const cell = e.target.closest('.grid-cell');
        const state = getState();

        // Prüfe, ob Zelle draggbar ist (hat Inhalt) UND ob wir auf ein Entry geklickt haben
        if (!cell || !entryElement || !cell.classList.contains('has-entry') || !(state.selectedClassId || state.selectedTeacherId)) {
            e.preventDefault(); return;
        }

        // Drag-Daten werden in renderTimetableGrid gesetzt

        const entryId = entryElement.dataset.entryId;
        const blockId = entryElement.dataset.blockId;
        const substitutionId = entryElement.dataset.substitutionId;

        let entryData = null; // Data of the dragged item (first entry of block, or single)
        let entryType = null;
        let span = 1;
        let blockStartCell = cell; // Cell representing the start of the block/entry
        let originalSubIds = []; // Stores IDs for each hour of a substitution block
        let originalRegularEntryId = null; // Store ID of underlying regular entry/block start
        let originalRegularBlockId = null;
        let underlyingRegularEntries = []; // *** Store ALL underlying entries ***

        const currentDay = cell.dataset.day;
        const currentPeriod = parseInt(cell.dataset.period);
        const cellKey = cell.dataset.cellKey;

        if (substitutionId) {
            entryType = 'substitution';
            // Finde den spezifischen Eintrag aus der Map
            const subsInCell = (state.substitutions[cellKey] || []);
            entryData = subsInCell.find(s => s.substitution_id == substitutionId);
            
            if (!entryData) {
                console.error("DragStart Error: Could not find substitution data for dragged item.", substitutionId);
                e.preventDefault(); return;
            }
            
            // Span für Vertretung neu berechnen
            const key = `${entryData.date}-${entryData.class_id}-${entryData.substitution_type}-${entryData.comment || ''}-${entryData.new_room_id || ''}-${entryData.new_teacher_id || ''}-${entryData.new_subject_id || ''}`;
            const substitutionBlocks = new Map();
            state.currentSubstitutions.forEach(sub => {
                if (!sub.day_of_week) return;
                const subKey = `${sub.date}-${sub.class_id}-${sub.substitution_type}-${sub.comment || ''}-${sub.new_room_id || ''}-${sub.new_teacher_id || ''}-${sub.new_subject_id || ''}`;
                if (!substitutionBlocks.has(subKey)) substitutionBlocks.set(subKey, []);
                substitutionBlocks.get(subKey).push(sub);
            });

            const subsInBlock = substitutionBlocks.get(key) || [];
            if (subsInBlock.length > 1) {
                subsInBlock.sort((a, b) => a.period_number - b.period_number);
                let isConsecutive = true;
                for (let i = 0; i < subsInBlock.length - 1; i++) {
                    if (parseInt(subsInBlock[i + 1].period_number) !== parseInt(subsInBlock[i].period_number) + 1) {
                        isConsecutive = false; break;
                    }
                }
                if (isConsecutive) {
                    const startSub = subsInBlock[0];
                    // Prüfe, ob der geklickte Eintrag der Start-Eintrag ist
                    if (startSub.substitution_id == substitutionId) {
                        span = subsInBlock.length;
                        entryData = startSub; // Stelle sicher, dass wir den Start-Eintrag ziehen
                        blockStartCell = cell;
                    } else {
                        // Teil eines Blocks gezogen. Finde Start-Zelle.
                        span = subsInBlock.length;
                        entryData = startSub;
                        blockStartCell = DOM.timetableContainer.querySelector(`.grid-cell[data-day='${startSub.day_of_week}'][data-period='${startSub.period_number}']`);
                    }
                }
            }
            // ENDE SPAN (Sub)

            originalSubIds = [];
            underlyingRegularEntries = [];
            const allSubsMap = state.substitutions;
            const allTimetableMap = state.timetable;

            for (let i = 0; i < span; i++) {
                const periodToCheck = parseInt(entryData.period_number) + i;
                const keyToCheck = `${entryData.day_of_week}-${periodToCheck}`;
                
                // Finde die Vertretung für diese Stunde (basierend auf Ähnlichkeit)
                const subForThisHour = (allSubsMap[keyToCheck] || []).find(s =>
                    s.class_id == entryData.class_id &&
                    s.substitution_type == entryData.substitution_type &&
                    s.new_teacher_id == entryData.new_teacher_id &&
                    s.new_subject_id == entryData.new_subject_id &&
                    s.new_room_id == entryData.new_room_id &&
                    s.comment == entryData.comment
                );

                if (subForThisHour) {
                    originalSubIds.push(subForThisHour.substitution_id);
                    // Finde zugrundeliegenden regulären Eintrag
                    const regularEntry = (allTimetableMap[keyToCheck] || []).find(e =>
                        e.class_id == subForThisHour.class_id &&
                        e.subject_id == subForThisHour.original_subject_id
                    );
                    if (regularEntry) {
                        underlyingRegularEntries.push(regularEntry);
                        if (i === 0) {
                            originalRegularBlockId = regularEntry.block_id || null;
                            originalRegularEntryId = regularEntry.entry_id || null;
                        }
                    } else {
                        underlyingRegularEntries.push(null);
                    }
                } else {
                    // Fallback
                    originalSubIds.push(null);
                    underlyingRegularEntries.push(null);
                    console.warn(`DragStart: Konnte Vertretung für Periode ${periodToCheck} im Block nicht finden.`);
                }
            }

        } else if (blockId) {
            entryType = 'block';
            // Finde in Map
            const entriesInCell = (state.timetable[cellKey] || []);
            entryData = entriesInCell.find(e => e.block_id == blockId);
            if (!entryData) { e.preventDefault(); return; }
            
            // Span für Regulären Block neu berechnen
            const allEntriesInBlock = state.currentTimetable.filter(e => e.block_id === blockId);
            if (allEntriesInBlock.length > 0) {
                 allEntriesInBlock.sort((a, b) => a.period_number - b.period_number);
                 const startEntry = allEntriesInBlock[0];
                 span = parseInt(allEntriesInBlock[allEntriesInBlock.length - 1].period_number) - parseInt(startEntry.period_number) + 1;
                 if (startEntry.entry_id !== entryData.entry_id) {
                     blockStartCell = DOM.timetableContainer.querySelector(`.grid-cell[data-day='${startEntry.day_of_week}'][data-period='${startEntry.period_number}']`);
                     entryData = startEntry; // Ziehe den *Start* des Blocks
                 }
            } else {
                span = 1;
            }
            // ENDE SPAN (Block)

            originalRegularBlockId = blockId;

        } else if (entryId) {
            entryType = 'entry';
            // Finde in Map
            const entriesInCell = (state.timetable[cellKey] || []);
            entryData = entriesInCell.find(e => e.entry_id == entryId);
            if (!entryData) { e.preventDefault(); return; }
            
            span = 1;
            originalRegularEntryId = entryId;
        }

        if (!entryData) {
            console.error("DragStart Error: Could not find entry data for dragged item.", { entryId, blockId, substitutionId });
            e.preventDefault();
            return;
         }

        clearSelectionState(state.selection.cells);
        updateState({
            dragData: {
                type: entryType,
                data: entryData,
                span: span,
                originalDay: blockStartCell.dataset.day,
                originalPeriod: parseInt(blockStartCell.dataset.period),
                originalSubIds: originalSubIds, // Store substitution IDs
                originalRegularEntryId: originalRegularEntryId, // Store underlying entry ID (of first hour)
                originalRegularBlockId: originalRegularBlockId,  // Store underlying block ID (of first hour)
                underlyingRegularEntries: underlyingRegularEntries || [] // *** Store ALL underlying entries ***
            }
        });
        console.log("Drag Start Data:", getState().dragData); // Log drag data

        setTimeout(() => {
            // Markiere die Zelle als 'dragging'
            // KORREKTUR: Verwende 'blockStartCell', da 'cell' nur der Klick-Ursprung sein könnte
            if (blockStartCell) blockStartCell.classList.add('dragging');
            
            // Wenn es ein Block ist, markiere alle Zellen des Blocks
            if (span > 1) {
                for (let i = 1; i < span; i++) {
                    const nextPeriod = parseInt(blockStartCell.dataset.period) + i;
                    const cellInBlock = DOM.timetableContainer.querySelector(`.grid-cell[data-day='${blockStartCell.dataset.day}'][data-period='${nextPeriod}']`);
                    if (cellInBlock) {
                        cellInBlock.classList.add('dragging');
                    }
                }
            }
        }, 0);
        DOM.timetableContainer.classList.add('is-dragging');
    });

    DOM.timetableContainer.addEventListener('dragover', async (e) => {
        e.preventDefault(); // Necessary to allow dropping
        const cell = e.target.closest('.grid-cell');
        const state = getState();

        // Ignore if not over a valid cell, no drag data, or same cell as before
        if (!cell || !state.dragData || cell === state.lastDragOverCell) return;

        // Clear previous target styling
        if (state.lastDragOverCell) {
            state.lastDragOverCell.classList.remove('drop-target', 'drop-target-valid', 'drop-target-invalid');
            delete state.lastDragOverCell.dataset.conflictError;
        }
        updateState({ lastDragOverCell: cell }); // Store current cell
        cell.classList.add('drop-target'); // Basic target styling

        const targetDay = cell.dataset.day;
        const targetStartPeriod = parseInt(cell.dataset.period);
        const targetEndPeriod = targetStartPeriod + state.dragData.span - 1;

        // --- Basic validity checks ---
        // Check if it fits vertically
        if (targetEndPeriod > DOM.timeSlots.length) {
            cell.classList.add('drop-target-invalid');
            cell.dataset.conflictError = "Eintrag passt nicht auf den Plan (zu lang).";
            return;
        }

        // Check if any target cell is already occupied (by a DIFFERENT entry/block/sub)
         for (let p = targetStartPeriod; p <= targetEndPeriod; p++) {
             const targetCell = DOM.timetableContainer.querySelector(`.grid-cell[data-day='${targetDay}'][data-period='${p}']`);
             // Check if targetCell exists AND has an entry (ignore placeholders like FU)
             if (targetCell && (targetCell.classList.contains('has-entry') || targetCell.classList.contains('has-substitution')) ) {
                 let isSelf = false; // Is the occupied cell part of the item being dragged?
                 const draggedItemType = state.dragData.type;
                
                 // isSelf Logik
                 if (draggedItemType === 'substitution') {
                     // Finde Sub-Einträge
                     const targetSubElements = Array.from(targetCell.querySelectorAll('.planner-entry[data-substitution-id]'));
                     // Prüfe, ob Eintrag zu gezogenen IDs gehört
                     isSelf = targetSubElements.some(el => state.dragData.originalSubIds.includes(parseInt(el.dataset.substitutionId)));
                 } else if (draggedItemType === 'block') {
                     const targetEntryElements = Array.from(targetCell.querySelectorAll('.planner-entry[data-block-id]'));
                     isSelf = targetEntryElements.some(el => el.dataset.blockId === state.dragData.originalRegularBlockId);
                 } else if (draggedItemType === 'entry') {
                     const targetEntryElements = Array.from(targetCell.querySelectorAll('.planner-entry[data-entry-id]'));
                     isSelf = targetEntryElements.some(el => el.dataset.entryId === state.dragData.originalRegularEntryId);
                 }
                 // ENDE isSelf Logik

                 if (!isSelf) { // Von anderem Eintrag belegt
                     cell.classList.add('drop-target-invalid');
                     const conflictType = targetCell.classList.contains('has-substitution') ? "Vertretung" : "Unterricht";
                     cell.dataset.conflictError = `KONFLIKT (Slot belegt): In diesem Zeitraum existiert bereits ${conflictType}.`;
                     return;
                 }
             }
         }


        // API-Konfliktprüfung (nur für reguläre Einträge oder Vertretungen mit regulärer Basis)
        let needsApiCheck = state.dragData.type !== 'substitution' || (state.dragData.originalRegularEntryId || state.dragData.originalRegularBlockId);

        if (!needsApiCheck) {
            cell.classList.add('drop-target-valid');
            updateState({ lastConflictCheckPromise: Promise.resolve({ success: true, conflicts: [] }) }); // Mock promise
            return;
        }

        // Bereite Daten für API-Prüfung vor (basierend auf regulärem Eintrag)
         // Verwende state.currentTimetable
         const regularEntryData = state.dragData.originalRegularBlockId
            ? (state.currentTimetable.find(e => e.block_id == state.dragData.originalRegularBlockId) || (state.dragData.underlyingRegularEntries[0] || null))
            : (state.currentTimetable.find(e => e.entry_id == state.dragData.originalRegularEntryId) || (state.dragData.underlyingRegularEntries[0] || null));

        // API-Prüfung nur, wenn reguläre Daten gefunden wurden
        if (!regularEntryData) {
            // Vertretung ohne Basis ist gültig (kein Check)
            cell.classList.add('drop-target-valid');
            updateState({ lastConflictCheckPromise: Promise.resolve({ success: true, conflicts: [] }) });
            return;
        }


        const checkData = {
            year: DOM.yearSelector.value,
            calendar_week: DOM.weekSelector.value,
            day_of_week: targetDay,
            start_period_number: targetStartPeriod,
            end_period_number: targetEndPeriod,
            teacher_id: regularEntryData.teacher_id, // Use teacher from the actual regular entry
            room_id: regularEntryData.room_id,     // Use room from the actual regular entry
            class_id: regularEntryData.class_id,   // Use class from the actual regular entry
            // Original-Eintrag von Prüfung ausschließen
            entry_id: state.dragData.originalRegularEntryId,
            block_id: state.dragData.originalRegularBlockId,
        };

        try {
            // Promise im State speichern
            const conflictCheckPromise = checkConflicts(checkData);
             updateState({ lastConflictCheckPromise: conflictCheckPromise });
            await conflictCheckPromise;
            // Wenn Promise resolved = gültig
             // Prüfe, ob Hover noch aktiv ist
             if (cell === getState().lastDragOverCell) {
                 cell.classList.add('drop-target-valid');
             }
        } catch (error) {
            // Wenn Promise rejected = ungültig
             if (cell === getState().lastDragOverCell) {
                 cell.classList.add('drop-target-invalid');
                 cell.dataset.conflictError = error.message; // Store the conflict message
             }
        }
    });

    DOM.timetableContainer.addEventListener('dragleave', (e) => {
        const cell = e.target.closest('.grid-cell');
        const state = getState();
        // Styling entfernen, wenn Zelle verlassen wird
        if (cell && cell === state.lastDragOverCell) {
            cell.classList.remove('drop-target', 'drop-target-valid', 'drop-target-invalid');
            delete cell.dataset.conflictError;
            updateState({ lastDragOverCell: null }); // Reset last hovered cell
        }
    });

    DOM.timetableContainer.addEventListener('dragend', (e) => {
        // Drag-Styling entfernen
         const draggedCells = DOM.timetableContainer.querySelectorAll('.grid-cell.dragging');
         draggedCells.forEach(cell => cell.classList.remove('dragging'));

        DOM.timetableContainer.classList.remove('is-dragging'); // Remove grid container class

        const state = getState();
        // Target-Styling entfernen
        if (state.lastDragOverCell) {
            state.lastDragOverCell.classList.remove('drop-target', 'drop-target-valid', 'drop-target-invalid');
            delete state.lastDragOverCell.dataset.conflictError;
        }
        // Drag-State zurücksetzen
        updateState({ dragData: null, lastDragOverCell: null, lastConflictCheckPromise: null });
    });

    DOM.timetableContainer.addEventListener('drop', async (e) => {
        e.preventDefault();
        const cell = e.target.closest('.grid-cell');
        const state = getState();
        // Abbruch, wenn kein Ziel oder keine Daten
        if (!cell || !state.dragData) return;

        // --- Finale Validierung ---
        // 1. Auf 'invalid' Marker prüfen
        if (cell.classList.contains('drop-target-invalid')) {
            const errorMessage = cell.dataset.conflictError || "Ablegen nicht möglich: Konflikt.";
            showToast(errorMessage.split("\n")[0], 'error', 4000); // Show first line of error
            return;
        }
        // 2. Prüfen, ob 'valid' Marker fehlt
        if (!cell.classList.contains('drop-target-valid')) {
            // Erneute Prüfung (Promise)
            try {
                let needsApiCheck = state.dragData.type !== 'substitution' || (state.dragData.originalRegularEntryId || state.dragData.originalRegularBlockId);
                if (state.lastConflictCheckPromise && needsApiCheck) {
                    await state.lastConflictCheckPromise; // Wait for the check result
                } else if (needsApiCheck) {
                    // Kein Promise + API-Check nötig = ungültig
                    showToast("Ablegen nicht möglich: Konfliktprüfung unvollständig.", 'error');
                    return;
                }
                 // If it's a substitution moving to empty or over itself, basic checks suffice
            } catch (error) {
                // Konflikt durch Promise bestätigt
                showToast(error.message.split("\n")[0], 'error', 4000);
                return;
            }
        }
         // 3. Vertikale Passform prüfen
         const targetStartPeriod = parseInt(cell.dataset.period);
         const targetEndPeriod = targetStartPeriod + state.dragData.span - 1;
         if (targetEndPeriod > DOM.timeSlots.length) {
             showToast("Ablegen nicht möglich: Eintrag passt nicht in den Plan.", 'error');
             return;
         }

        // --- Speichern vorbereiten ---
        const targetDay = cell.dataset.day;
        const entryData = state.dragData.data; // Data of the first entry
        const savePromises = []; // Array to hold all promises for saving

        const currentYear = DOM.yearSelector.value;
        const currentWeek = DOM.weekSelector.value;
        const newDate = getDateForDayInWeek(targetDay, currentYear, currentWeek);

        console.log("--- Drop Event ---"); // Log drop event start
        console.log("Drag Data:", state.dragData); // Log the full drag data
        console.log("Target Cell:", { day: targetDay, period: targetStartPeriod }); // Log target cell

        // --- Fall 1: Vertretung verschieben ---
        if (state.dragData.type === 'substitution') {
            const originalSubIds = state.dragData.originalSubIds || [];
            const underlyingRegularEntries = state.dragData.underlyingRegularEntries || [];
            console.log("Moving Substitution Block - Original Sub IDs:", originalSubIds);
            console.log("Moving underlying regular entries:", underlyingRegularEntries);

            // 1. Reguläre Basis-Einträge verschieben
            const movedRegularIds = new Set(); // Track moved regular entries/blocks
            for (let i = 0; i < underlyingRegularEntries.length; i++) {
                const regularEntry = underlyingRegularEntries[i];
                if (!regularEntry) continue; // Skip if underlying entry was null

                const idToMove = regularEntry.block_id || regularEntry.entry_id;
                const idType = regularEntry.block_id ? 'block_id' : 'entry_id';
                
                if (!idToMove || movedRegularIds.has(idToMove)) {
                    continue; // Skip if no ID or already processed (part of a block)
                }
                
                movedRegularIds.add(idToMove);

                // Span des Basis-Eintrags berechnen
                let regularEntrySpan = 1;
                if (regularEntry.block_id) {
                    const periods = state.currentTimetable
                        .filter(e => e.block_id === regularEntry.block_id)
                        .map(e => parseInt(e.period_number));
                    regularEntrySpan = periods.length > 0 ? Math.max(...periods) - Math.min(...periods) + 1 : 1;
                }
                
                // Neue Periode für Basis-Eintrag berechnen
                const originalPeriodForThisEntry = parseInt(regularEntry.period_number);
                const periodOffset = originalPeriodForThisEntry - state.dragData.originalPeriod;
                
                const newStartPeriod = targetStartPeriod + periodOffset;
                const newEndPeriod = newStartPeriod + regularEntrySpan - 1;

                // Prüfung auf Grid-Grenzen
                if (newEndPeriod > DOM.timeSlots.length) {
                    console.warn(`Skipping move of underlying entry ${idToMove}, would fall off grid.`);
                    continue;
                }

                const regularSaveData = {
                    entry_id: (idType === 'entry_id' ? idToMove : null),
                    block_id: (idType === 'block_id' ? idToMove : null),
                    year: currentYear,
                    calendar_week: currentWeek,
                    day_of_week: targetDay,
                    start_period_number: newStartPeriod,
                    end_period_number: newEndPeriod,
                    class_id: regularEntry.class_id,
                    teacher_id: regularEntry.teacher_id,
                    subject_id: regularEntry.subject_id,
                room_id: regularEntry.room_id,
                    comment: regularEntry.comment || null
                };
                console.log("Moving underlying regular entry:", regularSaveData);
                savePromises.push(saveEntry(regularSaveData));
            }

            // 2. Vertretungs-Einträge verschieben
            for (let i = 0; i < state.dragData.span; i++) {
                const currentTargetPeriod = targetStartPeriod + i;
                const originalSubId = originalSubIds[i]; // Use the ID stored for this index

                console.log(`Processing hour ${i + 1}/${state.dragData.span}: TargetPeriod=${currentTargetPeriod}, OriginalSubId=${originalSubId}`);

                if (!originalSubId) {
                    console.error(`Drop Error: Missing original substitution ID for index ${i} in dragged block.`);
                    showToast(`Fehler beim Verschieben von Stunde (Index ${i}). Original-ID fehlt.`, 'error');
                    continue; // Skip this part
                }

                // Finde Original-Daten der Vertretung
                // Verwende state.currentSubstitutions
                const originalSubData = state.currentSubstitutions.find(s => s.substitution_id == originalSubId);

                if (!originalSubData) {
                    console.error(`Drop Error: Could not find original substitution data for ID ${originalSubId}.`);
                    showToast(`Fehler beim Verschieben von Stunde mit ID ${originalSubId}. Originaldaten nicht gefunden.`, 'error');
                    continue; // Skip this part
                }

                const subSaveData = {
                    ...originalSubData, // Copy all existing details
                    substitution_id: originalSubData.substitution_id, // The ID of the entry being updated
                    date: newDate, // The NEW date
                    period_number: currentTargetPeriod, // The NEW period
                    // Alle anderen Felder (new_teacher_id etc.) werden von ...originalSubData übernommen
                };
                 console.log(`Substitution Save Data (ID: ${originalSubId}):`, subSaveData);
                savePromises.push(saveSubstitution(subSaveData));
            }

        }
        // --- Fall 2: Regulären Eintrag/Block verschieben ---
        else {
             console.log("Moving Regular Entry/Block:", { id: state.dragData.originalRegularEntryId || state.dragData.originalRegularBlockId, type: state.dragData.type });
            const saveData = {
                entry_id: state.dragData.originalRegularEntryId, // Use stored original ID
                block_id: state.dragData.originalRegularBlockId, // Use stored original ID
                year: currentYear,
                calendar_week: currentWeek,
                day_of_week: targetDay,
                start_period_number: targetStartPeriod,
                end_period_number: targetEndPeriod,
                class_id: entryData.class_id, // Data from the first entry of the block
                teacher_id: entryData.teacher_id,
                subject_id: entryData.subject_id,
                room_id: entryData.room_id,
                comment: entryData.comment || null
            };
             console.log("Regular Save Data:", saveData);
            savePromises.push(saveEntry(saveData)); // Single promise for regular entry/block
        }

        // --- Alle Speicher-Aktionen ausführen ---
        try {
             console.log(`Executing ${savePromises.length} save operations...`);
            const results = await Promise.all(savePromises);
            console.log("Save Results:", results);
            // Prüfe Erfolg
            const success = results.every(response => response && response.success);

            if (success) {
                showToast("Eintrag erfolgreich verschoben.", 'success');
                loadPlanData(); // Reload grid
            } else {
                // Finde ersten Fehler
                const firstErrorResult = results.find(r => !(r && r.success));
                const firstError = firstErrorResult?.message; // Get message from the failed response
                console.error("Fehler beim Speichern (Promise.all):", firstErrorResult);
                throw new Error(firstError || "Unbekannter Fehler beim Verschieben.");
            }
        } catch (error) {
            // Fehlerbehandlung
            console.error("Drop save error (catch):", error); // Log the specific error
            // Grid bei Fehler neuladen
            loadPlanData();
        }
    });


    // --- Aktions-Modals (Kopieren, Vorlagen) ---
    initializeActionModals(); // From this file

     // --- Template-Editor Grid-Handler ---
     DOM.templateEditorGridContainer.addEventListener('click', (e) => {
         const cell = e.target.closest('.grid-cell.template-cell');
         if (!cell) {
             clearSelectionState(getState().selection.cells); // Clear selection if clicking outside cells
             return;
         }
         handleCellClick(cell, DOM.templateEditorGridContainer);

         // Modal bei Doppelklick
         if (e.detail === 2) {
             openModal(e, true);
         }
     });

    // Ladevorgang (ausgelagert)
    // loadInitialData().then(() => { ... });
}


/**
 * Initialisiert die Event-Listener für die Aktions-Modals (Kopieren, Vorlagen).
 */
function initializeActionModals() {
    // --- Kopiermodal ---
    const openCopyModal = () => {
        const state = getState();
        if (!state.selectedClassId && !state.selectedTeacherId) {
            showToast("Bitte zuerst eine Klasse oder einen Lehrer auswählen.", 'error');
            return;
        }
        DOM.copySourceDisplay.value = `KW ${DOM.weekSelector.value} / ${DOM.yearSelector.value}`;
        // Calculate next week for default target
        const currentMonday = getDateOfISOWeek(parseInt(DOM.weekSelector.value), parseInt(DOM.yearSelector.value));
        const nextWeekDate = new Date(currentMonday.getTime() + 7 * 24 * 60 * 60 * 1000);
        const { week: nextWeek, year: nextYear } = getWeekAndYear(nextWeekDate);
        populateYearSelector(DOM.copyTargetYear, nextYear);
        populateWeekSelector(DOM.copyTargetWeek, nextWeek);
        DOM.copyWeekModal.classList.add('visible');
    };
    const closeCopyModal = () => DOM.copyWeekModal.classList.remove('visible');

    DOM.copyWeekBtn.addEventListener('click', openCopyModal);
    DOM.copyWeekCancelBtn.addEventListener('click', closeCopyModal);
    DOM.copyWeekModal.addEventListener('click', (e) => { if (e.target.id === 'copy-week-modal') closeCopyModal(); });

    DOM.copyWeekForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const state = getState();
        const sourceYear = parseInt(DOM.yearSelector.value);
        const sourceWeek = parseInt(DOM.weekSelector.value);
        const targetYear = parseInt(DOM.copyTargetYear.value);
        const targetWeek = parseInt(DOM.copyTargetWeek.value);

        if (sourceYear === targetYear && sourceWeek === targetWeek) {
            showToast("Fehler: Quell- und Zielwoche dürfen nicht identisch sein.", 'error');
            return;
        }
        const entityName = state.currentViewMode === 'class'
            ? `Klasse ${state.selectedClassId}`
            : `Lehrer ${DOM.teacherSelector.options[DOM.teacherSelector.selectedIndex]?.text || state.selectedTeacherId}`; // Add fallback

        if (await showConfirm("Kopieren bestätigen", `Sind Sie sicher, dass Sie den Plan für '${escapeHtml(entityName)}' von KW ${sourceWeek}/${sourceYear} nach KW ${targetWeek}/${targetYear} kopieren möchten? Alle Einträge in der Zielwoche werden überschrieben.`)) {
            const body = { sourceYear, sourceWeek, targetYear, targetWeek, classId: state.selectedClassId, teacherId: state.selectedTeacherId };
            try {
                const response = await copyWeek(body);
                if (response.success) {
                    showToast(response.message, 'success');
                    closeCopyModal();
                    // Switch view to the target week
                    DOM.yearSelector.value = targetYear;
                    DOM.weekSelector.value = targetWeek;
                    loadPlanData();
                }
                // Errors handled by apiFetch
            } catch (error) { /* Error already shown */ }
        }
    });

    // --- Vorlagen-Modals ---
    const openManageTemplatesModal = async () => {
        DOM.manageTemplatesForm.reset();
        const templates = await loadTemplates(); // Lädt Vorlagen neu und gibt Daten zurück
        renderTemplatesList(templates); // Rendert die Liste
        showTemplateView('list'); // Start in list view
        DOM.manageTemplatesModal.classList.add('visible');
    };
    const closeManageTemplatesModal = () => DOM.manageTemplatesModal.classList.remove('visible');
    const openApplyTemplateModal = async () => {
        const state = getState();
        if (!state.selectedClassId && !state.selectedTeacherId) {
            showToast("Bitte zuerst eine Klasse oder einen Lehrer auswählen.", 'error');
            return;
        }
        await loadTemplates(); // Stellt sicher, dass Liste aktuell ist (rendert Select neu)
        DOM.applyTemplateForm.reset();
        DOM.applyTemplateModal.classList.add('visible');
    };
    const closeApplyTemplateModal = () => DOM.applyTemplateModal.classList.remove('visible');

    DOM.createTemplateBtn.addEventListener('click', () => {
        const state = getState();
        if (!state.selectedClassId && !state.selectedTeacherId) {
            showToast("Bitte zuerst eine Klasse oder einen Lehrer auswählen, um eine Vorlage zu erstellen.", 'error');
            return;
        }
        // Prüfe flaches Array
        if (state.currentTimetable.length === 0) {
            showToast("Die aktuelle Woche enthält keine Einträge zum Speichern als Vorlage.", 'info');
            return;
        }
        openManageTemplatesModal(); // Opens the manage modal where the create form is
    });
    DOM.applyTemplateBtn.addEventListener('click', openApplyTemplateModal);
    DOM.manageTemplatesBtn.addEventListener('click', openManageTemplatesModal);
    DOM.manageTemplatesCloseBtn.addEventListener('click', closeManageTemplatesModal);
    DOM.applyTemplateCancelBtn.addEventListener('click', closeApplyTemplateModal);
    // Modals bei Klick daneben schließen
    DOM.manageTemplatesModal.addEventListener('click', (e) => { if (e.target.id === 'manage-templates-modal') closeManageTemplatesModal(); });
    DOM.applyTemplateModal.addEventListener('click', (e) => { if (e.target.id === 'apply-template-modal') closeApplyTemplateModal(); });

    // Submit: Vorlage aus Woche erstellen
    DOM.manageTemplatesForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const templateNameInput = DOM.manageTemplatesForm.querySelector('#template-name');
        const templateDescriptionInput = DOM.manageTemplatesForm.querySelector('#template-description');

        const templateName = templateNameInput ? templateNameInput.value.trim() : '';
        const templateDescription = templateDescriptionInput ? templateDescriptionInput.value.trim() : '';

        if (!templateName) {
            showToast("Bitte geben Sie einen Namen für die Vorlage ein.", 'error');
            return;
        }
        const state = getState();
        const body = {
            name: templateName,
            description: templateDescription || null,
            sourceYear: DOM.yearSelector.value,
            sourceWeek: DOM.weekSelector.value,
            sourceClassId: state.selectedClassId,
            sourceTeacherId: state.selectedTeacherId
        };
        try {
            const response = await createTemplate(body);
            if (response.success) {
                showToast(response.message, 'success');
                DOM.manageTemplatesForm.reset();
                const templates = await loadTemplates(); // Reload list and return data
                renderTemplatesList(templates); // Render updated list
            }
             // Errors (like duplicate name) handled by apiFetch
        } catch (error) { /* Error already shown */ }
    });

     // Submit: Vorlage anwenden
    DOM.applyTemplateForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const templateId = DOM.applyTemplateSelect.value;
        if (!templateId) {
            showToast("Bitte wählen Sie eine Vorlage aus.", 'error');
            return;
        }
        const targetYear = DOM.yearSelector.value;
        const targetWeek = DOM.weekSelector.value;
        if (!targetYear || !targetWeek) return; // Should not happen
        const state = getState();

        if (await showConfirm("Vorlage anwenden", "Sind Sie sicher? Alle Einträge für die aktuelle Auswahl in dieser Woche werden überschrieben.")) {
            const body = {
                templateId: templateId,
                targetYear: targetYear,
                targetWeek: targetWeek,
                targetClassId: state.selectedClassId,
                targetTeacherId: state.selectedTeacherId
            };
            try {
                const response = await applyTemplate(body);
                if (response.success) {
                    showToast(response.message, 'success');
                    closeApplyTemplateModal();
                    loadPlanData(); // Reload grid with applied template
                }
                 // Errors handled by apiFetch
            } catch (error) { /* Error already shown */ }
        }
    });

    // --- Template-Editor Buttons ---
     DOM.createEmptyTemplateBtn.addEventListener('click', () => {
         updateState({ 
            currentTemplateEditorData: [], // Start with empty data
            currentEditingTemplateId: null // Ensure no ID is set
         }); 
         DOM.templateEditorTitle.textContent = 'Neue leere Vorlage erstellen';
         const nameInput = DOM.manageTemplatesModal.querySelector('#template-editor-name');
         const descInput = DOM.manageTemplatesModal.querySelector('#template-editor-description');
         if(nameInput) nameInput.value = '';
         if(descInput) descInput.value = '';
         populateAllModalSelects(getState().stammdaten); // Ensure modal selects are populated
         renderTimetableGrid(getState(), true);
         showTemplateView('editor');
     });

     DOM.backToTemplateListBtn.addEventListener('click', () => {
         // TODO: Warnen bei ungespeicherten Änderungen
         showTemplateView('list');
         updateState({ 
            currentTemplateEditorData: null, // Clear editor data
            currentEditingTemplateId: null // Clear editing ID
        }); 
     });

     DOM.saveTemplateEditorBtn.addEventListener('click', async () => {
        const state = getState();
        const name = DOM.manageTemplatesModal.querySelector('#template-editor-name').value.trim();
        const description = DOM.manageTemplatesModal.querySelector('#template-editor-description').value.trim();
        const templateId = state.currentEditingTemplateId; // Get ID (null if new)
        const entries = state.currentTemplateEditorData || [];

        if (!name) {
            showToast("Bitte einen Vorlagennamen eingeben.", 'error');
            return;
        }

        const templateData = {
            template_id: templateId,
            name: name,
            description: description || null,
            entries: entries
        };

        try {
            const response = await saveTemplate(templateData);
            if (response.success) {
                showToast(response.message, 'success');
                updateState({ currentTemplateEditorData: null, currentEditingTemplateId: null });
                const templates = await loadTemplates();
                renderTemplatesList(templates);
                showTemplateView('list');
            }
            // Errors (like duplicate name) handled by apiFetch
        } catch (error) { /* Error already shown */ }
     });
}

/** Rendert die Liste der Vorlagen im Verwalten-Modal */
export const renderTemplatesList = (templates) => {
    if (!DOM.manageTemplatesList) return;
    if (!Array.isArray(templates)) {
        console.error("renderTemplatesList: Input 'templates' is not an array.", templates);
        DOM.manageTemplatesList.innerHTML = '<p class="message error">Fehler beim Anzeigen der Vorlagen.</p>';
        return;
    }
    if (templates.length === 0) {
        DOM.manageTemplatesList.innerHTML = '<p>Keine Vorlagen vorhanden.</p>';
        return;
    }
    DOM.manageTemplatesList.innerHTML = `
        <table class="data-table templates-list-table">
            <thead><tr><th>Name</th><th>Beschreibung</th><th>Aktion</th></tr></thead>
            <tbody>
                ${templates.map(t => `
                    <tr data-id="${t.template_id}">
                        <td>${escapeHtml(t.name)}</td>
                        <td>${escapeHtml(t.description) || '-'}</td>
                        <td class="actions">
                            <button class="btn btn-warning btn-small edit-template" data-id="${t.template_id}">Bearbeiten</button>
                            <button class="btn btn-danger btn-small delete-template" data-name="${escapeHtml(t.name)}">Löschen</button>
                        </td>
                    </tr>
                `).join('')}
            </tbody>
        </table>
    `;
    // Event Listeners (nach Render)
    DOM.manageTemplatesList.querySelectorAll('.delete-template').forEach(button => {
        button.addEventListener('click', handleDeleteTemplateClick);
    });
    // Edit-Buttons
    DOM.manageTemplatesList.querySelectorAll('.edit-template').forEach(button => {
        button.addEventListener('click', handleEditTemplateClick);
    });
};

/** Behandelt Klick auf "Vorlage bearbeiten" */
async function handleEditTemplateClick(e) {
    const button = e.target;
    const templateId = button.dataset.id;
    if (!templateId) return;

    try {
        const response = await loadTemplateDetails(templateId);
        if (response.success && response.data) {
            const { template, entries } = response.data;
            // Populate state for the editor
            updateState({
                currentTemplateEditorData: entries || [],
                currentEditingTemplateId: template.template_id
            });
            // Set editor form fields
            DOM.templateEditorTitle.textContent = 'Vorlage bearbeiten';
            const nameInput = DOM.manageTemplatesModal.querySelector('#template-editor-name');
            const descInput = DOM.manageTemplatesModal.querySelector('#template-editor-description');
            if (nameInput) nameInput.value = template.name;
            if (descInput) descInput.value = template.description || '';
            
            renderTimetableGrid(getState(), true);
            showTemplateView('editor');
        }
    } catch (error) { /* Error handled by apiFetch */ }
}


/** Behandelt Klick auf "Vorlage löschen" */
async function handleDeleteTemplateClick(e) {
    const button = e.target;
    const row = button.closest('tr');
    if (!row) return; // Should not happen
    const templateId = row.dataset.id;
    const templateName = button.dataset.name;

    if (await showConfirm("Vorlage löschen", `Sind Sie sicher, dass Sie die Vorlage "${templateName}" endgültig löschen möchten?`)) {
        try {
            const response = await deleteTemplate(templateId);
            if (response.success) {
                showToast(response.message, 'success');
                const updatedTemplates = await loadTemplates();
                renderTemplatesList(updatedTemplates);
            }
             // Errors handled by apiFetch
        } catch (error) { /* Error already shown */ }
    }
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-interactions-2.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-state.js ---
// public/assets/js/planer-state.js
// MODIFIZIERT: Fehlende Funktionen (getState, updateState, etc.) und 
// Status-Properties (selection, dragData etc.) hinzugefügt.
// 'state' ist jetzt eine interne Konstante.
// KORRIGIERT: processTimetableData wandelt Arrays jetzt korrekt in Maps (Objekte) um.

import { timeSlots, days } from './planer-dom.js';

// Globaler Status für den Planer (jetzt intern)
const state = {
    // Stammdaten (wird von loadInitialData gefüllt)
    stammdaten: {
        classes: [],
        teachers: [],
        subjects: [],
        rooms: [],
        absences: [],
        templates: []
    },

    // Aktuelle Ansicht
    currentViewMode: 'class', // 'class' oder 'teacher'
    selectedClassId: null,
    selectedTeacherId: null,
    selectedYear: null,
    selectedWeek: null,
    selectedDate: null, // Für tagesgenaue Vertretungen

    // Geladene Daten (Maps/Objekte)
    timetable: {}, // Wird jetzt als Objekt/Map geführt: { "1-1": [Eintrag1, Eintrag2], "1-2": [Eintrag3] }
    substitutions: {}, // Ebenfalls als Map: { "1-1": [Sub1], "1-2": [] }
    // KORRIGIERT: currentTimetable/currentSubstitutions speichern die flachen Arrays aus der API
    currentTimetable: [],
    currentSubstitutions: [],
    publishStatus: { student: false, teacher: false },

    // UI-Status
    isLoading: false,
    currentModalData: null,
    activeMode: 'regular', // 'regular' oder 'substitution'
    conflictCheckTimeout: null, // Timer für Konfliktprüfung
    lastConflictCheckPromise: null, // Promise für Drag&Drop-Konfliktprüfung
    
    // --- HINZUGEFÜGTE FEHLENDE PROPERTIES (aus interactions-1.js) ---
    selection: {
        start: null, // { day, period, cell, cellData }
        end: null,   // { day, period }
        cells: [],   // [HTMLElement]
    },
    dragData: null, // { type, data, span, originalDay, originalPeriod, ... }
    lastDragOverCell: null,
    editingClassId: null, // Speichert die class_id des Eintrags, der im Modal bearbeitet wird
    currentTemplateEditorData: null, // Speichert die [entries] für den Template-Editor
    currentEditingTemplateId: null, // Speichert die ID der Vorlage, die bearbeitet wird
};

// --- HINZUGEFÜGTE FEHLENDE FUNKTIONEN ---

/**
* Gibt den aktuellen Status zurück.
* @returns {object}
*/
export function getState() {
    return state;
}

/**
* Aktualisiert den Status durch Zusammenführen neuer Daten.
* @param {object} newState - Ein Objekt mit den zu aktualisierenden Schlüsseln.
*/
export function updateState(newState) {
    Object.assign(state, newState);
    // console.log("State updated:", newState, "New state is:", state); // Optional: Debugging
}

/**
* Setzt den Auswahlstatus.
* @param {object} selection - Das neue Auswahl-Objekt.
*/
export function setSelectionState(selection) {
    state.selection = selection;
}

/**
* Setzt den Auswahlstatus zurück und entfernt das visuelle Feedback.
* @param {HTMLElement[]} selectedCells - Array der aktuell ausgewählten Zellen-Elemente.
*/
export function clearSelectionState(selectedCells = []) {
    selectedCells.forEach(cell => cell.classList.remove('selected'));
    state.selection = { start: null, end: null, cells: [] };
}
// --- ENDE HINZUGEFÜGTE FUNKTIONEN ---


/**
 * Initialisiert den Status mit geladenen Stammdaten.
 * (Wird von planer-api.js -> loadInitialData aufgerufen)
 * @param {object} data - Das 'data'-Objekt von der API (classes, teachers, etc.)
 */
export function initializeState(data) {
    // Diese Funktion wird durch updateState({ stammdaten: ... }) in loadInitialData ersetzt.
    // Wir behalten sie zur Referenz, falls sie woanders genutzt wird,
    // aber der Haupt-Ladeprozess nutzt updateState.
    updateState({
        stammdaten: data,
        isLoading: false
    });
}

/**
 * Verarbeitet die geladenen Stundenplan- und Vertretungsdaten (Arrays)
 * und wandelt sie in die Map-Struktur um, die für das Rendering benötigt wird.
 * KORRIGIERT: Speichert Einträge als Arrays in den Maps.
 * @param {object} data - Das 'data'-Objekt von der API (enthält timetable (Array), substitutions (Array), etc.)
 */
export function processTimetableData(data) {
    const newTimetableMap = {};
    const newSubstitutionMap = {};

    // 1. Alle Zellen als leere Arrays initialisieren
    const numPeriods = timeSlots.length; // z.B. 10
    const numDays = days.length; // 5

    for (let day = 1; day <= numDays; day++) {
        for (let period = 1; period <= numPeriods; period++) {
            const cellKey = `${day}-${period}`;
            newTimetableMap[cellKey] = [];
            newSubstitutionMap[cellKey] = [];
        }
    }

    // 2. Reguläre Einträge (Array) in die Map füllen
    if (data.timetable && Array.isArray(data.timetable)) {
        data.timetable.forEach(entry => {
            const cellKey = `${entry.day_of_week}-${entry.period_number}`;
            if (newTimetableMap[cellKey]) {
                // *** KORREKTUR: .push() statt Zuweisung ***
                newTimetableMap[cellKey].push(entry);
            }
        });
    }

    // 3. Vertretungen (Array) in die Map füllen
    if (data.substitutions && Array.isArray(data.substitutions)) {
        data.substitutions.forEach(sub => {
            // 'day_of_week' (1-5) wird vom Repository berechnet
            if (sub.day_of_week) {
                const cellKey = `${sub.day_of_week}-${sub.period_number}`;
                if (newSubstitutionMap[cellKey]) {
                    // *** KORREKTUR: .push() statt Zuweisung ***
                    newSubstitutionMap[cellKey].push(sub);
                }
            }
        });
    }

    // 4. Status aktualisieren (jetzt interne updateState verwenden)
    updateState({
        timetable: newTimetableMap, // Map der regulären Einträge
        substitutions: newSubstitutionMap, // Map der Vertretungen
        // KORREKTUR: Diese Arrays sind die rohen Daten, die wir gerade verarbeitet haben.
        // Wir speichern sie als currentTimetable / currentSubstitutions (flache Arrays)
        currentTimetable: data.timetable || [],
        currentSubstitutions: data.substitutions || [],
        publishStatus: data.publishStatus || { student: false, teacher: false },
        // KORREKTUR: Sicherstellen, dass Abwesenheiten im Stammdaten-Objekt aktualisiert werden
        stammdaten: {
            ...state.stammdaten, // Behalte alte Stammdaten (Klassen, Lehrer etc.)
            absences: data.absences || state.stammdaten.absences || [] // Aktualisiere Abwesenheiten
        },
        isLoading: false
    });
    console.log("planer-state: processTimetableData abgeschlossen. State aktualisiert:", getState());
}


--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-state.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-timetable.js ---
// public/assets/js/planer-timetable.js
// MODIFIZIERT: Redundante, fehlerhafte Neudeklaration von 'days' entfernt.
// MODIFIZIERT: Verwendung von 'timeSlotsDisplay' auf das importierte 'timeSlots' vereinheitlicht.
// KORRIGIERT: Syntaktische Fehler (eingestreute Zeichen wie 'source:', 'section:', 's') entfernt.

import { getState } from './planer-state.js';
import { days, timeSlots, timetableContainer } from './planer-dom.js';
import { escapeHtml } from './planer-utils.js'; // Importiere escapeHtml

/**
 * Erstellt und rendert das gesamte Stundenplan-Raster im DOM.
 * @param {object} [overrideState] - Optionaler State (wird im Template-Editor verwendet)
 * @param {boolean} [isTemplateEditor=false] - Flag für den Template-Editor-Modus
 */
export function renderTimetableGrid(overrideState = null, isTemplateEditor = false) {
    const container = isTemplateEditor ? document.getElementById('template-editor-grid-container') : timetableContainer;
    if (!container) return;

    // KORREKTUR: State über die Funktion holen oder Override verwenden
    const state = overrideState || getState();

    // KORREKTUR: Stelle sicher, dass stammdaten und settings vorhanden sind
    const stammdaten = state.stammdaten || {};
    const settings = (stammdaten && stammdaten.settings) ? stammdaten.settings : (window.APP_CONFIG.settings || {});
    const startHour = parseInt(settings.default_start_hour, 10) || 1;
    const endHour = parseInt(settings.default_end_hour, 10) || 10;
    
    const grid = document.createElement('div');
    grid.className = 'timetable-grid'; // Verwende die CSS-Grid-Klasse
    if (isTemplateEditor) {
        grid.classList.add('template-editor-grid');
    } else {
        grid.id = 'timetable-grid'; // ID für Drag&Drop-Listener
    }

    let gridHTML = '';

    // 1. Header-Zeile (Zeit + Tage)
    gridHTML += '<div class="grid-header period-header">Zeit</div>';
    days.forEach(dayName => { // Verwendet importierte 'days'
        gridHTML += `<div class="grid-header">${dayName}</div>`;
    });

    // 2. Zeit-Spalte (Stunden)
    // KORREKTUR: Verwendet importierte 'timeSlots'
    for (let period = 1; period <= timeSlots.length; period++) {
        if (isTemplateEditor && (period < startHour || period > endHour)) {
            continue;
        }
        // KORREKTUR: Verwendet importierte 'timeSlots'
        gridHTML += `<div class="grid-header period-header" style="grid-row: ${period + 1};">
            <div class="time-slot-period">${period}. Std</div>
            <div class="time-slot-time">${timeSlots[period - 1]}</div>
        </div>`;
    }

    // 3. Datenzellen vorbereiten (inkl. Block-Logik)
    const processedCellKeys = new Set();
    const blockSpans = new Map();
    // KORREKTUR: Verwende die flachen Arrays (currentTimetable/currentSubstitutions) für die Block-Berechnung
    const dataToRender = isTemplateEditor ? (state.currentTemplateEditorData || []) : (state.currentTimetable || []);
    const subsToRender = isTemplateEditor ? [] : (state.currentSubstitutions || []);
    // KORREKTUR: Verwende die Maps (timetable/substitutions) für das Füllen der Zellen
    const stateTimetableMap = isTemplateEditor ? null : (state.timetable || {}); // Map für schnellen Zugriff
    const stateSubMap = isTemplateEditor ? null : (state.substitutions || {}); // Map für schnellen Zugriff

    // 3a. Reguläre Blöcke (verwende dataToRender = flaches Array)
    if (dataToRender.length > 0) {
        const blocks = new Map();
        dataToRender.forEach(entry => {
            const blockKey = isTemplateEditor ? entry.block_ref : entry.block_id;
            if (blockKey) {
                if (!blocks.has(blockKey)) blocks.set(blockKey, []);
                blocks.get(blockKey).push(entry);
            }
        });
        blocks.forEach(entries => {
            if (entries.length === 0) return;
            entries.sort((a, b) => a.period_number - b.period_number);
            const startEntry = entries[0];
            // KORREKTUR: Span-Berechnung muss Perioden-Strings in Zahlen umwandeln
            const span = parseInt(entries[entries.length - 1].period_number) - parseInt(startEntry.period_number) + 1;
            blockSpans.set(`${startEntry.day_of_week}-${startEntry.period_number}`, span);
            for (let i = 1; i < span; i++) {
                processedCellKeys.add(`${startEntry.day_of_week}-${parseInt(startEntry.period_number) + i}`);
            }
        });
    }
    // 3b. Vertretungs-Blöcke (verwende subsToRender = flaches Array)
    if (subsToRender.length > 0) {
        const substitutionBlocks = new Map();
        subsToRender.forEach(sub => {
            if (!sub.day_of_week) return;
            const key = `${sub.date}-${sub.class_id}-${sub.substitution_type}-${sub.comment || ''}-${sub.new_room_id || ''}-${sub.new_teacher_id || ''}-${sub.new_subject_id || ''}`;
            if (!substitutionBlocks.has(key)) substitutionBlocks.set(key, []);
            substitutionBlocks.get(key).push(sub);
        });
        substitutionBlocks.forEach(subs => {
            if (subs.length > 1) { 
                subs.sort((a, b) => a.period_number - b.period_number);
                let isConsecutive = true;
                for (let i = 0; i < subs.length - 1; i++) {
                    if (parseInt(subs[i + 1].period_number) !== parseInt(subs[i].period_number) + 1) {
                        isConsecutive = false; break;
                    }
                }
                if (isConsecutive) { 
                    const startSub = subs[0];
                    const span = subs.length;
                    const dayNum = startSub.day_of_week;
                    if (dayNum) {
                        blockSpans.set(`${dayNum}-${startSub.period_number}`, span);
                        for (let i = 1; i < span; i++) {
                            processedCellKeys.add(`${dayNum}-${parseInt(startSub.period_number) + i}`);
                        }
                    }
                }
            }
        });
    }


    // 4. Zellen-HTML generieren
    // KORREKTUR: Verwendet importierte 'timeSlots'
    for (let period = 1; period <= timeSlots.length; period++) {
        // Logik für Template-Editor (ausblenden)
        if (isTemplateEditor && (period < startHour || period > endHour)) {
            continue;
        }
        
        // KORREKTUR: Verwendet importierte 'days'
        for (let day = 1; day <= days.length; day++) {
            const cellKey = `${day}-${period}`;
            
            // Überspringe Zellen, die Teil eines Blocks sind (außer der Startzelle)
            if (processedCellKeys.has(cellKey)) continue;

            // KORREKTUR: Hole die Arrays aus den Maps
            const entries = isTemplateEditor ? dataToRender.filter(e => e.day_of_week == day && e.period_number == period) : (stateTimetableMap[cellKey] || []);
            const subs = isTemplateEditor ? [] : (stateSubMap[cellKey] || []);
            
            let cellClass = 'grid-cell';
            if (isTemplateEditor) cellClass += ' template-cell';
            
            let cellContent = '';
            let dataAttrs = `data-day="${day}" data-period="${period}" data-cell-key="${cellKey}"`;
            let style = `grid-row: ${period + 1}; grid-column: ${day + 1};`;

            const span = blockSpans.get(cellKey);
            if (span) {
                style += `grid-row: ${period + 1} / span ${span};`;
                cellClass += ' block-start';
            }

            // KORREKTUR: Iteriere über Vertretungen (haben Vorrang)
            if (subs.length > 0) {
                cellClass += ' has-substitution';
                dataAttrs += ` draggable="true"`; // Zelle draggbar machen
                subs.forEach(sub => {
                    // Verwende die erste Sub-ID für die Zelle, falls mehrere vorhanden sind
                    if (!dataAttrs.includes('data-substitution-id')) {
                        dataAttrs += ` data-substitution-id="${sub.substitution_id}"`;
                    }
                    // Füge die Klasse nur einmal hinzu, auch bei mehreren Vertretungen
                    const typeClass = `substitution-${sub.substitution_type.toLowerCase()}`;
                    if (!cellClass.includes(typeClass)) {
                        cellClass += ` ${typeClass}`;
                    }
                    cellContent += createSubstitutionElement(sub, state).outerHTML;
                });
            // KORREKTUR: Iteriere über reguläre Einträge
            } else if (entries.length > 0) {
                cellClass += ' has-entry';
                dataAttrs += ` draggable="true"`; // Zelle draggbar machen
                entries.forEach(entry => {
                    if (isTemplateEditor) {
                        // Verwende die erste ID für die Zelle
                        if (!dataAttrs.includes('data-template-entry-id')) {
                            dataAttrs += ` data-template-entry-id="${entry.template_entry_id}"`;
                            if (entry.block_ref) dataAttrs += ` data-block-id="${entry.block_ref}"`;
                        }
                    } else {
                        // Verwende die erste ID für die Zelle
                        if (!dataAttrs.includes('data-entry-id')) {
                            dataAttrs += ` data-entry-id="${entry.entry_id}"`;
                            if (entry.block_id) dataAttrs += ` data-block-id="${entry.block_id}"`;
                        }
                    }
                    cellContent += createTimetableElement(entry, isTemplateEditor, state).outerHTML;
                });
            } else {
                cellClass += ' is-empty';
                if (!isTemplateEditor && (period === startHour || period === endHour)) {
                    cellClass += ' default-entry';
                    cellContent = `<div class="planner-entry default-entry" style="pointer-events: none;"><strong>FU</strong></div>`;
                } else {
                    cellContent = `<span class="sr-only">Kein Eintrag für ${days[day-1]}, ${period}. Stunde</span>`;
                }
            }

            // KORREKTUR: Container .cell-entries-container wird jetzt verwendet
            gridHTML += `<div class="${cellClass}" ${dataAttrs} style="${style}">
                            <div class="cell-entries-container">${cellContent}</div>
                        </div>`;
        }
    }

    grid.innerHTML = gridHTML;
    
    // Altes Grid ersetzen
    container.innerHTML = '';
    container.appendChild(grid);
}


/**
 * Erstellt ein einzelnes HTML-Element (DIV) für einen regulären Stundenplaneintrag.
* @param {object} entry - Das Eintragsobjekt.
 * @param {boolean} [isTemplateEditor=false] - Flag für den Template-Editor-Modus
 * @param {object} state - Der aktuelle Anwendungsstatus (wird benötigt)
 * @returns {HTMLDivElement}
 */
function createTimetableElement(entry, isTemplateEditor = false, state) {
    const entryElement = document.createElement('div');
    entryElement.className = 'planner-entry timetable-entry';
    
    // WICHTIG: IDs für die Interaktion speichern
    if (isTemplateEditor) {
        entryElement.dataset.templateEntryId = entry.template_entry_id; // ID aus Template-Tabelle
        if (entry.block_ref) {
            entryElement.dataset.blockId = entry.block_ref; // Verwende block_ref im Editor
        }
    } else {
        entryElement.dataset.entryId = entry.entry_id;
        if (entry.block_id) {
            entryElement.dataset.blockId = entry.block_id;
        }
    }


    const isTeacherView = state.currentViewMode === 'teacher';
    const stammdaten = state.stammdaten || {};
    
    let subjectShortcut, teacherShortcut, roomName, className;

    if (isTemplateEditor) {
        subjectShortcut = (stammdaten.subjects?.find(s => s.subject_id == entry.subject_id) || {}).subject_shortcut || 'F?';
        teacherShortcut = (stammdaten.teachers?.find(t => t.teacher_id == entry.teacher_id) || {}).teacher_shortcut || 'L?';
        roomName = (stammdaten.rooms?.find(r => r.room_id == entry.room_id) || {}).room_name || 'R?';
        className = (stammdaten.classes?.find(c => c.class_id == entry.class_id) || {}).class_name || 'K?';
        if (entry.class_id == 0) className = 'Alle'; // Spezialfall für "Keine Klasse" im Template
    } else {
        subjectShortcut = entry.subject_shortcut || '---';
        teacherShortcut = entry.teacher_shortcut || '---';
        roomName = entry.room_name || '---';
        className = entry.class_name || 'N/A';
    }
    
    // KORREKTUR: Logik für Lehreransicht (Klasse + ID)
    let mainHtml = '';
    if (isTeacherView) {
        const classDisplay = escapeHtml(className);
        // Zeige (ID: 0) nicht an, wenn es "Keine Klasse" ist (Template-Editor)
        if (entry.class_id && entry.class_id != 0) {
            mainHtml = `<div class="entry-line entry-main">${classDisplay} (ID: ${escapeHtml(entry.class_id)})</div>`;
        } else {
            mainHtml = `<div class="entry-line entry-main">${classDisplay}</div>`;
        }
    } else {
        mainHtml = `<div class="entry-line entry-main">${escapeHtml(teacherShortcut)}</div>`;
    }
    // ENDE KORREKTUR

    entryElement.innerHTML = `
        <div class="entry-line entry-subject">${escapeHtml(subjectShortcut)}</div>
        ${mainHtml}
        <div class="entry-line entry-room">${escapeHtml(roomName)}</div>
    `;

    if (entry.comment) {
        entryElement.classList.add('has-comment');
        entryElement.title = `Kommentar: ${escapeHtml(entry.comment)}`;
    }

    // Abwesenheits-Check (nur im normalen Modus)
    // KORREKTUR: Prüfung auf state.stammdaten.absences
    if (!isTemplateEditor && entry.teacher_id && state.stammdaten.absences && state.stammdaten.absences.length > 0) {
        let entryDate;
        try {
            // KORREKTUR: Verwende state.selectedYear/Week statt DOM
            const dto = new Date();
            // KORREKTUR: Verwende setISODate (UTC-basiert, aber erzeugt lokales Datumsobjekt)
            dto.setUTCFullYear(state.selectedYear);
            dto.setUTCMonth(0); // Jan
            dto.setUTCDate(1); // 1. Jan
            // Finde den Montag der ersten Woche
            let dayOfWeek = dto.getUTCDay();
            let firstMonday = (dayOfWeek <= 1) ? (2 - dayOfWeek) : (9 - dayOfWeek);
            dto.setUTCDate(firstMonday);
            // Füge die Wochen hinzu
            dto.setUTCDate(dto.getUTCDate() + (state.selectedWeek - 1) * 7);
            // Füge den Tag hinzu
            dto.setUTCDate(dto.getUTCDate() + (entry.day_of_week - 1));
            
            entryDate = dto.toISOString().split('T')[0];
        } catch(e) {
            console.error("Datumsberechnung fehlgeschlagen", e);
            entryDate = null;
        }

        if(entryDate) {
            const absence = isTeacherAbsent(entry.teacher_id, entryDate, state); // State übergeben
            if (absence) {
                entryElement.classList.add('is-absent');
                const warning = document.createElement('small');
                warning.className = 'absence-warning';
                warning.textContent = `(Lehrer abwesend: ${escapeHtml(absence.reason)})`;
                entryElement.appendChild(warning);
                entryElement.title = `Lehrer abwesend: ${escapeHtml(absence.reason)}`;
            }
        }
    }

    return entryElement;
}

/**
 * Erstellt ein einzelnes HTML-Element (DIV) für einen Vertretungseintrag.
 * @param {object} sub - Das Vertretungsobjekt.
 * @param {object} state - Der aktuelle Anwendungsstatus.
 * @returns {HTMLDivElement}
 */
function createSubstitutionElement(sub, state) {
    const entryElement = document.createElement('div');
    entryElement.className = `planner-entry substitution-entry ${sub.substitution_type.toLowerCase()}`;
    
    // WICHTIG: IDs für die Interaktion speichern
    entryElement.dataset.substitutionId = sub.substitution_id;
    entryElement.dataset.day = sub.day_of_week;
    entryElement.dataset.period = sub.period_number;
    entryElement.dataset.date = sub.date;
    // Füge auch die zugrundeliegende Eintrags-ID hinzu (falls vorhanden), um das Modal zu füllen
    const originalEntry = getOriginalEntry(sub, state); // KORREKTUR: state übergeben
    if (originalEntry) {
        entryElement.dataset.entryId = originalEntry.entry_id;
        if(originalEntry.block_id) entryElement.dataset.blockId = originalEntry.block_id;
    }


    const isTeacherView = state.currentViewMode === 'teacher';
    let subjectText = '---';
    let mainText = '---';
    let roomText = '---';
    let typeText = sub.substitution_type;

    // KORREKTUR: Logik für Lehreransicht (Klasse + ID)
    let classDisplay = escapeHtml(sub.class_name || 'N/A');
    // Zeige ID nur an, wenn sie vorhanden und nicht 0 ist
    if (sub.class_id && sub.class_id != 0) {
        classDisplay += ` (ID: ${escapeHtml(sub.class_id)})`;
    }
    // ENDE KORREKTUR

    switch (sub.substitution_type) {
        case 'Vertretung':
            subjectText = sub.new_subject_shortcut || sub.original_subject_shortcut || '---';
            // KORREKTUR: Verwende classDisplay
            mainText = isTeacherView ? classDisplay : (sub.new_teacher_shortcut || '!!!');
            roomText = sub.new_room_name || '---';
            break;
        case 'Raumänderung':
            typeText = 'Raum'; // Kürzer
            subjectText = sub.original_subject_shortcut || '---';
            // KORREKTUR: Verwende classDisplay
            mainText = isTeacherView ? classDisplay : (getOriginalTeacher(sub, state) || '---'); // KORREKTUR: state übergeben
            roomText = sub.new_room_name || '!!!';
            break;
        case 'Entfall':
            subjectText = sub.original_subject_shortcut || '---';
            // KORREKTUR: Verwende classDisplay
            mainText = `(${isTeacherView ? classDisplay : (getOriginalTeacher(sub, state) || '---')})`; // KORREKTUR: state übergeben
            roomText = '---';
            break;
        case 'Sonderevent':
            typeText = 'Event'; // Kürzer
            subjectText = sub.new_subject_shortcut || 'EVENT';
            mainText = sub.comment ? (sub.comment.substring(0, 10) + '...') : 'Info';
            roomText = sub.new_room_name || '---';
            break;
    }

    entryElement.innerHTML = `
        <div class="entry-line sub-type">${escapeHtml(typeText)}</div>
        <div class="entry-line entry-subject">${escapeHtml(subjectText)}</div>
        <div class="entry-line entry-main">${mainText}</div> <!-- mainText ist bereits escaped oder HTML -->
        <div class="entry-line entry-room">${escapeHtml(roomText)}</div>
    `;
    
    if (sub.comment && sub.substitution_type !== 'Sonderevent') {
         entryElement.title = `Kommentar: ${escapeHtml(sub.comment)}`;
    }

    return entryElement;
}


/**
 * Prüft, ob ein Lehrer an einem bestimmten Datum abwesend ist.
 * @param {number} teacherId 
 * @param {string} dateString (YYYY-MM-DD)
 * @param {object} state - Der aktuelle Anwendungsstatus.
* @returns {object|null} - Das Abwesenheitsobjekt oder null.
 */
function isTeacherAbsent(teacherId, dateString, state) {
    if (!teacherId || !dateString) return null;
    
    // KORREKTUR: Zugriff auf state.stammdaten.absences
    const absences = (state.stammdaten && state.stammdaten.absences) ? state.stammdaten.absences : [];
    if (absences.length === 0) return null;

    // Konvertiere Datum in ein Objekt für einfachen Vergleich
    // (UTC, um Zeitzonenprobleme beim reinen Datumsvergleich zu vermeiden)
    try {
        const checkDate = new Date(dateString + 'T00:00:00Z');
        if (isNaN(checkDate.getTime())) {
            console.warn(`isTeacherAbsent: Ungültiges Datum ${dateString}`);
            return null;
        }

        for (const absence of absences) {
            if (absence.teacher_id == teacherId) { 
                const startDate = new Date(absence.start_date + 'T00:00:00Z');
                const endDate = new Date(absence.end_date + 'T00:00:00Z');
                
                if (checkDate >= startDate && checkDate <= endDate) {
                    return absence;
                }
            }
        }
    } catch (e) {
        console.error("Fehler beim Prüfen der Abwesenheit:", e);
    }
    return null;
}

/**
 * Findet den ursprünglichen regulären Eintrag für eine Vertretung.
 * @param {object} sub 
 * @param {object} state - Der aktuelle Anwendungsstatus.
 * @returns {object|null}
 */
function getOriginalEntry(sub, state) {
    // KORREKTUR: state.timetable ist jetzt eine Map
    const cellKey = `${sub.day_of_week}-${sub.period_number}`;
    const entries = state.timetable[cellKey] || [];
    
    // Finde den Eintrag, der zur Klasse UND Fach passt
    const originalEntry = entries.find(e => 
        e.class_id == sub.class_id && 
        e.subject_id == sub.original_subject_id
    );

    return originalEntry || null;
}

/**
 * Versucht, das Kürzel des ursprünglichen Lehrers einer Vertretung zu finden.
 * @param {object} sub 
 * @param {object} state - Der aktuelle Anwendungsstatus.
 * @returns {string|null} - Das Kürzel des Lehrers oder null.
 */
function getOriginalTeacher(sub, state) {
    // KORREKTUR: state übergeben
    const originalEntry = getOriginalEntry(sub, state);
    if (originalEntry) {
        // Versuche, das Kürzel aus dem Eintrag zu holen
        if (originalEntry.teacher_shortcut) {
            return originalEntry.teacher_shortcut;
        }
        // Fallback: Suche in Stammdaten (falls shortcut fehlt)
        // KORREKTUR: Zugriff auf state.stammdaten.teachers
        const teacher = (state.stammdaten.teachers || []).find(t => t.teacher_id == originalEntry.teacher_id);
        if (teacher) {
            return teacher.teacher_shortcut;
        }
    }
    return null; // Konnte nicht gefunden werden
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-timetable.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-ui.js ---
import * as DOM from './planer-dom.js';
import { getState } from './planer-state.js';
import { escapeHtml } from './planer-utils.js';

/** Füllt einen Jahres-Selektor (allgemein) */
export const populateYearSelector = (selectorElement, defaultYear) => {
    if (!selectorElement) return; // Add check
    const currentYear = new Date().getFullYear();
    let options = '';
    for (let i = currentYear - 2; i <= currentYear + 2; i++) {
        options += `<option value="${i}">${i}</option>`;
    }
    selectorElement.innerHTML = options;
    selectorElement.value = defaultYear;
};

/** Füllt einen Wochen-Selektor (allgemein) */
export const populateWeekSelector = (selectorElement, defaultWeek) => {
     if (!selectorElement) return; // Add check
    let options = '';
    for (let i = 1; i <= 53; i++) {
        options += `<option value="${i}">KW ${i}</option>`;
    }
    selectorElement.innerHTML = options;
    selectorElement.value = defaultWeek;
};

/** Füllt den Klassen-Hauptselektor */
export const populateClassSelector = (classes = []) => { // Default to empty array
    if (!DOM.classSelector) return; // Add check
    console.log(`planer-ui: Populating class selector with ${classes.length} classes...`); // Logging hinzugefügt
    DOM.classSelector.innerHTML = '<option value="">Bitte wählen...</option>' +
        classes.map(c => `<option value="${c.class_id}">${c.class_id} - ${escapeHtml(c.class_name)}</option>`).join(''); // Escape class name
};

/** Füllt den Lehrer-Hauptselektor */
export const populateTeacherSelector = (teachers = []) => { // Default to empty array
     if (!DOM.teacherSelector) return; // Add check
    const filteredTeachers = teachers.filter(t => t.teacher_shortcut !== 'SGL'); // Filter out 'SGL'
    console.log(`planer-ui: Populating teacher selector with ${filteredTeachers.length} teachers...`); // Logging hinzugefügt
    DOM.teacherSelector.innerHTML = '<option value="">Bitte wählen...</option>' +
        filteredTeachers.map(t => `<option value="${t.teacher_id}">${escapeHtml(t.last_name)}, ${escapeHtml(t.first_name)} (${escapeHtml(t.teacher_shortcut)})</option>`).join(''); // Escape names/shortcut
};

/** Füllt alle Selects in den Modals */
export const populateAllModalSelects = (stammdaten) => {
     if (!DOM.modal) return; // Exit if modal doesn't exist on the page
    console.log("planer-ui: Populating modal selects..."); // Logging hinzugefügt
    const { subjects = [], teachers = [], rooms = [], classes = [] } = stammdaten || {}; // Default to empty objects/arrays

    // Safely query selectors within the modal
    const subjectSelect = DOM.modal.querySelector('#subject_id');
    const newSubjectSelect = DOM.modal.querySelector('#new_subject_id');
    const teacherSelect = DOM.modal.querySelector('#teacher_id');
    const newTeacherSelect = DOM.modal.querySelector('#new_teacher_id');
    const roomSelect = DOM.modal.querySelector('#room_id');
    const newRoomSelect = DOM.modal.querySelector('#new_room_id');
    const templateClassSelect = DOM.modal.querySelector('#template_class_id');

    // Populate Subject Selects
    if (subjectSelect) {
        subjectSelect.innerHTML = subjects.map(s => `<option value="${s.subject_id}">${escapeHtml(s.subject_name)} (${escapeHtml(s.subject_shortcut)})</option>`).join('');
    }
    if (newSubjectSelect) {
        newSubjectSelect.innerHTML = '<option value="">(wie Original)</option>' + subjects.map(s => `<option value="${s.subject_id}">${escapeHtml(s.subject_name)} (${escapeHtml(s.subject_shortcut)})</option>`).join('');
    }

    // Populate Teacher Selects (filter out SGL)
    const filteredTeachers = teachers.filter(t => t.teacher_shortcut !== 'SGL');
    const teacherOptions = filteredTeachers.map(t => `<option value="${t.teacher_id}">${escapeHtml(t.first_name)} ${escapeHtml(t.last_name)}</option>`).join('');
    if (teacherSelect) {
        teacherSelect.innerHTML = teacherOptions;
    }
    if (newTeacherSelect) {
        newTeacherSelect.innerHTML = '<option value="">(kein Lehrer)</option>' + teacherOptions;
    }

    // Populate Room Selects
    const roomOptions = rooms.map(r => `<option value="${r.room_id}">${escapeHtml(r.room_name)}</option>`).join('');
    if (roomSelect) {
        roomSelect.innerHTML = roomOptions;
    }
    if (newRoomSelect) {
        newRoomSelect.innerHTML = '<option value="">(kein Raum)</option>' + roomOptions;
    }

    // Populate Class Select (for Template Editor within the modal)
    if (templateClassSelect) {
        templateClassSelect.innerHTML = '<option value="0">(Keine Klasse)</option>' + classes.map(c => `<option value="${c.class_id}">${escapeHtml(c.class_name)}</option>`).join('');
    }
};


/** Füllt die Vorlagen-Selects (Anwenden-Modal) */
export const populateTemplateSelects = (templates = []) => { // Default to empty array
     if (!DOM.applyTemplateSelect) return; // Add check
     console.log(`planer-ui: Populating template select with ${templates.length} templates...`); // Logging hinzugefügt
    DOM.applyTemplateSelect.innerHTML = templates.length > 0
        ? '<option value="">-- Vorlage wählen --</option>' + templates.map(t => `<option value="${t.template_id}">${escapeHtml(t.name)}</option>`).join('')
        : '<option value="">Keine Vorlagen verfügbar</option>';
};

/** Aktualisiert die UI für den Veröffentlichungsstatus */
export const updatePublishControls = (status = { student: false, teacher: false }) => { // Default status
     // Check if elements exist before updating
    if (DOM.publishWeekLabel) DOM.publishWeekLabel.textContent = DOM.weekSelector?.value || '--'; // Use optional chaining

    if (DOM.publishStatusStudent) {
        DOM.publishStatusStudent.textContent = status.student ? 'Schüler: Veröffentlicht' : 'Schüler: Nicht veröffentlicht';
        DOM.publishStatusStudent.classList.toggle('published', !!status.student);
        DOM.publishStatusStudent.classList.toggle('not-published', !status.student);
    }
     if (DOM.publishStudentBtn) DOM.publishStudentBtn.classList.toggle('hidden', !!status.student);
     if (DOM.unpublishStudentBtn) DOM.unpublishStudentBtn.classList.toggle('hidden', !status.student);

    if (DOM.publishStatusTeacher) {
        DOM.publishStatusTeacher.textContent = status.teacher ? 'Lehrer: Veröffentlicht' : 'Lehrer: Nicht veröffentlicht';
        DOM.publishStatusTeacher.classList.toggle('published', !!status.teacher);
        DOM.publishStatusTeacher.classList.toggle('not-published', !status.teacher);
    }
     if (DOM.publishTeacherBtn) DOM.publishTeacherBtn.classList.toggle('hidden', !!status.teacher);
     if (DOM.unpublishTeacherBtn) DOM.unpublishTeacherBtn.classList.toggle('hidden', !status.teacher);

    // Disable buttons if year or week is not selected
    const isValidWeek = DOM.yearSelector?.value && DOM.weekSelector?.value;
     if (DOM.publishStudentBtn) DOM.publishStudentBtn.disabled = !isValidWeek;
     if (DOM.publishTeacherBtn) DOM.publishTeacherBtn.disabled = !isValidWeek;
     if (DOM.unpublishStudentBtn) DOM.unpublishStudentBtn.disabled = !isValidWeek;
     if (DOM.unpublishTeacherBtn) DOM.unpublishTeacherBtn.disabled = !isValidWeek;
};

/** Zeigt Konfliktwarnungen im Modal an */
export const showConflicts = (conflictMessages = []) => { // Default to empty array
    if (DOM.conflictWarningBox) {
        DOM.conflictWarningBox.innerHTML = conflictMessages.map(msg => `<div>${escapeHtml(msg)}</div>`).join('');
        DOM.conflictWarningBox.style.display = 'block';
    }
     // Disable save button when conflicts are shown
    if (DOM.saveButton) {
        DOM.saveButton.disabled = true;
        DOM.saveButton.style.opacity = '0.5';
        DOM.saveButton.style.cursor = 'not-allowed';
    }
};

/** Versteckt Konfliktwarnungen im Modal */
export const hideConflicts = () => {
    if (DOM.conflictWarningBox) {
        DOM.conflictWarningBox.innerHTML = '';
        DOM.conflictWarningBox.style.display = 'none';
    }
     // Re-enable save button when conflicts are hidden
    if (DOM.saveButton) {
        DOM.saveButton.disabled = false;
        DOM.saveButton.style.opacity = '1';
        DOM.saveButton.style.cursor = 'pointer';
    }
};

/** Schaltet die Ansicht im "Vorlagen verwalten"-Modal um */
export const showTemplateView = (viewType) => {
     // Check if elements exist before manipulating them
     if (!DOM.templateListView || !DOM.templateEditorView || !DOM.manageTemplatesModal) return;

    if (viewType === 'editor') {
        DOM.templateListView.style.display = 'none';
        DOM.templateEditorView.style.display = 'flex'; // MODIFIZIERT: 'block' zu 'flex' geändert
        if (DOM.templateEditorTitle) DOM.templateEditorTitle.textContent = "Neue leere Vorlage erstellen"; // Default title
        const nameInput = DOM.manageTemplatesModal.querySelector('#template-editor-name');
        if (nameInput) nameInput.focus(); // Focus on name input when editor opens
    } else { // 'list' or default
        DOM.templateListView.style.display = 'flex'; // MODIFIZIERT: 'block' zu 'flex' geändert
        DOM.templateEditorView.style.display = 'none';
    }
};
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-ui.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-utils.js ---
/**
 * Hilfsfunktion zur Ermittlung der Kalenderwoche und des Jahres nach ISO 8601.
 */
export function getWeekAndYear(date) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    return { week: weekNo, year: d.getUTCFullYear() };
}

/**
 * Ermittelt das Datum des Montags einer gegebenen Kalenderwoche und eines Jahres.
 * @param {number} week - Die Kalenderwoche.
 * @param {number} year - Das Jahr.
 * @returns {Date} Das Datumsobjekt für den Montag.
 */
export function getDateOfISOWeek(week, year) {
    const simple = new Date(Date.UTC(year, 0, 1 + (week - 1) * 7));
    const dow = simple.getUTCDay(); // Sonntag = 0, Montag = 1 ...
    const ISOweekStart = simple;
    // Gehe zum Montag der Woche
    ISOweekStart.setUTCDate(simple.getUTCDate() - (dow || 7) + 1);
    // Konvertiere zurück in lokale Zeit für die Anzeige
    return new Date(ISOweekStart.getFullYear(), ISOweekStart.getMonth(), ISOweekStart.getDate());
}

/**
 * Berechnet den YYYY-MM-DD Datumsstring für einen Wochentag (1-5) in der aktuell gewählten Woche.
 * @param {number} dayNum - Der Wochentag (1=Mo, 5=Fr).
 * @param {string} year - Das ausgewählte Jahr.
 * @param {string} week - Die ausgewählte Woche.
 * @returns {string} Das Datum im Format YYYY-MM-DD.
A*/
export function getDateForDayInWeek(dayNum, year, week) {
    const monday = getDateOfISOWeek(week, year);
    const targetDate = new Date(monday.getTime() + (dayNum - 1) * 24 * 60 * 60 * 1000);

    const yyyy = targetDate.getFullYear();
    const mm = String(targetDate.getMonth() + 1).padStart(2, '0');
    const dd = String(targetDate.getDate()).padStart(2, '0');

    return `${yyyy}-${mm}-${dd}`;
}

/**
 * Bereinigt einen String für die sichere Anzeige in HTML.
 * @param {*} unsafe - Der Eingabewert.
Source: 
 * @returns {string} Der bereinigte String.
 */
export function escapeHtml(unsafe) {
    if (!unsafe) return '';
    return String(unsafe)
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\planer-utils.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\spa-router.js ---
// Vorerst leer.

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\spa-router.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\teacher-cockpit.js ---
// public/assets/js/teacher-cockpit.js
import { apiFetch } from './api-client.js';
import { showToast, showConfirm } from './notifications.js';

/**
 * Escapes HTML special characters.
 * @param {string} unsafe
 * @returns {string}
 */
function escapeHtml(unsafe) {
    if (!unsafe) return '';
    return String(unsafe)
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}

// NEU: Formatiert HH:MM:SS zu HH:MM
function formatShortTime(timeString) {
    if (!timeString) return '';
    const parts = timeString.split(':');
    if (parts.length >= 2) {
        return `${parts[0]}:${parts[1]}`;
    }
    return timeString; // Fallback
}
// NEU: Wandelt 1-5 in Wochentage um
function formatDayOfWeek(dayNum) {
    const days = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag'];
    const index = parseInt(dayNum, 10) - 1;
    return days[index] || 'Unbekannt';
}

// ▼▼▼ KORREKTUR: Fehlende Funktion hinzugefügt ▼▼▼
/**
 * Formatiert einen YYYY-MM-DD Datum in ein lesbares deutsches Format.
 * @param {string} dateString - YYYY-MM-DD
 * @returns {string} TT.MM.YYYY
 */
function formatGermanDate(dateString) {
    if (!dateString) return '';
    try {
        const parts = dateString.split('-');
        if (parts.length === 3) {
            return `${parts[2]}.${parts[1]}.${parts[0]}`;
        }
        return dateString;
    } catch(e) {
        return dateString;
    }
}
// ▲▲▲ ENDE KORREKTUR ▲▲▲


// Globale Variable für den Controller der Anwesenheitsliste
let attendanceController = null;

export function initializeTeacherCockpit() {
    const cockpit = document.getElementById('teacher-cockpit');
    if (!cockpit || window.APP_CONFIG.userRole !== 'lehrer') {
        return; // Nur für Lehrer initialisieren
    }

    // --- Feature: Kollege finden ---
    const searchInput = document.getElementById('colleague-search-input');
    const searchResults = document.getElementById('colleague-search-results');
    const resultDisplay = document.getElementById('colleague-result-display');
    const resultSpinner = resultDisplay.querySelector('.loading-spinner');
    const resultParagraph = resultDisplay.querySelector('p');
    // KORREKTUR: Cockpit-Container für Klick-Außerhalb-Erkennung
    const findColleagueFeature = document.getElementById('find-colleague-feature');


    let searchTimeout;
    let selectedTeacherId = null;

    const handleSearchInput = () => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(async () => {
            const query = searchInput.value.trim();
            if (query.length < 2) {
                searchResults.innerHTML = '';
                searchResults.classList.remove('visible');
                return;
            }
            
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/search-colleagues?query=${encodeURIComponent(query)}`);
                if (response.success && response.data) {
                      const filteredTeachers = response.data.filter(t => t.teacher_shortcut !== 'SGL');
                      if (filteredTeachers.length > 0) {
                        searchResults.innerHTML = filteredTeachers.map(teacher => `
                            <div class="search-result-item" data-id="${teacher.teacher_id}" data-name="${escapeHtml(teacher.first_name)} ${escapeHtml(teacher.last_name)} (${escapeHtml(teacher.teacher_shortcut)})">
                                <strong>${escapeHtml(teacher.last_name)}, ${escapeHtml(teacher.first_name)}</strong> (${escapeHtml(teacher.teacher_shortcut)})
                            </div>
                        `).join('');
                        searchResults.classList.add('visible');
                    } else {
                        searchResults.innerHTML = '<div class="search-result-item none">Keine Treffer</div>';
                        searchResults.classList.add('visible');
                    }
                } else {
                    searchResults.innerHTML = '<div class="search-result-item none">Keine Treffer</div>';
                    searchResults.classList.add('visible');
                }
            } catch (error) {
                console.error("Fehler bei Lehrersuche:", error);
                searchResults.innerHTML = `<div class="search-result-item none">Fehler: ${escapeHtml(error.message)}</div>`;
                searchResults.classList.add('visible');
            }
        }, 300); // 300ms Verzögerung
    };

    const handleResultClick = async (e) => {
        const item = e.target.closest('.search-result-item');
        if (!item || !item.dataset.id) return;

        selectedTeacherId = item.dataset.id;
        const selectedName = item.dataset.name;

        // UI-Vorbereitung
        searchInput.value = selectedName; // Feld füllen
        searchResults.innerHTML = ''; // Ergebnisse schließen
        searchResults.classList.remove('visible');
        resultDisplay.style.display = 'flex';
        if(resultSpinner) resultSpinner.style.display = 'block';
        if(resultParagraph) resultParagraph.innerHTML = `Suche nach ${escapeHtml(selectedName)}...`;

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/find-colleague?teacher_id=${selectedTeacherId}`);
            if (response.success) {
                // Antwort anzeigen
                if(resultParagraph) resultParagraph.innerHTML = `
                    <strong>${escapeHtml(selectedName)}:</strong><br>
                    ${escapeHtml(response.data.message)}
                `;
            } else {
                throw new Error(response.message);
            }
        } catch (error) {
            console.error("Fehler bei Standortabfrage:", error);
            if(resultParagraph) resultParagraph.innerHTML = `<span class="text-danger">Fehler: ${escapeHtml(error.message)}</span>`;
        } finally {
            if(resultSpinner) resultSpinner.style.display = 'none';
        }
    };

    if (searchInput && searchResults && resultDisplay && findColleagueFeature) {
        searchInput.addEventListener('input', handleSearchInput);
        searchResults.addEventListener('click', handleResultClick);
        // KORREKTUR: Klick außerhalb des Widgets schließt Dropdown
        document.addEventListener('click', (e) => {
            if (!findColleagueFeature.contains(e.target)) {
                searchResults.classList.remove('visible');
            }
        });
    }

    // --- Feature: Digitale Anwesenheit ---
    const attendanceContainer = document.getElementById('attendance-feature');
    if (attendanceContainer) {
        attendanceController = new AttendanceController(attendanceContainer);
        attendanceController.loadCurrentLesson();
    }
    
    // --- Feature: Aufgaben/Klausuren ---
    const eventsContainer = document.getElementById('academic-events-feature');
    if (eventsContainer) {
        const eventsController = new AcademicEventsController(eventsContainer);
        eventsController.initialize();
    }

    // --- Feature: Sprechstunden verwalten ---
    const officeHoursContainer = document.getElementById('office-hours-feature');
    if (officeHoursContainer) {
        const officeHoursController = new OfficeHoursController(officeHoursContainer);
        officeHoursController.initialize();
    }
}


/**
 * Klasse zur Verwaltung der Anwesenheits-Logik
 */
class AttendanceController {
    constructor(containerElement) {
        this.container = containerElement;
        this.lessonDisplay = document.getElementById('attendance-current-lesson');
        this.listContainer = document.getElementById('attendance-list-container');
        this.studentList = document.getElementById('attendance-student-list');
        this.saveButton = document.getElementById('save-attendance-btn');
        this.saveSpinner = document.getElementById('attendance-save-spinner');
        this.saveContext = null; 
        
        this.bindEvents();
    }

    bindEvents() {
        if (this.saveButton) {
            this.saveButton.addEventListener('click', () => this.handleSaveAttendance());
        }
        
        if (this.studentList) {
            this.studentList.addEventListener('click', (e) => {
                const button = e.target.closest('.btn-toggle');
                if (!button) return;
                
                const li = button.closest('.student-row');
                if (!li) return;
                const newStatus = button.dataset.status;
                
                li.dataset.status = newStatus;
                
                li.querySelectorAll('.btn-toggle').forEach(btn => {
                    btn.classList.remove('active');
                });
                button.classList.add('active');
            });
        }
    }

    async loadCurrentLesson() {
        if (!this.lessonDisplay || !this.listContainer) return;
        
        this.lessonDisplay.innerHTML = '<div class="loading-spinner small"></div><p>Prüfe aktuelle Stunde...</p>';
        this.listContainer.style.display = 'none';

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/current-lesson`);
            if (!response.success) throw new Error(response.message);

            const { status, lesson, students, attendance, context } = response.data;

            if (status === 'Unterricht' || status === 'Vertretung') {
                this.lessonDisplay.innerHTML = `
                    <p class="lesson-info">
                        Aktuelle Stunde: <strong>${escapeHtml(lesson.class_name)} (${escapeHtml(lesson.subject_shortcut || lesson.new_subject_shortcut || '?')})</strong>
                        in Raum <strong>${escapeHtml(lesson.room_name || lesson.new_room_name || '?')}</strong>
                        (${status === 'Vertretung' ? 'Vertretung' : 'Regulär'})
                    </p>
                `;
                this.renderStudentList(students, attendance);
                this.listContainer.style.display = 'block';
                this.saveContext = {
                    class_id: lesson.class_id,
                    date: context.date,
                    period_number: context.period
                };
                
            } else if (status === 'Freistunde') {
                this.lessonDisplay.innerHTML = '<p class="message info" style="margin: 0; padding: 0; background: transparent; border: none;">Sie haben jetzt eine Freistunde.</p>';
            } else {
                this.lessonDisplay.innerHTML = '<p class="message info" style="margin: 0; padding: 0; background: transparent; border: none;">Aktuell findet kein Unterricht statt.</p>';
            }

        } catch (error) {
            console.error("Fehler beim Laden der aktuellen Stunde:", error);
            this.lessonDisplay.innerHTML = `<p class="message error">Fehler: ${escapeHtml(error.message)}</p>`;
        }
    }

    renderStudentList(students, attendance) {
        if (!students || students.length === 0) {
            this.studentList.innerHTML = '<li>Keine Schüler für diese Klasse gefunden.</li>';
            this.saveButton.disabled = true;
            return;
        }

        this.studentList.innerHTML = students.map(student => {
            const currentStatus = attendance[student.user_id] || 'anwesend'; 
            
            return `
                <li class="student-row" data-student-id="${student.user_id}" data-status="${currentStatus}">
                    <span class="student-name">${escapeHtml(student.last_name)}, ${escapeHtml(student.first_name)}</span>
                    <div class="attendance-toggles">
                        <button class="btn-toggle status-anwesend ${currentStatus === 'anwesend' ? 'active' : ''}" data-status="anwesend">A</button>
                        <button class="btn-toggle status-abwesend ${currentStatus === 'abwesend' ? 'active' : ''}" data-status="abwesend">F</button>
                        <button class="btn-toggle status-verspaetet ${currentStatus === 'verspaetet' ? 'active' : ''}" data-status="verspaetet">V</button>
                    </div>
                </li>
            `;
        }).join('');
        this.saveButton.disabled = false;
    }

    async handleSaveAttendance() {
        if (!this.saveContext) {
            showToast("Fehler: Keine Stundendaten zum Speichern vorhanden.", "error");
            return;
        }

        this.saveButton.disabled = true;
        this.saveSpinner.style.display = 'block';

        const studentsStatus = [];
        this.studentList.querySelectorAll('.student-row').forEach(row => {
            studentsStatus.push({
                student_id: row.dataset.studentId,
                status: row.dataset.status
            });
        });

        const body = {
            ...this.saveContext,
            students: studentsStatus
        };

        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/attendance/save`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            if (response.success) {
                showToast(response.message, 'success');
            }
        } catch (error) {
            console.error("Fehler beim Speichern der Anwesenheit:", error);
        } finally {
            this.saveButton.disabled = false;
            this.saveSpinner.style.display = 'none';
        }
    }
}

/**
 * Klasse zur Verwaltung der Aufgaben/Klausuren-Logik im Cockpit
 */
class AcademicEventsController {
    constructor(containerElement) {
        this.container = containerElement;
        this.form = document.getElementById('academic-event-form');
        this.classSelect = document.getElementById('event-class-id');
        this.subjectSelect = document.getElementById('event-subject-id');
        this.eventList = document.getElementById('teacher-event-list');
        this.saveButton = document.getElementById('save-event-btn');
        this.saveSpinner = document.getElementById('event-save-spinner');
        
        this.teacherClasses = [];
        this.allSubjects = [];
    }

    async initialize() {
        if (!this.form) return;
        
        this.bindEvents();
        await this.loadPrerequisites();
        await this.loadTeacherEvents();
    }

    bindEvents() {
        this.form.addEventListener('submit', (e) => this.handleSaveEvent(e));
        
        this.eventList.addEventListener('click', (e) => {
            const deleteButton = e.target.closest('.delete-event-btn');
            if (deleteButton) {
                const eventId = deleteButton.dataset.eventId;
                const eventTitle = deleteButton.dataset.eventTitle;
                this.handleDeleteEvent(eventId, eventTitle);
            }
        });
    }

    async loadPrerequisites() {
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/prerequisites`);
            
            if (response.success && response.data) {
                this.allSubjects = response.data.subjects || [];
                this.teacherClasses = response.data.classes || [];

                this.subjectSelect.innerHTML = '<option value="">Kein Fach</option>' + 
                    this.allSubjects.map(s => 
                        `<option value="${s.subject_id}">${escapeHtml(s.subject_name)} (${escapeHtml(s.subject_shortcut)})</option>`
                    ).join('');
                
                if (this.teacherClasses.length > 0) {
                    this.classSelect.innerHTML = '<option value="">-- Klasse wählen --</option>' + 
                        this.teacherClasses.map(c => 
                            `<option value="${c.class_id}">${escapeHtml(c.class_name)} (ID: ${c.class_id})</option>`
                        ).join('');
                } else {
                    this.classSelect.innerHTML = '<option value="">Keine Klassen gefunden</option>';
                    this.form.querySelector('button[type="submit"]').disabled = true;
                    showToast("Es wurden keine Klassen gefunden, die Sie unterrichten.", "info", 5000);
                }
            } else {
                throw new Error(response.message || "Stammdaten konnten nicht geladen werden.");
            }
        } catch (error) {
            console.error("Fehler beim Laden der Voraussetzungen für Events:", error);
            this.classSelect.innerHTML = '<option value="">Fehler</option>';
            this.subjectSelect.innerHTML = '<option value="">Fehler</option>';
            showToast(`Fehler beim Laden der Klassen/Fächer: ${error.message}`, 'error');
        }
    }

    async loadTeacherEvents() {
        this.eventList.innerHTML = '<div class="loading-spinner small"></div>';
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/events`);
            if (response.success && response.data) {
                this.renderEventList(response.data);
            } else {
                throw new Error(response.message || "Events konnten nicht geladen werden.");
            }
        } catch (error) {
            console.error("Fehler beim Laden der Lehrer-Events:", error);
            this.eventList.innerHTML = `<p class="message error small">${escapeHtml(error.message)}</p>`;
        }
    }

    renderEventList(events) {
        if (events.length === 0) {
            this.eventList.innerHTML = '<p class="message info small" style="margin: 10px;">Keine Einträge für die nächsten 14 Tage gefunden.</p>';
            return;
        }

        const groups = events.reduce((acc, event) => {
            const date = event.due_date;
            if (!acc[date]) {
                acc[date] = [];
            }
            acc[date].push(event);
            return acc;
        }, {});

        let html = '';
        const sortedDates = Object.keys(groups).sort();

        for (const date of sortedDates) {
            html += `<div class="event-group">
                        <div class="event-group-date">${escapeHtml(formatGermanDate(date))}</div>
                        <ul class="event-list-items">`;
            
            groups[date].forEach(event => {
                let icon = 'ℹ️'; // Info
                if (event.event_type === 'klausur') icon = '🎓'; // Klausur
                if (event.event_type === 'aufgabe') icon = '📚'; // Aufgabe
                
                html += `
                    <li class="event-list-item type-${escapeHtml(event.event_type)}" data-event-id="${event.event_id}">
                        <span class="event-icon">${icon}</span>
                        <div class="event-details">
                            <strong>${escapeHtml(event.title)}</strong>
                            <span>
                                ${escapeHtml(event.class_name)} 
                                ${event.subject_shortcut ? `(${escapeHtml(event.subject_shortcut)})` : ''}
                            </span>
                            ${event.description ? `<small>${escapeHtml(event.description)}</small>` : ''}
                        </div>
                        <button class="btn btn-danger btn-small delete-event-btn" 
                                title="Eintrag löschen"
                                data-event-id="${event.event_id}" 
                                data-event-title="${escapeHtml(event.title)}">
                            &times;
                        </button>
                    </li>
                `;
            });
            
            html += `</ul></div>`;
        }
        this.eventList.innerHTML = html;
    }

    async handleSaveEvent(e) {
        e.preventDefault();
        this.saveButton.disabled = true;
        this.saveSpinner.style.display = 'block';

        const formData = new FormData(this.form);
        const data = Object.fromEntries(formData.entries());
        
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/events/create`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (response.success) {
                showToast(response.message, 'success');
                this.form.reset();
                this.loadTeacherEvents();
            }
        } catch (error) {
            console.error("Fehler beim Speichern des Events:", error);
        } finally {
            this.saveButton.disabled = false;
            this.saveSpinner.style.display = 'none';
        }
    }

    async handleDeleteEvent(eventId, eventTitle) {
        if (!eventId) return;

        if (await showConfirm("Eintrag löschen", `Möchten Sie den Eintrag "${eventTitle}" wirklich löschen?`)) {
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/events/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ event_id: eventId })
                });

                if (response.success) {
                    showToast(response.message, 'success');
                    this.loadTeacherEvents();
                }
            } catch (error) {
                console.error("Fehler beim Löschen des Events:", error);
            }
        }
    }
}

/**
 * NEU: Klasse zur Verwaltung der Sprechstunden-Logik im Cockpit
 */
class OfficeHoursController {
    constructor(containerElement) {
        this.container = containerElement;
        this.form = document.getElementById('office-hours-form');
        this.listContainer = document.getElementById('teacher-office-hours-list');
        this.saveButton = document.getElementById('save-office-hours-btn');
        this.saveSpinner = document.getElementById('office-hours-save-spinner');
    }

    async initialize() {
        if (!this.form) return;
        this.bindEvents();
        await this.loadOfficeHours();
    }

    bindEvents() {
        this.form.addEventListener('submit', (e) => this.handleSave(e));
        
        this.listContainer.addEventListener('click', (e) => {
            const deleteButton = e.target.closest('.delete-office-hour-btn');
            if (deleteButton) {
                const availabilityId = deleteButton.dataset.id;
                this.handleDelete(availabilityId);
            }
        });
    }

    async loadOfficeHours() {
        this.listContainer.innerHTML = '<div class="loading-spinner small"></div>';
        try {
            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/office-hours`);
            if (response.success && response.data) {
                this.renderList(response.data);
            } else {
                throw new Error(response.message || "Sprechzeiten konnten nicht geladen werden.");
            }
        } catch (error) {
            console.error("Fehler beim Laden der Sprechzeiten:", error);
            this.listContainer.innerHTML = `<p class="message error small">${escapeHtml(error.message)}</p>`;
        }
    }

    renderList(availabilities) {
        if (availabilities.length === 0) {
            this.listContainer.innerHTML = '<p class="message info small" style="margin: 0;">Keine Sprechzeitenfenster definiert.</p>';
            return;
        }
        
        this.listContainer.innerHTML = availabilities.map(av => `
            <div class="office-hour-item" data-id="${av.availability_id}">
                <span>
                    <strong>${escapeHtml(formatDayOfWeek(av.day_of_week))}</strong>, 
                    ${escapeHtml(formatShortTime(av.start_time))} - ${escapeHtml(formatShortTime(av.end_time))} Uhr 
                    (${escapeHtml(av.slot_duration)} Min. Slots)
                </span>
                <button class="btn btn-danger btn-small delete-office-hour-btn" 
                        title="Fenster löschen" 
                        data-id="${av.availability_id}">
                    &times;
                </button>
            </div>
        `).join('');
    }

    async handleSave(e) {
        e.preventDefault();
        this.saveButton.disabled = true;
        this.saveSpinner.style.display = 'block';

        const formData = new FormData(this.form);
        const data = Object.fromEntries(formData.entries());

        try {
            // Validierung: Startzeit muss vor Endzeit liegen
            if (data.start_time >= data.end_time) {
                throw new Error("Startzeit muss vor der Endzeit liegen.");
            }

            const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/office-hours/save`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });

            if (response.success) {
                showToast(response.message, 'success');
                this.form.reset();
                this.loadOfficeHours(); // Liste neu laden
            }
        } catch (error) {
            console.error("Fehler beim Speichern der Sprechzeit:", error);
            showToast(error.message, 'error'); // Zeige Fehler als Toast
        } finally {
            this.saveButton.disabled = false;
            this.saveSpinner.style.display = 'none';
        }
    }

    async handleDelete(availabilityId) {
        if (!availabilityId) return;

        if (await showConfirm("Sprechzeit löschen", `Möchten Sie dieses Zeitfenster wirklich löschen? Zukünftige Termine in diesem Fenster werden möglicherweise mit entfernt.`)) {
            try {
                const response = await apiFetch(`${window.APP_CONFIG.baseUrl}/api/teacher/office-hours/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ availability_id: availabilityId })
                });

                if (response.success) {
                    showToast(response.message, 'success');
                    this.loadOfficeHours(); // Liste neu laden
                }
            } catch (error) {
                console.error("Fehler beim Löschen der Sprechzeit:", error);
            }
        }
    }
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\teacher-cockpit.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\ui-interactions.js ---
// Vorerst leer.

--- END FILE: C:\xampp\htdocs\files\PAUSE\public\assets\js\ui-interactions.js ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\public\index.php ---
<?php
// public/index.php

// Diese Datei leitet alle Anfragen an den Haupt-Controller im übergeordneten Verzeichnis weiter.
// Dies ist eine bewährte Sicherheitspraxis, da der Webserver-Root nur auf diesen
// Ordner zeigen sollte und der Anwendungscode somit geschützt ist.

// KORREKTUR: Der Pfad geht eine Ebene nach oben (../), um init.php zu finden.
require_once __DIR__ . '/../init.php';

// Die Hauptanwendungslogik wird von der index.php im Projektstammverzeichnis behandelt.
// KORREKTUR: Auch dieser Pfad muss eine Ebene nach oben gehen.
require_once __DIR__ . '/../index.php';
--- END FILE: C:\xampp\htdocs\files\PAUSE\public\index.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\index.php ---
<?php
// index.php

// 1. Initialisiert das Projekt (Session, Autoloader, DB-Verbindung, Wartungsmodus-Check)
require_once __DIR__ . '/init.php';

// 2. NEU: Prüfe, ob der Wartungsmodus den Zugriff blockieren soll
if (defined('MAINTENANCE_MODE_ACTIVE') && MAINTENANCE_MODE_ACTIVE === true) {
    http_response_code(503); // Service Unavailable
    
    // Lade die globalen Einstellungen für die Wartungsmeldung
    $settings = \App\Core\Utils::getSettings();
    $page_title = $settings['site_title'] . ' - Wartung';
    $maintenance_message = $settings['maintenance_message']; // Wird in 503.php verwendet
    
    // Lade die Wartungsseite
    // $config ist bereits global durch init.php
    include_once __DIR__ . '/pages/partials/header.php'; // Minimaler Header
    include_once __DIR__ . '/pages/errors/503.php';      // Die Wartungsseite
    include_once __DIR__ . '/pages/partials/footer.php'; // Minimaler Footer
    
    exit(); // Beende die Skriptausführung hier
}


// 3. Router einrichten und Routen laden (zuvor Schritt 2)
$router = new \App\Core\Router();
$routes = require __DIR__ . '/config/routes.php';
foreach ($routes as $pattern => $handler) {
    $router->add($pattern, $handler);
}

// 4. Aktuelle Anfrage-URL ermitteln (zuvor Schritt 3)
$request_uri = $_GET['url'] ?? '/';
$request_path = trim(parse_url($request_uri, PHP_URL_PATH), '/');

// 5. Passende Route finden (zuvor Schritt 4)
$routeInfo = $router->resolve($request_path);

// 6. Route verarbeiten oder 404-Fehler anzeigen (zuvor Schritt 5)
if ($routeInfo) {
    $handler = $routeInfo['handler'];
    $matches = $routeInfo['matches'];

    // Prüfen, ob der Handler eine Controller-Methode ist
    if (is_array($handler) && class_exists($handler[0]) && method_exists($handler[0], $handler[1])) {
        $controllerClass = $handler[0];
        $method = $handler[1];
        $controller = new $controllerClass();
        // Ruft die Controller-Methode auf und übergibt URL-Parameter (z.B. IDs)
        call_user_func_array([$controller, $method], $matches);
    }
    // Fallback für einfache, dateibasierte Routen
    elseif (is_string($handler) && file_exists(__DIR__ . '/' . $handler)) {
        include __DIR__ . '/' . $handler;
    }
    // Wenn der Handler ungültig ist
    else {
        http_response_code(500);
        echo "Fehler: Route-Handler für '{$request_path}' ist ungültig konfiguriert.";
    }
} else {
    // Keine passende Route gefunden -> 404
    http_response_code(404);
    $page_title = '404 - Seite nicht gefunden';
    // HINWEIS: Die Pfade zu den Partials müssen vom Stammverzeichnis aus korrekt sein.
    include_once __DIR__ . '/pages/partials/header.php';
    include_once __DIR__ . '/pages/errors/404.php';
    include_once __DIR__ . '/pages/partials/footer.php';
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\index.php ---
--- START FILE: C:\xampp\htdocs\files\PAUSE\init.php ---
<?php
// init.php

// Include Parsedown library (hat keine App\ Abhängigkeiten)
require_once __DIR__ . '/libs/Parsedown.php';

// 1. Session starten (MUSS vor JEDER anderen Ausgabe erfolgen)
// Setzt sicherere Session-Optionen
ini_set('session.cookie_httponly', 1);
ini_set('session.use_only_cookies', 1);
if (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on') {
    ini_set('session.cookie_secure', 1);
}
// Stellt sicher, dass die Session nicht automatisch gestartet wird, falls doch schon geschehen
if (session_status() === PHP_SESSION_NONE) {
    session_start();
}


// 2. Autoloader für alle Klassen im 'App' Namespace (MUSS VOR der Nutzung von App\ Klassen kommen)
spl_autoload_register(function ($class) {
    // Projekt-spezifischer Namespace-Präfix
    $prefix = 'App\\';

    // Basisverzeichnis für den Namespace-Präfix
    // __DIR__ ist das Verzeichnis der init.php Datei (PAUSE/)
    $base_dir = __DIR__ . '/app/'; // Sollte C:\xampp\htdocs\files\PAUSE\app\ sein

    // Prüft, ob die Klasse den Präfix verwendet
    $len = strlen($prefix);
    if (strncmp($prefix, $class, $len) !== 0) {
        // Nein, zum nächsten registrierten Autoloader wechseln
        return;
    }

    // Holt den relativen Klassennamen
    $relative_class = substr($class, $len);

    // Ersetzt den Namespace-Präfix mit dem Basisverzeichnis,
    // ersetzt Namespace-Trenner mit Verzeichnis-Trennern,
    // und hängt .php an
    $file = $base_dir . str_replace('\\', '/', $relative_class) . '.php';
    
    // Wenn die Datei existiert, lade sie
    if (file_exists($file)) {
        require $file;
    }
});

// 3. CSRF-Token generieren oder holen (Session ist bereits aktiv)
// Diese Funktion nutzt jetzt den Autoloader, um App\Core\Security zu laden.
if (session_status() === PHP_SESSION_ACTIVE) {
    \App\Core\Security::getCsrfToken();
} else {
    // Optional: Log, dass keine Session aktiv war für CSRF
    error_log("Session not active when trying to get CSRF token in init.php");
}


// 4. Konfiguration und Datenbankverbindung laden
// Globale Variable $config für leichten Zugriff in Views etc.
global $config;
try {
    $config = App\Core\Database::getConfig();
    // Stelle sicher, dass die DB-Instanz nur geholt wird, wenn nötig,
    // aber hier ist es ok, um die Verbindung früh zu testen.
    $pdo = App\Core\Database::getInstance();
} catch (RuntimeException $e) {
    // Fängt den Fehler ab, wenn die DB-Verbindung fehlschlägt
    // Zeigt eine benutzerfreundliche Fehlerseite an
    http_response_code(503); // Service Unavailable

    // Logge den eigentlichen Fehler für den Admin, damit er im Server-Log erscheint
    error_log("Schwerwiegender DB-Fehler in init.php: " . $e->getMessage());

    // Definiere die Nachricht für die 503-Seite.
    // Die Seite pages/errors/503.php (Wartungsseite) wird hier wiederverwendet
    // und erwartet die Variable $maintenance_message.
    
    // KORRIGIERT: \n statt <br> verwenden, damit nl2br() im Template funktioniert
    $maintenance_message = "Fehler: Die Datenbankverbindung konnte nicht hergestellt werden. \nBitte versuchen Sie es zu einem späteren Zeitpunkt erneut.";

    // Da dieser Fehler vor dem Router auftritt, müssen wir das Template manuell laden.
    // $config sollte global verfügbar sein (von getConfig()), was für den Header benötigt wird.
    // Der Autoloader ist ebenfalls bereits aktiv.
    
    require_once __DIR__ . '/pages/partials/header.php';
    require_once __DIR__ . '/pages/errors/503.php';
    require_once __DIR__ . '/pages/partials/footer.php';
    
    // Beende die Ausführung, nachdem die Seite gerendert wurde
    exit;
    
} catch (Exception $e) { // Fange generische Exceptions beim Laden ab
    http_response_code(500);
    die("Ein kritischer Initialisierungsfehler ist aufgetreten: " . $e->getMessage());
}


// 5. NEU: Wartungsmodus-Prüfung
// Definiert eine Konstante, falls der Zugriff gesperrt werden soll.
try {
    $settings = \App\Core\Utils::getSettings();

    if ($settings['maintenance_mode'] === true) {
        $userRole = $_SESSION['user_role'] ?? 'guest';
        $allowedRoles = ['admin', 'planer']; // Diese Rollen dürfen immer rein
        $userIsAllowed = in_array($userRole, $allowedRoles);

        $userIP = $_SERVER['REMOTE_ADDR'] ?? 'UNKNOWN';
        
        // KORRIGIERT: Lese Whitelist aus $settings (DB) statt $config (Datei)
        $ipWhitelistString = $settings['maintenance_whitelist_ips'] ?? '';
        // Wandle den String in ein Array um, entferne Leerzeichen
        $ipWhitelist = array_map('trim', explode(',', $ipWhitelistString));
        // Entferne leere Einträge
        $ipWhitelist = array_filter($ipWhitelist); 

        $ipIsAllowed = in_array($userIP, $ipWhitelist);

        // Sperre den Benutzer, wenn er KEINE erlaubte Rolle hat UND seine IP NICHT auf der Whitelist ist
        if (!$userIsAllowed && !$ipIsAllowed) {
            
            // Ausnahme: Login-Seiten müssen erreichbar bleiben, damit Admins sich einloggen können
            $request_uri = $_GET['url'] ?? '/';
            $request_path = trim(parse_url($request_uri, PHP_URL_PATH), '/');
            $allowedPaths = ['login', 'login/process']; // Routen, die immer funktionieren

            if (!in_array($request_path, $allowedPaths)) {
                // Setze die globale Konstante. index.php wird darauf reagieren.
                define('MAINTENANCE_MODE_ACTIVE', true);
            }
        }
    }
} catch (Exception $e) {
    // Kritischer Fehler beim Laden der Einstellungen
    http_response_code(500);
    die("Fehler beim Prüfen des Wartungsstatus: " . $e->getMessage());
}
--- END FILE: C:\xampp\htdocs\files\PAUSE\init.php ---

