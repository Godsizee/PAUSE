<?php
// app/Http/Controllers/DashboardController.php
namespace App\Http\Controllers;

use App\Core\Security;
use App\Core\Utils;
use App\Core\Database;
use App\Repositories\PlanRepository;
use App\Repositories\UserRepository;
use App\Repositories\AppointmentRepository;
use App\Repositories\StudentNoteRepository; // NEU
use App\Services\AuditLogger;
use Exception;
use PDO;
use DateTime;
use DateTimeZone;

class DashboardController
{
    private PDO $pdo;
    private UserRepository $userRepository;
    private PlanRepository $planRepository;
    private AppointmentRepository $appointmentRepo;
    private StudentNoteRepository $noteRepo; // NEU

    public function __construct()
    {
        $this->pdo = Database::getInstance();
        $this->userRepository = new UserRepository($this->pdo);
        $this->planRepository = new PlanRepository($this->pdo);
        $this->appointmentRepo = new AppointmentRepository($this->pdo);
        $this->noteRepo = new StudentNoteRepository($this->pdo); // NEU
    }

    public function index()
    {
        Security::requireLogin();
        $userId = $_SESSION['user_id']; // Get user ID from session
        $role = $_SESSION['user_role'] ?? 'Unbekannt';
        global $config;
        $config = Database::getConfig();

        // Redirect Admins and Planers to their specific dashboards
        if ($role === 'admin') {
            header("Location: " . Utils::url('admin/dashboard'));
            exit();
        }
        if ($role === 'planer') {
            header("Location: " . Utils::url('planer/dashboard'));
            exit();
        }

        // --- Fetch iCal Token and URL for Students/Teachers ---
        $icalSubscriptionUrl = null;
        $user = null; // Initialize user variable
        if (in_array($role, ['schueler', 'lehrer'])) {
             try {
                 $user = $this->userRepository->findById($userId); // Fetch user data once
                 if ($user) {
                     $token = $this->userRepository->generateOrGetIcalToken($userId);
                     if ($token) {
                         // Construct the full URL - ensure base_url ends correctly
                         $baseUrl = rtrim($config['base_url'], '/');
                         // Use Utils::url to handle potential base URL structure correctly
                         $icalPath = 'ical/' . $token;
                         // Build absolute URL
                         $protocol = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off' || $_SERVER['SERVER_PORT'] == 443) ? "https://" : "http://";
                         $host = $_SERVER['HTTP_HOST']; // e.g., localhost, yourdomain.com
                         // Combine protocol, host, and the relative path generated by Utils::url
                         $icalSubscriptionUrl = $protocol . $host . Utils::url($icalPath);

                     } else {
                          error_log("Could not generate or get iCal token for user ID: " . $userId);
                     }
                 } else {
                      error_log("User not found for ID: " . $userId . " in DashboardController");
                 }

             } catch (Exception $e) {
                   error_log("Error fetching iCal token: " . $e->getMessage());
                   // Don't crash the page, just don't show the URL
             }
        }
        // --- End iCal Token Fetch ---


        // Default for schueler, lehrer
        $page_title = 'Mein Stundenplan';
        $body_class = 'dashboard-body'; // Consistent class name

        // Today's date info for "Mein Tag" (Moved from view to controller)
        $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
        $dayOfWeekName = [
            1 => 'Montag', 2 => 'Dienstag', 3 => 'Mittwoch', 4 => 'Donnerstag', 5 => 'Freitag', 6 => 'Samstag', 7 => 'Sonntag'
        ][$today->format('N')] ?? 'Unbekannt';
        $dateFormatted = $today->format('d.m.Y');


        require_once dirname(__DIR__, 3) . '/pages/dashboard.php';
    }


    /**
     * API-Endpunkt zum Laden des kompletten Wochenplans, aller Wochen-Vertretungen,
     * UND NEU: anstehender Termine (Aufgaben, Sprechstunden) SOWIE NOTIZEN.
     * NUR VERÖFFENTLICHTE DATEN.
     */
    public function getWeeklyData()
    {
        Security::requireLogin();
        header('Content-Type: application/json');

        try {
            $userId = $_SESSION['user_id'];
            $userRole = $_SESSION['user_role'];

            $year = filter_input(INPUT_GET, 'year', FILTER_VALIDATE_INT);
            $calendarWeek = filter_input(INPUT_GET, 'week', FILTER_VALIDATE_INT);

            if (!$year || !$calendarWeek) {
                $today = new DateTime('now', new DateTimeZone('Europe/Berlin'));
                $year = (int)$today->format('o'); // ISO year
                $calendarWeek = (int)$today->format('W'); // ISO week
            }
            
            // NEU: Datumsbereich für die Abfrage von Terminen
            $monday = new DateTime();
            $monday->setISODate($year, $calendarWeek, 1);
            $startDate = $monday->format('Y-m-d');
            
            $sunday = new DateTime();
            $sunday->setISODate($year, $calendarWeek, 7);
            $endDate = $sunday->format('Y-m-d');
            

            $user = $this->userRepository->findById($userId);
            if (!$user) {
                throw new Exception("Benutzer nicht gefunden.");
            }

            $regularTimetable = [];
            $substitutions = [];
            $appointments = [];
            $notes = []; // NEU
            $targetGroup = null; // Determine target group for publish check

            if ($userRole === 'schueler' && !empty($user['class_id'])) {
                $targetGroup = 'student';
                if ($this->planRepository->isWeekPublishedFor($targetGroup, $year, $calendarWeek)) {
                    $regularTimetable = $this->planRepository->getPublishedTimetableForClass($user['class_id'], $year, $calendarWeek);
                    $substitutions = $this->planRepository->getPublishedSubstitutionsForClassWeek($user['class_id'], $year, $calendarWeek);
                    // Lade Sprechstunden für Schüler
                    $appointments = $this->appointmentRepo->getAppointmentsForStudent($userId, $startDate, $endDate);
                    // NEU: Lade Notizen für Schüler
                    $notes = $this->noteRepo->getNotesForWeek($userId, $year, $calendarWeek);
                }
            } elseif ($userRole === 'lehrer' && !empty($user['teacher_id'])) {
                 $targetGroup = 'teacher';
                 if ($this->planRepository->isWeekPublishedFor($targetGroup, $year, $calendarWeek)) {
                      $regularTimetable = $this->planRepository->getPublishedTimetableForTeacher($user['teacher_id'], $year, $calendarWeek);
                      $substitutions = $this->planRepository->getPublishedSubstitutionsForTeacherWeek($user['teacher_id'], $year, $calendarWeek);
                      // Lade Sprechstunden für Lehrer (user_id verwenden)
                      $appointments = $this->appointmentRepo->getAppointmentsForTeacher($userId, $startDate, $endDate);
                      // Lehrer haben keine Notizen
                 }
            }

            // Wenn $targetGroup null ist (z.B. Admin/Planer, obwohl sie hier nicht sein sollten) oder
            // die Woche nicht veröffentlicht wurde, bleiben die Arrays leer, was korrekt ist.

            echo json_encode(['success' => true, 'data' => [
                'timetable' => $regularTimetable,
                'substitutions' => $substitutions,
                'appointments' => $appointments,
                'notes' => $notes // NEU
            ]]);

        } catch (Exception $e) {
            http_response_code(500);
            error_log("API Error in getWeeklyData API: " . $e->getMessage()); // Log error
            echo json_encode(['success' => false, 'message' => 'Fehler beim Laden der Plandaten.']); // Generic message
        }
        exit();
    }

    // --- NEUE API-ENDPUNKTE FÜR SCHÜLER (SPRECHSTUNDEN & NOTIZEN) ---

    /**
     * NEU: API: Speichert eine private Notiz für einen Schüler.
     */
    public function saveNoteApi()
    {
        Security::requireRole('schueler');
        Security::verifyCsrfToken();
        header('Content-Type: application/json');
        
        try {
            $userId = $_SESSION['user_id'];
            $data = json_decode(file_get_contents('php://input'), true);

            $year = filter_var($data['year'] ?? null, FILTER_VALIDATE_INT);
            $calendarWeek = filter_var($data['calendar_week'] ?? null, FILTER_VALIDATE_INT);
            $dayOfWeek = filter_var($data['day_of_week'] ?? null, FILTER_VALIDATE_INT);
            $periodNumber = filter_var($data['period_number'] ?? null, FILTER_VALIDATE_INT);
            $content = $data['note_content'] ?? ''; // Erlaube leeren String (zum Löschen)

            if (!$year || !$calendarWeek || !$dayOfWeek || !$periodNumber) {
                throw new Exception("Fehlende Kontextdaten (Woche, Tag oder Stunde).", 400);
            }

            $success = $this->noteRepo->saveNote(
                $userId,
                $year,
                $calendarWeek,
                $dayOfWeek,
                $periodNumber,
                $content
            );

            if ($success) {
                // Logge das Speichern (aber nicht den Inhalt)
                AuditLogger::log('save_student_note', 'student_note', null, [
                    'year' => $year,
                    'week' => $calendarWeek,
                    'day' => $dayOfWeek,
                    'period' => $periodNumber,
                    'action' => empty(trim($content)) ? 'deleted' : 'saved'
                ]);
                echo json_encode(['success' => true, 'message' => 'Notiz gespeichert.']);
            } else {
                throw new Exception("Notiz konnte nicht gespeichert werden.");
            }

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (saveNoteApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }


    /**
     * API: Holt die verfügbaren Slots für einen Lehrer an einem Datum.
     * (Für Schüler)
     */
    public function getAvailableSlotsApi()
    {
        Security::requireRole('schueler'); // Nur Schüler können Slots buchen
        header('Content-Type: application/json');

        try {
            // KORREKTUR: Muss teacher_id (aus Stammdaten) in teacher_user_id (aus users) umwandeln
            $teacherId = filter_input(INPUT_GET, 'teacher_id', FILTER_VALIDATE_INT);
            $date = filter_input(INPUT_GET, 'date', FILTER_UNSAFE_RAW); // Y-m-d

            if (!$teacherId || !$date || DateTime::createFromFormat('Y-m-d', $date) === false) {
                throw new Exception("Ungültige Lehrer-ID oder Datum.", 400);
            }
            
            // KORREKTUR: Finde die user_id des Lehrers
            $teacherUser = $this->userRepository->findUserByTeacherId($teacherId);
            if (!$teacherUser) {
                throw new Exception("Lehrerprofil (Benutzer) nicht gefunden.", 404);
            }
            $teacherUserId = $teacherUser['user_id'];
            
            // Verhindere Buchungen in der Vergangenheit
            $today = (new DateTime('now', new DateTimeZone('Europe/Berlin')))->format('Y-m-d');
            $slots = []; // Initialisiere Slots
            if ($date < $today) {
                 // Erlaube die Anzeige heutiger Slots
                 $slots = $this->appointmentRepo->getAvailableSlots($teacherUserId, $date);
                 if (empty($slots) && $date < $today) { // Nur wenn keine Slots UND Vergangenheit
                      throw new Exception("Termine können nicht in der Vergangenheit gebucht werden.", 400);
                 }
            } else {
                 $slots = $this->appointmentRepo->getAvailableSlots($teacherUserId, $date);
            }
            
            echo json_encode(['success' => true, 'data' => $slots]);

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (getAvailableSlotsApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }

    /**
     * API: Bucht einen Termin.
     * (Für Schüler)
     */
    public function bookAppointmentApi()
    {
        Security::requireRole('schueler');
        Security::verifyCsrfToken();
        header('Content-Type: application/json');
        
        try {
            $studentUserId = $_SESSION['user_id'];
            $data = json_decode(file_get_contents('php://input'), true);

            // KORREKTUR: Empfängt teacher_id (Stammdaten), muss teacher_user_id finden
            $teacherId = filter_var($data['teacher_id'] ?? null, FILTER_VALIDATE_INT);
            $date = $data['date'] ?? null;
            $time = $data['time'] ?? null; // HH:MM:SS
            $duration = filter_var($data['duration'] ?? null, FILTER_VALIDATE_INT);
            $notes = isset($data['notes']) ? trim($data['notes']) : null;

            if (!$teacherId || !$date || !$time || !$duration) {
                throw new Exception("Fehlende Daten für die Buchung.", 400);
            }
            
            // KORREKTUR: Finde die user_id des Lehrers
            $teacherUser = $this->userRepository->findUserByTeacherId($teacherId);
            if (!$teacherUser) {
                throw new Exception("Lehrerprofil (Benutzer) nicht gefunden.", 404);
            }
            $teacherUserId = $teacherUser['user_id'];
            
            // Verhindere Buchungen in der Vergangenheit
            $today = (new DateTime('now', new DateTimeZone('Europe/Berlin')))->format('Y-m-d');
            if ($date < $today) {
                 throw new Exception("Termine können nicht in der Vergangenheit gebucht werden.", 400);
            }

            $newId = $this->appointmentRepo->bookAppointment(
                $studentUserId,
                $teacherUserId, // KORREKTUR: Verwende die gefundene user_id
                $date,
                $time,
                $duration,
                $notes
            );
            
            AuditLogger::log('book_appointment', 'appointment', $newId, [
                'teacher_user_id' => $teacherUserId,
                'date' => $date,
                'time' => $time
            ]);

            echo json_encode(['success' => true, 'message' => 'Sprechstunde erfolgreich gebucht!']);

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (bookAppointmentApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }

    /**
     * API: Storniert einen Termin.
     * (Für Schüler ODER Lehrer)
     */
    public function cancelAppointmentApi()
    {
        Security::requireLogin(); // Lehrer oder Schüler
        Security::verifyCsrfToken();
        header('Content-Type: application/json');
        
        try {
            $userId = $_SESSION['user_id'];
            $role = $_SESSION['user_role'];

            $data = json_decode(file_get_contents('php://input'), true);
            $appointmentId = filter_var($data['appointment_id'] ?? null, FILTER_VALIDATE_INT);

            if (!$appointmentId) {
                throw new Exception("Keine Termin-ID angegeben.", 400);
            }

            $success = $this->appointmentRepo->cancelAppointment($appointmentId, $userId, $role);
            
            if ($success) {
                 AuditLogger::log('cancel_appointment', 'appointment', $appointmentId, ['cancelled_by_role' => $role]);
                 echo json_encode(['success' => true, 'message' => 'Termin erfolgreich storniert.']);
            }
            // Fehler (403, 404) werden vom Repository geworfen

        } catch (Exception $e) {
            $code = ($e->getCode() >= 400 && $e->getCode() < 600) ? $e->getCode() : 500;
            http_response_code($code);
            error_log("API Error (cancelAppointmentApi): " . $e->getMessage());
            echo json_encode(['success' => false, 'message' => $e->getMessage()]);
        }
        exit();
    }
}

